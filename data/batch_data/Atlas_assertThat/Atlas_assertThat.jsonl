{"focal": "size ( ) { return this . cells . size ( ) ; }", "testMethod": "numberedRgroupSymbol ( ) { org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generatePseudoSymbol ( \"R1\" , HydrogenPosition . Right ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "numberedRgroupSymbol ( ) { org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generatePseudoSymbol ( \"R1\" , HydrogenPosition . Right ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . cells . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "makeScheduledPayments ( org . mifos . accounts . business . AccountPaymentEntity , java . util . List , org . mifos . customers . business . CustomerBO , org . mifos . accounts . productdefinition . util . helpers . SavingsType , org . mifos . framework . util . helpers . Money ) { org . mifos . application . master . business . MifosCurrency currency = payment . getAccount ( ) . getCurrency ( ) ; org . mifos . framework . util . helpers . Money amountRemaining = new org . mifos . framework . util . helpers . Money ( currency , payment . getAmount ( ) . getAmount ( ) ) ; org . mifos . framework . util . helpers . Money runningBalance = new org . mifos . framework . util . helpers . Money ( currency , savingsBalanceBeforeDeposit . getAmount ( ) ) ; final java . util . Date transactionDate = payment . getPaymentDate ( ) ; org . mifos . framework . util . helpers . Money depositAmount ; org . mifos . accounts . util . helpers . PaymentStatus paymentStatus ; if ( savingsType . getValue ( ) . equals ( SavingsType . VOLUNTARY . getValue ( ) ) ) { paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . PAID ; org . mifos . accounts . savings . business . SavingsScheduleEntity lastExpectedPayment = null ; for ( org . mifos . accounts . savings . business . SavingsScheduleEntity expectedPayment : scheduledDeposits ) { lastExpectedPayment = expectedPayment ; expectedPayment . setPaymentDetails ( new org . mifos . framework . util . helpers . Money ( currency ) , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; } if ( lastExpectedPayment != null ) { if ( amountRemaining . isGreaterThanOrEqual ( lastExpectedPayment . getTotalDepositDue ( ) ) ) { depositAmount = lastExpectedPayment . getTotalDepositDue ( ) ; amountRemaining = amountRemaining . subtract ( lastExpectedPayment . getTotalDepositDue ( ) ) ; } else { depositAmount = new org . mifos . framework . util . helpers . Money ( currency , amountRemaining . getAmount ( ) ) ; amountRemaining = new org . mifos . framework . util . helpers . Money ( currency ) ; } lastExpectedPayment . setPaymentDetails ( depositAmount , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; runningBalance = runningBalance . add ( depositAmount ) ; final org . mifos . accounts . savings . business . SavingsTrxnDetailEntity voluntaryPaymentTrxn = savingsTransactionActivityHelper . createSavingsTrxnForDeposit ( payment , depositAmount , payingCustomer , lastExpectedPayment , runningBalance ) ; payment . addAccountTrxn ( voluntaryPaymentTrxn ) ; } } else { for ( org . mifos . accounts . savings . business . SavingsScheduleEntity accountAction : scheduledDeposits ) { paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . UNPAID ; if ( amountRemaining . isGreaterThanOrEqual ( accountAction . getTotalDepositDue ( ) ) ) { depositAmount = accountAction . getTotalDepositDue ( ) ; amountRemaining = amountRemaining . subtract ( accountAction . getTotalDepositDue ( ) ) ; paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . PAID ; } else { depositAmount = new org . mifos . framework . util . helpers . Money ( currency , amountRemaining . getAmount ( ) ) ; amountRemaining = new org . mifos . framework . util . helpers . Money ( currency ) ; } accountAction . setPaymentDetails ( depositAmount , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; runningBalance = runningBalance . add ( depositAmount ) ; final org . mifos . accounts . savings . business . SavingsTrxnDetailEntity mandatoryScheduledPaymentTrxn = savingsTransactionActivityHelper . createSavingsTrxnForDeposit ( payment , depositAmount , payingCustomer , accountAction , runningBalance ) ; payment . addAccountTrxn ( mandatoryScheduledPaymentTrxn ) ; if ( amountRemaining . isLessThanOrEqualZero ( ) ) { return amountRemaining ; } } } return amountRemaining ; }", "testMethod": "whenNoUnpaidScheduledInstallmentsExistTheFullAmountOfTheDepositIsReturned ( ) { final org . mifos . framework . util . helpers . Money balanceBeforeDeposit = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"0.0\" ) ; final org . mifos . framework . util . helpers . Money fullDepositAmount = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"100.0\" ) ; final java . util . Date dateOfDeposit = new org . joda . time . DateTime ( ) . toDate ( ) ; final java . util . List < org . mifos . accounts . savings . business . SavingsScheduleEntity > unpaidDepositsForPayingCustomer = java . util . Arrays . asList ( ) ; when ( accountPayment . getAmount ( ) ) . thenReturn ( fullDepositAmount ) ; when ( accountPayment . getPaymentDate ( ) ) . thenReturn ( dateOfDeposit ) ; final org . mifos . framework . util . helpers . Money remainingAmount = paymentStrategy . makeScheduledPayments ( accountPayment , unpaidDepositsForPayingCustomer , payingCustomer , SavingsType . MANDATORY , balanceBeforeDeposit ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( remainingAmount , org . hamcrest . CoreMatchers . is ( fullDepositAmount ) )", "total": "whenNoUnpaidScheduledInstallmentsExistTheFullAmountOfTheDepositIsReturned ( ) { final org . mifos . framework . util . helpers . Money balanceBeforeDeposit = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"0.0\" ) ; final org . mifos . framework . util . helpers . Money fullDepositAmount = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"100.0\" ) ; final java . util . Date dateOfDeposit = new org . joda . time . DateTime ( ) . toDate ( ) ; final java . util . List < org . mifos . accounts . savings . business . SavingsScheduleEntity > unpaidDepositsForPayingCustomer = java . util . Arrays . asList ( ) ; when ( accountPayment . getAmount ( ) ) . thenReturn ( fullDepositAmount ) ; when ( accountPayment . getPaymentDate ( ) ) . thenReturn ( dateOfDeposit ) ; final org . mifos . framework . util . helpers . Money remainingAmount = paymentStrategy . makeScheduledPayments ( accountPayment , unpaidDepositsForPayingCustomer , payingCustomer , SavingsType . MANDATORY , balanceBeforeDeposit ) ; \"<AssertPlaceHolder>\" ; } makeScheduledPayments ( org . mifos . accounts . business . AccountPaymentEntity , java . util . List , org . mifos . customers . business . CustomerBO , org . mifos . accounts . productdefinition . util . helpers . SavingsType , org . mifos . framework . util . helpers . Money ) { org . mifos . application . master . business . MifosCurrency currency = payment . getAccount ( ) . getCurrency ( ) ; org . mifos . framework . util . helpers . Money amountRemaining = new org . mifos . framework . util . helpers . Money ( currency , payment . getAmount ( ) . getAmount ( ) ) ; org . mifos . framework . util . helpers . Money runningBalance = new org . mifos . framework . util . helpers . Money ( currency , savingsBalanceBeforeDeposit . getAmount ( ) ) ; final java . util . Date transactionDate = payment . getPaymentDate ( ) ; org . mifos . framework . util . helpers . Money depositAmount ; org . mifos . accounts . util . helpers . PaymentStatus paymentStatus ; if ( savingsType . getValue ( ) . equals ( SavingsType . VOLUNTARY . getValue ( ) ) ) { paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . PAID ; org . mifos . accounts . savings . business . SavingsScheduleEntity lastExpectedPayment = null ; for ( org . mifos . accounts . savings . business . SavingsScheduleEntity expectedPayment : scheduledDeposits ) { lastExpectedPayment = expectedPayment ; expectedPayment . setPaymentDetails ( new org . mifos . framework . util . helpers . Money ( currency ) , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; } if ( lastExpectedPayment != null ) { if ( amountRemaining . isGreaterThanOrEqual ( lastExpectedPayment . getTotalDepositDue ( ) ) ) { depositAmount = lastExpectedPayment . getTotalDepositDue ( ) ; amountRemaining = amountRemaining . subtract ( lastExpectedPayment . getTotalDepositDue ( ) ) ; } else { depositAmount = new org . mifos . framework . util . helpers . Money ( currency , amountRemaining . getAmount ( ) ) ; amountRemaining = new org . mifos . framework . util . helpers . Money ( currency ) ; } lastExpectedPayment . setPaymentDetails ( depositAmount , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; runningBalance = runningBalance . add ( depositAmount ) ; final org . mifos . accounts . savings . business . SavingsTrxnDetailEntity voluntaryPaymentTrxn = savingsTransactionActivityHelper . createSavingsTrxnForDeposit ( payment , depositAmount , payingCustomer , lastExpectedPayment , runningBalance ) ; payment . addAccountTrxn ( voluntaryPaymentTrxn ) ; } } else { for ( org . mifos . accounts . savings . business . SavingsScheduleEntity accountAction : scheduledDeposits ) { paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . UNPAID ; if ( amountRemaining . isGreaterThanOrEqual ( accountAction . getTotalDepositDue ( ) ) ) { depositAmount = accountAction . getTotalDepositDue ( ) ; amountRemaining = amountRemaining . subtract ( accountAction . getTotalDepositDue ( ) ) ; paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . PAID ; } else { depositAmount = new org . mifos . framework . util . helpers . Money ( currency , amountRemaining . getAmount ( ) ) ; amountRemaining = new org . mifos . framework . util . helpers . Money ( currency ) ; } accountAction . setPaymentDetails ( depositAmount , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; runningBalance = runningBalance . add ( depositAmount ) ; final org . mifos . accounts . savings . business . SavingsTrxnDetailEntity mandatoryScheduledPaymentTrxn = savingsTransactionActivityHelper . createSavingsTrxnForDeposit ( payment , depositAmount , payingCustomer , accountAction , runningBalance ) ; payment . addAccountTrxn ( mandatoryScheduledPaymentTrxn ) ; if ( amountRemaining . isLessThanOrEqualZero ( ) ) { return amountRemaining ; } } } return amountRemaining ; }", "answer": "org . junit . Assert . assertThat ( remainingAmount , org . hamcrest . CoreMatchers . is ( fullDepositAmount ) )"}
{"focal": "pulseCount ( ) { return count ; }", "testMethod": "countIs2AfterAdding2Pulses ( ) { pulseLengthAnalyzer . addPulse ( 10.0 , false ) ; pulseLengthAnalyzer . addPulse ( 10.0 , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pulseLengthAnalyzer . pulseCount ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "countIs2AfterAdding2Pulses ( ) { pulseLengthAnalyzer . addPulse ( 10.0 , false ) ; pulseLengthAnalyzer . addPulse ( 10.0 , true ) ; \"<AssertPlaceHolder>\" ; } pulseCount ( ) { return count ; }", "answer": "org . junit . Assert . assertThat ( pulseLengthAnalyzer . pulseCount ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "size ( ) { return this . cells . size ( ) ; }", "testMethod": "RgroupSymbolY ( ) { org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generatePseudoSymbol ( \"Y1a2\" , HydrogenPosition . Right ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "RgroupSymbolY ( ) { org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generatePseudoSymbol ( \"Y1a2\" , HydrogenPosition . Right ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . cells . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "apply ( T1 , T2 , T3 , T4 , T5 ) { return new com . m3 . scalaflavor4j . Tuple5 < T1 , T2 , T3 , T4 , T5 > ( _1 , _2 , _3 , _4 , _5 ) ; }", "testMethod": "__A$VoidFunction1_emptyGenerator ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs1 = com . m3 . scalaflavor4j . Seq . apply ( \"a\" , \"b\" ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Integer > xs2 = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 , 4 , 5 ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Long > xs3 = com . m3 . scalaflavor4j . Seq . apply ( ) ; final com . m3 . scalaflavor4j . ForComprehension3Test . Called c = new com . m3 . scalaflavor4j . ForComprehension3Test . Called ( ) ; com . m3 . scalaflavor4j . For . apply ( xs1 , xs2 , xs3 ) . apply ( new com . m3 . scalaflavor4j . VoidF1 < com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > > ( ) { public void apply ( com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > t ) { ( c . count ) ++ ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( c . count , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "__A$VoidFunction1_emptyGenerator ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs1 = com . m3 . scalaflavor4j . Seq . apply ( \"a\" , \"b\" ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Integer > xs2 = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 , 4 , 5 ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Long > xs3 = com . m3 . scalaflavor4j . Seq . apply ( ) ; final com . m3 . scalaflavor4j . ForComprehension3Test . Called c = new com . m3 . scalaflavor4j . ForComprehension3Test . Called ( ) ; com . m3 . scalaflavor4j . For . apply ( xs1 , xs2 , xs3 ) . apply ( new com . m3 . scalaflavor4j . VoidF1 < com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > > ( ) { public void apply ( com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > t ) { ( c . count ) ++ ; } } ) ; \"<AssertPlaceHolder>\" ; } apply ( T1 , T2 , T3 , T4 , T5 ) { return new com . m3 . scalaflavor4j . Tuple5 < T1 , T2 , T3 , T4 , T5 > ( _1 , _2 , _3 , _4 , _5 ) ; }", "answer": "org . junit . Assert . assertThat ( c . count , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . ChannelRenameEvent event = new com . github . seratch . jslack . api . model . event . ChannelRenameEvent ( ) ; event . setChannel ( new com . github . seratch . jslack . api . model . event . ChannelRenameEvent . Channel ( ) ) ; event . getChannel ( ) . setName ( \"foo\" ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"channel_rename\\\",\\\"channel\\\":{\\\"name\\\":\\\"foo\\\"}}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . ChannelRenameEvent event = new com . github . seratch . jslack . api . model . event . ChannelRenameEvent ( ) ; event . setChannel ( new com . github . seratch . jslack . api . model . event . ChannelRenameEvent . Channel ( ) ) ; event . getChannel ( ) . setName ( \"foo\" ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"channel_rename\\\",\\\"channel\\\":{\\\"name\\\":\\\"foo\\\"}}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "testMethod": "testConstructorOneParamLongUnsuccessful ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"japicmp.Test#Test(java.lang.Long)\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test\" ) . addToClassPool ( classPool ) ; javassist . CtConstructor ctConstructor = japicmp . util . CtConstructorBuilder . create ( ) . parameter ( classPool . get ( \"java.lang.Double\" ) ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filter . matches ( ctConstructor ) , org . hamcrest . core . Is . is ( false ) )", "total": "testConstructorOneParamLongUnsuccessful ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"japicmp.Test#Test(java.lang.Long)\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test\" ) . addToClassPool ( classPool ) ; javassist . CtConstructor ctConstructor = japicmp . util . CtConstructorBuilder . create ( ) . parameter ( classPool . get ( \"java.lang.Double\" ) ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; } matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "answer": "org . junit . Assert . assertThat ( filter . matches ( ctConstructor ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "testMethod": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%<sp>if<sp>1.0<sp>==<sp>1<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>nil<sp>==<sp>nil<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>false<sp>==<sp>false<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>\\\"\\\"<sp>==<sp>\\'\\'<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%<sp>if<sp>1.0<sp>==<sp>1<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>nil<sp>==<sp>nil<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>false<sp>==<sp>false<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>\\\"\\\"<sp>==<sp>\\'\\'<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } } render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "getMergeFeature ( java . lang . String ) { if ( ( ! ( this . orderedBuildList . isEmpty ( ) ) ) && ( this . features . containsKey ( featureId , getLatestBuild ( ) ) ) ) { final xbdd . model . simple . Feature feature = this . features . get ( featureId , getLatestBuild ( ) ) ; final java . util . List < java . lang . String > featureStatuses = getFeatureStatuses ( feature ) ; final java . util . List < xbdd . model . MergeScenario > scenarioList = getMergedScenarios ( feature ) ; final xbdd . model . MergeFeature mergeFeature = new xbdd . model . MergeFeature ( ) ; mergeFeature . setId ( feature . getId ( ) ) ; mergeFeature . setName ( feature . getName ( ) ) ; mergeFeature . setStatuses ( featureStatuses ) ; mergeFeature . setUrl ( ( ( ( ( ( \"reports/\" + ( feature . getCoordinates ( ) . getProduct ( ) ) ) + \"/\" ) + ( feature . getCoordinates ( ) . getVersionString ( ) ) ) + \"/{{BUILD_NAME}}/\" ) + ( feature . getId ( ) ) ) ) ; mergeFeature . setScenarios ( scenarioList ) ; return mergeFeature ; } else { return null ; } }", "testMethod": "noFeatureAdded ( ) { final xbdd . model . simple . Feature feature = new xbdd . model . simple . Feature ( ( ( com . mongodb . BasicDBObject ) ( com . mongodb . util . JSON . parse ( \"{'_id'<sp>:<sp>'p1/f1','id'<sp>:<sp>'f1','description'<sp>:<sp>''<sp>,'name'<sp>:<sp>'f1',<sp>'elements'<sp>:<sp>[{'id'<sp>:<sp>'e1','description'<sp>:<sp>'','name'<sp>:<sp>'e1','steps'<sp>:<sp>[{'result'<sp>:<sp>{'status'<sp>:<sp>'passed'},'name'<sp>:<sp>'e2',},{'result'<sp>:<sp>{'status'<sp>:<sp>'passed'},'name'<sp>:<sp>'e3',}],}],'coordinates'<sp>:<sp>{'product'<sp>:<sp>'P1','major'<sp>:<sp>1,'minor'<sp>:<sp>1,'servicePack'<sp>:<sp>1,'build'<sp>:<sp>'build1','version'<sp>:<sp>'1.1.1'},'calculatedStatus'<sp>:<sp>'unknown<sp>status?<sp>-<sp>expected<sp>passed,failed<sp>or<sp>undefined','originalAutomatedStatus'<sp>:<sp>'unknown<sp>status?<sp>-<sp>expected<sp>passed,failed<sp>or<sp>undefined'}\" ) ) ) ) ; final java . lang . String [ ] builds = new java . lang . String [ ] { \"build1\" , \"build2\" } ; final xbdd . util . MultipleBuildsFeatureMergeHelper target = new xbdd . util . MultipleBuildsFeatureMergeHelper ( java . util . Arrays . asList ( builds ) ) ; final xbdd . model . MergeFeature isNull = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getMergeFeature ( feature . getId ( ) ) , org . hamcrest . Matchers . is ( isNull ) )", "total": "noFeatureAdded ( ) { final xbdd . model . simple . Feature feature = new xbdd . model . simple . Feature ( ( ( com . mongodb . BasicDBObject ) ( com . mongodb . util . JSON . parse ( \"{'_id'<sp>:<sp>'p1/f1','id'<sp>:<sp>'f1','description'<sp>:<sp>''<sp>,'name'<sp>:<sp>'f1',<sp>'elements'<sp>:<sp>[{'id'<sp>:<sp>'e1','description'<sp>:<sp>'','name'<sp>:<sp>'e1','steps'<sp>:<sp>[{'result'<sp>:<sp>{'status'<sp>:<sp>'passed'},'name'<sp>:<sp>'e2',},{'result'<sp>:<sp>{'status'<sp>:<sp>'passed'},'name'<sp>:<sp>'e3',}],}],'coordinates'<sp>:<sp>{'product'<sp>:<sp>'P1','major'<sp>:<sp>1,'minor'<sp>:<sp>1,'servicePack'<sp>:<sp>1,'build'<sp>:<sp>'build1','version'<sp>:<sp>'1.1.1'},'calculatedStatus'<sp>:<sp>'unknown<sp>status?<sp>-<sp>expected<sp>passed,failed<sp>or<sp>undefined','originalAutomatedStatus'<sp>:<sp>'unknown<sp>status?<sp>-<sp>expected<sp>passed,failed<sp>or<sp>undefined'}\" ) ) ) ) ; final java . lang . String [ ] builds = new java . lang . String [ ] { \"build1\" , \"build2\" } ; final xbdd . util . MultipleBuildsFeatureMergeHelper target = new xbdd . util . MultipleBuildsFeatureMergeHelper ( java . util . Arrays . asList ( builds ) ) ; final xbdd . model . MergeFeature isNull = null ; \"<AssertPlaceHolder>\" ; } getMergeFeature ( java . lang . String ) { if ( ( ! ( this . orderedBuildList . isEmpty ( ) ) ) && ( this . features . containsKey ( featureId , getLatestBuild ( ) ) ) ) { final xbdd . model . simple . Feature feature = this . features . get ( featureId , getLatestBuild ( ) ) ; final java . util . List < java . lang . String > featureStatuses = getFeatureStatuses ( feature ) ; final java . util . List < xbdd . model . MergeScenario > scenarioList = getMergedScenarios ( feature ) ; final xbdd . model . MergeFeature mergeFeature = new xbdd . model . MergeFeature ( ) ; mergeFeature . setId ( feature . getId ( ) ) ; mergeFeature . setName ( feature . getName ( ) ) ; mergeFeature . setStatuses ( featureStatuses ) ; mergeFeature . setUrl ( ( ( ( ( ( \"reports/\" + ( feature . getCoordinates ( ) . getProduct ( ) ) ) + \"/\" ) + ( feature . getCoordinates ( ) . getVersionString ( ) ) ) + \"/{{BUILD_NAME}}/\" ) + ( feature . getId ( ) ) ) ) ; mergeFeature . setScenarios ( scenarioList ) ; return mergeFeature ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( target . getMergeFeature ( feature . getId ( ) ) , org . hamcrest . Matchers . is ( isNull ) )"}
{"focal": "valueOf ( long ) { return new org . postgresql . replication . LogSequenceNumber ( value ) ; }", "testMethod": "testEqualLSN ( ) { org . postgresql . replication . LogSequenceNumber first = org . postgresql . replication . LogSequenceNumber . valueOf ( \"0/15D690F8\" ) ; org . postgresql . replication . LogSequenceNumber second = org . postgresql . replication . LogSequenceNumber . valueOf ( \"0/15D690F8\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( first , org . hamcrest . CoreMatchers . equalTo ( second ) )", "total": "testEqualLSN ( ) { org . postgresql . replication . LogSequenceNumber first = org . postgresql . replication . LogSequenceNumber . valueOf ( \"0/15D690F8\" ) ; org . postgresql . replication . LogSequenceNumber second = org . postgresql . replication . LogSequenceNumber . valueOf ( \"0/15D690F8\" ) ; \"<AssertPlaceHolder>\" ; } valueOf ( long ) { return new org . postgresql . replication . LogSequenceNumber ( value ) ; }", "answer": "org . junit . Assert . assertThat ( first , org . hamcrest . CoreMatchers . equalTo ( second ) )"}
{"focal": "not ( org . batfish . datamodel . acl . AclLineMatchExpr ) { if ( expr == ( org . batfish . datamodel . acl . AclLineMatchExprs . TRUE ) ) { return org . batfish . datamodel . acl . AclLineMatchExprs . FALSE ; } if ( expr == ( org . batfish . datamodel . acl . AclLineMatchExprs . FALSE ) ) { return org . batfish . datamodel . acl . AclLineMatchExprs . TRUE ; } if ( expr instanceof org . batfish . datamodel . acl . NotMatchExpr ) { return ( ( org . batfish . datamodel . acl . NotMatchExpr ) ( expr ) ) . getOperand ( ) ; } return new org . batfish . datamodel . acl . NotMatchExpr ( expr ) ; }", "testMethod": "testDifferentAclsNotEqual ( ) { org . batfish . datamodel . IpAccessList acl1 = _aclb . setName ( \"acl1\" ) . setLines ( com . google . common . collect . ImmutableList . of ( org . batfish . datamodel . IpAccessListLine . acceptingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"10.10.10.10/8\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; org . batfish . datamodel . IpAccessList acl2 = _aclb2 . setName ( \"acl2\" ) . setLines ( com . google . common . collect . ImmutableList . of ( org . batfish . datamodel . IpAccessListLine . rejectingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; org . batfish . datamodel . acl . CanonicalAcl canonicalAcl1 = new org . batfish . datamodel . acl . CanonicalAcl ( acl1 , acl1 , com . google . common . collect . ImmutableMap . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) ) ; org . batfish . datamodel . acl . CanonicalAcl canonicalAcl2 = new org . batfish . datamodel . acl . CanonicalAcl ( acl2 , acl2 , com . google . common . collect . ImmutableMap . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( canonicalAcl1 , org . hamcrest . Matchers . not ( org . hamcrest . Matchers . equalTo ( canonicalAcl2 ) ) )", "total": "testDifferentAclsNotEqual ( ) { org . batfish . datamodel . IpAccessList acl1 = _aclb . setName ( \"acl1\" ) . setLines ( com . google . common . collect . ImmutableList . of ( org . batfish . datamodel . IpAccessListLine . acceptingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"10.10.10.10/8\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; org . batfish . datamodel . IpAccessList acl2 = _aclb2 . setName ( \"acl2\" ) . setLines ( com . google . common . collect . ImmutableList . of ( org . batfish . datamodel . IpAccessListLine . rejectingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; org . batfish . datamodel . acl . CanonicalAcl canonicalAcl1 = new org . batfish . datamodel . acl . CanonicalAcl ( acl1 , acl1 , com . google . common . collect . ImmutableMap . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) ) ; org . batfish . datamodel . acl . CanonicalAcl canonicalAcl2 = new org . batfish . datamodel . acl . CanonicalAcl ( acl2 , acl2 , com . google . common . collect . ImmutableMap . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) ) ; \"<AssertPlaceHolder>\" ; } not ( org . batfish . datamodel . acl . AclLineMatchExpr ) { if ( expr == ( org . batfish . datamodel . acl . AclLineMatchExprs . TRUE ) ) { return org . batfish . datamodel . acl . AclLineMatchExprs . FALSE ; } if ( expr == ( org . batfish . datamodel . acl . AclLineMatchExprs . FALSE ) ) { return org . batfish . datamodel . acl . AclLineMatchExprs . TRUE ; } if ( expr instanceof org . batfish . datamodel . acl . NotMatchExpr ) { return ( ( org . batfish . datamodel . acl . NotMatchExpr ) ( expr ) ) . getOperand ( ) ; } return new org . batfish . datamodel . acl . NotMatchExpr ( expr ) ; }", "answer": "org . junit . Assert . assertThat ( canonicalAcl1 , org . hamcrest . Matchers . not ( org . hamcrest . Matchers . equalTo ( canonicalAcl2 ) ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "saveAnAlreadyExistingAxisValue ( ) { com . silverpeas . pdc . model . PdcAxisValue theExistingValue = findPdcAxisValue ( \"3\" , \"1\" ) ; com . silverpeas . pdc . model . PdcAxisValue theSavedValue = savePdcAxisValue ( theExistingValue ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( theSavedValue , is ( equalTo ( theExistingValue ) ) )", "total": "saveAnAlreadyExistingAxisValue ( ) { com . silverpeas . pdc . model . PdcAxisValue theExistingValue = findPdcAxisValue ( \"3\" , \"1\" ) ; com . silverpeas . pdc . model . PdcAxisValue theSavedValue = savePdcAxisValue ( theExistingValue ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( theSavedValue , is ( equalTo ( theExistingValue ) ) )"}
{"focal": "isNull ( ) { return nullValue ; }", "testMethod": "init ( ) { com . asakusafw . runtime . value . DateTimeOption option = new com . asakusafw . runtime . value . DateTimeOption ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( option . isNull ( ) , is ( true ) )", "total": "init ( ) { com . asakusafw . runtime . value . DateTimeOption option = new com . asakusafw . runtime . value . DateTimeOption ( ) ; \"<AssertPlaceHolder>\" ; } isNull ( ) { return nullValue ; }", "answer": "org . junit . Assert . assertThat ( option . isNull ( ) , is ( true ) )"}
{"focal": "toRegex ( java . lang . String ) { return text . replaceAll ( \"\\\\.\" , \"\\\\\\\\(\" 0 ) . replaceAll ( \"\\\\\\\\(\" 1 , \"\\\\\\\\[\" ) . replaceAll ( \"]\" , \"\\\\\\\\]\" ) . replaceAll ( \"\\\\(\" , \"\\\\\\\\(\" ) . replaceAll ( \"\\\\)\" , \"\\\\\\\\)\" ) . replaceAll ( \"\\\\*\" , \".*\" ) ; }", "testMethod": "testToRegex ( ) { java . lang . String regex = org . apache . maven . surefire . its . JUnitPlatformEnginesIT . toRegex ( \".[]()*\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"\\\\.\\\\[\\\\]\\\\(\\\\).*\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( regex )", "total": "testToRegex ( ) { java . lang . String regex = org . apache . maven . surefire . its . JUnitPlatformEnginesIT . toRegex ( \".[]()*\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"\\\\.\\\\[\\\\]\\\\(\\\\).*\" ) ; } toRegex ( java . lang . String ) { return text . replaceAll ( \"\\\\.\" , \"\\\\\\\\(\" 0 ) . replaceAll ( \"\\\\\\\\(\" 1 , \"\\\\\\\\[\" ) . replaceAll ( \"]\" , \"\\\\\\\\]\" ) . replaceAll ( \"\\\\(\" , \"\\\\\\\\(\" ) . replaceAll ( \"\\\\)\" , \"\\\\\\\\)\" ) . replaceAll ( \"\\\\*\" , \".*\" ) ; }", "answer": "org . junit . Assert . assertThat ( regex )"}
{"focal": "__doRender ( ) { this . __internal . writeValue ( views . A . getUser ( ) . getName ( ) ) ; }", "testMethod": "contextPath ( ) { final ninja . i18n . Lang ninjaLang = mock ( ninja . i18n . Lang . class ) ; final ninja . Context context = mock ( ninja . Context . class ) ; final ninja . Result result = mock ( ninja . Result . class ) ; when ( context . getContextPath ( ) ) . thenReturn ( \"/context\" ) ; when ( ninjaLang . getLanguage ( context , java . util . Optional . of ( result ) ) ) . thenReturn ( java . util . Optional . of ( \"en\" ) ) ; final com . fizzed . ninja . rocker . NinjaRockerFactory ninjaRockerFactory = new com . fizzed . ninja . rocker . NinjaRockerFactoryImpl ( ) ; com . fizzed . rocker . runtime . DefaultRockerModel model = new com . fizzed . rocker . runtime . DefaultRockerModel ( ) { @ com . fizzed . ninja . rocker . Override protected com . fizzed . rocker . runtime . DefaultRockerTemplate buildTemplate ( ) throws com . fizzed . rocker . RenderingException { return new com . fizzed . ninja . rocker . NinjaRockerTemplate ( this ) { { this . __internal . setCharset ( \"UTF-8\" ) ; this . __internal . setContentType ( ContentType . HTML ) ; this . __internal . setTemplatePackageName ( \"test\" ) ; this . __internal . setTemplateName ( \"test\" ) ; this . N = ninjaRockerFactory . create ( null , null , null , null , ninjaLang , context , result ) ; } @ com . fizzed . ninja . rocker . Override protected void __doRender ( ) throws com . fizzed . rocker . RenderingException , java . io . IOException { this . __internal . writeValue ( N . contextPath ) ; } } ; } } ; com . fizzed . rocker . RockerOutput out = model . render ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( out . toString ( ) , org . hamcrest . CoreMatchers . is ( \"/context\" ) )", "total": "contextPath ( ) { final ninja . i18n . Lang ninjaLang = mock ( ninja . i18n . Lang . class ) ; final ninja . Context context = mock ( ninja . Context . class ) ; final ninja . Result result = mock ( ninja . Result . class ) ; when ( context . getContextPath ( ) ) . thenReturn ( \"/context\" ) ; when ( ninjaLang . getLanguage ( context , java . util . Optional . of ( result ) ) ) . thenReturn ( java . util . Optional . of ( \"en\" ) ) ; final com . fizzed . ninja . rocker . NinjaRockerFactory ninjaRockerFactory = new com . fizzed . ninja . rocker . NinjaRockerFactoryImpl ( ) ; com . fizzed . rocker . runtime . DefaultRockerModel model = new com . fizzed . rocker . runtime . DefaultRockerModel ( ) { @ com . fizzed . ninja . rocker . Override protected com . fizzed . rocker . runtime . DefaultRockerTemplate buildTemplate ( ) throws com . fizzed . rocker . RenderingException { return new com . fizzed . ninja . rocker . NinjaRockerTemplate ( this ) { { this . __internal . setCharset ( \"UTF-8\" ) ; this . __internal . setContentType ( ContentType . HTML ) ; this . __internal . setTemplatePackageName ( \"test\" ) ; this . __internal . setTemplateName ( \"test\" ) ; this . N = ninjaRockerFactory . create ( null , null , null , null , ninjaLang , context , result ) ; } @ com . fizzed . ninja . rocker . Override protected void __doRender ( ) throws com . fizzed . rocker . RenderingException , java . io . IOException { this . __internal . writeValue ( N . contextPath ) ; } } ; } } ; com . fizzed . rocker . RockerOutput out = model . render ( ) ; \"<AssertPlaceHolder>\" ; } __doRender ( ) { this . __internal . writeValue ( views . A . getUser ( ) . getName ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( out . toString ( ) , org . hamcrest . CoreMatchers . is ( \"/context\" ) )"}
{"focal": "size ( ) { return delegate . size ( ) ; }", "testMethod": "resolversAreCopied ( ) { int initialResolversCount = childResolvers . size ( ) ; childResolvers . add ( org . mule . test . module . extension . internal . util . ExtensionsTestUtils . getResolver ( ( - 1 ) , resolvingContext , false ) ) ; java . util . Collection < java . lang . Object > resolved = ( ( java . util . Collection < java . lang . Object > ) ( resolver . resolve ( resolvingContext ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resolved . size ( ) , org . hamcrest . CoreMatchers . equalTo ( initialResolversCount ) )", "total": "resolversAreCopied ( ) { int initialResolversCount = childResolvers . size ( ) ; childResolvers . add ( org . mule . test . module . extension . internal . util . ExtensionsTestUtils . getResolver ( ( - 1 ) , resolvingContext , false ) ) ; java . util . Collection < java . lang . Object > resolved = ( ( java . util . Collection < java . lang . Object > ) ( resolver . resolve ( resolvingContext ) ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return delegate . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( resolved . size ( ) , org . hamcrest . CoreMatchers . equalTo ( initialResolversCount ) )"}
{"focal": "toString ( ) { return ( ( ( \"spacemanager={\" + ( destination ) ) + \",<sp>\" ) + ( inner ) ) + \"}\" ; }", "testMethod": "shouldOmitOnlyWSCharArray ( ) { writer . print ( \"<sp>\" . toCharArray ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . toString ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( \"\" ) ) )", "total": "shouldOmitOnlyWSCharArray ( ) { writer . print ( \"<sp>\" . toCharArray ( ) ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return ( ( ( \"spacemanager={\" + ( destination ) ) + \",<sp>\" ) + ( inner ) ) + \"}\" ; }", "answer": "org . junit . Assert . assertThat ( result . toString ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( \"\" ) ) )"}
{"focal": "runTaskTimer ( org . bukkit . scheduler . BukkitRunnable , long , long ) { return task . runTaskTimer ( authMe , delay , period ) ; }", "testMethod": "shouldRunTaskTimer ( ) { org . bukkit . scheduler . BukkitRunnable bukkitRunnable = mock ( org . bukkit . scheduler . BukkitRunnable . class ) ; long delay = 20 ; long period = 80 ; org . bukkit . scheduler . BukkitTask bukkitTask = mock ( org . bukkit . scheduler . BukkitTask . class ) ; given ( bukkitRunnable . runTaskTimer ( authMe , delay , period ) ) . willReturn ( bukkitTask ) ; org . bukkit . scheduler . BukkitTask result = bukkitService . runTaskTimer ( bukkitRunnable , delay , period ) ; \"<AssertPlaceHolder>\" ; verify ( bukkitRunnable ) . runTaskTimer ( authMe , delay , period ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( bukkitTask ) )", "total": "shouldRunTaskTimer ( ) { org . bukkit . scheduler . BukkitRunnable bukkitRunnable = mock ( org . bukkit . scheduler . BukkitRunnable . class ) ; long delay = 20 ; long period = 80 ; org . bukkit . scheduler . BukkitTask bukkitTask = mock ( org . bukkit . scheduler . BukkitTask . class ) ; given ( bukkitRunnable . runTaskTimer ( authMe , delay , period ) ) . willReturn ( bukkitTask ) ; org . bukkit . scheduler . BukkitTask result = bukkitService . runTaskTimer ( bukkitRunnable , delay , period ) ; \"<AssertPlaceHolder>\" ; verify ( bukkitRunnable ) . runTaskTimer ( authMe , delay , period ) ; } runTaskTimer ( org . bukkit . scheduler . BukkitRunnable , long , long ) { return task . runTaskTimer ( authMe , delay , period ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( bukkitTask ) )"}
{"focal": "isActive ( org . togglz . core . repository . FeatureState , org . togglz . core . user . FeatureUser ) { return true ; }", "testMethod": "isActiveWillReturnFalseWhenUserHasNoneOfSelectedRoles ( ) { org . mockito . Mockito . when ( user . getAttribute ( org . togglz . core . activation . UserRoleActivationStrategy . USER_ATTRIBUTE_ROLES ) ) . thenReturn ( userRoles ) ; org . mockito . Mockito . when ( state . getParameter ( org . togglz . core . activation . UserRoleActivationStrategy . PARAM_ROLES_NAME ) ) . thenReturn ( \"ROLE_1,<sp>ROLE_2,<sp>ROLE_3\" ) ; boolean result = activationStrategy . isActive ( state , user ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "isActiveWillReturnFalseWhenUserHasNoneOfSelectedRoles ( ) { org . mockito . Mockito . when ( user . getAttribute ( org . togglz . core . activation . UserRoleActivationStrategy . USER_ATTRIBUTE_ROLES ) ) . thenReturn ( userRoles ) ; org . mockito . Mockito . when ( state . getParameter ( org . togglz . core . activation . UserRoleActivationStrategy . PARAM_ROLES_NAME ) ) . thenReturn ( \"ROLE_1,<sp>ROLE_2,<sp>ROLE_3\" ) ; boolean result = activationStrategy . isActive ( state , user ) ; \"<AssertPlaceHolder>\" ; } isActive ( org . togglz . core . repository . FeatureState , org . togglz . core . user . FeatureUser ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "hasAdminAccess ( ) { throw new java . lang . UnsupportedOperationException ( \"Not<sp>implemented\" ) ; }", "testMethod": "hasAdminAccessReturnsFalseIfTheRolesAreEmpty ( ) { nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization instance = nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization . create ( \"\" , \"\" ) ; boolean allowedToWrite = instance . hasAdminAccess ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allowedToWrite , org . hamcrest . core . Is . is ( false ) )", "total": "hasAdminAccessReturnsFalseIfTheRolesAreEmpty ( ) { nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization instance = nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization . create ( \"\" , \"\" ) ; boolean allowedToWrite = instance . hasAdminAccess ( ) ; \"<AssertPlaceHolder>\" ; } hasAdminAccess ( ) { throw new java . lang . UnsupportedOperationException ( \"Not<sp>implemented\" ) ; }", "answer": "org . junit . Assert . assertThat ( allowedToWrite , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "testMethod": "applyTest ( ) { java . lang . String json = \"{<sp>\\\"html\\\"<sp>:<sp>\\\"1<h>2</h>3\\\"<sp>}\" ; java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>nil<sp>|<sp>strip_html<sp>}}\" , \"\" } , new java . lang . String [ ] { \"{{<sp>456<sp>|<sp>strip_html<sp>}}\" , \"456\" } , new java . lang . String [ ] { \"{{<sp>'45<6'<sp>|<sp>strip_html<sp>}}\" , \"45<6\" } , new java . lang . String [ ] { \"45<6\" 1 , \"\" } , new java . lang . String [ ] { \"45<6\" 0 , \"123\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( json ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "applyTest ( ) { java . lang . String json = \"{<sp>\\\"html\\\"<sp>:<sp>\\\"1<h>2</h>3\\\"<sp>}\" ; java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>nil<sp>|<sp>strip_html<sp>}}\" , \"\" } , new java . lang . String [ ] { \"{{<sp>456<sp>|<sp>strip_html<sp>}}\" , \"456\" } , new java . lang . String [ ] { \"{{<sp>'45<6'<sp>|<sp>strip_html<sp>}}\" , \"45<6\" } , new java . lang . String [ ] { \"45<6\" 1 , \"\" } , new java . lang . String [ ] { \"45<6\" 0 , \"123\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( json ) ) ; \"<AssertPlaceHolder>\" ; } } render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "empty ( ) { return com . annimon . stream . DoubleStream . EMPTY ; }", "testMethod": "testStreamEmpty ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . annimon . stream . DoubleStream . empty ( ) , isEmpty ( ) )", "total": "testStreamEmpty ( ) { \"<AssertPlaceHolder>\" ; } empty ( ) { return com . annimon . stream . DoubleStream . EMPTY ; }", "answer": "org . junit . Assert . assertThat ( com . annimon . stream . DoubleStream . empty ( ) , isEmpty ( ) )"}
{"focal": "get ( ) { org . neo4j . kernel . recovery . LogTailScanner . LogTailInformation logTailInformation = logTailScanner . getTailInformation ( ) ; org . neo4j . kernel . impl . transaction . log . entry . CheckPoint lastCheckPoint = logTailInformation . lastCheckPoint ; long txIdAfterLastCheckPoint = logTailInformation . firstTxIdAfterLastCheckPoint ; if ( ! ( logTailInformation . commitsAfterLastCheckpoint ( ) ) ) { monitor . noCommitsAfterLastCheckPoint ( ( lastCheckPoint != null ? lastCheckPoint . getLogPosition ( ) : null ) ) ; return createRecoveryInformation ( LogPosition . UNSPECIFIED , txIdAfterLastCheckPoint ) ; } if ( lastCheckPoint != null ) { monitor . commitsAfterLastCheckPoint ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; return createRecoveryInformation ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; } else { if ( ( logTailInformation . oldestLogVersionFound ) != ( INITIAL_LOG_VERSION ) ) { long fromLogVersion = java . lang . Math . max ( org . neo4j . kernel . recovery . INITIAL_LOG_VERSION , logTailInformation . oldestLogVersionFound ) ; throw new org . neo4j . kernel . impl . store . UnderlyingStorageException ( ( ( ( \"No<sp>check<sp>point<sp>found<sp>in<sp>any<sp>log<sp>file<sp>from<sp>version<sp>\" + fromLogVersion ) + \"<sp>to<sp>\" ) + ( logTailInformation . currentLogVersion ) ) ) ; } monitor . noCheckPointFound ( ) ; return createRecoveryInformation ( org . neo4j . kernel . impl . transaction . log . LogPosition . start ( 0 ) , txIdAfterLastCheckPoint ) ; } }", "testMethod": "givenAccessGuardWithConditionWhenGrantAndDenyThenNotifyListeners ( ) { org . neo4j . logging . Log log = mock ( org . neo4j . logging . Log . class ) ; final org . neo4j . kernel . availability . DatabaseAvailabilityGuard databaseAvailabilityGuard = org . neo4j . kernel . DatabaseAvailabilityGuardTest . getDatabaseAvailabilityGuard ( clock , log ) ; databaseAvailabilityGuard . require ( org . neo4j . kernel . DatabaseAvailabilityGuardTest . REQUIREMENT_1 ) ; final java . util . concurrent . atomic . AtomicBoolean notified = new java . util . concurrent . atomic . AtomicBoolean ( ) ; org . neo4j . kernel . availability . AvailabilityListener availabilityListener = new org . neo4j . kernel . availability . AvailabilityListener ( ) { @ org . neo4j . kernel . Override public void available ( ) { } @ org . neo4j . kernel . Override public void unavailable ( ) { notified . set ( true ) ; } } ; databaseAvailabilityGuard . addListener ( availabilityListener ) ; databaseAvailabilityGuard . fulfill ( org . neo4j . kernel . DatabaseAvailabilityGuardTest . REQUIREMENT_1 ) ; databaseAvailabilityGuard . require ( org . neo4j . kernel . DatabaseAvailabilityGuardTest . REQUIREMENT_1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( notified . get ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "givenAccessGuardWithConditionWhenGrantAndDenyThenNotifyListeners ( ) { org . neo4j . logging . Log log = mock ( org . neo4j . logging . Log . class ) ; final org . neo4j . kernel . availability . DatabaseAvailabilityGuard databaseAvailabilityGuard = org . neo4j . kernel . DatabaseAvailabilityGuardTest . getDatabaseAvailabilityGuard ( clock , log ) ; databaseAvailabilityGuard . require ( org . neo4j . kernel . DatabaseAvailabilityGuardTest . REQUIREMENT_1 ) ; final java . util . concurrent . atomic . AtomicBoolean notified = new java . util . concurrent . atomic . AtomicBoolean ( ) ; org . neo4j . kernel . availability . AvailabilityListener availabilityListener = new org . neo4j . kernel . availability . AvailabilityListener ( ) { @ org . neo4j . kernel . Override public void available ( ) { } @ org . neo4j . kernel . Override public void unavailable ( ) { notified . set ( true ) ; } } ; databaseAvailabilityGuard . addListener ( availabilityListener ) ; databaseAvailabilityGuard . fulfill ( org . neo4j . kernel . DatabaseAvailabilityGuardTest . REQUIREMENT_1 ) ; databaseAvailabilityGuard . require ( org . neo4j . kernel . DatabaseAvailabilityGuardTest . REQUIREMENT_1 ) ; \"<AssertPlaceHolder>\" ; } get ( ) { org . neo4j . kernel . recovery . LogTailScanner . LogTailInformation logTailInformation = logTailScanner . getTailInformation ( ) ; org . neo4j . kernel . impl . transaction . log . entry . CheckPoint lastCheckPoint = logTailInformation . lastCheckPoint ; long txIdAfterLastCheckPoint = logTailInformation . firstTxIdAfterLastCheckPoint ; if ( ! ( logTailInformation . commitsAfterLastCheckpoint ( ) ) ) { monitor . noCommitsAfterLastCheckPoint ( ( lastCheckPoint != null ? lastCheckPoint . getLogPosition ( ) : null ) ) ; return createRecoveryInformation ( LogPosition . UNSPECIFIED , txIdAfterLastCheckPoint ) ; } if ( lastCheckPoint != null ) { monitor . commitsAfterLastCheckPoint ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; return createRecoveryInformation ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; } else { if ( ( logTailInformation . oldestLogVersionFound ) != ( INITIAL_LOG_VERSION ) ) { long fromLogVersion = java . lang . Math . max ( org . neo4j . kernel . recovery . INITIAL_LOG_VERSION , logTailInformation . oldestLogVersionFound ) ; throw new org . neo4j . kernel . impl . store . UnderlyingStorageException ( ( ( ( \"No<sp>check<sp>point<sp>found<sp>in<sp>any<sp>log<sp>file<sp>from<sp>version<sp>\" + fromLogVersion ) + \"<sp>to<sp>\" ) + ( logTailInformation . currentLogVersion ) ) ) ; } monitor . noCheckPointFound ( ) ; return createRecoveryInformation ( org . neo4j . kernel . impl . transaction . log . LogPosition . start ( 0 ) , txIdAfterLastCheckPoint ) ; } }", "answer": "org . junit . Assert . assertThat ( notified . get ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "zouMeldingMoetenGevenOmdatOudersOpDezelfdeDagZijnGeboren ( ) { final nl . bzk . brp . model . objecttype . operationeel . RelatieModel relatieModel = mock ( nl . bzk . brp . model . objecttype . operationeel . RelatieModel . class ) ; final nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht kindBetrokkeneBericht = maakBetrokkeneBericht ( SoortBetrokkenheid . KIND , \"1\" ) ; final nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht moederBetrokkeneBericht = maakBetrokkeneBericht ( SoortBetrokkenheid . OUDER , \"2\" ) ; final nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht vaderBetrokkeneBericht = maakBetrokkeneBericht ( SoortBetrokkenheid . OUDER , \"3\" ) ; final nl . bzk . brp . model . objecttype . operationeel . PersoonModel vaderModel = mock ( nl . bzk . brp . model . objecttype . operationeel . PersoonModel . class ) ; final nl . bzk . brp . model . objecttype . operationeel . PersoonModel moederModel = mock ( nl . bzk . brp . model . objecttype . operationeel . PersoonModel . class ) ; final nl . bzk . brp . model . objecttype . bericht . RelatieBericht relatieBericht = new nl . bzk . brp . model . objecttype . bericht . RelatieBericht ( ) ; relatieBericht . setSoort ( SoortRelatie . FAMILIERECHTELIJKE_BETREKKING ) ; relatieBericht . setBetrokkenheden ( java . util . Arrays . asList ( kindBetrokkeneBericht , vaderBetrokkeneBericht , moederBetrokkeneBericht ) ) ; final nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel moederGeboorte = mock ( nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel . class ) ; final nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel vaderGeboorte = mock ( nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel . class ) ; when ( persoonRepository . findByBurgerservicenummer ( new nl . bzk . brp . model . attribuuttype . Burgerservicenummer ( \"2\" ) ) ) . thenReturn ( moederModel ) ; when ( persoonRepository . findByBurgerservicenummer ( new nl . bzk . brp . model . attribuuttype . Burgerservicenummer ( \"3\" ) ) ) . thenReturn ( vaderModel ) ; org . springframework . test . util . ReflectionTestUtils . setField ( moederGeboorte , \"datumGeboorte\" , nl . bzk . brp . util . DatumUtil . gisteren ( ) ) ; when ( moederModel . getGeboorte ( ) ) . thenReturn ( moederGeboorte ) ; when ( vaderModel . getGeboorte ( ) ) . thenReturn ( vaderGeboorte ) ; when ( moederGeboorte . getDatumGeboorte ( ) ) . thenReturn ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; when ( vaderGeboorte . getDatumGeboorte ( ) ) . thenReturn ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; java . util . List < nl . bzk . brp . model . validatie . Melding > meldingen = brby0129 . executeer ( relatieModel , relatieBericht , null ) ; \"<AssertPlaceHolder>\" ; verify ( persoonRepository , times ( 2 ) ) . findByBurgerservicenummer ( isA ( nl . bzk . brp . model . attribuuttype . Burgerservicenummer . class ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( meldingen . size ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "zouMeldingMoetenGevenOmdatOudersOpDezelfdeDagZijnGeboren ( ) { final nl . bzk . brp . model . objecttype . operationeel . RelatieModel relatieModel = mock ( nl . bzk . brp . model . objecttype . operationeel . RelatieModel . class ) ; final nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht kindBetrokkeneBericht = maakBetrokkeneBericht ( SoortBetrokkenheid . KIND , \"1\" ) ; final nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht moederBetrokkeneBericht = maakBetrokkeneBericht ( SoortBetrokkenheid . OUDER , \"2\" ) ; final nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht vaderBetrokkeneBericht = maakBetrokkeneBericht ( SoortBetrokkenheid . OUDER , \"3\" ) ; final nl . bzk . brp . model . objecttype . operationeel . PersoonModel vaderModel = mock ( nl . bzk . brp . model . objecttype . operationeel . PersoonModel . class ) ; final nl . bzk . brp . model . objecttype . operationeel . PersoonModel moederModel = mock ( nl . bzk . brp . model . objecttype . operationeel . PersoonModel . class ) ; final nl . bzk . brp . model . objecttype . bericht . RelatieBericht relatieBericht = new nl . bzk . brp . model . objecttype . bericht . RelatieBericht ( ) ; relatieBericht . setSoort ( SoortRelatie . FAMILIERECHTELIJKE_BETREKKING ) ; relatieBericht . setBetrokkenheden ( java . util . Arrays . asList ( kindBetrokkeneBericht , vaderBetrokkeneBericht , moederBetrokkeneBericht ) ) ; final nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel moederGeboorte = mock ( nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel . class ) ; final nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel vaderGeboorte = mock ( nl . bzk . brp . model . groep . operationeel . actueel . PersoonGeboorteGroepModel . class ) ; when ( persoonRepository . findByBurgerservicenummer ( new nl . bzk . brp . model . attribuuttype . Burgerservicenummer ( \"2\" ) ) ) . thenReturn ( moederModel ) ; when ( persoonRepository . findByBurgerservicenummer ( new nl . bzk . brp . model . attribuuttype . Burgerservicenummer ( \"3\" ) ) ) . thenReturn ( vaderModel ) ; org . springframework . test . util . ReflectionTestUtils . setField ( moederGeboorte , \"datumGeboorte\" , nl . bzk . brp . util . DatumUtil . gisteren ( ) ) ; when ( moederModel . getGeboorte ( ) ) . thenReturn ( moederGeboorte ) ; when ( vaderModel . getGeboorte ( ) ) . thenReturn ( vaderGeboorte ) ; when ( moederGeboorte . getDatumGeboorte ( ) ) . thenReturn ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; when ( vaderGeboorte . getDatumGeboorte ( ) ) . thenReturn ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; java . util . List < nl . bzk . brp . model . validatie . Melding > meldingen = brby0129 . executeer ( relatieModel , relatieBericht , null ) ; \"<AssertPlaceHolder>\" ; verify ( persoonRepository , times ( 2 ) ) . findByBurgerservicenummer ( isA ( nl . bzk . brp . model . attribuuttype . Burgerservicenummer . class ) ) ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( meldingen . size ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "fromDBObject ( com . mongodb . DBObject ) { checkNotNull ( dbObj , \"line_items\" 8 ) ; com . mongodb . BasicDBObject orderObj = ( ( com . mongodb . BasicDBObject ) ( dbObj ) ) ; org . mybatis . jpetstore . domain . Order order = new org . mybatis . jpetstore . domain . Order ( ) ; order . setOrderId ( orderObj . getInt ( \"line_items\" 7 ) ) ; order . setUsername ( orderObj . getString ( \"ship_country\" 4 ) ) ; order . setOrderDate ( orderObj . getDate ( \"order_date\" ) ) ; order . setCourier ( orderObj . getString ( \"ship_country\" 5 ) ) ; java . lang . String totalPrice = orderObj . getString ( \"line_items\" 4 ) ; if ( ! ( isNullOrEmpty ( totalPrice ) ) ) { order . setTotalPrice ( new java . math . BigDecimal ( totalPrice ) ) ; } order . setLocale ( orderObj . getString ( \"locale\" ) ) ; order . setStatus ( orderObj . getString ( \"line_items\" 2 ) ) ; com . mongodb . BasicDBObject shipToObj = ( ( com . mongodb . BasicDBObject ) ( orderObj . get ( \"ship_country\" 7 ) ) ) ; order . setShipToFirstName ( shipToObj . getString ( \"line_items\" 5 ) ) ; order . setShipToLastName ( shipToObj . getString ( \"ship_to_lastname\" ) ) ; order . setShipAddress1 ( shipToObj . getString ( \"ship_country\" 0 ) ) ; order . setShipAddress2 ( shipToObj . getString ( \"line_items\" 9 ) ) ; order . setShipCity ( shipToObj . getString ( \"ship_city\" ) ) ; order . setShipState ( shipToObj . getString ( \"ship_state\" ) ) ; order . setShipZip ( shipToObj . getString ( \"ship_zip\" ) ) ; order . setShipCountry ( shipToObj . getString ( \"ship_country\" ) ) ; com . mongodb . BasicDBObject billToObj = ( ( com . mongodb . BasicDBObject ) ( orderObj . get ( \"billing_address\" ) ) ) ; order . setBillToFirstName ( billToObj . getString ( \"order_date\" 0 ) ) ; order . setBillToLastName ( billToObj . getString ( \"ship_country\" 8 ) ) ; order . setBillAddress1 ( billToObj . getString ( \"ship_country\" 1 ) ) ; order . setBillAddress2 ( billToObj . getString ( \"bill_address_2\" ) ) ; order . setBillCity ( billToObj . getString ( \"ship_country\" 3 ) ) ; order . setBillState ( billToObj . getString ( \"ship_country\" 9 ) ) ; order . setBillZip ( billToObj . getString ( \"line_items\" 3 ) ) ; order . setBillCountry ( billToObj . getString ( \"ship_country\" 2 ) ) ; com . mongodb . BasicDBObject paymentInfoObj = ( ( com . mongodb . BasicDBObject ) ( orderObj . get ( \"line_items\" 0 ) ) ) ; order . setCreditCard ( paymentInfoObj . getString ( \"line_items\" 1 ) ) ; order . setExpiryDate ( paymentInfoObj . getString ( \"ship_country\" 6 ) ) ; order . setCardType ( paymentInfoObj . getString ( \"line_items\" 6 ) ) ; java . util . List < com . mongodb . DBObject > lineItemObjs = ( ( java . util . ArrayList < com . mongodb . DBObject > ) ( orderObj . get ( \"line_items\" ) ) ) ; java . util . List < org . mybatis . jpetstore . domain . LineItem > lineItems = new java . util . ArrayList ( ) ; for ( com . mongodb . DBObject lineItemObj : lineItemObjs ) { org . mybatis . jpetstore . domain . LineItem lineItem = org . mybatis . jpetstore . domain . LineItem . fromDBObject ( lineItemObj ) ; lineItem . setOrderId ( order . getOrderId ( ) ) ; lineItems . add ( lineItem ) ; } order . setLineItems ( lineItems ) ; return order ; }", "testMethod": "insertLineItem_shouldAddNewLineItemToExistingOrder ( ) { org . mybatis . jpetstore . domain . Order existingOrder = createOrderWithAllFields ( ) ; insertOrder ( existingOrder ) ; java . lang . Integer lineNumber = ( existingOrder . getLineItems ( ) . size ( ) ) + 1 ; org . mybatis . jpetstore . domain . LineItem newLineItem = createLineItemBuilderWithAllFields ( existingOrder . getOrderId ( ) , lineNumber ) . build ( ) ; orderDao . insertLineItem ( newLineItem ) ; com . mongodb . DBObject orderObj = collection . findOne ( new com . mongodb . BasicDBObject ( \"_id\" , existingOrder . getOrderId ( ) ) ) ; java . util . List < org . mybatis . jpetstore . domain . LineItem > lineItems = com . google . common . collect . Lists . newArrayList ( ) ; if ( orderObj != null ) { org . mybatis . jpetstore . domain . Order order = org . mybatis . jpetstore . domain . Order . fromDBObject ( orderObj ) ; lineItems . addAll ( order . getLineItems ( ) ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( lineItems . contains ( newLineItem ) , org . hamcrest . core . Is . is ( true ) )", "total": "insertLineItem_shouldAddNewLineItemToExistingOrder ( ) { org . mybatis . jpetstore . domain . Order existingOrder = createOrderWithAllFields ( ) ; insertOrder ( existingOrder ) ; java . lang . Integer lineNumber = ( existingOrder . getLineItems ( ) . size ( ) ) + 1 ; org . mybatis . jpetstore . domain . LineItem newLineItem = createLineItemBuilderWithAllFields ( existingOrder . getOrderId ( ) , lineNumber ) . build ( ) ; orderDao . insertLineItem ( newLineItem ) ; com . mongodb . DBObject orderObj = collection . findOne ( new com . mongodb . BasicDBObject ( \"_id\" , existingOrder . getOrderId ( ) ) ) ; java . util . List < org . mybatis . jpetstore . domain . LineItem > lineItems = com . google . common . collect . Lists . newArrayList ( ) ; if ( orderObj != null ) { org . mybatis . jpetstore . domain . Order order = org . mybatis . jpetstore . domain . Order . fromDBObject ( orderObj ) ; lineItems . addAll ( order . getLineItems ( ) ) ; } \"<AssertPlaceHolder>\" ; } fromDBObject ( com . mongodb . DBObject ) { checkNotNull ( dbObj , \"line_items\" 8 ) ; com . mongodb . BasicDBObject orderObj = ( ( com . mongodb . BasicDBObject ) ( dbObj ) ) ; org . mybatis . jpetstore . domain . Order order = new org . mybatis . jpetstore . domain . Order ( ) ; order . setOrderId ( orderObj . getInt ( \"line_items\" 7 ) ) ; order . setUsername ( orderObj . getString ( \"ship_country\" 4 ) ) ; order . setOrderDate ( orderObj . getDate ( \"order_date\" ) ) ; order . setCourier ( orderObj . getString ( \"ship_country\" 5 ) ) ; java . lang . String totalPrice = orderObj . getString ( \"line_items\" 4 ) ; if ( ! ( isNullOrEmpty ( totalPrice ) ) ) { order . setTotalPrice ( new java . math . BigDecimal ( totalPrice ) ) ; } order . setLocale ( orderObj . getString ( \"locale\" ) ) ; order . setStatus ( orderObj . getString ( \"line_items\" 2 ) ) ; com . mongodb . BasicDBObject shipToObj = ( ( com . mongodb . BasicDBObject ) ( orderObj . get ( \"ship_country\" 7 ) ) ) ; order . setShipToFirstName ( shipToObj . getString ( \"line_items\" 5 ) ) ; order . setShipToLastName ( shipToObj . getString ( \"ship_to_lastname\" ) ) ; order . setShipAddress1 ( shipToObj . getString ( \"ship_country\" 0 ) ) ; order . setShipAddress2 ( shipToObj . getString ( \"line_items\" 9 ) ) ; order . setShipCity ( shipToObj . getString ( \"ship_city\" ) ) ; order . setShipState ( shipToObj . getString ( \"ship_state\" ) ) ; order . setShipZip ( shipToObj . getString ( \"ship_zip\" ) ) ; order . setShipCountry ( shipToObj . getString ( \"ship_country\" ) ) ; com . mongodb . BasicDBObject billToObj = ( ( com . mongodb . BasicDBObject ) ( orderObj . get ( \"billing_address\" ) ) ) ; order . setBillToFirstName ( billToObj . getString ( \"order_date\" 0 ) ) ; order . setBillToLastName ( billToObj . getString ( \"ship_country\" 8 ) ) ; order . setBillAddress1 ( billToObj . getString ( \"ship_country\" 1 ) ) ; order . setBillAddress2 ( billToObj . getString ( \"bill_address_2\" ) ) ; order . setBillCity ( billToObj . getString ( \"ship_country\" 3 ) ) ; order . setBillState ( billToObj . getString ( \"ship_country\" 9 ) ) ; order . setBillZip ( billToObj . getString ( \"line_items\" 3 ) ) ; order . setBillCountry ( billToObj . getString ( \"ship_country\" 2 ) ) ; com . mongodb . BasicDBObject paymentInfoObj = ( ( com . mongodb . BasicDBObject ) ( orderObj . get ( \"line_items\" 0 ) ) ) ; order . setCreditCard ( paymentInfoObj . getString ( \"line_items\" 1 ) ) ; order . setExpiryDate ( paymentInfoObj . getString ( \"ship_country\" 6 ) ) ; order . setCardType ( paymentInfoObj . getString ( \"line_items\" 6 ) ) ; java . util . List < com . mongodb . DBObject > lineItemObjs = ( ( java . util . ArrayList < com . mongodb . DBObject > ) ( orderObj . get ( \"line_items\" ) ) ) ; java . util . List < org . mybatis . jpetstore . domain . LineItem > lineItems = new java . util . ArrayList ( ) ; for ( com . mongodb . DBObject lineItemObj : lineItemObjs ) { org . mybatis . jpetstore . domain . LineItem lineItem = org . mybatis . jpetstore . domain . LineItem . fromDBObject ( lineItemObj ) ; lineItem . setOrderId ( order . getOrderId ( ) ) ; lineItems . add ( lineItem ) ; } order . setLineItems ( lineItems ) ; return order ; }", "answer": "org . junit . Assert . assertThat ( lineItems . contains ( newLineItem ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "resourceUrl ( ddf . catalog . data . Metacard ) { if ( ( resourceActionProvider ) != null ) { ddf . action . Action action = resourceActionProvider . getAction ( context ) ; if ( action != null ) { return action . getUrl ( ) . toString ( ) ; } } return context . getResourceURI ( ) . toString ( ) ; }", "testMethod": "testNoActionProviderResourceUrl ( ) { ddf . catalog . data . impl . MetacardImpl metacard = new ddf . catalog . data . impl . MetacardImpl ( ) ; metacard . setSourceId ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . SOURCE ) ; metacard . setId ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . ID ) ; metacard . setResourceURI ( new java . net . URI ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . DEFAULT_URI ) ) ; org . codice . ddf . spatial . kml . transformer . DescriptionTemplateHelper noActionHelper = new org . codice . ddf . spatial . kml . transformer . DescriptionTemplateHelper ( null ) ; java . lang . String url = noActionHelper . resourceUrl ( metacard ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( url , org . hamcrest . Matchers . is ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . DEFAULT_URI ) )", "total": "testNoActionProviderResourceUrl ( ) { ddf . catalog . data . impl . MetacardImpl metacard = new ddf . catalog . data . impl . MetacardImpl ( ) ; metacard . setSourceId ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . SOURCE ) ; metacard . setId ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . ID ) ; metacard . setResourceURI ( new java . net . URI ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . DEFAULT_URI ) ) ; org . codice . ddf . spatial . kml . transformer . DescriptionTemplateHelper noActionHelper = new org . codice . ddf . spatial . kml . transformer . DescriptionTemplateHelper ( null ) ; java . lang . String url = noActionHelper . resourceUrl ( metacard ) ; \"<AssertPlaceHolder>\" ; } resourceUrl ( ddf . catalog . data . Metacard ) { if ( ( resourceActionProvider ) != null ) { ddf . action . Action action = resourceActionProvider . getAction ( context ) ; if ( action != null ) { return action . getUrl ( ) . toString ( ) ; } } return context . getResourceURI ( ) . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( url , org . hamcrest . Matchers . is ( org . codice . ddf . spatial . kml . transformer . TestDescriptionTemplateHelper . DEFAULT_URI ) )"}
{"focal": "getDomain ( ) { return domain ; }", "testMethod": "testThatCookieUseApplicationDomain ( ) { when ( ninjaProperties . get ( NinjaConstant . applicationCookieDomain ) ) . thenReturn ( \"domain.com\" ) ; ninja . session . Session sessionCookie = createNewSession ( ) ; sessionCookie . init ( context ) ; sessionCookie . put ( \"anykey\" , \"anyvalue\" ) ; sessionCookie . save ( context ) ; verify ( context ) . addCookie ( cookieCaptor . capture ( ) ) ; ninja . Cookie cookie = cookieCaptor . getValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cookie . getDomain ( ) , org . hamcrest . CoreMatchers . equalTo ( \"domain.com\" ) )", "total": "testThatCookieUseApplicationDomain ( ) { when ( ninjaProperties . get ( NinjaConstant . applicationCookieDomain ) ) . thenReturn ( \"domain.com\" ) ; ninja . session . Session sessionCookie = createNewSession ( ) ; sessionCookie . init ( context ) ; sessionCookie . put ( \"anykey\" , \"anyvalue\" ) ; sessionCookie . save ( context ) ; verify ( context ) . addCookie ( cookieCaptor . capture ( ) ) ; ninja . Cookie cookie = cookieCaptor . getValue ( ) ; \"<AssertPlaceHolder>\" ; } getDomain ( ) { return domain ; }", "answer": "org . junit . Assert . assertThat ( cookie . getDomain ( ) , org . hamcrest . CoreMatchers . equalTo ( \"domain.com\" ) )"}
{"focal": "getStatusInfo ( ) { return status ; }", "testMethod": "thingManagerHandlesThingStatusUpdateUninitializedWithAnExceptionCorrectly ( ) { java . lang . String exceptionMessage = \"Some<sp>runtime<sp>exception<sp>occurred!\" ; org . eclipse . smarthome . core . thing . binding . ThingHandler thingHandler = mock ( org . eclipse . smarthome . core . thing . binding . ThingHandler . class ) ; when ( thingHandler . getThing ( ) ) . thenReturn ( thing ) ; org . eclipse . smarthome . core . thing . binding . ThingHandlerFactory thingHandlerFactory = mock ( org . eclipse . smarthome . core . thing . binding . ThingHandlerFactory . class ) ; when ( thingHandlerFactory . supportsThingType ( org . hamcrest . CoreMatchers . any ( org . eclipse . smarthome . core . thing . ThingTypeUID . class ) ) ) . thenReturn ( true ) ; when ( thingHandlerFactory . registerHandler ( org . hamcrest . CoreMatchers . any ( org . eclipse . smarthome . core . thing . Thing . class ) ) ) . thenThrow ( new java . lang . RuntimeException ( exceptionMessage ) ) ; registerService ( thingHandlerFactory ) ; managedThingProvider . add ( thing ) ; org . eclipse . smarthome . core . thing . ThingStatusInfo statusInfo = org . eclipse . smarthome . core . thing . binding . builder . ThingStatusInfoBuilder . create ( ThingStatus . UNINITIALIZED , ThingStatusDetail . HANDLER_REGISTERING_ERROR ) . withDescription ( exceptionMessage ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( thing . getStatusInfo ( ) , org . hamcrest . CoreMatchers . is ( statusInfo ) )", "total": "thingManagerHandlesThingStatusUpdateUninitializedWithAnExceptionCorrectly ( ) { java . lang . String exceptionMessage = \"Some<sp>runtime<sp>exception<sp>occurred!\" ; org . eclipse . smarthome . core . thing . binding . ThingHandler thingHandler = mock ( org . eclipse . smarthome . core . thing . binding . ThingHandler . class ) ; when ( thingHandler . getThing ( ) ) . thenReturn ( thing ) ; org . eclipse . smarthome . core . thing . binding . ThingHandlerFactory thingHandlerFactory = mock ( org . eclipse . smarthome . core . thing . binding . ThingHandlerFactory . class ) ; when ( thingHandlerFactory . supportsThingType ( org . hamcrest . CoreMatchers . any ( org . eclipse . smarthome . core . thing . ThingTypeUID . class ) ) ) . thenReturn ( true ) ; when ( thingHandlerFactory . registerHandler ( org . hamcrest . CoreMatchers . any ( org . eclipse . smarthome . core . thing . Thing . class ) ) ) . thenThrow ( new java . lang . RuntimeException ( exceptionMessage ) ) ; registerService ( thingHandlerFactory ) ; managedThingProvider . add ( thing ) ; org . eclipse . smarthome . core . thing . ThingStatusInfo statusInfo = org . eclipse . smarthome . core . thing . binding . builder . ThingStatusInfoBuilder . create ( ThingStatus . UNINITIALIZED , ThingStatusDetail . HANDLER_REGISTERING_ERROR ) . withDescription ( exceptionMessage ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getStatusInfo ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( thing . getStatusInfo ( ) , org . hamcrest . CoreMatchers . is ( statusInfo ) )"}
{"focal": "readFromParcel ( android . os . Parcel , java . lang . Class , java . lang . String ) { parcel . setDataPosition ( 0 ) ; android . os . Bundle bundle = parcel . readBundle ( ) ; bundle . setClassLoader ( parcelableType . getClassLoader ( ) ) ; android . os . Parcelable unparceledInstance = bundle . getParcelable ( key ) ; return unparceledInstance ; }", "testMethod": "parcelableTreeIsParcelable ( ) { java . lang . Class < ? > parcelableType = schemaRule . generateAndCompile ( \"/schema/parcelable/parcelable-schema.json\" , \"com.example\" , config ( \"parcelable\" , true ) ) . loadClass ( \"com.example.ParcelableSchema\" ) ; android . os . Parcelable instance = ( ( android . os . Parcelable ) ( new com . fasterxml . jackson . databind . ObjectMapper ( ) . readValue ( org . jsonschema2pojo . integration . config . ParcelableIT . class . getResourceAsStream ( \"/schema/parcelable/parcelable-data.json\" ) , parcelableType ) ) ) ; java . lang . String key = \"example\" ; android . os . Parcel parcel = writeToParcel ( instance , key ) ; android . os . Parcelable unparceledInstance = readFromParcel ( parcel , parcelableType , key ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( instance , is ( equalTo ( unparceledInstance ) ) )", "total": "parcelableTreeIsParcelable ( ) { java . lang . Class < ? > parcelableType = schemaRule . generateAndCompile ( \"/schema/parcelable/parcelable-schema.json\" , \"com.example\" , config ( \"parcelable\" , true ) ) . loadClass ( \"com.example.ParcelableSchema\" ) ; android . os . Parcelable instance = ( ( android . os . Parcelable ) ( new com . fasterxml . jackson . databind . ObjectMapper ( ) . readValue ( org . jsonschema2pojo . integration . config . ParcelableIT . class . getResourceAsStream ( \"/schema/parcelable/parcelable-data.json\" ) , parcelableType ) ) ) ; java . lang . String key = \"example\" ; android . os . Parcel parcel = writeToParcel ( instance , key ) ; android . os . Parcelable unparceledInstance = readFromParcel ( parcel , parcelableType , key ) ; \"<AssertPlaceHolder>\" ; } readFromParcel ( android . os . Parcel , java . lang . Class , java . lang . String ) { parcel . setDataPosition ( 0 ) ; android . os . Bundle bundle = parcel . readBundle ( ) ; bundle . setClassLoader ( parcelableType . getClassLoader ( ) ) ; android . os . Parcelable unparceledInstance = bundle . getParcelable ( key ) ; return unparceledInstance ; }", "answer": "org . junit . Assert . assertThat ( instance , is ( equalTo ( unparceledInstance ) ) )"}
{"focal": "getDesiredState ( ) { return ( serverSpec ) == null ? null : serverSpec . getDesiredState ( ) ; }", "testMethod": "whenSpecified_managedServerDesiredStateIsAsSpecified ( ) { configureServer ( oracle . kubernetes . weblogic . domain . DomainTestBase . SERVER1 ) . withDesiredState ( \"STAND-BY\" ) ; oracle . kubernetes . weblogic . domain . model . ServerSpec spec = domain . getServer ( oracle . kubernetes . weblogic . domain . DomainTestBase . SERVER1 , oracle . kubernetes . weblogic . domain . DomainTestBase . CLUSTER_NAME ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( spec . getDesiredState ( ) , org . hamcrest . Matchers . equalTo ( \"STAND-BY\" ) )", "total": "whenSpecified_managedServerDesiredStateIsAsSpecified ( ) { configureServer ( oracle . kubernetes . weblogic . domain . DomainTestBase . SERVER1 ) . withDesiredState ( \"STAND-BY\" ) ; oracle . kubernetes . weblogic . domain . model . ServerSpec spec = domain . getServer ( oracle . kubernetes . weblogic . domain . DomainTestBase . SERVER1 , oracle . kubernetes . weblogic . domain . DomainTestBase . CLUSTER_NAME ) ; \"<AssertPlaceHolder>\" ; } getDesiredState ( ) { return ( serverSpec ) == null ? null : serverSpec . getDesiredState ( ) ; }", "answer": "org . junit . Assert . assertThat ( spec . getDesiredState ( ) , org . hamcrest . Matchers . equalTo ( \"STAND-BY\" ) )"}
{"focal": "getID ( org . eclipse . emf . ecore . EObject ) { org . eclipse . emf . ecore . resource . Resource resource = object . eResource ( ) ; if ( resource == null ) return null ; org . eclipse . emf . common . util . URI uri = resource . getURI ( ) ; if ( ( uri . segmentCount ( ) ) != 3 ) return null ; return uri . segment ( 2 ) ; }", "testMethod": "testUpdateWithOptionGenerateId ( ) { java . lang . String id = \"ID\" ; org . eclipselabs . mongoemf . junit . model . TargetObject targetObject = ModelFactory . eINSTANCE . createTargetObject ( ) ; targetObject . setSingleAttribute ( \"junit\" ) ; saveObject ( targetObject , createObjectURI ( targetObject . eClass ( ) , id ) , null ) ; targetObject . setSingleAttribute ( \"updated\" ) ; targetObject . eResource ( ) . save ( null ) ; org . eclipselabs . mongoemf . junit . model . TargetObject actual = org . eclipselabs . mongoemf . junit . support . EChecker . checkObject ( targetObject , createResourceSet ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . eclipselabs . mongoemf . junit . support . EChecker . getID ( actual ) , org . hamcrest . CoreMatchers . is ( id ) )", "total": "testUpdateWithOptionGenerateId ( ) { java . lang . String id = \"ID\" ; org . eclipselabs . mongoemf . junit . model . TargetObject targetObject = ModelFactory . eINSTANCE . createTargetObject ( ) ; targetObject . setSingleAttribute ( \"junit\" ) ; saveObject ( targetObject , createObjectURI ( targetObject . eClass ( ) , id ) , null ) ; targetObject . setSingleAttribute ( \"updated\" ) ; targetObject . eResource ( ) . save ( null ) ; org . eclipselabs . mongoemf . junit . model . TargetObject actual = org . eclipselabs . mongoemf . junit . support . EChecker . checkObject ( targetObject , createResourceSet ( ) ) ; \"<AssertPlaceHolder>\" ; } getID ( org . eclipse . emf . ecore . EObject ) { org . eclipse . emf . ecore . resource . Resource resource = object . eResource ( ) ; if ( resource == null ) return null ; org . eclipse . emf . common . util . URI uri = resource . getURI ( ) ; if ( ( uri . segmentCount ( ) ) != 3 ) return null ; return uri . segment ( 2 ) ; }", "answer": "org . junit . Assert . assertThat ( org . eclipselabs . mongoemf . junit . support . EChecker . getID ( actual ) , org . hamcrest . CoreMatchers . is ( id ) )"}
{"focal": "getHeaderField ( java . lang . String ) { java . lang . String canonicalizedField = com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse . canonicalizeFieldName ( field ) ; java . lang . String values = this . headerFields . get ( canonicalizedField ) ; if ( values == null ) { java . lang . String errMsg = java . lang . String . format ( ( \"Could<sp>not<sp>find<sp>a<sp>value<sp>\" + \"associated<sp>with<sp>the<sp>header<sp>field<sp>name<sp>\\'%s\\'.\\n\" ) , field ) ; throw new java . lang . IllegalArgumentException ( errMsg ) ; } return values ; }", "testMethod": "getHeaderFieldReturnsHeaderField ( ) { final int status = 200 ; final byte [ ] body = new byte [ ] { 1 } ; final byte [ ] errorReason = new byte [ ] { } ; final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final java . lang . String field = \"test-field\" ; final java . util . List < java . lang . String > values = new java . util . LinkedList ( ) ; final java . lang . String value0 = \"test-field-value0\" ; final java . lang . String value1 = \"test-field-value1\" ; final java . lang . String expectedValues = ( value0 + \",\" ) + value1 ; values . add ( value0 ) ; values . add ( value1 ) ; headerFields . put ( field , values ) ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = new com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse ( status , body , headerFields , errorReason ) ; java . lang . String testValues = response . getHeaderField ( field ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testValues , org . hamcrest . CoreMatchers . is ( expectedValues ) )", "total": "getHeaderFieldReturnsHeaderField ( ) { final int status = 200 ; final byte [ ] body = new byte [ ] { 1 } ; final byte [ ] errorReason = new byte [ ] { } ; final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final java . lang . String field = \"test-field\" ; final java . util . List < java . lang . String > values = new java . util . LinkedList ( ) ; final java . lang . String value0 = \"test-field-value0\" ; final java . lang . String value1 = \"test-field-value1\" ; final java . lang . String expectedValues = ( value0 + \",\" ) + value1 ; values . add ( value0 ) ; values . add ( value1 ) ; headerFields . put ( field , values ) ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = new com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse ( status , body , headerFields , errorReason ) ; java . lang . String testValues = response . getHeaderField ( field ) ; \"<AssertPlaceHolder>\" ; } getHeaderField ( java . lang . String ) { java . lang . String canonicalizedField = com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse . canonicalizeFieldName ( field ) ; java . lang . String values = this . headerFields . get ( canonicalizedField ) ; if ( values == null ) { java . lang . String errMsg = java . lang . String . format ( ( \"Could<sp>not<sp>find<sp>a<sp>value<sp>\" + \"associated<sp>with<sp>the<sp>header<sp>field<sp>name<sp>\\'%s\\'.\\n\" ) , field ) ; throw new java . lang . IllegalArgumentException ( errMsg ) ; } return values ; }", "answer": "org . junit . Assert . assertThat ( testValues , org . hamcrest . CoreMatchers . is ( expectedValues ) )"}
{"focal": "matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "testMethod": "testMatchExactlyNodeNotFoundErr ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; long idleTimeout = 0 ; long hardTimeout = 0 ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow flow = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , idleTimeout , hardTimeout , path , edgeAction , flowAttributes ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_s1\" , \"node_s1\" 0 ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_s2\" , \"port_s2\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match3 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_d1\" , \"port_d1\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match4 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_d2\" , \"port_d2\" ) ; flow . addMatch ( match1 ) ; flow . addMatch ( match2 ) ; flow . addMatch ( match3 ) ; flow . addMatch ( match4 ) ; flow . addPath ( link1 . getId ( ) ) ; flow . addPath ( link2 . getId ( ) ) ; queriesString = \"node_s1\" 1 ; org . o3project . odenos . core . component . network . topology . Topology topology = new org . o3project . odenos . core . component . network . topology . Topology ( nodes , links ) ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowQuery ( queriesString ) ; target . setTopology ( topology ) ; target . parse ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testMatchExactlyNodeNotFoundErr ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; long idleTimeout = 0 ; long hardTimeout = 0 ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow flow = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , idleTimeout , hardTimeout , path , edgeAction , flowAttributes ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_s1\" , \"node_s1\" 0 ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_s2\" , \"port_s2\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match3 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_d1\" , \"port_d1\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match4 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node_d2\" , \"port_d2\" ) ; flow . addMatch ( match1 ) ; flow . addMatch ( match2 ) ; flow . addMatch ( match3 ) ; flow . addMatch ( match4 ) ; flow . addPath ( link1 . getId ( ) ) ; flow . addPath ( link2 . getId ( ) ) ; queriesString = \"node_s1\" 1 ; org . o3project . odenos . core . component . network . topology . Topology topology = new org . o3project . odenos . core . component . network . topology . Topology ( nodes , links ) ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowQuery ( queriesString ) ; target . setTopology ( topology ) ; target . parse ( ) ; \"<AssertPlaceHolder>\" ; } matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "get ( ) { return java . util . concurrent . CompletableFuture . completedFuture ( value . get ( ) ) ; }", "testMethod": "testValueAsPrimitiveDouble ( ) { org . onosproject . net . resource . ContinuousResource resource = org . onosproject . net . resource . Resources . continuous ( org . onosproject . net . resource . ContinuousResourceTest . D1 , org . onosproject . net . resource . ContinuousResourceTest . P1 , org . onlab . util . Bandwidth . class ) . resource ( org . onosproject . net . resource . ContinuousResourceTest . BW1 . bps ( ) ) ; java . util . Optional < java . lang . Double > volume = resource . valueAs ( double . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( volume . get ( ) , org . hamcrest . Matchers . is ( org . onosproject . net . resource . ContinuousResourceTest . BW1 . bps ( ) ) )", "total": "testValueAsPrimitiveDouble ( ) { org . onosproject . net . resource . ContinuousResource resource = org . onosproject . net . resource . Resources . continuous ( org . onosproject . net . resource . ContinuousResourceTest . D1 , org . onosproject . net . resource . ContinuousResourceTest . P1 , org . onlab . util . Bandwidth . class ) . resource ( org . onosproject . net . resource . ContinuousResourceTest . BW1 . bps ( ) ) ; java . util . Optional < java . lang . Double > volume = resource . valueAs ( double . class ) ; \"<AssertPlaceHolder>\" ; } get ( ) { return java . util . concurrent . CompletableFuture . completedFuture ( value . get ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( volume . get ( ) , org . hamcrest . Matchers . is ( org . onosproject . net . resource . ContinuousResourceTest . BW1 . bps ( ) ) )"}
{"focal": "getStatus ( ) { try { return transactionManager . getStatus ( ) ; } catch ( javax . transaction . SystemException e ) { throw new org . silverpeas . core . persistence . TransactionRuntimeException ( e ) ; } }", "testMethod": "setTheCipherKeyByANonAuthenticatedUser ( ) { com . sun . jersey . api . client . ClientResponse response = put ( aCipherKeyInHexa ( ) , org . silverpeas . security . web . CipherKeyResourceTest . withAsSessionKey ( null ) ) ; int unauthorized = ClientResponse . Status . UNAUTHORIZED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . getStatus ( ) , org . hamcrest . Matchers . is ( unauthorized ) )", "total": "setTheCipherKeyByANonAuthenticatedUser ( ) { com . sun . jersey . api . client . ClientResponse response = put ( aCipherKeyInHexa ( ) , org . silverpeas . security . web . CipherKeyResourceTest . withAsSessionKey ( null ) ) ; int unauthorized = ClientResponse . Status . UNAUTHORIZED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { try { return transactionManager . getStatus ( ) ; } catch ( javax . transaction . SystemException e ) { throw new org . silverpeas . core . persistence . TransactionRuntimeException ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( response . getStatus ( ) , org . hamcrest . Matchers . is ( unauthorized ) )"}
{"focal": "add ( org . batfish . datamodel . Prefix6 ) { boolean changed = _prefixes . add ( prefix ) ; if ( changed ) { _trie . addPrefix ( prefix ) ; } return changed ; }", "testMethod": "testFold ( ) { org . batfish . datamodel . PrefixTrieMultiMap < java . lang . Integer > map = new org . batfish . datamodel . PrefixTrieMultiMap ( Prefix . ZERO ) ; org . batfish . datamodel . Prefix l = org . batfish . datamodel . Prefix . parse ( \"0.0.0.0/8\" ) ; org . batfish . datamodel . Prefix ll = org . batfish . datamodel . Prefix . parse ( \"0.0.0.0/16\" ) ; org . batfish . datamodel . Prefix lr = org . batfish . datamodel . Prefix . parse ( \"0.128.0.0/16\" ) ; org . batfish . datamodel . Prefix r = org . batfish . datamodel . Prefix . parse ( \"128.0.0.0/8\" ) ; org . batfish . datamodel . Prefix rl = org . batfish . datamodel . Prefix . parse ( \"128.0.0.0/16\" ) ; org . batfish . datamodel . Prefix rr = org . batfish . datamodel . Prefix . parse ( \"128.128.0.0/16\" ) ; map . put ( l , 0 ) ; map . put ( ll , 0 ) ; map . put ( lr , 0 ) ; map . put ( rr , 0 ) ; map . put ( rl , 0 ) ; map . put ( r , 0 ) ; java . util . List < org . batfish . datamodel . Prefix > prefixes = map . fold ( new org . batfish . datamodel . PrefixTrieMultiMap . FoldOperator < java . lang . Integer , java . util . List < org . batfish . datamodel . Prefix > > ( ) { @ javax . annotation . Nonnull @ org . batfish . datamodel . Override public java . util . List < org . batfish . datamodel . Prefix > fold ( org . batfish . datamodel . Prefix prefix , java . util . Set < java . lang . Integer > elems , @ javax . annotation . Nullable java . util . List < org . batfish . datamodel . Prefix > leftResult , @ javax . annotation . Nullable java . util . List < org . batfish . datamodel . Prefix > rightResult ) { java . util . List < org . batfish . datamodel . Prefix > result = new java . util . ArrayList ( ) ; if ( leftResult != null ) { result . addAll ( leftResult ) ; } if ( rightResult != null ) { result . addAll ( rightResult ) ; } result . add ( prefix ) ; return result ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( prefixes , org . hamcrest . Matchers . contains ( ll , lr , l , rl , rr , r , Prefix . ZERO ) )", "total": "testFold ( ) { org . batfish . datamodel . PrefixTrieMultiMap < java . lang . Integer > map = new org . batfish . datamodel . PrefixTrieMultiMap ( Prefix . ZERO ) ; org . batfish . datamodel . Prefix l = org . batfish . datamodel . Prefix . parse ( \"0.0.0.0/8\" ) ; org . batfish . datamodel . Prefix ll = org . batfish . datamodel . Prefix . parse ( \"0.0.0.0/16\" ) ; org . batfish . datamodel . Prefix lr = org . batfish . datamodel . Prefix . parse ( \"0.128.0.0/16\" ) ; org . batfish . datamodel . Prefix r = org . batfish . datamodel . Prefix . parse ( \"128.0.0.0/8\" ) ; org . batfish . datamodel . Prefix rl = org . batfish . datamodel . Prefix . parse ( \"128.0.0.0/16\" ) ; org . batfish . datamodel . Prefix rr = org . batfish . datamodel . Prefix . parse ( \"128.128.0.0/16\" ) ; map . put ( l , 0 ) ; map . put ( ll , 0 ) ; map . put ( lr , 0 ) ; map . put ( rr , 0 ) ; map . put ( rl , 0 ) ; map . put ( r , 0 ) ; java . util . List < org . batfish . datamodel . Prefix > prefixes = map . fold ( new org . batfish . datamodel . PrefixTrieMultiMap . FoldOperator < java . lang . Integer , java . util . List < org . batfish . datamodel . Prefix > > ( ) { @ javax . annotation . Nonnull @ org . batfish . datamodel . Override public java . util . List < org . batfish . datamodel . Prefix > fold ( org . batfish . datamodel . Prefix prefix , java . util . Set < java . lang . Integer > elems , @ javax . annotation . Nullable java . util . List < org . batfish . datamodel . Prefix > leftResult , @ javax . annotation . Nullable java . util . List < org . batfish . datamodel . Prefix > rightResult ) { java . util . List < org . batfish . datamodel . Prefix > result = new java . util . ArrayList ( ) ; if ( leftResult != null ) { result . addAll ( leftResult ) ; } if ( rightResult != null ) { result . addAll ( rightResult ) ; } result . add ( prefix ) ; return result ; } } ) ; \"<AssertPlaceHolder>\" ; } add ( org . batfish . datamodel . Prefix6 ) { boolean changed = _prefixes . add ( prefix ) ; if ( changed ) { _trie . addPrefix ( prefix ) ; } return changed ; }", "answer": "org . junit . Assert . assertThat ( prefixes , org . hamcrest . Matchers . contains ( ll , lr , l , rl , rr , r , Prefix . ZERO ) )"}
{"focal": "value ( int ) { return _values . get ( i ) ; }", "testMethod": "test_icmpType ( ) { org . batfish . datamodel . HeaderSpace headerSpace = org . batfish . datamodel . HeaderSpace . builder ( ) . setIcmpTypes ( com . google . common . collect . ImmutableList . of ( new org . batfish . datamodel . SubRange ( 8 , 8 ) ) ) . build ( ) ; net . sf . javabdd . BDD matchExprBDD = _toBDD . toBDD ( headerSpace ) ; net . sf . javabdd . BDD icmpTypeBDD = _pkt . getIcmpType ( ) . value ( 8 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( matchExprBDD , org . hamcrest . Matchers . equalTo ( icmpTypeBDD ) )", "total": "test_icmpType ( ) { org . batfish . datamodel . HeaderSpace headerSpace = org . batfish . datamodel . HeaderSpace . builder ( ) . setIcmpTypes ( com . google . common . collect . ImmutableList . of ( new org . batfish . datamodel . SubRange ( 8 , 8 ) ) ) . build ( ) ; net . sf . javabdd . BDD matchExprBDD = _toBDD . toBDD ( headerSpace ) ; net . sf . javabdd . BDD icmpTypeBDD = _pkt . getIcmpType ( ) . value ( 8 ) ; \"<AssertPlaceHolder>\" ; } value ( int ) { return _values . get ( i ) ; }", "answer": "org . junit . Assert . assertThat ( matchExprBDD , org . hamcrest . Matchers . equalTo ( icmpTypeBDD ) )"}
{"focal": "isModified ( ) { return false ; }", "testMethod": "shouldBeUnmodifiedAfterSave ( ) { vdb . setDescription ( \"new<sp>description\" ) ; vdb . save ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( vdb . isModified ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "shouldBeUnmodifiedAfterSave ( ) { vdb . setDescription ( \"new<sp>description\" ) ; vdb . save ( ) ; \"<AssertPlaceHolder>\" ; } isModified ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( vdb . isModified ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "getField ( ) { return field ; }", "testMethod": "givenValidOtherDirective_whenGetField_theResultEqualsExpected ( ) { com . brandwatch . robots . domain . OtherDirective directive = new com . brandwatch . robots . domain . OtherDirective ( com . brandwatch . robots . domain . OtherDirectiveTest . FIELD , com . brandwatch . robots . domain . OtherDirectiveTest . VALUE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( directive . getField ( ) , org . hamcrest . CoreMatchers . equalTo ( com . brandwatch . robots . domain . OtherDirectiveTest . FIELD ) )", "total": "givenValidOtherDirective_whenGetField_theResultEqualsExpected ( ) { com . brandwatch . robots . domain . OtherDirective directive = new com . brandwatch . robots . domain . OtherDirective ( com . brandwatch . robots . domain . OtherDirectiveTest . FIELD , com . brandwatch . robots . domain . OtherDirectiveTest . VALUE ) ; \"<AssertPlaceHolder>\" ; } getField ( ) { return field ; }", "answer": "org . junit . Assert . assertThat ( directive . getField ( ) , org . hamcrest . CoreMatchers . equalTo ( com . brandwatch . robots . domain . OtherDirectiveTest . FIELD ) )"}
{"focal": "getValidationReport ( ) { return validationReport ; }", "testMethod": "testMigrateNullSourceActivityId ( ) { org . camunda . bpm . engine . repository . ProcessDefinition sourceDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; org . camunda . bpm . engine . repository . ProcessDefinition targetDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; try { runtimeService . createMigrationPlan ( sourceDefinition . getId ( ) , targetDefinition . getId ( ) ) . mapActivities ( null , \"userTask\" ) . build ( ) ; org . junit . Assert . fail ( \"Should<sp>not<sp>succeed\" ) ; } catch ( org . camunda . bpm . engine . migration . MigrationPlanValidationException e ) { \"<AssertPlaceHolder>\" . hasInstructionFailures ( null , \"Source<sp>activity<sp>id<sp>is<sp>null\" ) ; } }", "assertLine": "org . junit . Assert . assertThat ( e . getValidationReport ( ) )", "total": "testMigrateNullSourceActivityId ( ) { org . camunda . bpm . engine . repository . ProcessDefinition sourceDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; org . camunda . bpm . engine . repository . ProcessDefinition targetDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; try { runtimeService . createMigrationPlan ( sourceDefinition . getId ( ) , targetDefinition . getId ( ) ) . mapActivities ( null , \"userTask\" ) . build ( ) ; org . junit . Assert . fail ( \"Should<sp>not<sp>succeed\" ) ; } catch ( org . camunda . bpm . engine . migration . MigrationPlanValidationException e ) { \"<AssertPlaceHolder>\" . hasInstructionFailures ( null , \"Source<sp>activity<sp>id<sp>is<sp>null\" ) ; } } getValidationReport ( ) { return validationReport ; }", "answer": "org . junit . Assert . assertThat ( e . getValidationReport ( ) )"}
{"focal": "toSql ( annis . ql . parser . QueryData ) { java . lang . String result = toSql ( queryData , \"\" ) ; return result ; }", "testMethod": "shouldAppendWithClause ( ) { java . util . LinkedList < java . lang . String > clauses = new java . util . LinkedList ( ) ; clauses . add ( \"A<sp>as<sp>(SELECT<sp>1)\" ) ; clauses . add ( \"B<sp>as<sp>(SELECT<sp>2)\" ) ; clauses . add ( \"C<sp>as<sp>(SELECT<sp>3)\" ) ; when ( withClauseSqlGenerator . withClauses ( any ( annis . ql . parser . QueryData . class ) , anyListOf ( annis . model . QueryNode . class ) , anyString ( ) ) ) . thenReturn ( clauses ) ; java . lang . String sql = generator . toSql ( queryData ) ; java . lang . String expected = \"WITH\\n\" + ( ( ( \"A<sp>as<sp>(SELECT<sp>1),\\n\" + \"B<sp>as<sp>(SELECT<sp>2),\\n\" ) + \"C<sp>as<sp>(SELECT<sp>3)\\n\" ) + \"SELECT<sp>null\\nFROM\\n<sp>\\n\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sql , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldAppendWithClause ( ) { java . util . LinkedList < java . lang . String > clauses = new java . util . LinkedList ( ) ; clauses . add ( \"A<sp>as<sp>(SELECT<sp>1)\" ) ; clauses . add ( \"B<sp>as<sp>(SELECT<sp>2)\" ) ; clauses . add ( \"C<sp>as<sp>(SELECT<sp>3)\" ) ; when ( withClauseSqlGenerator . withClauses ( any ( annis . ql . parser . QueryData . class ) , anyListOf ( annis . model . QueryNode . class ) , anyString ( ) ) ) . thenReturn ( clauses ) ; java . lang . String sql = generator . toSql ( queryData ) ; java . lang . String expected = \"WITH\\n\" + ( ( ( \"A<sp>as<sp>(SELECT<sp>1),\\n\" + \"B<sp>as<sp>(SELECT<sp>2),\\n\" ) + \"C<sp>as<sp>(SELECT<sp>3)\\n\" ) + \"SELECT<sp>null\\nFROM\\n<sp>\\n\" ) ; \"<AssertPlaceHolder>\" ; } toSql ( annis . ql . parser . QueryData ) { java . lang . String result = toSql ( queryData , \"\" ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( sql , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "get ( K ) { return this . cache . getOrDefault ( key , null ) ; }", "testMethod": "whenGetFirstElementThenResultOne ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . arr . get ( 1 ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "whenGetFirstElementThenResultOne ( ) { \"<AssertPlaceHolder>\" ; } get ( K ) { return this . cache . getOrDefault ( key , null ) ; }", "answer": "org . junit . Assert . assertThat ( this . arr . get ( 1 ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "getPredicate ( ) { return predicate ; }", "testMethod": "testBasics ( ) { org . gbif . api . model . occurrence . predicate . Predicate p = mock ( org . gbif . api . model . occurrence . predicate . Predicate . class ) ; org . gbif . api . model . occurrence . predicate . NotPredicate np = new org . gbif . api . model . occurrence . predicate . NotPredicate ( p ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( p , org . hamcrest . CoreMatchers . equalTo ( np . getPredicate ( ) ) )", "total": "testBasics ( ) { org . gbif . api . model . occurrence . predicate . Predicate p = mock ( org . gbif . api . model . occurrence . predicate . Predicate . class ) ; org . gbif . api . model . occurrence . predicate . NotPredicate np = new org . gbif . api . model . occurrence . predicate . NotPredicate ( p ) ; \"<AssertPlaceHolder>\" ; } getPredicate ( ) { return predicate ; }", "answer": "org . junit . Assert . assertThat ( p , org . hamcrest . CoreMatchers . equalTo ( np . getPredicate ( ) ) )"}
{"focal": "isDefinedAt ( java . lang . Object ) { return getCaseClauses ( ) . foldLeft ( false , new com . m3 . scalaflavor4j . F2 < java . lang . Boolean , com . m3 . scalaflavor4j . CaseClause < ? , R > , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . Boolean isDefinedAt , com . m3 . scalaflavor4j . CaseClause < ? , R > caseClause ) throws com . m3 . scalaflavor4j . Exception { if ( isDefinedAt ) { return true ; } return caseClause . isDefinedAt ( v ) ; } } ) ; }", "testMethod": "isDefinedAt_A$Object_null ( ) { com . m3 . scalaflavor4j . CaseClause < java . lang . String , java . lang . String > caseClause = com . m3 . scalaflavor4j . CaseClause . _case ( java . lang . String . class ) . _arrow ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . String > ( ) { public java . lang . String apply ( java . lang . String v1 ) throws com . m3 . scalaflavor4j . Exception { return v1 ; } } ) ; java . lang . Object v = null ; boolean actual = caseClause . isDefinedAt ( v ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isDefinedAt_A$Object_null ( ) { com . m3 . scalaflavor4j . CaseClause < java . lang . String , java . lang . String > caseClause = com . m3 . scalaflavor4j . CaseClause . _case ( java . lang . String . class ) . _arrow ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . String > ( ) { public java . lang . String apply ( java . lang . String v1 ) throws com . m3 . scalaflavor4j . Exception { return v1 ; } } ) ; java . lang . Object v = null ; boolean actual = caseClause . isDefinedAt ( v ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } isDefinedAt ( java . lang . Object ) { return getCaseClauses ( ) . foldLeft ( false , new com . m3 . scalaflavor4j . F2 < java . lang . Boolean , com . m3 . scalaflavor4j . CaseClause < ? , R > , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . Boolean isDefinedAt , com . m3 . scalaflavor4j . CaseClause < ? , R > caseClause ) throws com . m3 . scalaflavor4j . Exception { if ( isDefinedAt ) { return true ; } return caseClause . isDefinedAt ( v ) ; } } ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "from ( java . lang . Class ) { return new com . psddev . dari . db . Query < T > ( ( objectClass != null ? objectClass . getName ( ) : null ) , objectClass ) ; }", "testMethod": "deleteFirst ( ) { java . util . List < com . psddev . dari . h2 . WriteModel > models = createDeleteTestModels ( ) ; com . psddev . dari . db . Query . from ( com . psddev . dari . h2 . WriteModel . class ) . first ( ) . delete ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . psddev . dari . db . Query . from ( com . psddev . dari . h2 . WriteModel . class ) . count ( ) , is ( ( ( ( long ) ( models . size ( ) ) ) - 1 ) ) )", "total": "deleteFirst ( ) { java . util . List < com . psddev . dari . h2 . WriteModel > models = createDeleteTestModels ( ) ; com . psddev . dari . db . Query . from ( com . psddev . dari . h2 . WriteModel . class ) . first ( ) . delete ( ) ; \"<AssertPlaceHolder>\" ; } from ( java . lang . Class ) { return new com . psddev . dari . db . Query < T > ( ( objectClass != null ? objectClass . getName ( ) : null ) , objectClass ) ; }", "answer": "org . junit . Assert . assertThat ( com . psddev . dari . db . Query . from ( com . psddev . dari . h2 . WriteModel . class ) . count ( ) , is ( ( ( ( long ) ( models . size ( ) ) ) - 1 ) ) )"}
{"focal": "getIcon ( ) { return org . infinitest . intellij . idea . facet . IconLoader . getIcon ( \"/infinitest.png\" ) ; }", "testMethod": "shouldHaveIconToIndicatePoFNodes ( ) { java . lang . Object node = \"PointOfFailure.java:32\" ; org . infinitest . intellij . plugin . swingui . JLabel treeCell = ( ( org . infinitest . intellij . plugin . swingui . JLabel ) ( cellRenderer . getTreeCellRendererComponent ( resultsPane . getTree ( ) , node , false , false , false , 0 , false ) ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( expectedIcon ( \"error\" ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( treeCell . getIcon ( ) . toString ( ) )", "total": "shouldHaveIconToIndicatePoFNodes ( ) { java . lang . Object node = \"PointOfFailure.java:32\" ; org . infinitest . intellij . plugin . swingui . JLabel treeCell = ( ( org . infinitest . intellij . plugin . swingui . JLabel ) ( cellRenderer . getTreeCellRendererComponent ( resultsPane . getTree ( ) , node , false , false , false , 0 , false ) ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( expectedIcon ( \"error\" ) ) ; } getIcon ( ) { return org . infinitest . intellij . idea . facet . IconLoader . getIcon ( \"/infinitest.png\" ) ; }", "answer": "org . junit . Assert . assertThat ( treeCell . getIcon ( ) . toString ( ) )"}
{"focal": "find ( java . lang . Number ) { T entity = entityManager . find ( entityType , id ) ; return entity ; }", "testMethod": "shouldCreateTheRightAmountOfRestrictionsIfUsersAndRoleAreGiven ( ) { java . lang . String roleName1 = \"Role1\" ; java . lang . String userName1 = \"User1\" ; java . lang . String userName2 = \"User2\" ; java . lang . String permissionName1 = \"RESOURCE\" ; java . lang . String permissionName2 = \"RESOURCETYPE\" ; java . lang . String contextNameA = \"A\" ; when ( permissionRepository . getPermissionByName ( \"RESOURCE\" ) ) . thenReturn ( resourcePermission ) ; when ( permissionRepository . getPermissionByName ( \"RESOURCETYPE\" ) ) . thenReturn ( resourceTypePermission ) ; when ( resourceGroupRepository . find ( 1 ) ) . thenReturn ( new ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceGroupEntity ( ) ) ; int total = permissionBoundary . createMultipleRestrictions ( roleName1 , java . util . Arrays . asList ( userName1 , userName2 ) , java . util . Arrays . asList ( permissionName1 , permissionName2 ) , java . util . Arrays . asList ( 1 ) , null , ResourceTypePermission . ANY , java . util . Arrays . asList ( contextNameA ) , java . util . Arrays . asList ( Action . CREATE ) , false , true ) ; \"<AssertPlaceHolder>\" ; verify ( restrictionRepository , times ( total ) ) . create ( any ( ch . puzzle . itc . mobiliar . business . security . boundary . RestrictionEntity . class ) ) ; verify ( permissionRepository , times ( 1 ) ) . forceReloadingOfLists ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( total , org . hamcrest . CoreMatchers . is ( 6 ) )", "total": "shouldCreateTheRightAmountOfRestrictionsIfUsersAndRoleAreGiven ( ) { java . lang . String roleName1 = \"Role1\" ; java . lang . String userName1 = \"User1\" ; java . lang . String userName2 = \"User2\" ; java . lang . String permissionName1 = \"RESOURCE\" ; java . lang . String permissionName2 = \"RESOURCETYPE\" ; java . lang . String contextNameA = \"A\" ; when ( permissionRepository . getPermissionByName ( \"RESOURCE\" ) ) . thenReturn ( resourcePermission ) ; when ( permissionRepository . getPermissionByName ( \"RESOURCETYPE\" ) ) . thenReturn ( resourceTypePermission ) ; when ( resourceGroupRepository . find ( 1 ) ) . thenReturn ( new ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceGroupEntity ( ) ) ; int total = permissionBoundary . createMultipleRestrictions ( roleName1 , java . util . Arrays . asList ( userName1 , userName2 ) , java . util . Arrays . asList ( permissionName1 , permissionName2 ) , java . util . Arrays . asList ( 1 ) , null , ResourceTypePermission . ANY , java . util . Arrays . asList ( contextNameA ) , java . util . Arrays . asList ( Action . CREATE ) , false , true ) ; \"<AssertPlaceHolder>\" ; verify ( restrictionRepository , times ( total ) ) . create ( any ( ch . puzzle . itc . mobiliar . business . security . boundary . RestrictionEntity . class ) ) ; verify ( permissionRepository , times ( 1 ) ) . forceReloadingOfLists ( ) ; } find ( java . lang . Number ) { T entity = entityManager . find ( entityType , id ) ; return entity ; }", "answer": "org . junit . Assert . assertThat ( total , org . hamcrest . CoreMatchers . is ( 6 ) )"}
{"focal": "parseExpr ( java . lang . Class , java . lang . String ) { org . teavm . flavour . expr . EvaluatorBuilder builder = new org . teavm . flavour . expr . InterpretingEvaluatorBuilder ( ) . importPackage ( \"java.lang\" ) . importPackage ( \"java.util\" ) . importClass ( org . teavm . flavour . expr . test . EvaluatorTest . class . getName ( ) ) . importClass ( java . util . stream . Collectors . class . getName ( ) ) ; org . teavm . flavour . expr . Evaluator < T , org . teavm . flavour . expr . test . TestVars > e ; try { e = builder . build ( cls , org . teavm . flavour . expr . test . TestVars . class , str ) ; } catch ( org . teavm . flavour . expr . InvalidExpressionException ex ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"Errors<sp>occurred<sp>compiling<sp>expression:\\n\" ) ; sb . append ( str ) . append ( \"\\n\" ) ; java . util . List < org . teavm . flavour . expr . Diagnostic > diagnostics = ex . getDiagnostics ( ) . stream ( ) . sorted ( java . util . Comparator . comparingInt ( ( d ) -> d . getStart ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( org . teavm . flavour . expr . Diagnostic diagnostic : diagnostics ) { for ( int i = 0 ; i < ( diagnostic . getStart ( ) ) ; ++ i ) { sb . append ( '<sp>' ) ; } sb . append ( \"^\\n\" ) ; sb . append ( diagnostic . getMessage ( ) ) . append ( \"\\n\\n\" ) ; } throw new java . lang . AssertionError ( sb . toString ( ) ) ; } vars = e . getVariables ( ) ; return e . getFunction ( ) ; }", "testMethod": "evaluatesLambda3 ( ) { org . teavm . flavour . expr . test . ObjectComputation c = parseExpr ( org . teavm . flavour . expr . test . ObjectComputation . class , \"EvaluatorTest.sort(integerList,<sp>(a,<sp>b)<sp>-><sp>Integer.compare(a,<sp>b))\" ) ; vars . integerList ( java . util . Arrays . asList ( 7 , 11 , 5 , 13 , 2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( c . compute ( ) , org . hamcrest . Matchers . is ( java . util . Arrays . asList ( 2 , 5 , 7 , 11 , 13 ) ) )", "total": "evaluatesLambda3 ( ) { org . teavm . flavour . expr . test . ObjectComputation c = parseExpr ( org . teavm . flavour . expr . test . ObjectComputation . class , \"EvaluatorTest.sort(integerList,<sp>(a,<sp>b)<sp>-><sp>Integer.compare(a,<sp>b))\" ) ; vars . integerList ( java . util . Arrays . asList ( 7 , 11 , 5 , 13 , 2 ) ) ; \"<AssertPlaceHolder>\" ; } parseExpr ( java . lang . Class , java . lang . String ) { org . teavm . flavour . expr . EvaluatorBuilder builder = new org . teavm . flavour . expr . InterpretingEvaluatorBuilder ( ) . importPackage ( \"java.lang\" ) . importPackage ( \"java.util\" ) . importClass ( org . teavm . flavour . expr . test . EvaluatorTest . class . getName ( ) ) . importClass ( java . util . stream . Collectors . class . getName ( ) ) ; org . teavm . flavour . expr . Evaluator < T , org . teavm . flavour . expr . test . TestVars > e ; try { e = builder . build ( cls , org . teavm . flavour . expr . test . TestVars . class , str ) ; } catch ( org . teavm . flavour . expr . InvalidExpressionException ex ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"Errors<sp>occurred<sp>compiling<sp>expression:\\n\" ) ; sb . append ( str ) . append ( \"\\n\" ) ; java . util . List < org . teavm . flavour . expr . Diagnostic > diagnostics = ex . getDiagnostics ( ) . stream ( ) . sorted ( java . util . Comparator . comparingInt ( ( d ) -> d . getStart ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( org . teavm . flavour . expr . Diagnostic diagnostic : diagnostics ) { for ( int i = 0 ; i < ( diagnostic . getStart ( ) ) ; ++ i ) { sb . append ( '<sp>' ) ; } sb . append ( \"^\\n\" ) ; sb . append ( diagnostic . getMessage ( ) ) . append ( \"\\n\\n\" ) ; } throw new java . lang . AssertionError ( sb . toString ( ) ) ; } vars = e . getVariables ( ) ; return e . getFunction ( ) ; }", "answer": "org . junit . Assert . assertThat ( c . compute ( ) , org . hamcrest . Matchers . is ( java . util . Arrays . asList ( 2 , 5 , 7 , 11 , 13 ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testL2LanId ( ) { isisNeighbor . setL2LanId ( lanId ) ; result1 = isisNeighbor . l2LanId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( lanId ) )", "total": "testL2LanId ( ) { isisNeighbor . setL2LanId ( lanId ) ; result1 = isisNeighbor . l2LanId ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( lanId ) )"}
{"focal": "hasSize ( int ) { return new com . github . msemys . esjc . matcher . IteratorSizeMatcher ( size ) ; }", "testMethod": "iteratesStreamEventsFromEndToStartWithSmallBatchSize ( ) { final java . lang . String stream = generateStreamName ( ) ; eventstore . appendToStream ( stream , ExpectedVersion . NO_STREAM , newTestEvents ( 10 ) ) . join ( ) ; java . util . Iterator < com . github . msemys . esjc . ResolvedEvent > iterator = eventstore . iterateStreamEventsBackward ( stream , StreamPosition . END , 2 , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( iterator , hasSize ( 10 ) )", "total": "iteratesStreamEventsFromEndToStartWithSmallBatchSize ( ) { final java . lang . String stream = generateStreamName ( ) ; eventstore . appendToStream ( stream , ExpectedVersion . NO_STREAM , newTestEvents ( 10 ) ) . join ( ) ; java . util . Iterator < com . github . msemys . esjc . ResolvedEvent > iterator = eventstore . iterateStreamEventsBackward ( stream , StreamPosition . END , 2 , false ) ; \"<AssertPlaceHolder>\" ; } hasSize ( int ) { return new com . github . msemys . esjc . matcher . IteratorSizeMatcher ( size ) ; }", "answer": "org . junit . Assert . assertThat ( iterator , hasSize ( 10 ) )"}
{"focal": "getStatus ( ) { return status ; }", "testMethod": "setStatus_availabilityStatus_statusIsSet ( ) { eu . chargetime . ocpp . model . core . AvailabilityStatus availabilityStatus = eu . chargetime . ocpp . model . core . AvailabilityStatus . Accepted ; confirmation . setStatus ( availabilityStatus ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( confirmation . getStatus ( ) , org . hamcrest . CoreMatchers . equalTo ( availabilityStatus ) )", "total": "setStatus_availabilityStatus_statusIsSet ( ) { eu . chargetime . ocpp . model . core . AvailabilityStatus availabilityStatus = eu . chargetime . ocpp . model . core . AvailabilityStatus . Accepted ; confirmation . setStatus ( availabilityStatus ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( confirmation . getStatus ( ) , org . hamcrest . CoreMatchers . equalTo ( availabilityStatus ) )"}
{"focal": "getFeatures ( ) { return features ; }", "testMethod": "shouldRetrieveAnnotatedClass ( ) { final org . objectweb . asm . ClassWriter cw = initClassWriterFor ( \"test.utils.ClassAnnotatedTest\" ) ; uut = new com . github . bmsantos . core . cola . injector . InfoClassVisitor ( cw , getClass ( ) . getClassLoader ( ) ) ; cr . accept ( uut , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uut . getFeatures ( ) . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "shouldRetrieveAnnotatedClass ( ) { final org . objectweb . asm . ClassWriter cw = initClassWriterFor ( \"test.utils.ClassAnnotatedTest\" ) ; uut = new com . github . bmsantos . core . cola . injector . InfoClassVisitor ( cw , getClass ( ) . getClassLoader ( ) ) ; cr . accept ( uut , 0 ) ; \"<AssertPlaceHolder>\" ; } getFeatures ( ) { return features ; }", "answer": "org . junit . Assert . assertThat ( uut . getFeatures ( ) . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "apply ( ) { com . m3 . scalaflavor4j . MainFunction main = new com . m3 . scalaflavor4j . MainFunction ( ) { public void apply ( java . lang . String [ ] args ) throws com . m3 . scalaflavor4j . Exception { print . apply ( args . length ) ; com . m3 . scalaflavor4j . Seq . apply ( args ) . foreach ( new com . m3 . scalaflavor4j . VoidF1 < java . lang . String > ( ) { public void apply ( java . lang . String arg ) throws com . m3 . scalaflavor4j . Exception { print . apply ( arg ) ; } } ) ; } } ; main . apply ( new java . lang . String [ ] { \"a\" , \"b\" } ) ; }", "testMethod": "exists_A$Function1_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . IndexedSeq . apply ( ) ; boolean actual = seq . exists ( new com . m3 . scalaflavor4j . F1 < java . lang . Integer , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . Integer v1 ) { return v1 < 3 ; } } ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "exists_A$Function1_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . IndexedSeq . apply ( ) ; boolean actual = seq . exists ( new com . m3 . scalaflavor4j . F1 < java . lang . Integer , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . Integer v1 ) { return v1 < 3 ; } } ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } apply ( ) { com . m3 . scalaflavor4j . MainFunction main = new com . m3 . scalaflavor4j . MainFunction ( ) { public void apply ( java . lang . String [ ] args ) throws com . m3 . scalaflavor4j . Exception { print . apply ( args . length ) ; com . m3 . scalaflavor4j . Seq . apply ( args ) . foreach ( new com . m3 . scalaflavor4j . VoidF1 < java . lang . String > ( ) { public void apply ( java . lang . String arg ) throws com . m3 . scalaflavor4j . Exception { print . apply ( arg ) ; } } ) ; } } ; main . apply ( new java . lang . String [ ] { \"a\" , \"b\" } ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "xContentBuilderToString ( org . elasticsearch . common . xcontent . XContentBuilder ) { builder . close ( ) ; java . io . ByteArrayOutputStream bos = ( ( java . io . ByteArrayOutputStream ) ( builder . getOutputStream ( ) ) ) ; return bos . toString ( ) ; }", "testMethod": "shouldCreateMappingForSpecifiedParentType ( ) { final java . lang . String expected = \"{\\\"mapping\\\":{\\\"_parent\\\":{\\\"type\\\":\\\"parentType\\\"},\\\"properties\\\":{}}}\" ; org . elasticsearch . common . xcontent . XContentBuilder xContentBuilder = org . springframework . data . elasticsearch . core . MappingBuilder . buildMapping ( org . springframework . data . elasticsearch . entities . MinimalEntity . class , \"mapping\" , \"id\" , \"parentType\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( xContentBuilderToString ( xContentBuilder ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldCreateMappingForSpecifiedParentType ( ) { final java . lang . String expected = \"{\\\"mapping\\\":{\\\"_parent\\\":{\\\"type\\\":\\\"parentType\\\"},\\\"properties\\\":{}}}\" ; org . elasticsearch . common . xcontent . XContentBuilder xContentBuilder = org . springframework . data . elasticsearch . core . MappingBuilder . buildMapping ( org . springframework . data . elasticsearch . entities . MinimalEntity . class , \"mapping\" , \"id\" , \"parentType\" ) ; \"<AssertPlaceHolder>\" ; } xContentBuilderToString ( org . elasticsearch . common . xcontent . XContentBuilder ) { builder . close ( ) ; java . io . ByteArrayOutputStream bos = ( ( java . io . ByteArrayOutputStream ) ( builder . getOutputStream ( ) ) ) ; return bos . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( xContentBuilderToString ( xContentBuilder ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getText ( ) { return stb . getText ( ) ; }", "testMethod": "testShouldBeAbleToEnterTextIntoATextAreaBySettingItsValue ( ) { org . openqa . selenium . qtwebkit . quick_tests . WebElement textarea = driver . findElement ( org . openqa . selenium . qtwebkit . quick_tests . By . id ( \"workingArea\" ) ) ; textarea . clear ( ) ; java . lang . String cheesy = \"brie<sp>and<sp>cheddar\" ; textarea . sendKeys ( cheesy ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( textarea . getText ( ) , org . hamcrest . Matchers . equalTo ( cheesy ) )", "total": "testShouldBeAbleToEnterTextIntoATextAreaBySettingItsValue ( ) { org . openqa . selenium . qtwebkit . quick_tests . WebElement textarea = driver . findElement ( org . openqa . selenium . qtwebkit . quick_tests . By . id ( \"workingArea\" ) ) ; textarea . clear ( ) ; java . lang . String cheesy = \"brie<sp>and<sp>cheddar\" ; textarea . sendKeys ( cheesy ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { return stb . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( textarea . getText ( ) , org . hamcrest . Matchers . equalTo ( cheesy ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . FileCommentAddedEvent event = new com . github . seratch . jslack . api . model . event . FileCommentAddedEvent ( ) ; event . setFileId ( \"123\" ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"file_comment_added\\\",\\\"file_id\\\":\\\"123\\\"}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . FileCommentAddedEvent event = new com . github . seratch . jslack . api . model . event . FileCommentAddedEvent ( ) ; event . setFileId ( \"123\" ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"file_comment_added\\\",\\\"file_id\\\":\\\"123\\\"}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "getDay ( java . time . LocalDate ) { return localDate . getDayOfMonth ( ) ; }", "testMethod": "whenGetDay_thenCorrectDay ( ) { int actualDayOfMonth = localDateExtractYearMonthDayIntegerValues . getDay ( localDate ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualDayOfMonth , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "whenGetDay_thenCorrectDay ( ) { int actualDayOfMonth = localDateExtractYearMonthDayIntegerValues . getDay ( localDate ) ; \"<AssertPlaceHolder>\" ; } getDay ( java . time . LocalDate ) { return localDate . getDayOfMonth ( ) ; }", "answer": "org . junit . Assert . assertThat ( actualDayOfMonth , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "get ( ) { int i = 0 ; for ( org . tessell . tests . model . properties . DummyModel model : models . get ( ) ) { if ( ( ( model . name . get ( ) ) != null ) && ( model . name . get ( ) . startsWith ( \"foo\" ) ) ) { i ++ ; } } return i ; }", "testMethod": "whenTrueSetAnotherProperty ( ) { final org . tessell . tests . model . dsl . BooleanProperty b = booleanProperty ( \"b\" , false ) ; final org . tessell . tests . model . dsl . IntegerProperty i = integerProperty ( \"i\" , 1 ) ; binder . when ( b ) . is ( true ) . set ( i ) . to ( 10 ) ; b . set ( true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( i . get ( ) , org . hamcrest . CoreMatchers . is ( 10 ) )", "total": "whenTrueSetAnotherProperty ( ) { final org . tessell . tests . model . dsl . BooleanProperty b = booleanProperty ( \"b\" , false ) ; final org . tessell . tests . model . dsl . IntegerProperty i = integerProperty ( \"i\" , 1 ) ; binder . when ( b ) . is ( true ) . set ( i ) . to ( 10 ) ; b . set ( true ) ; \"<AssertPlaceHolder>\" ; } get ( ) { int i = 0 ; for ( org . tessell . tests . model . properties . DummyModel model : models . get ( ) ) { if ( ( ( model . name . get ( ) ) != null ) && ( model . name . get ( ) . startsWith ( \"foo\" ) ) ) { i ++ ; } } return i ; }", "answer": "org . junit . Assert . assertThat ( i . get ( ) , org . hamcrest . CoreMatchers . is ( 10 ) )"}
{"focal": "greaterThanOrEqualTo ( T extends org . apache . beam . sdk . testing . Comparable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . greaterThanOrEqualTo ( target ) ) ; }", "testMethod": "testEstimateFractionForKey ( ) { double last = 0.0 ; org . apache . beam . sdk . io . range . ByteKeyRange range = org . apache . beam . sdk . io . range . ByteKeyRange . of ( org . apache . beam . sdk . io . range . ByteKeyRangeEstimateFractionTest . TEST_KEYS [ i ] , org . apache . beam . sdk . io . range . ByteKeyRangeEstimateFractionTest . TEST_KEYS [ k ] ) ; for ( int j = i ; j < ( k ) ; ++ j ) { org . apache . beam . sdk . io . range . ByteKey key = org . apache . beam . sdk . io . range . ByteKeyRangeEstimateFractionTest . TEST_KEYS [ j ] ; if ( key . isEmpty ( ) ) { continue ; } double fraction = range . estimateFractionForKey ( key ) ; \"<AssertPlaceHolder>\" ; last = fraction ; } }", "assertLine": "org . junit . Assert . assertThat ( fraction , org . hamcrest . Matchers . greaterThanOrEqualTo ( last ) )", "total": "testEstimateFractionForKey ( ) { double last = 0.0 ; org . apache . beam . sdk . io . range . ByteKeyRange range = org . apache . beam . sdk . io . range . ByteKeyRange . of ( org . apache . beam . sdk . io . range . ByteKeyRangeEstimateFractionTest . TEST_KEYS [ i ] , org . apache . beam . sdk . io . range . ByteKeyRangeEstimateFractionTest . TEST_KEYS [ k ] ) ; for ( int j = i ; j < ( k ) ; ++ j ) { org . apache . beam . sdk . io . range . ByteKey key = org . apache . beam . sdk . io . range . ByteKeyRangeEstimateFractionTest . TEST_KEYS [ j ] ; if ( key . isEmpty ( ) ) { continue ; } double fraction = range . estimateFractionForKey ( key ) ; \"<AssertPlaceHolder>\" ; last = fraction ; } } greaterThanOrEqualTo ( T extends org . apache . beam . sdk . testing . Comparable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . greaterThanOrEqualTo ( target ) ) ; }", "answer": "org . junit . Assert . assertThat ( fraction , org . hamcrest . Matchers . greaterThanOrEqualTo ( last ) )"}
{"focal": "size ( ) { return whiteList . size ( ) ; }", "testMethod": "emptyName ( ) { metaStore . setName ( \"<sp>\" ) ; java . util . Set < javax . validation . ConstraintViolation < T > > violations = validator . validate ( metaStore ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "emptyName ( ) { metaStore . setName ( \"<sp>\" ) ; java . util . Set < javax . validation . ConstraintViolation < T > > violations = validator . validate ( metaStore ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return whiteList . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "fromInteger ( int ) { final java . util . Set < name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag > flags = java . util . EnumSet . noneOf ( name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag . class ) ; int identifiedFlags = 0 ; for ( final name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag f : name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag . values ( ) ) { if ( ( bitmask & ( f . flag ) ) != 0 ) { flags . add ( f ) ; identifiedFlags |= f . flag ; } } if ( identifiedFlags != bitmask ) { final int unknownFlags = ( ~ identifiedFlags ) & bitmask ; throw new java . lang . IllegalArgumentException ( ( \"Could<sp>not<sp>identify<sp>the<sp>following<sp>KeyFlags:<sp>0b\" + ( java . lang . Long . toBinaryString ( unknownFlags ) ) ) ) ; } return flags ; }", "testMethod": "fromInteger_withZero_yieldsEmptySet ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag . fromInteger ( 0 ) , org . hamcrest . Matchers . empty ( ) )", "total": "fromInteger_withZero_yieldsEmptySet ( ) { \"<AssertPlaceHolder>\" ; } fromInteger ( int ) { final java . util . Set < name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag > flags = java . util . EnumSet . noneOf ( name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag . class ) ; int identifiedFlags = 0 ; for ( final name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag f : name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag . values ( ) ) { if ( ( bitmask & ( f . flag ) ) != 0 ) { flags . add ( f ) ; identifiedFlags |= f . flag ; } } if ( identifiedFlags != bitmask ) { final int unknownFlags = ( ~ identifiedFlags ) & bitmask ; throw new java . lang . IllegalArgumentException ( ( \"Could<sp>not<sp>identify<sp>the<sp>following<sp>KeyFlags:<sp>0b\" + ( java . lang . Long . toBinaryString ( unknownFlags ) ) ) ) ; } return flags ; }", "answer": "org . junit . Assert . assertThat ( name . neuhalfen . projects . crypto . bouncycastle . openpgp . keys . generation . KeyFlag . fromInteger ( 0 ) , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getInitialOffset ( ) { org . junit . Assert . assertThat ( net . time4j . tz . model . ArrayTransitionModelTest . MODEL . getInitialOffset ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . tz . ZonalOffset . ofHoursMinutes ( OffsetSign . AHEAD_OF_UTC , 0 , 30 ) ) ) ; }", "testMethod": "getInitialOffset ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . tz . model . ArrayTransitionModelTest . MODEL . getInitialOffset ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . tz . ZonalOffset . ofHoursMinutes ( OffsetSign . AHEAD_OF_UTC , 0 , 30 ) ) )", "total": "getInitialOffset ( ) { \"<AssertPlaceHolder>\" ; } getInitialOffset ( ) { org . junit . Assert . assertThat ( net . time4j . tz . model . ArrayTransitionModelTest . MODEL . getInitialOffset ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . tz . ZonalOffset . ofHoursMinutes ( OffsetSign . AHEAD_OF_UTC , 0 , 30 ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . tz . model . ArrayTransitionModelTest . MODEL . getInitialOffset ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . tz . ZonalOffset . ofHoursMinutes ( OffsetSign . AHEAD_OF_UTC , 0 , 30 ) ) )"}
{"focal": "toString ( ) { return ( ( ( \"MutableMoney<sp>[amount=\" + ( amount ) ) + \",<sp>currency=\" ) + ( currency ) ) + \"]\" ; }", "testMethod": "givenUsingTempFile_whenConvertingAnInputStreamToAString_thenCorrect ( ) { final java . lang . String originalString = org . apache . commons . lang3 . RandomStringUtils . randomAlphabetic ( org . baeldung . java . io . JavaInputStreamToXUnitTest . DEFAULT_SIZE ) ; final org . baeldung . java . io . InputStream inputStream = new org . baeldung . java . io . ByteArrayInputStream ( originalString . getBytes ( ) ) ; java . nio . file . Path tempFile = java . nio . file . Files . createTempDirectory ( \"\" ) . resolve ( ( ( java . util . UUID . randomUUID ( ) . toString ( ) ) + \".tmp\" ) ) ; java . nio . file . Files . copy ( inputStream , tempFile , StandardCopyOption . REPLACE_EXISTING ) ; java . lang . String result = new java . lang . String ( java . nio . file . Files . readAllBytes ( tempFile ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( originalString ) )", "total": "givenUsingTempFile_whenConvertingAnInputStreamToAString_thenCorrect ( ) { final java . lang . String originalString = org . apache . commons . lang3 . RandomStringUtils . randomAlphabetic ( org . baeldung . java . io . JavaInputStreamToXUnitTest . DEFAULT_SIZE ) ; final org . baeldung . java . io . InputStream inputStream = new org . baeldung . java . io . ByteArrayInputStream ( originalString . getBytes ( ) ) ; java . nio . file . Path tempFile = java . nio . file . Files . createTempDirectory ( \"\" ) . resolve ( ( ( java . util . UUID . randomUUID ( ) . toString ( ) ) + \".tmp\" ) ) ; java . nio . file . Files . copy ( inputStream , tempFile , StandardCopyOption . REPLACE_EXISTING ) ; java . lang . String result = new java . lang . String ( java . nio . file . Files . readAllBytes ( tempFile ) ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return ( ( ( \"MutableMoney<sp>[amount=\" + ( amount ) ) + \",<sp>currency=\" ) + ( currency ) ) + \"]\" ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( originalString ) )"}
{"focal": "getState ( ) { return state ; }", "testMethod": "shouldGetStateTemplate ( ) { panelState . setState ( State . TEMPLATE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( panelState . getState ( ) , org . hamcrest . core . Is . is ( State . TEMPLATE ) )", "total": "shouldGetStateTemplate ( ) { panelState . setState ( State . TEMPLATE ) ; \"<AssertPlaceHolder>\" ; } getState ( ) { return state ; }", "answer": "org . junit . Assert . assertThat ( panelState . getState ( ) , org . hamcrest . core . Is . is ( State . TEMPLATE ) )"}
{"focal": "compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "testMethod": "comparisonWithJsonLiteralExpression ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , Selection ( Comparison ( \"==\" , Property ( \"bar\" ) , JsonLiteral ( \"{\\\"foo\\\":\\\"bar\\\"}\" ) ) ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo[?bar<sp>==<sp>`{\\\"foo\\\":<sp>\\\"bar\\\"}`]\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "comparisonWithJsonLiteralExpression ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , Selection ( Comparison ( \"==\" , Property ( \"bar\" ) , JsonLiteral ( \"{\\\"foo\\\":\\\"bar\\\"}\" ) ) ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo[?bar<sp>==<sp>`{\\\"foo\\\":<sp>\\\"bar\\\"}`]\" ) ; \"<AssertPlaceHolder>\" ; } compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "trimLabels ( java . util . List ) { if ( ( labels . size ( ) ) <= 1 ) { return labels ; } int greatestChangingPrecision = org . diirt . graphene . TimeScales . calculateGreatestChangingField ( labels ) ; java . util . ArrayList < java . lang . String > rtn = new java . util . ArrayList < java . lang . String > ( labels . size ( ) ) ; org . diirt . graphene . TimeScales . DateTrimmer firstDate = new org . diirt . graphene . TimeScales . DateTrimmer ( labels . get ( 0 ) ) ; rtn . add ( firstDate . getCompactForm ( org . diirt . graphene . TimeScales . DateTrimmer . NO_PRECISION , greatestChangingPrecision ) ) ; for ( int i = 1 ; i < ( labels . size ( ) ) ; i ++ ) { java . lang . String prevLabel = labels . get ( ( i - 1 ) ) ; java . lang . String nextLabel = labels . get ( i ) ; int redundancePrecision = org . diirt . graphene . TimeScales . greatestRedundancePrecision ( prevLabel , nextLabel ) ; org . diirt . graphene . TimeScales . DateTrimmer f = new org . diirt . graphene . TimeScales . DateTrimmer ( nextLabel ) ; java . lang . String trimmedLabel = f . getCompactForm ( redundancePrecision , greatestChangingPrecision ) ; rtn . add ( trimmedLabel ) ; } return rtn ; }", "testMethod": "trimLabelsYears1 ( ) { java . util . List < java . lang . String > input = java . util . Arrays . asList ( \"2014/01/01<sp>00:00:00.000000000\" , \"2015/01/01<sp>00:00:00.000000000\" , \"2016/01/01<sp>00:00:00.000000000\" , \"2019\" 1 , \"2018/01/01<sp>00:00:00.000000000\" , \"2019/01/01<sp>00:00:00.000000000\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"2014\" , \"2019\" 0 , \"2016\" , \"2017\" , \"2018\" , \"2019\" ) ; java . util . List < java . lang . String > found = org . diirt . graphene . TimeScales . trimLabels ( input ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( found , equalTo ( expected ) )", "total": "trimLabelsYears1 ( ) { java . util . List < java . lang . String > input = java . util . Arrays . asList ( \"2014/01/01<sp>00:00:00.000000000\" , \"2015/01/01<sp>00:00:00.000000000\" , \"2016/01/01<sp>00:00:00.000000000\" , \"2019\" 1 , \"2018/01/01<sp>00:00:00.000000000\" , \"2019/01/01<sp>00:00:00.000000000\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"2014\" , \"2019\" 0 , \"2016\" , \"2017\" , \"2018\" , \"2019\" ) ; java . util . List < java . lang . String > found = org . diirt . graphene . TimeScales . trimLabels ( input ) ; \"<AssertPlaceHolder>\" ; } trimLabels ( java . util . List ) { if ( ( labels . size ( ) ) <= 1 ) { return labels ; } int greatestChangingPrecision = org . diirt . graphene . TimeScales . calculateGreatestChangingField ( labels ) ; java . util . ArrayList < java . lang . String > rtn = new java . util . ArrayList < java . lang . String > ( labels . size ( ) ) ; org . diirt . graphene . TimeScales . DateTrimmer firstDate = new org . diirt . graphene . TimeScales . DateTrimmer ( labels . get ( 0 ) ) ; rtn . add ( firstDate . getCompactForm ( org . diirt . graphene . TimeScales . DateTrimmer . NO_PRECISION , greatestChangingPrecision ) ) ; for ( int i = 1 ; i < ( labels . size ( ) ) ; i ++ ) { java . lang . String prevLabel = labels . get ( ( i - 1 ) ) ; java . lang . String nextLabel = labels . get ( i ) ; int redundancePrecision = org . diirt . graphene . TimeScales . greatestRedundancePrecision ( prevLabel , nextLabel ) ; org . diirt . graphene . TimeScales . DateTrimmer f = new org . diirt . graphene . TimeScales . DateTrimmer ( nextLabel ) ; java . lang . String trimmedLabel = f . getCompactForm ( redundancePrecision , greatestChangingPrecision ) ; rtn . add ( trimmedLabel ) ; } return rtn ; }", "answer": "org . junit . Assert . assertThat ( found , equalTo ( expected ) )"}
{"focal": "set ( java . lang . String , java . lang . Object ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"set\" ) ; invoke ( jn . toMemberName ( ) , value ) ; return this ; }", "testMethod": "collectNearest_ignoreItself ( ) { com . asakusafw . utils . graph . Graph < java . lang . Integer > graph = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . addPath ( graph , ( - 1 ) , 2 , ( - 3 ) ) ; java . util . Set < java . lang . Integer > results = com . asakusafw . utils . graph . Graphs . collectNearest ( graph , set ( ( - 1 ) ) , ( object ) -> object < 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( set ( 2 , ( - 3 ) ) ) )", "total": "collectNearest_ignoreItself ( ) { com . asakusafw . utils . graph . Graph < java . lang . Integer > graph = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . addPath ( graph , ( - 1 ) , 2 , ( - 3 ) ) ; java . util . Set < java . lang . Integer > results = com . asakusafw . utils . graph . Graphs . collectNearest ( graph , set ( ( - 1 ) ) , ( object ) -> object < 0 ) ; \"<AssertPlaceHolder>\" ; } set ( java . lang . String , java . lang . Object ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"set\" ) ; invoke ( jn . toMemberName ( ) , value ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( results , is ( set ( 2 , ( - 3 ) ) ) )"}
{"focal": "check ( ) { format = - 1 ; width = - 1 ; height = - 1 ; bitsPerPixel = - 1 ; numberOfImages = 1 ; physicalHeightDpi = - 1 ; physicalWidthDpi = - 1 ; comments = null ; try { int b1 = ( read ( ) ) & 255 ; int b2 = ( read ( ) ) & 255 ; if ( ( b1 == 71 ) && ( b2 == 73 ) ) { return checkGif ( ) ; } else if ( ( b1 == 137 ) && ( b2 == 80 ) ) { return checkPng ( ) ; } else if ( ( b1 == 255 ) && ( b2 == 216 ) ) { return checkJpeg ( ) ; } else if ( ( b1 == 66 ) && ( b2 == 77 ) ) { return checkBmp ( ) ; } else if ( ( b1 == 10 ) && ( b2 < 6 ) ) { return checkPcx ( ) ; } else if ( ( b1 == 70 ) && ( b2 == 79 ) ) { return checkIff ( ) ; } else if ( ( b1 == 89 ) && ( b2 == 166 ) ) { return checkRas ( ) ; } else if ( ( ( b1 == 80 ) && ( b2 >= 49 ) ) && ( b2 <= 54 ) ) { return checkPnm ( ( b2 - '0' ) ) ; } else if ( ( b1 == 56 ) && ( b2 == 66 ) ) { return checkPsd ( ) ; } else { return false ; } } catch ( java . io . IOException ioe ) { return false ; } }", "testMethod": "shouldNotBeAbleToLoadPictImage ( ) { java . io . InputStream stream = getTestImage ( \"caution.pict\" ) ; image . setInput ( stream ) ; image . setDetermineImageNumber ( true ) ; image . setCollectComments ( true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( image . check ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "shouldNotBeAbleToLoadPictImage ( ) { java . io . InputStream stream = getTestImage ( \"caution.pict\" ) ; image . setInput ( stream ) ; image . setDetermineImageNumber ( true ) ; image . setCollectComments ( true ) ; \"<AssertPlaceHolder>\" ; } check ( ) { format = - 1 ; width = - 1 ; height = - 1 ; bitsPerPixel = - 1 ; numberOfImages = 1 ; physicalHeightDpi = - 1 ; physicalWidthDpi = - 1 ; comments = null ; try { int b1 = ( read ( ) ) & 255 ; int b2 = ( read ( ) ) & 255 ; if ( ( b1 == 71 ) && ( b2 == 73 ) ) { return checkGif ( ) ; } else if ( ( b1 == 137 ) && ( b2 == 80 ) ) { return checkPng ( ) ; } else if ( ( b1 == 255 ) && ( b2 == 216 ) ) { return checkJpeg ( ) ; } else if ( ( b1 == 66 ) && ( b2 == 77 ) ) { return checkBmp ( ) ; } else if ( ( b1 == 10 ) && ( b2 < 6 ) ) { return checkPcx ( ) ; } else if ( ( b1 == 70 ) && ( b2 == 79 ) ) { return checkIff ( ) ; } else if ( ( b1 == 89 ) && ( b2 == 166 ) ) { return checkRas ( ) ; } else if ( ( ( b1 == 80 ) && ( b2 >= 49 ) ) && ( b2 <= 54 ) ) { return checkPnm ( ( b2 - '0' ) ) ; } else if ( ( b1 == 56 ) && ( b2 == 66 ) ) { return checkPsd ( ) ; } else { return false ; } } catch ( java . io . IOException ioe ) { return false ; } }", "answer": "org . junit . Assert . assertThat ( image . check ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "read ( ) { com . asakusafw . runtime . io . json . value . LongOptionPropertyAdapter adapter = builder . build ( ) ; com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; adapter . read ( new com . asakusafw . runtime . io . json . value . MockValue ( 100L ) , option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( option , is ( new com . asakusafw . runtime . value . LongOption ( 100L ) ) )", "total": "read ( ) { com . asakusafw . runtime . io . json . value . LongOptionPropertyAdapter adapter = builder . build ( ) ; com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; adapter . read ( new com . asakusafw . runtime . io . json . value . MockValue ( 100L ) , option ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( option , is ( new com . asakusafw . runtime . value . LongOption ( 100L ) ) )"}
{"focal": "getTuples ( ) { return tuples ; }", "testMethod": "addCoerceTypes ( ) { com . hotels . plunger . DataBuilder builder = new com . hotels . plunger . DataBuilder ( new cascading . tuple . Fields ( \"A\" , \"B\" , \"C\" , \"D\" ) , new java . lang . Class < ? > [ ] { java . lang . String . class , com . hotels . plunger . Integer . class , int . class , boolean . class } ) ; com . hotels . plunger . Data source = builder . addTuple ( 1 , \"1\" , null , null ) . build ( ) ; java . util . List < cascading . tuple . Tuple > tuples = source . getTuples ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tuples . get ( 0 ) , org . hamcrest . CoreMatchers . is ( new cascading . tuple . Tuple ( \"1\" , 1 , 0 , false ) ) )", "total": "addCoerceTypes ( ) { com . hotels . plunger . DataBuilder builder = new com . hotels . plunger . DataBuilder ( new cascading . tuple . Fields ( \"A\" , \"B\" , \"C\" , \"D\" ) , new java . lang . Class < ? > [ ] { java . lang . String . class , com . hotels . plunger . Integer . class , int . class , boolean . class } ) ; com . hotels . plunger . Data source = builder . addTuple ( 1 , \"1\" , null , null ) . build ( ) ; java . util . List < cascading . tuple . Tuple > tuples = source . getTuples ( ) ; \"<AssertPlaceHolder>\" ; } getTuples ( ) { return tuples ; }", "answer": "org . junit . Assert . assertThat ( tuples . get ( 0 ) , org . hamcrest . CoreMatchers . is ( new cascading . tuple . Tuple ( \"1\" , 1 , 0 , false ) ) )"}
{"focal": "toString ( ) { java . lang . Iterable < java . lang . String > errorMessages = com . google . common . collect . FluentIterable . from ( errors ) . transform ( com . hotels . bdp . circustrain . CircusTrainHelp . OBJECT_ERROR_TO_TABBED_MESSAGE ) ; java . lang . StringBuilder help = new java . lang . StringBuilder ( 500 ) . append ( \"Usage:<sp>circus-train.sh<sp>--config=<config_file>[,<config_file>,...]\" ) . append ( java . lang . System . lineSeparator ( ) ) . append ( \"Errors<sp>found<sp>in<sp>the<sp>provided<sp>configuration<sp>file:\" ) . append ( java . lang . System . lineSeparator ( ) ) . append ( com . google . common . base . Joiner . on ( java . lang . System . lineSeparator ( ) ) . join ( errorMessages ) ) . append ( java . lang . System . lineSeparator ( ) ) . append ( \"Configuration<sp>file<sp>help:\" ) . append ( java . lang . System . lineSeparator ( ) ) . append ( com . hotels . bdp . circustrain . CircusTrainHelp . TAB ) . append ( \"For<sp>more<sp>information<sp>and<sp>help<sp>please<sp>refer<sp>to<sp>\" ) . append ( \"https://github.com/HotelsDotCom/circus-train/blob/master/README.md\" ) ; return help . toString ( ) ; }", "testMethod": "unescapedStatement ( ) { java . util . Map < java . lang . String , java . lang . String > replicationMappings = com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . String > builder ( ) . put ( \"db1.table_a\" , \"r_db.a_table\" ) . build ( ) ; when ( tableReplication . getTableMappings ( ) ) . thenReturn ( replicationMappings ) ; com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslator translator = new com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslator ( tableReplications ) ; java . lang . String translatedStatement = translator . translate ( com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslatorTest . VIEW_NAME , com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslatorTest . UNESCAPED_SELECT_STATEMENT ) ; java . lang . String expectedTranslatedStatement = new java . lang . StringBuilder ( ) . append ( \"SELECT<sp>a_table.col1,<sp>b.col2<sp>\\n\" ) . append ( \"<sp>FROM<sp>r_db.a_table<sp>\\n\" ) . append ( \"<sp>JOIN<sp>db2.table_b<sp>AS<sp>B<sp>ON<sp>B.key<sp>=<sp>a_table.key<sp>\\n\" ) . append ( \"<sp>WHERE<sp>a_table.cond<sp>=<sp>\\'VAL\\'<sp>\\n\" ) . append ( \"<sp>AND<sp>a_table.cmp<sp><<sp>b.cmp<sp>\\n\" ) . toString ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( translatedStatement , org . hamcrest . CoreMatchers . is ( expectedTranslatedStatement ) )", "total": "unescapedStatement ( ) { java . util . Map < java . lang . String , java . lang . String > replicationMappings = com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . String > builder ( ) . put ( \"db1.table_a\" , \"r_db.a_table\" ) . build ( ) ; when ( tableReplication . getTableMappings ( ) ) . thenReturn ( replicationMappings ) ; com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslator translator = new com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslator ( tableReplications ) ; java . lang . String translatedStatement = translator . translate ( com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslatorTest . VIEW_NAME , com . hotels . bdp . circustrain . hive . view . transformation . HqlTranslatorTest . UNESCAPED_SELECT_STATEMENT ) ; java . lang . String expectedTranslatedStatement = new java . lang . StringBuilder ( ) . append ( \"SELECT<sp>a_table.col1,<sp>b.col2<sp>\\n\" ) . append ( \"<sp>FROM<sp>r_db.a_table<sp>\\n\" ) . append ( \"<sp>JOIN<sp>db2.table_b<sp>AS<sp>B<sp>ON<sp>B.key<sp>=<sp>a_table.key<sp>\\n\" ) . append ( \"<sp>WHERE<sp>a_table.cond<sp>=<sp>\\'VAL\\'<sp>\\n\" ) . append ( \"<sp>AND<sp>a_table.cmp<sp><<sp>b.cmp<sp>\\n\" ) . toString ( ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { java . lang . Iterable < java . lang . String > errorMessages = com . google . common . collect . FluentIterable . from ( errors ) . transform ( com . hotels . bdp . circustrain . CircusTrainHelp . OBJECT_ERROR_TO_TABBED_MESSAGE ) ; java . lang . StringBuilder help = new java . lang . StringBuilder ( 500 ) . append ( \"Usage:<sp>circus-train.sh<sp>--config=<config_file>[,<config_file>,...]\" ) . append ( java . lang . System . lineSeparator ( ) ) . append ( \"Errors<sp>found<sp>in<sp>the<sp>provided<sp>configuration<sp>file:\" ) . append ( java . lang . System . lineSeparator ( ) ) . append ( com . google . common . base . Joiner . on ( java . lang . System . lineSeparator ( ) ) . join ( errorMessages ) ) . append ( java . lang . System . lineSeparator ( ) ) . append ( \"Configuration<sp>file<sp>help:\" ) . append ( java . lang . System . lineSeparator ( ) ) . append ( com . hotels . bdp . circustrain . CircusTrainHelp . TAB ) . append ( \"For<sp>more<sp>information<sp>and<sp>help<sp>please<sp>refer<sp>to<sp>\" ) . append ( \"https://github.com/HotelsDotCom/circus-train/blob/master/README.md\" ) ; return help . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( translatedStatement , org . hamcrest . CoreMatchers . is ( expectedTranslatedStatement ) )"}
{"focal": "toWritableObject ( java . lang . Object ) { if ( value == null ) { return null ; } try { return toWritableObjectInternal ( value ) ; } catch ( java . lang . ClassCastException e ) { throw new com . hotels . corc . UnexpectedTypeException ( value ) ; } }", "testMethod": "mapStringStringWritable ( ) { org . apache . hadoop . hive . serde2 . typeinfo . TypeInfo typeInfo = org . apache . hadoop . hive . serde2 . typeinfo . TypeInfoFactory . getMapTypeInfo ( TypeInfoFactory . stringTypeInfo , TypeInfoFactory . stringTypeInfo ) ; com . hotels . corc . Converter converter = getConverter ( typeInfo ) ; java . util . Map < org . apache . hadoop . io . Text , org . apache . hadoop . io . Text > writableMap = new java . util . HashMap ( ) ; writableMap . put ( new org . apache . hadoop . io . Text ( \"hello\" ) , new org . apache . hadoop . io . Text ( \"world\" ) ) ; java . util . Map < java . lang . String , java . lang . String > javaMap = new java . util . HashMap ( ) ; javaMap . put ( \"hello\" , \"world\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( converter . toWritableObject ( javaMap ) , org . hamcrest . CoreMatchers . is ( ( ( java . lang . Object ) ( writableMap ) ) ) )", "total": "mapStringStringWritable ( ) { org . apache . hadoop . hive . serde2 . typeinfo . TypeInfo typeInfo = org . apache . hadoop . hive . serde2 . typeinfo . TypeInfoFactory . getMapTypeInfo ( TypeInfoFactory . stringTypeInfo , TypeInfoFactory . stringTypeInfo ) ; com . hotels . corc . Converter converter = getConverter ( typeInfo ) ; java . util . Map < org . apache . hadoop . io . Text , org . apache . hadoop . io . Text > writableMap = new java . util . HashMap ( ) ; writableMap . put ( new org . apache . hadoop . io . Text ( \"hello\" ) , new org . apache . hadoop . io . Text ( \"world\" ) ) ; java . util . Map < java . lang . String , java . lang . String > javaMap = new java . util . HashMap ( ) ; javaMap . put ( \"hello\" , \"world\" ) ; \"<AssertPlaceHolder>\" ; } toWritableObject ( java . lang . Object ) { if ( value == null ) { return null ; } try { return toWritableObjectInternal ( value ) ; } catch ( java . lang . ClassCastException e ) { throw new com . hotels . corc . UnexpectedTypeException ( value ) ; } }", "answer": "org . junit . Assert . assertThat ( converter . toWritableObject ( javaMap ) , org . hamcrest . CoreMatchers . is ( ( ( java . lang . Object ) ( writableMap ) ) ) )"}
{"focal": "isAlive ( ) { return java . util . EnumSet . range ( Status . RUNNING , Status . DONE ) . contains ( status ) ; }", "testMethod": "runnerShouldBeAliveWhenStatusRunning ( ) { runner . setStatus ( Runner . Status . RUNNING ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( runner . isAlive ( ) , org . hamcrest . core . Is . is ( true ) )", "total": "runnerShouldBeAliveWhenStatusRunning ( ) { runner . setStatus ( Runner . Status . RUNNING ) ; \"<AssertPlaceHolder>\" ; } isAlive ( ) { return java . util . EnumSet . range ( Status . RUNNING , Status . DONE ) . contains ( status ) ; }", "answer": "org . junit . Assert . assertThat ( runner . isAlive ( ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getList ( ) { return list ; }", "testMethod": "testAddAll11 ( ) { org . terasoluna . gfw . common . message . ResultMessage msg1 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"foo\" , \"aa\" ) ; org . terasoluna . gfw . common . message . ResultMessage msg2 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"bar\" , \"bb\" ) ; org . terasoluna . gfw . common . message . ResultMessages messages = new org . terasoluna . gfw . common . message . ResultMessages ( ( ( org . terasoluna . gfw . common . message . ResultMessageType ) ( ERROR ) ) ) ; messages . addAll ( java . util . Arrays . asList ( msg1 , msg2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( messages . getList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( msg1 , msg2 ) ) )", "total": "testAddAll11 ( ) { org . terasoluna . gfw . common . message . ResultMessage msg1 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"foo\" , \"aa\" ) ; org . terasoluna . gfw . common . message . ResultMessage msg2 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"bar\" , \"bb\" ) ; org . terasoluna . gfw . common . message . ResultMessages messages = new org . terasoluna . gfw . common . message . ResultMessages ( ( ( org . terasoluna . gfw . common . message . ResultMessageType ) ( ERROR ) ) ) ; messages . addAll ( java . util . Arrays . asList ( msg1 , msg2 ) ) ; \"<AssertPlaceHolder>\" ; } getList ( ) { return list ; }", "answer": "org . junit . Assert . assertThat ( messages . getList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( msg1 , msg2 ) ) )"}
{"focal": "getLoanOffering ( ) { return loanOffering ; }", "testMethod": "testIsDisbursalPreventedDueToAnyExistingActiveLoansForTheSameProductReturnsTrueIfCustomerHasSuchAccounts ( ) { client = new org . mifos . domain . builders . ClientBuilder ( ) . active ( ) . buildForUnitTests ( ) ; org . mifos . accounts . productdefinition . business . LoanOfferingBO loanProduct = new org . mifos . domain . builders . LoanProductBuilder ( ) . active ( ) . withoutLoanAmountSameForAllLoans ( ) . buildForUnitTests ( ) ; client . addAccount ( loanAccount ) ; when ( loanAccount . isActiveLoanAccount ( ) ) . thenReturn ( true ) ; when ( loanAccount . getLoanOffering ( ) ) . thenReturn ( loanProduct ) ; boolean isDisbursalPrevented = client . isDisbursalPreventedDueToAnyExistingActiveLoansForTheSameProduct ( loanProduct ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isDisbursalPrevented , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testIsDisbursalPreventedDueToAnyExistingActiveLoansForTheSameProductReturnsTrueIfCustomerHasSuchAccounts ( ) { client = new org . mifos . domain . builders . ClientBuilder ( ) . active ( ) . buildForUnitTests ( ) ; org . mifos . accounts . productdefinition . business . LoanOfferingBO loanProduct = new org . mifos . domain . builders . LoanProductBuilder ( ) . active ( ) . withoutLoanAmountSameForAllLoans ( ) . buildForUnitTests ( ) ; client . addAccount ( loanAccount ) ; when ( loanAccount . isActiveLoanAccount ( ) ) . thenReturn ( true ) ; when ( loanAccount . getLoanOffering ( ) ) . thenReturn ( loanProduct ) ; boolean isDisbursalPrevented = client . isDisbursalPreventedDueToAnyExistingActiveLoansForTheSameProduct ( loanProduct ) ; \"<AssertPlaceHolder>\" ; } getLoanOffering ( ) { return loanOffering ; }", "answer": "org . junit . Assert . assertThat ( isDisbursalPrevented , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getOutFile ( com . facebook . buck . features . js . JsBundle ) { com . fasterxml . jackson . databind . JsonNode args = getJobJson ( bundle ) ; return java . nio . file . Paths . get ( args . get ( \"bundlePath\" ) . asText ( ) ) . getFileName ( ) . toString ( ) ; }", "testMethod": "testFirstMatchingFlavorSetsBundleName ( ) { java . lang . String bundleName = \"for-ios.js\" ; com . facebook . buck . features . js . JsBundle bundle = scenario . createBundle ( \"//:arbitrary#arbitrary,release,ios\" , ( builder ) -> builder . setBundleNameForFlavor ( com . google . common . collect . ImmutableList . of ( new com . facebook . buck . features . js . Pair < > ( JsFlavors . IOS , bundleName ) , new com . facebook . buck . features . js . Pair < > ( JsFlavors . RELEASE , \"other-name\" ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( getOutFile ( bundle ) , org . hamcrest . Matchers . equalTo ( bundleName ) )", "total": "testFirstMatchingFlavorSetsBundleName ( ) { java . lang . String bundleName = \"for-ios.js\" ; com . facebook . buck . features . js . JsBundle bundle = scenario . createBundle ( \"//:arbitrary#arbitrary,release,ios\" , ( builder ) -> builder . setBundleNameForFlavor ( com . google . common . collect . ImmutableList . of ( new com . facebook . buck . features . js . Pair < > ( JsFlavors . IOS , bundleName ) , new com . facebook . buck . features . js . Pair < > ( JsFlavors . RELEASE , \"other-name\" ) ) ) ) ; \"<AssertPlaceHolder>\" ; } getOutFile ( com . facebook . buck . features . js . JsBundle ) { com . fasterxml . jackson . databind . JsonNode args = getJobJson ( bundle ) ; return java . nio . file . Paths . get ( args . get ( \"bundlePath\" ) . asText ( ) ) . getFileName ( ) . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( getOutFile ( bundle ) , org . hamcrest . Matchers . equalTo ( bundleName ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "zouGeenMeldingMoetenGevenOmdatGeslachtenAndersZijn ( ) { betrokkenheden . add ( createOuderBetrokkenheidBericht ( \"123\" ) ) ; final nl . bzk . brp . model . operationeel . kern . PersoonModel eerderkindModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonModel . class ) ; createPathToEerderKindModel ( eerderkindModel ) ; final nl . bzk . brp . model . bericht . kern . PersoonGeboorteGroepBericht persoonGeboorteGroepBericht = new nl . bzk . brp . model . bericht . kern . PersoonGeboorteGroepBericht ( ) ; persoonGeboorteGroepBericht . setDatumGeboorte ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; kindBericht . setGeboorte ( persoonGeboorteGroepBericht ) ; final nl . bzk . brp . model . operationeel . kern . PersoonGeboorteGroepModel persoonGeboorteGroepModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonGeboorteGroepModel . class ) ; final nl . bzk . brp . model . bericht . kern . PersoonGeslachtsaanduidingGroepBericht persoonGeslachtsaanduidingGroepBericht = new nl . bzk . brp . model . bericht . kern . PersoonGeslachtsaanduidingGroepBericht ( ) ; persoonGeslachtsaanduidingGroepBericht . setGeslachtsaanduiding ( Geslachtsaanduiding . MAN ) ; kindBericht . setGeslachtsaanduiding ( persoonGeslachtsaanduidingGroepBericht ) ; final nl . bzk . brp . model . operationeel . kern . PersoonGeslachtsaanduidingGroepModel persoonGeslachtsaanduidingGroepModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonGeslachtsaanduidingGroepModel . class ) ; final nl . bzk . brp . model . bericht . kern . PersoonSamengesteldeNaamGroepBericht persoonSamengesteldeNaamGroepBericht = new nl . bzk . brp . model . bericht . kern . PersoonSamengesteldeNaamGroepBericht ( ) ; persoonSamengesteldeNaamGroepBericht . setGeslachtsnaam ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Geslachtsnaam ( \"Janssen\" ) ) ; persoonSamengesteldeNaamGroepBericht . setScheidingsteken ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Scheidingsteken ( \"/\" ) ) ; persoonSamengesteldeNaamGroepBericht . setVoornamen ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voornamen ( \"Jan\" ) ) ; persoonSamengesteldeNaamGroepBericht . setVoorvoegsel ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voorvoegsel ( \"den\" ) ) ; kindBericht . setSamengesteldeNaam ( persoonSamengesteldeNaamGroepBericht ) ; final nl . bzk . brp . model . operationeel . kern . PersoonSamengesteldeNaamGroepModel persoonSamengesteldeNaamGroepModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonSamengesteldeNaamGroepModel . class ) ; when ( eerderkindModel . getGeboorte ( ) ) . thenReturn ( persoonGeboorteGroepModel ) ; when ( persoonGeboorteGroepModel . getDatumGeboorte ( ) ) . thenReturn ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; when ( eerderkindModel . getGeslachtsaanduiding ( ) ) . thenReturn ( persoonGeslachtsaanduidingGroepModel ) ; when ( persoonGeslachtsaanduidingGroepModel . getGeslachtsaanduiding ( ) ) . thenReturn ( Geslachtsaanduiding . VROUW ) ; when ( eerderkindModel . getSamengesteldeNaam ( ) ) . thenReturn ( persoonSamengesteldeNaamGroepModel ) ; when ( persoonSamengesteldeNaamGroepModel . getGeslachtsnaam ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Geslachtsnaam ( \"Janssen\" ) ) ; when ( persoonSamengesteldeNaamGroepModel . getScheidingsteken ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Scheidingsteken ( \"/\" ) ) ; when ( persoonSamengesteldeNaamGroepModel . getVoornamen ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voornamen ( \"Jan\" ) ) ; when ( persoonSamengesteldeNaamGroepModel . getVoorvoegsel ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voorvoegsel ( \"den\" ) ) ; java . util . List < nl . bzk . brp . model . validatie . Melding > meldingen = brby0126 . executeer ( relatieModel , relatieBericht , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( meldingen . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "zouGeenMeldingMoetenGevenOmdatGeslachtenAndersZijn ( ) { betrokkenheden . add ( createOuderBetrokkenheidBericht ( \"123\" ) ) ; final nl . bzk . brp . model . operationeel . kern . PersoonModel eerderkindModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonModel . class ) ; createPathToEerderKindModel ( eerderkindModel ) ; final nl . bzk . brp . model . bericht . kern . PersoonGeboorteGroepBericht persoonGeboorteGroepBericht = new nl . bzk . brp . model . bericht . kern . PersoonGeboorteGroepBericht ( ) ; persoonGeboorteGroepBericht . setDatumGeboorte ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; kindBericht . setGeboorte ( persoonGeboorteGroepBericht ) ; final nl . bzk . brp . model . operationeel . kern . PersoonGeboorteGroepModel persoonGeboorteGroepModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonGeboorteGroepModel . class ) ; final nl . bzk . brp . model . bericht . kern . PersoonGeslachtsaanduidingGroepBericht persoonGeslachtsaanduidingGroepBericht = new nl . bzk . brp . model . bericht . kern . PersoonGeslachtsaanduidingGroepBericht ( ) ; persoonGeslachtsaanduidingGroepBericht . setGeslachtsaanduiding ( Geslachtsaanduiding . MAN ) ; kindBericht . setGeslachtsaanduiding ( persoonGeslachtsaanduidingGroepBericht ) ; final nl . bzk . brp . model . operationeel . kern . PersoonGeslachtsaanduidingGroepModel persoonGeslachtsaanduidingGroepModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonGeslachtsaanduidingGroepModel . class ) ; final nl . bzk . brp . model . bericht . kern . PersoonSamengesteldeNaamGroepBericht persoonSamengesteldeNaamGroepBericht = new nl . bzk . brp . model . bericht . kern . PersoonSamengesteldeNaamGroepBericht ( ) ; persoonSamengesteldeNaamGroepBericht . setGeslachtsnaam ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Geslachtsnaam ( \"Janssen\" ) ) ; persoonSamengesteldeNaamGroepBericht . setScheidingsteken ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Scheidingsteken ( \"/\" ) ) ; persoonSamengesteldeNaamGroepBericht . setVoornamen ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voornamen ( \"Jan\" ) ) ; persoonSamengesteldeNaamGroepBericht . setVoorvoegsel ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voorvoegsel ( \"den\" ) ) ; kindBericht . setSamengesteldeNaam ( persoonSamengesteldeNaamGroepBericht ) ; final nl . bzk . brp . model . operationeel . kern . PersoonSamengesteldeNaamGroepModel persoonSamengesteldeNaamGroepModel = mock ( nl . bzk . brp . model . operationeel . kern . PersoonSamengesteldeNaamGroepModel . class ) ; when ( eerderkindModel . getGeboorte ( ) ) . thenReturn ( persoonGeboorteGroepModel ) ; when ( persoonGeboorteGroepModel . getDatumGeboorte ( ) ) . thenReturn ( nl . bzk . brp . util . DatumUtil . vandaag ( ) ) ; when ( eerderkindModel . getGeslachtsaanduiding ( ) ) . thenReturn ( persoonGeslachtsaanduidingGroepModel ) ; when ( persoonGeslachtsaanduidingGroepModel . getGeslachtsaanduiding ( ) ) . thenReturn ( Geslachtsaanduiding . VROUW ) ; when ( eerderkindModel . getSamengesteldeNaam ( ) ) . thenReturn ( persoonSamengesteldeNaamGroepModel ) ; when ( persoonSamengesteldeNaamGroepModel . getGeslachtsnaam ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Geslachtsnaam ( \"Janssen\" ) ) ; when ( persoonSamengesteldeNaamGroepModel . getScheidingsteken ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Scheidingsteken ( \"/\" ) ) ; when ( persoonSamengesteldeNaamGroepModel . getVoornamen ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voornamen ( \"Jan\" ) ) ; when ( persoonSamengesteldeNaamGroepModel . getVoorvoegsel ( ) ) . thenReturn ( new nl . bzk . brp . model . algemeen . attribuuttype . kern . Voorvoegsel ( \"den\" ) ) ; java . util . List < nl . bzk . brp . model . validatie . Melding > meldingen = brby0126 . executeer ( relatieModel , relatieBericht , null ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( meldingen . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getVersion ( ) { return version ; }", "testMethod": "shouldReturnSchemaVersionOfZeroInAnEmptyDatabase ( ) { org . cognitor . cassandra . migration . Database database = new org . cognitor . cassandra . migration . Database ( cassandra . getCluster ( ) , org . cognitor . cassandra . CassandraJUnitRule . TEST_KEYSPACE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( database . getVersion ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "shouldReturnSchemaVersionOfZeroInAnEmptyDatabase ( ) { org . cognitor . cassandra . migration . Database database = new org . cognitor . cassandra . migration . Database ( cassandra . getCluster ( ) , org . cognitor . cassandra . CassandraJUnitRule . TEST_KEYSPACE ) ; \"<AssertPlaceHolder>\" ; } getVersion ( ) { return version ; }", "answer": "org . junit . Assert . assertThat ( database . getVersion ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "isNull ( ) { return nullValue ; }", "testMethod": "init ( ) { com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( option . isNull ( ) , is ( true ) )", "total": "init ( ) { com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; \"<AssertPlaceHolder>\" ; } isNull ( ) { return nullValue ; }", "answer": "org . junit . Assert . assertThat ( option . isNull ( ) , is ( true ) )"}
{"focal": "size ( ) { final long c = count . get ( ) ; if ( c > ( values . length ( ) ) ) { return values . length ( ) ; } return ( ( int ) ( c ) ) ; }", "testMethod": "testUnitNullInvalid ( ) { org . kairosdb . core . http . rest . json . RelativeTime time = new org . kairosdb . core . http . rest . json . RelativeTime ( ) ; java . util . Set < javax . validation . ConstraintViolation < org . kairosdb . core . http . rest . json . RelativeTime > > violations = BeanValidationHelper . VALIDATOR . validate ( time ) ; java . util . List < java . lang . String > violationMessages = org . kairosdb . testing . BeanValidationHelper . messagesFor ( violations ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violationMessages . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 2 ) )", "total": "testUnitNullInvalid ( ) { org . kairosdb . core . http . rest . json . RelativeTime time = new org . kairosdb . core . http . rest . json . RelativeTime ( ) ; java . util . Set < javax . validation . ConstraintViolation < org . kairosdb . core . http . rest . json . RelativeTime > > violations = BeanValidationHelper . VALIDATOR . validate ( time ) ; java . util . List < java . lang . String > violationMessages = org . kairosdb . testing . BeanValidationHelper . messagesFor ( violations ) ; \"<AssertPlaceHolder>\" ; } size ( ) { final long c = count . get ( ) ; if ( c > ( values . length ( ) ) ) { return values . length ( ) ; } return ( ( int ) ( c ) ) ; }", "answer": "org . junit . Assert . assertThat ( violationMessages . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 2 ) )"}
{"focal": "returnsSameItems ( java . lang . Iterable ) { return new org . hamcrest . TypeSafeMatcher < java . lang . Iterable < T > > ( ) { @ org . neo4j . neode . Override public boolean matchesSafely ( java . lang . Iterable < T > actual ) { java . util . Iterator < T > expectedIterator = expected . iterator ( ) ; java . util . Iterator < T > iterator = actual . iterator ( ) ; boolean result = true ; while ( ( expectedIterator . hasNext ( ) ) && ( iterator . hasNext ( ) ) ) { T expectedNext = expectedIterator . next ( ) ; T next = iterator . next ( ) ; if ( ( expectedNext == null ) && ( next == null ) ) { result &= true ; } else { result &= expectedNext . equals ( next ) ; } } return result &= ( ! ( expectedIterator . hasNext ( ) ) ) && ( ! ( iterator . hasNext ( ) ) ) ; } @ org . neo4j . neode . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Iterables<sp>do<sp>not<sp>return<sp>the<sp>same<sp>items\" ) ; } } ; }", "testMethod": "shouldNotBeAbleToAddSameNodeTwice ( ) { org . neo4j . neode . test . Db . usingSampleDataset ( new org . neo4j . neode . test . Db . WithSampleDataset ( ) { @ org . neo4j . neode . Override public void execute ( org . neo4j . graphdb . GraphDatabaseService db , org . neo4j . graphdb . Node firstNode , org . neo4j . graphdb . Node secondNode , org . neo4j . graphdb . Node thirdNode ) { org . neo4j . neode . NodeCollection nodeCollection = new org . neo4j . neode . NodeCollection ( db , \"user\" , org . neo4j . neode . NodeCollectionTest . toSet ( firstNode . getId ( ) ) ) ; nodeCollection . add ( firstNode ) ; java . lang . Iterable < org . neo4j . graphdb . Node > expectedNodes = asList ( firstNode ) ; \"<AssertPlaceHolder>\" ; } } ) ; }", "assertLine": "org . junit . Assert . assertThat ( nodeCollection , returnsSameItems ( expectedNodes ) )", "total": "shouldNotBeAbleToAddSameNodeTwice ( ) { org . neo4j . neode . test . Db . usingSampleDataset ( new org . neo4j . neode . test . Db . WithSampleDataset ( ) { @ org . neo4j . neode . Override public void execute ( org . neo4j . graphdb . GraphDatabaseService db , org . neo4j . graphdb . Node firstNode , org . neo4j . graphdb . Node secondNode , org . neo4j . graphdb . Node thirdNode ) { org . neo4j . neode . NodeCollection nodeCollection = new org . neo4j . neode . NodeCollection ( db , \"user\" , org . neo4j . neode . NodeCollectionTest . toSet ( firstNode . getId ( ) ) ) ; nodeCollection . add ( firstNode ) ; java . lang . Iterable < org . neo4j . graphdb . Node > expectedNodes = asList ( firstNode ) ; \"<AssertPlaceHolder>\" ; } } ) ; } returnsSameItems ( java . lang . Iterable ) { return new org . hamcrest . TypeSafeMatcher < java . lang . Iterable < T > > ( ) { @ org . neo4j . neode . Override public boolean matchesSafely ( java . lang . Iterable < T > actual ) { java . util . Iterator < T > expectedIterator = expected . iterator ( ) ; java . util . Iterator < T > iterator = actual . iterator ( ) ; boolean result = true ; while ( ( expectedIterator . hasNext ( ) ) && ( iterator . hasNext ( ) ) ) { T expectedNext = expectedIterator . next ( ) ; T next = iterator . next ( ) ; if ( ( expectedNext == null ) && ( next == null ) ) { result &= true ; } else { result &= expectedNext . equals ( next ) ; } } return result &= ( ! ( expectedIterator . hasNext ( ) ) ) && ( ! ( iterator . hasNext ( ) ) ) ; } @ org . neo4j . neode . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Iterables<sp>do<sp>not<sp>return<sp>the<sp>same<sp>items\" ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( nodeCollection , returnsSameItems ( expectedNodes ) )"}
{"focal": "getVar ( ) { return ( ( java . lang . String ) ( getStateHelper ( ) . get ( org . springframework . springfaces . selectitems . ui . UISelectItems . PropertyKeys . var ) ) ) ; }", "testMethod": "shouldGetVarIfSpecified ( ) { this . uiPagedData . setVar ( \"myVar\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . uiPagedData . getVar ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"myVar\" ) ) )", "total": "shouldGetVarIfSpecified ( ) { this . uiPagedData . setVar ( \"myVar\" ) ; \"<AssertPlaceHolder>\" ; } getVar ( ) { return ( ( java . lang . String ) ( getStateHelper ( ) . get ( org . springframework . springfaces . selectitems . ui . UISelectItems . PropertyKeys . var ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( this . uiPagedData . getVar ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"myVar\" ) ) )"}
{"focal": "getEmptyTransactionCallback ( ) { return org . mule . runtime . core . api . transaction . TransactionTemplateTestUtils . getEmptyTransactionCallback ( RETURN_VALUE ) ; }", "testMethod": "testActionNoneAndTxForCommit ( ) { org . mule . runtime . core . api . transaction . TransactionCoordination . getInstance ( ) . bindTransaction ( mockTransaction ) ; org . mule . runtime . core . api . transaction . MuleTransactionConfig config = new org . mule . runtime . core . api . transaction . MuleTransactionConfig ( org . mule . runtime . core . api . transaction . TransactionConfig . ACTION_NONE ) ; org . mule . runtime . core . api . execution . ExecutionTemplate executionTemplate = createExecutionTemplate ( config ) ; java . lang . Object result = executionTemplate . execute ( getEmptyTransactionCallback ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( mockTransaction , never ( ) ) . commit ( ) ; verify ( mockTransaction , never ( ) ) . rollback ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( RETURN_VALUE ) )", "total": "testActionNoneAndTxForCommit ( ) { org . mule . runtime . core . api . transaction . TransactionCoordination . getInstance ( ) . bindTransaction ( mockTransaction ) ; org . mule . runtime . core . api . transaction . MuleTransactionConfig config = new org . mule . runtime . core . api . transaction . MuleTransactionConfig ( org . mule . runtime . core . api . transaction . TransactionConfig . ACTION_NONE ) ; org . mule . runtime . core . api . execution . ExecutionTemplate executionTemplate = createExecutionTemplate ( config ) ; java . lang . Object result = executionTemplate . execute ( getEmptyTransactionCallback ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( mockTransaction , never ( ) ) . commit ( ) ; verify ( mockTransaction , never ( ) ) . rollback ( ) ; } getEmptyTransactionCallback ( ) { return org . mule . runtime . core . api . transaction . TransactionTemplateTestUtils . getEmptyTransactionCallback ( RETURN_VALUE ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( RETURN_VALUE ) )"}
{"focal": "findParameterAt ( int ) { int tokenIndex = getTokenIndexForChar ( ( dot == 0 ? 1 : dot ) ) ; if ( tokenIndex == ( - 1 ) ) { return \"\" ; } java . lang . String token = tokens . get ( tokenIndex ) ; if ( isSeparator ( token ) ) { return tokenIndex < ( ( tokens . size ( ) ) - 1 ) ? tokens . get ( ( tokenIndex + 1 ) ) : \"\" ; } else if ( token . equals ( \"=\" ) ) { return tokenIndex > 1 ? tokens . get ( ( tokenIndex - 1 ) ) : \"\" ; } if ( ( tokenIndex > 1 ) && ( tokens . get ( ( tokenIndex - 1 ) ) . equals ( \"=\" ) ) ) { return tokens . get ( ( tokenIndex - 2 ) ) ; } return token ; }", "testMethod": "returnsFirstParameterWhenLeadingCharIsClicked ( ) { java . lang . String parametersString = \"?name=Johan&reallyLongOne=value&\" ; com . eviware . soapui . impl . rest . panels . request . ParameterFinder finder = new com . eviware . soapui . impl . rest . panels . request . ParameterFinder ( parametersString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( finder . findParameterAt ( 0 ) , org . hamcrest . core . Is . is ( \"name\" ) )", "total": "returnsFirstParameterWhenLeadingCharIsClicked ( ) { java . lang . String parametersString = \"?name=Johan&reallyLongOne=value&\" ; com . eviware . soapui . impl . rest . panels . request . ParameterFinder finder = new com . eviware . soapui . impl . rest . panels . request . ParameterFinder ( parametersString ) ; \"<AssertPlaceHolder>\" ; } findParameterAt ( int ) { int tokenIndex = getTokenIndexForChar ( ( dot == 0 ? 1 : dot ) ) ; if ( tokenIndex == ( - 1 ) ) { return \"\" ; } java . lang . String token = tokens . get ( tokenIndex ) ; if ( isSeparator ( token ) ) { return tokenIndex < ( ( tokens . size ( ) ) - 1 ) ? tokens . get ( ( tokenIndex + 1 ) ) : \"\" ; } else if ( token . equals ( \"=\" ) ) { return tokenIndex > 1 ? tokens . get ( ( tokenIndex - 1 ) ) : \"\" ; } if ( ( tokenIndex > 1 ) && ( tokens . get ( ( tokenIndex - 1 ) ) . equals ( \"=\" ) ) ) { return tokens . get ( ( tokenIndex - 2 ) ) ; } return token ; }", "answer": "org . junit . Assert . assertThat ( finder . findParameterAt ( 0 ) , org . hamcrest . core . Is . is ( \"name\" ) )"}
{"focal": "getPayload ( ) { return payload ; }", "testMethod": "messagePublishFromOtherAccount ( ) { appCtx = new org . springframework . context . support . ClassPathXmlApplicationContext ( \"InterAccountSQSPermissionTest.xml\" , getClass ( ) ) ; org . springframework . integration . core . SubscribableChannel inboundChannel = appCtx . getBean ( \"message-in\" , org . springframework . integration . core . SubscribableChannel . class ) ; inboundChannel . subscribe ( new org . springframework . integration . core . MessageHandler ( ) { @ intaws . integration . test . Override public void handleMessage ( org . springframework . integration . Message < ? > message ) throws org . springframework . integration . MessagingException { synchronized ( messages ) { messages . add ( ( ( java . lang . String ) ( message . getPayload ( ) ) ) ) ; } } } ) ; org . springframework . integration . MessageChannel outboundChannel = appCtx . getBean ( \"message-out\" , org . springframework . integration . MessageChannel . class ) ; final java . lang . String msg1 = \"This<sp>is<sp>message<sp>1\" ; outboundChannel . send ( org . springframework . integration . support . MessageBuilder . withPayload ( msg1 ) . build ( ) ) ; java . lang . Thread . sleep ( 30000 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( messages , contains ( msg1 ) )", "total": "messagePublishFromOtherAccount ( ) { appCtx = new org . springframework . context . support . ClassPathXmlApplicationContext ( \"InterAccountSQSPermissionTest.xml\" , getClass ( ) ) ; org . springframework . integration . core . SubscribableChannel inboundChannel = appCtx . getBean ( \"message-in\" , org . springframework . integration . core . SubscribableChannel . class ) ; inboundChannel . subscribe ( new org . springframework . integration . core . MessageHandler ( ) { @ intaws . integration . test . Override public void handleMessage ( org . springframework . integration . Message < ? > message ) throws org . springframework . integration . MessagingException { synchronized ( messages ) { messages . add ( ( ( java . lang . String ) ( message . getPayload ( ) ) ) ) ; } } } ) ; org . springframework . integration . MessageChannel outboundChannel = appCtx . getBean ( \"message-out\" , org . springframework . integration . MessageChannel . class ) ; final java . lang . String msg1 = \"This<sp>is<sp>message<sp>1\" ; outboundChannel . send ( org . springframework . integration . support . MessageBuilder . withPayload ( msg1 ) . build ( ) ) ; java . lang . Thread . sleep ( 30000 ) ; \"<AssertPlaceHolder>\" ; } getPayload ( ) { return payload ; }", "answer": "org . junit . Assert . assertThat ( messages , contains ( msg1 ) )"}
{"focal": "matches ( java . lang . String , java . lang . String ) { if ( ( pattern == null ) || ( source == null ) ) { return false ; } pattern = pattern . trim ( ) ; source = source . trim ( ) ; else if ( pattern . startsWith ( \"*\" ) ) { int length = ( pattern . length ( ) ) - 1 ; if ( ( ( source . length ( ) ) >= length ) && ( source . endsWith ( pattern . substring ( 1 ) ) ) ) { return true ; } } else if ( pattern . contains ( \"*\" ) ) { int start = pattern . indexOf ( \"*\" ) ; int end = pattern . lastIndexOf ( \"*\" ) ; if ( ( source . startsWith ( pattern . substring ( 0 , start ) ) ) && ( source . endsWith ( pattern . substring ( ( end + 1 ) ) ) ) ) { return true ; } } else { if ( pattern . equals ( source ) ) { return true ; } } return false ; }", "testMethod": "testPatternPriority ( ) { java . lang . String [ ] bogusPatterns = new java . lang . String [ ] { \"*html*\" , \"/favicon.ico*\" , \"*html\" } ; java . lang . String [ ] bogusSources = new java . lang . String [ ] { \"*html/ok?\" , \"/favicon.ico/ok?\" , \"/index.html\" } ; boolean result = false ; for ( int i = 0 ; i < ( bogusSources . length ) ; i ++ ) { for ( int j = 0 ; j < ( bogusPatterns . length ) ; j ++ ) { java . lang . String bogusSource = bogusSources [ i ] ; java . lang . String bogusPattern = bogusPatterns [ j ] ; if ( pathMatcher . matches ( bogusPattern , bogusSource ) ) { result = true ; } if ( result == true ) { break ; } } \"<AssertPlaceHolder>\" ; result = false ; } }", "assertLine": "org . junit . Assert . assertThat ( true , org . hamcrest . CoreMatchers . equalTo ( result ) )", "total": "testPatternPriority ( ) { java . lang . String [ ] bogusPatterns = new java . lang . String [ ] { \"*html*\" , \"/favicon.ico*\" , \"*html\" } ; java . lang . String [ ] bogusSources = new java . lang . String [ ] { \"*html/ok?\" , \"/favicon.ico/ok?\" , \"/index.html\" } ; boolean result = false ; for ( int i = 0 ; i < ( bogusSources . length ) ; i ++ ) { for ( int j = 0 ; j < ( bogusPatterns . length ) ; j ++ ) { java . lang . String bogusSource = bogusSources [ i ] ; java . lang . String bogusPattern = bogusPatterns [ j ] ; if ( pathMatcher . matches ( bogusPattern , bogusSource ) ) { result = true ; } if ( result == true ) { break ; } } \"<AssertPlaceHolder>\" ; result = false ; } } matches ( java . lang . String , java . lang . String ) { if ( ( pattern == null ) || ( source == null ) ) { return false ; } pattern = pattern . trim ( ) ; source = source . trim ( ) ; else if ( pattern . startsWith ( \"*\" ) ) { int length = ( pattern . length ( ) ) - 1 ; if ( ( ( source . length ( ) ) >= length ) && ( source . endsWith ( pattern . substring ( 1 ) ) ) ) { return true ; } } else if ( pattern . contains ( \"*\" ) ) { int start = pattern . indexOf ( \"*\" ) ; int end = pattern . lastIndexOf ( \"*\" ) ; if ( ( source . startsWith ( pattern . substring ( 0 , start ) ) ) && ( source . endsWith ( pattern . substring ( ( end + 1 ) ) ) ) ) { return true ; } } else { if ( pattern . equals ( source ) ) { return true ; } } return false ; }", "answer": "org . junit . Assert . assertThat ( true , org . hamcrest . CoreMatchers . equalTo ( result ) )"}
{"focal": "isNpc ( org . bukkit . entity . Player ) { return fr . xephi . authme . util . PlayerUtils . isNpc ( player ) ; }", "testMethod": "shouldReturnIfPlayerIsNpc ( ) { org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; given ( player . hasMetadata ( \"NPC\" ) ) . willReturn ( true ) ; boolean result = api . isNpc ( player ) ; \"<AssertPlaceHolder>\" ; verify ( player ) . hasMetadata ( \"NPC\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldReturnIfPlayerIsNpc ( ) { org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; given ( player . hasMetadata ( \"NPC\" ) ) . willReturn ( true ) ; boolean result = api . isNpc ( player ) ; \"<AssertPlaceHolder>\" ; verify ( player ) . hasMetadata ( \"NPC\" ) ; } isNpc ( org . bukkit . entity . Player ) { return fr . xephi . authme . util . PlayerUtils . isNpc ( player ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "getLeakedObjectsCount ( ) { return allocator . countLeakedObjects ( ) ; }", "testMethod": "managedPoolMustNotCountResizeAsLeak ( ) { config . setSize ( 2 ) ; stormpot . ManagedPool managedPool = assumeManagedPool ( ) ; claimRelease ( 2 , pool , stormpot . PoolTest . longTimeout ) ; managedPool . setTargetSize ( 4 ) ; claimRelease ( 4 , pool , stormpot . PoolTest . longTimeout ) ; managedPool . setTargetSize ( 1 ) ; while ( ( allocator . countDeallocations ( ) ) < 3 ) { spinwait ( 1 ) ; } allocator . clearLists ( ) ; java . lang . System . gc ( ) ; java . lang . System . gc ( ) ; java . lang . System . gc ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( managedPool . getLeakedObjectsCount ( ) , is ( 0L ) )", "total": "managedPoolMustNotCountResizeAsLeak ( ) { config . setSize ( 2 ) ; stormpot . ManagedPool managedPool = assumeManagedPool ( ) ; claimRelease ( 2 , pool , stormpot . PoolTest . longTimeout ) ; managedPool . setTargetSize ( 4 ) ; claimRelease ( 4 , pool , stormpot . PoolTest . longTimeout ) ; managedPool . setTargetSize ( 1 ) ; while ( ( allocator . countDeallocations ( ) ) < 3 ) { spinwait ( 1 ) ; } allocator . clearLists ( ) ; java . lang . System . gc ( ) ; java . lang . System . gc ( ) ; java . lang . System . gc ( ) ; \"<AssertPlaceHolder>\" ; } getLeakedObjectsCount ( ) { return allocator . countLeakedObjects ( ) ; }", "answer": "org . junit . Assert . assertThat ( managedPool . getLeakedObjectsCount ( ) , is ( 0L ) )"}
{"focal": "getVersion ( ) { return version ; }", "testMethod": "testAllServiceConfigVersionsWithConfigGroups ( ) { createDefaultCluster ( ) ; c1 . addService ( \"HDFS\" , helper . getOrCreateRepositoryVersion ( new org . apache . ambari . server . state . StackId ( \"HDP\" , \"0.1\" ) , \"0.1\" ) ) ; org . apache . ambari . server . state . Config hdfsSiteConfigV1 = configFactory . createNew ( c1 , \"HDP\" 1 , \"version1\" , com . google . common . collect . ImmutableMap . of ( \"HDP\" 3 , \"v1\" ) , com . google . common . collect . ImmutableMap . of ( ) ) ; org . apache . ambari . server . controller . ServiceConfigVersionResponse hdfsSiteConfigResponseV1 = c1 . addDesiredConfig ( \"admin\" , java . util . Collections . singleton ( hdfsSiteConfigV1 ) ) ; java . util . List < org . apache . ambari . server . controller . ConfigurationResponse > configResponsesDefaultGroup = java . util . Collections . singletonList ( new org . apache . ambari . server . controller . ConfigurationResponse ( c1 . getClusterName ( ) , hdfsSiteConfigV1 . getStackId ( ) , hdfsSiteConfigV1 . getType ( ) , hdfsSiteConfigV1 . getTag ( ) , hdfsSiteConfigV1 . getVersion ( ) , hdfsSiteConfigV1 . getProperties ( ) , hdfsSiteConfigV1 . getPropertiesAttributes ( ) , hdfsSiteConfigV1 . getPropertiesTypes ( ) ) ) ; hdfsSiteConfigResponseV1 . setConfigurations ( configResponsesDefaultGroup ) ; org . apache . ambari . server . state . Config hdfsSiteConfigV2 = configFactory . createNew ( c1 , \"HDP\" 1 , \"version2\" , com . google . common . collect . ImmutableMap . of ( \"HDP\" 3 , \"v2\" ) , com . google . common . collect . ImmutableMap . of ( ) ) ; org . apache . ambari . server . state . configgroup . ConfigGroup configGroup = configGroupFactory . createNew ( c1 , \"HDFS\" , \"configGroup1\" , \"version1\" , \"HDP\" 2 , com . google . common . collect . ImmutableMap . of ( hdfsSiteConfigV2 . getType ( ) , hdfsSiteConfigV2 ) , com . google . common . collect . ImmutableMap . of ( ) ) ; c1 . addConfigGroup ( configGroup ) ; org . apache . ambari . server . controller . ServiceConfigVersionResponse hdfsSiteConfigResponseV2 = c1 . createServiceConfigVersion ( \"HDFS\" , \"admin\" , \"HDP\" 0 , configGroup ) ; hdfsSiteConfigResponseV2 . setConfigurations ( java . util . Collections . singletonList ( new org . apache . ambari . server . controller . ConfigurationResponse ( c1 . getClusterName ( ) , hdfsSiteConfigV2 . getStackId ( ) , hdfsSiteConfigV2 . getType ( ) , hdfsSiteConfigV2 . getTag ( ) , hdfsSiteConfigV2 . getVersion ( ) , hdfsSiteConfigV2 . getProperties ( ) , hdfsSiteConfigV2 . getPropertiesAttributes ( ) , hdfsSiteConfigV2 . getPropertiesTypes ( ) ) ) ) ; hdfsSiteConfigResponseV2 . setIsCurrent ( true ) ; org . apache . ambari . server . controller . ServiceConfigVersionResponse hdfsSiteConfigResponseV3 = c1 . createServiceConfigVersion ( \"HDFS\" , \"admin\" , \"new<sp>config<sp>in<sp>default<sp>group\" , null ) ; hdfsSiteConfigResponseV3 . setConfigurations ( configResponsesDefaultGroup ) ; hdfsSiteConfigResponseV3 . setIsCurrent ( true ) ; java . util . List < org . apache . ambari . server . controller . ServiceConfigVersionResponse > expectedServiceConfigResponses = com . google . common . collect . ImmutableList . of ( hdfsSiteConfigResponseV1 , hdfsSiteConfigResponseV2 , hdfsSiteConfigResponseV3 ) ; java . util . List < org . apache . ambari . server . controller . ServiceConfigVersionResponse > allServiceConfigResponses = c1 . getServiceConfigVersions ( ) ; java . util . Collections . sort ( allServiceConfigResponses , new java . util . Comparator < org . apache . ambari . server . controller . ServiceConfigVersionResponse > ( ) { @ org . apache . ambari . server . state . cluster . Override public int compare ( org . apache . ambari . server . controller . ServiceConfigVersionResponse o1 , org . apache . ambari . server . controller . ServiceConfigVersionResponse o2 ) { return o1 . getVersion ( ) . compareTo ( o2 . getVersion ( ) ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allServiceConfigResponses , org . hamcrest . CoreMatchers . is ( expectedServiceConfigResponses ) )", "total": "testAllServiceConfigVersionsWithConfigGroups ( ) { createDefaultCluster ( ) ; c1 . addService ( \"HDFS\" , helper . getOrCreateRepositoryVersion ( new org . apache . ambari . server . state . StackId ( \"HDP\" , \"0.1\" ) , \"0.1\" ) ) ; org . apache . ambari . server . state . Config hdfsSiteConfigV1 = configFactory . createNew ( c1 , \"HDP\" 1 , \"version1\" , com . google . common . collect . ImmutableMap . of ( \"HDP\" 3 , \"v1\" ) , com . google . common . collect . ImmutableMap . of ( ) ) ; org . apache . ambari . server . controller . ServiceConfigVersionResponse hdfsSiteConfigResponseV1 = c1 . addDesiredConfig ( \"admin\" , java . util . Collections . singleton ( hdfsSiteConfigV1 ) ) ; java . util . List < org . apache . ambari . server . controller . ConfigurationResponse > configResponsesDefaultGroup = java . util . Collections . singletonList ( new org . apache . ambari . server . controller . ConfigurationResponse ( c1 . getClusterName ( ) , hdfsSiteConfigV1 . getStackId ( ) , hdfsSiteConfigV1 . getType ( ) , hdfsSiteConfigV1 . getTag ( ) , hdfsSiteConfigV1 . getVersion ( ) , hdfsSiteConfigV1 . getProperties ( ) , hdfsSiteConfigV1 . getPropertiesAttributes ( ) , hdfsSiteConfigV1 . getPropertiesTypes ( ) ) ) ; hdfsSiteConfigResponseV1 . setConfigurations ( configResponsesDefaultGroup ) ; org . apache . ambari . server . state . Config hdfsSiteConfigV2 = configFactory . createNew ( c1 , \"HDP\" 1 , \"version2\" , com . google . common . collect . ImmutableMap . of ( \"HDP\" 3 , \"v2\" ) , com . google . common . collect . ImmutableMap . of ( ) ) ; org . apache . ambari . server . state . configgroup . ConfigGroup configGroup = configGroupFactory . createNew ( c1 , \"HDFS\" , \"configGroup1\" , \"version1\" , \"HDP\" 2 , com . google . common . collect . ImmutableMap . of ( hdfsSiteConfigV2 . getType ( ) , hdfsSiteConfigV2 ) , com . google . common . collect . ImmutableMap . of ( ) ) ; c1 . addConfigGroup ( configGroup ) ; org . apache . ambari . server . controller . ServiceConfigVersionResponse hdfsSiteConfigResponseV2 = c1 . createServiceConfigVersion ( \"HDFS\" , \"admin\" , \"HDP\" 0 , configGroup ) ; hdfsSiteConfigResponseV2 . setConfigurations ( java . util . Collections . singletonList ( new org . apache . ambari . server . controller . ConfigurationResponse ( c1 . getClusterName ( ) , hdfsSiteConfigV2 . getStackId ( ) , hdfsSiteConfigV2 . getType ( ) , hdfsSiteConfigV2 . getTag ( ) , hdfsSiteConfigV2 . getVersion ( ) , hdfsSiteConfigV2 . getProperties ( ) , hdfsSiteConfigV2 . getPropertiesAttributes ( ) , hdfsSiteConfigV2 . getPropertiesTypes ( ) ) ) ) ; hdfsSiteConfigResponseV2 . setIsCurrent ( true ) ; org . apache . ambari . server . controller . ServiceConfigVersionResponse hdfsSiteConfigResponseV3 = c1 . createServiceConfigVersion ( \"HDFS\" , \"admin\" , \"new<sp>config<sp>in<sp>default<sp>group\" , null ) ; hdfsSiteConfigResponseV3 . setConfigurations ( configResponsesDefaultGroup ) ; hdfsSiteConfigResponseV3 . setIsCurrent ( true ) ; java . util . List < org . apache . ambari . server . controller . ServiceConfigVersionResponse > expectedServiceConfigResponses = com . google . common . collect . ImmutableList . of ( hdfsSiteConfigResponseV1 , hdfsSiteConfigResponseV2 , hdfsSiteConfigResponseV3 ) ; java . util . List < org . apache . ambari . server . controller . ServiceConfigVersionResponse > allServiceConfigResponses = c1 . getServiceConfigVersions ( ) ; java . util . Collections . sort ( allServiceConfigResponses , new java . util . Comparator < org . apache . ambari . server . controller . ServiceConfigVersionResponse > ( ) { @ org . apache . ambari . server . state . cluster . Override public int compare ( org . apache . ambari . server . controller . ServiceConfigVersionResponse o1 , org . apache . ambari . server . controller . ServiceConfigVersionResponse o2 ) { return o1 . getVersion ( ) . compareTo ( o2 . getVersion ( ) ) ; } } ) ; \"<AssertPlaceHolder>\" ; } getVersion ( ) { return version ; }", "answer": "org . junit . Assert . assertThat ( allServiceConfigResponses , org . hamcrest . CoreMatchers . is ( expectedServiceConfigResponses ) )"}
{"focal": "isError ( java . lang . String ) { if ( ( method . equals ( \"GET\" ) ) || ( method . equals ( \"DELETE\" ) ) ) { if ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . OK ) ) ) { return true ; } } else if ( method . equals ( \"PUT\" ) ) { if ( ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . OK ) ) ) && ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . CREATED ) ) ) ) { return true ; } } else { if ( ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . OK ) ) ) && ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . CREATED ) ) ) ) { return true ; } } return false ; }", "testMethod": "testIsErrorPutFalse ( ) { target . statusCode = target . CREATED ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . isError ( \"PUT\" ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testIsErrorPutFalse ( ) { target . statusCode = target . CREATED ; \"<AssertPlaceHolder>\" ; } isError ( java . lang . String ) { if ( ( method . equals ( \"GET\" ) ) || ( method . equals ( \"DELETE\" ) ) ) { if ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . OK ) ) ) { return true ; } } else if ( method . equals ( \"PUT\" ) ) { if ( ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . OK ) ) ) && ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . CREATED ) ) ) ) { return true ; } } else { if ( ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . OK ) ) ) && ( ! ( statusCode . equals ( org . o3project . odenos . remoteobject . message . Response . CREATED ) ) ) ) { return true ; } } return false ; }", "answer": "org . junit . Assert . assertThat ( target . isError ( \"PUT\" ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isSameCause ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause , hudson . model . Cause ) { if ( ! ( oldMavenCause instanceof org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ) { return java . util . Collections . emptyList ( ) ; } java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > newCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( newMavenCause . getMavenArtifacts ( ) , \"newMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > oldCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( ( ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ( oldMavenCause ) ) . getMavenArtifacts ( ) , \"oldMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = new java . util . ArrayList ( ) ; for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact newCauseArtifact : newCauseArtifacts ) { if ( ( newCauseArtifact . isSnapshot ( ) ) && ( newCauseArtifact . getVersion ( ) . contains ( \"SNAPSHOT\" ) ) ) { } else { for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact oldCauseArtifact : oldCauseArtifacts ) { if ( ( ( ( ( ( java . util . Objects . equals ( newCauseArtifact . getGroupId ( ) , oldCauseArtifact . getGroupId ( ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getArtifactId ( ) , oldCauseArtifact . getArtifactId ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getVersion ( ) , oldCauseArtifact . getVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getBaseVersion ( ) , oldCauseArtifact . getBaseVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getClassifier ( ) , oldCauseArtifact . getClassifier ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getType ( ) , oldCauseArtifact . getType ( ) ) ) ) { matchingArtifacts . add ( newCauseArtifact ) ; } } } } return matchingArtifacts ; }", "testMethod": "isSameCause_singleArtifact_mixedBaseVersion_false ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100530-2101-1\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( secondArtifact ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( ! ( matchingArtifacts . isEmpty ( ) ) ) , org . hamcrest . Matchers . is ( false ) )", "total": "isSameCause_singleArtifact_mixedBaseVersion_false ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100530-2101-1\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( secondArtifact ) ) ; \"<AssertPlaceHolder>\" ; } isSameCause ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause , hudson . model . Cause ) { if ( ! ( oldMavenCause instanceof org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ) { return java . util . Collections . emptyList ( ) ; } java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > newCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( newMavenCause . getMavenArtifacts ( ) , \"newMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > oldCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( ( ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ( oldMavenCause ) ) . getMavenArtifacts ( ) , \"oldMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = new java . util . ArrayList ( ) ; for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact newCauseArtifact : newCauseArtifacts ) { if ( ( newCauseArtifact . isSnapshot ( ) ) && ( newCauseArtifact . getVersion ( ) . contains ( \"SNAPSHOT\" ) ) ) { } else { for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact oldCauseArtifact : oldCauseArtifacts ) { if ( ( ( ( ( ( java . util . Objects . equals ( newCauseArtifact . getGroupId ( ) , oldCauseArtifact . getGroupId ( ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getArtifactId ( ) , oldCauseArtifact . getArtifactId ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getVersion ( ) , oldCauseArtifact . getVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getBaseVersion ( ) , oldCauseArtifact . getBaseVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getClassifier ( ) , oldCauseArtifact . getClassifier ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getType ( ) , oldCauseArtifact . getType ( ) ) ) ) { matchingArtifacts . add ( newCauseArtifact ) ; } } } } return matchingArtifacts ; }", "answer": "org . junit . Assert . assertThat ( ( ! ( matchingArtifacts . isEmpty ( ) ) ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "findJobRegisterStatistics ( java . util . Date ) { java . util . List < io . elasticjob . cloud . statistics . type . job . JobRegisterStatistics > result = new java . util . LinkedList ( ) ; java . text . SimpleDateFormat formatter = new java . text . SimpleDateFormat ( \"yyyy-MM-dd<sp>HH:mm:ss\" ) ; java . lang . String sql = java . lang . String . format ( \"SELECT<sp>id,<sp>registered_count,<sp>statistics_time,<sp>creation_time<sp>FROM<sp>%s<sp>WHERE<sp>statistics_time<sp>>=<sp>'%s'<sp>order<sp>by<sp>id<sp>ASC\" , io . elasticjob . cloud . statistics . rdb . StatisticRdbRepository . TABLE_JOB_REGISTER_STATISTICS , formatter . format ( from ) ) ; try ( java . sql . Connection conn = dataSource . getConnection ( ) ; java . sql . PreparedStatement preparedStatement = conn . prepareStatement ( sql ) ; java . sql . ResultSet resultSet = preparedStatement . executeQuery ( ) ) { while ( resultSet . next ( ) ) { io . elasticjob . cloud . statistics . type . job . JobRegisterStatistics jobRegisterStatistics = new io . elasticjob . cloud . statistics . type . job . JobRegisterStatistics ( resultSet . getLong ( 1 ) , resultSet . getInt ( 2 ) , new java . util . Date ( resultSet . getTimestamp ( 3 ) . getTime ( ) ) , new java . util . Date ( resultSet . getTimestamp ( 4 ) . getTime ( ) ) ) ; result . add ( jobRegisterStatistics ) ; } } catch ( final java . sql . SQLException ex ) { log . error ( \"Fetch<sp>jobRegisterStatistics<sp>from<sp>DB<sp>error:\" , ex ) ; } return result ; }", "testMethod": "assertFindJobRegisterStatisticsWhenTableIsEmpty ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( repository . findJobRegisterStatistics ( new java . util . Date ( ) ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "assertFindJobRegisterStatisticsWhenTableIsEmpty ( ) { \"<AssertPlaceHolder>\" ; } findJobRegisterStatistics ( java . util . Date ) { java . util . List < io . elasticjob . cloud . statistics . type . job . JobRegisterStatistics > result = new java . util . LinkedList ( ) ; java . text . SimpleDateFormat formatter = new java . text . SimpleDateFormat ( \"yyyy-MM-dd<sp>HH:mm:ss\" ) ; java . lang . String sql = java . lang . String . format ( \"SELECT<sp>id,<sp>registered_count,<sp>statistics_time,<sp>creation_time<sp>FROM<sp>%s<sp>WHERE<sp>statistics_time<sp>>=<sp>'%s'<sp>order<sp>by<sp>id<sp>ASC\" , io . elasticjob . cloud . statistics . rdb . StatisticRdbRepository . TABLE_JOB_REGISTER_STATISTICS , formatter . format ( from ) ) ; try ( java . sql . Connection conn = dataSource . getConnection ( ) ; java . sql . PreparedStatement preparedStatement = conn . prepareStatement ( sql ) ; java . sql . ResultSet resultSet = preparedStatement . executeQuery ( ) ) { while ( resultSet . next ( ) ) { io . elasticjob . cloud . statistics . type . job . JobRegisterStatistics jobRegisterStatistics = new io . elasticjob . cloud . statistics . type . job . JobRegisterStatistics ( resultSet . getLong ( 1 ) , resultSet . getInt ( 2 ) , new java . util . Date ( resultSet . getTimestamp ( 3 ) . getTime ( ) ) , new java . util . Date ( resultSet . getTimestamp ( 4 ) . getTime ( ) ) ) ; result . add ( jobRegisterStatistics ) ; } } catch ( final java . sql . SQLException ex ) { log . error ( \"Fetch<sp>jobRegisterStatistics<sp>from<sp>DB<sp>error:\" , ex ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( repository . findJobRegisterStatistics ( new java . util . Date ( ) ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "calculateMinPercentageUsedBy ( org . apache . storm . scheduler . resource . normalization . NormalizedResources , double , double ) { if ( org . apache . storm . scheduler . resource . normalization . NormalizedResources . LOG . isTraceEnabled ( ) ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources . LOG . trace ( ( \"Calculating<sp>min<sp>percentage<sp>used<sp>by.<sp>Used<sp>Mem:<sp>{}<sp>Total<sp>Mem:<sp>{}\" + \"<sp>Used<sp>Normalized<sp>Resources:<sp>{}<sp>Total<sp>Normalized<sp>Resources:<sp>{}\" ) , totalMemoryMb , usedMemoryMb , toNormalizedMap ( ) , used . toNormalizedMap ( ) ) ; } double min = 1.0 ; if ( usedMemoryMb > totalMemoryMb ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalMemoryMb != 0.0 ) { min = java . lang . Math . min ( min , ( usedMemoryMb / totalMemoryMb ) ) ; } double totalCpu = getTotalCpu ( ) ; if ( ( used . getTotalCpu ( ) ) > totalCpu ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalCpu != 0.0 ) { min = java . lang . Math . min ( min , ( ( used . getTotalCpu ( ) ) / totalCpu ) ) ; } if ( ( used . otherResources . length ) > ( otherResources . length ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } for ( int i = 0 ; i < ( otherResources . length ) ; i ++ ) { if ( ( otherResources [ i ] ) == 0.0 ) { continue ; } if ( i >= ( used . otherResources . length ) ) { return 0 ; } if ( ( used . otherResources [ i ] ) > ( otherResources [ i ] ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } min = java . lang . Math . min ( min , ( ( used . otherResources [ i ] ) / ( otherResources [ i ] ) ) ) ; } return min * 100.0 ; }", "testMethod": "testCalculateMinUsageWithNoResourcesInTotal ( ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources resources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; org . apache . storm . scheduler . resource . normalization . NormalizedResources usedResources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; double min = resources . calculateMinPercentageUsedBy ( usedResources , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( min , org . hamcrest . CoreMatchers . is ( 100.0 ) )", "total": "testCalculateMinUsageWithNoResourcesInTotal ( ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources resources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; org . apache . storm . scheduler . resource . normalization . NormalizedResources usedResources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; double min = resources . calculateMinPercentageUsedBy ( usedResources , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; } calculateMinPercentageUsedBy ( org . apache . storm . scheduler . resource . normalization . NormalizedResources , double , double ) { if ( org . apache . storm . scheduler . resource . normalization . NormalizedResources . LOG . isTraceEnabled ( ) ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources . LOG . trace ( ( \"Calculating<sp>min<sp>percentage<sp>used<sp>by.<sp>Used<sp>Mem:<sp>{}<sp>Total<sp>Mem:<sp>{}\" + \"<sp>Used<sp>Normalized<sp>Resources:<sp>{}<sp>Total<sp>Normalized<sp>Resources:<sp>{}\" ) , totalMemoryMb , usedMemoryMb , toNormalizedMap ( ) , used . toNormalizedMap ( ) ) ; } double min = 1.0 ; if ( usedMemoryMb > totalMemoryMb ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalMemoryMb != 0.0 ) { min = java . lang . Math . min ( min , ( usedMemoryMb / totalMemoryMb ) ) ; } double totalCpu = getTotalCpu ( ) ; if ( ( used . getTotalCpu ( ) ) > totalCpu ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalCpu != 0.0 ) { min = java . lang . Math . min ( min , ( ( used . getTotalCpu ( ) ) / totalCpu ) ) ; } if ( ( used . otherResources . length ) > ( otherResources . length ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } for ( int i = 0 ; i < ( otherResources . length ) ; i ++ ) { if ( ( otherResources [ i ] ) == 0.0 ) { continue ; } if ( i >= ( used . otherResources . length ) ) { return 0 ; } if ( ( used . otherResources [ i ] ) > ( otherResources [ i ] ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } min = java . lang . Math . min ( min , ( ( used . otherResources [ i ] ) / ( otherResources [ i ] ) ) ) ; } return min * 100.0 ; }", "answer": "org . junit . Assert . assertThat ( min , org . hamcrest . CoreMatchers . is ( 100.0 ) )"}
{"focal": "is ( com . jaxio . jpa . querybyexample . SearchMode ) { return ( getSearchMode ( ) ) == searchMode ; }", "testMethod": "simpleQueryOnLastNameWithLike ( ) { demo . Account example = new demo . Account ( ) ; example . setLastName ( \"Jag\" ) ; demo . SearchParameters sp = new demo . SearchParameters ( ) . startingLike ( ) ; java . util . List < demo . Account > result = accountRepository . find ( example , sp ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "simpleQueryOnLastNameWithLike ( ) { demo . Account example = new demo . Account ( ) ; example . setLastName ( \"Jag\" ) ; demo . SearchParameters sp = new demo . SearchParameters ( ) . startingLike ( ) ; java . util . List < demo . Account > result = accountRepository . find ( example , sp ) ; \"<AssertPlaceHolder>\" ; } is ( com . jaxio . jpa . querybyexample . SearchMode ) { return ( getSearchMode ( ) ) == searchMode ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsInstanceofFalse ( ) { boolean result = target . equals ( new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsInstanceofFalse ( ) { boolean result = target . equals ( new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "findAll ( ) { return anotherDatasource . findAll ( ) ; }", "testMethod": "testFindAll ( ) { java . util . List < com . example . model . ExampleModel > actualList = sut . findAll ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualList . size ( ) , org . hamcrest . CoreMatchers . is ( 1000 ) )", "total": "testFindAll ( ) { java . util . List < com . example . model . ExampleModel > actualList = sut . findAll ( ) ; \"<AssertPlaceHolder>\" ; } findAll ( ) { return anotherDatasource . findAll ( ) ; }", "answer": "org . junit . Assert . assertThat ( actualList . size ( ) , org . hamcrest . CoreMatchers . is ( 1000 ) )"}
{"focal": "allCrossings ( ) { org . eclipse . elk . alg . layered . graph . LNode [ ] [ ] nodeArray = graph . toNodeArray ( ) ; int portId = 0 ; for ( org . eclipse . elk . alg . layered . graph . LNode [ ] lNodes : nodeArray ) { for ( org . eclipse . elk . alg . layered . graph . LNode lNode : lNodes ) { for ( org . eclipse . elk . alg . layered . graph . LPort port : lNode . getPorts ( ) ) { port . id = portId ; portId ++ ; } } } org . eclipse . elk . alg . layered . p3order . GraphInfoHolder gd = new org . eclipse . elk . alg . layered . p3order . GraphInfoHolder ( graph , org . eclipse . elk . alg . layered . p3order . LayerSweepCrossingMinimizer . CrossMinType . BARYCENTER , null ) ; return gd . crossCounter ( ) . countAllCrossings ( nodeArray ) ; }", "testMethod": "countInLayerCrossingAndSwitch ( ) { graph = getInLayerEdgesGraph ( ) ; int amountOfCrossings = allCrossings ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( amountOfCrossings , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "countInLayerCrossingAndSwitch ( ) { graph = getInLayerEdgesGraph ( ) ; int amountOfCrossings = allCrossings ( ) ; \"<AssertPlaceHolder>\" ; } allCrossings ( ) { org . eclipse . elk . alg . layered . graph . LNode [ ] [ ] nodeArray = graph . toNodeArray ( ) ; int portId = 0 ; for ( org . eclipse . elk . alg . layered . graph . LNode [ ] lNodes : nodeArray ) { for ( org . eclipse . elk . alg . layered . graph . LNode lNode : lNodes ) { for ( org . eclipse . elk . alg . layered . graph . LPort port : lNode . getPorts ( ) ) { port . id = portId ; portId ++ ; } } } org . eclipse . elk . alg . layered . p3order . GraphInfoHolder gd = new org . eclipse . elk . alg . layered . p3order . GraphInfoHolder ( graph , org . eclipse . elk . alg . layered . p3order . LayerSweepCrossingMinimizer . CrossMinType . BARYCENTER , null ) ; return gd . crossCounter ( ) . countAllCrossings ( nodeArray ) ; }", "answer": "org . junit . Assert . assertThat ( amountOfCrossings , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "indent ( java . util . List ) { java . lang . StringBuilder indentedLines = new java . lang . StringBuilder ( ) ; java . util . Set < java . lang . String > alreadyDone = new java . util . HashSet ( ) ; for ( java . lang . String line : lines ) { if ( ( ! ( line . startsWith ( \"#\" ) ) ) && ( ! ( line . isEmpty ( ) ) ) ) { java . lang . String [ ] parts = line . replaceFirst ( \"\\\\s*#.*\" , \"\" ) . split ( \";\\\\s*\" ) ; java . lang . String key = ( ( parts [ 0 ] ) + \";\" ) + ( parts [ 1 ] ) ; if ( alreadyDone . contains ( key ) ) { continue ; } alreadyDone . add ( key ) ; } int commentPos = line . lastIndexOf ( '#' ) ; if ( commentPos <= 0 ) { indentedLines . append ( line ) . append ( \"\\n\" ) ; } else { int endData = commentPos ; while ( java . lang . Character . isWhitespace ( line . charAt ( ( endData - 1 ) ) ) ) { endData -- ; } java . lang . String spaces = org . apache . commons . lang3 . StringUtils . repeat ( \"<sp>\" , java . lang . Math . max ( 1 , ( 82 - endData ) ) ) ; indentedLines . append ( line , 0 , endData ) . append ( spaces ) . append ( line . substring ( commentPos ) ) . append ( \"\\n\" ) ; } } return indentedLines . toString ( ) ; }", "testMethod": "indentCommentedLineTest ( ) { java . util . List < java . lang . String > lines = java . util . Arrays . asList ( \"#mir;<sp>mit;<sp>1.50<sp>#<sp>p=0.994,<sp>r=0.658,<sp>tp=775,<sp>tn=1173,<sp>fp=5,<sp>fn=403,<sp>178+1000,<sp>2017-10-23\" , \"nach;<sp>noch;<sp>1.75#<sp>p=0.990,<sp>r=0.504,<sp>tp=1009,<sp>tn=1990,<sp>fp=10,<sp>fn=991,<sp>1000+1000,<sp>2017-10-23\" ) ; java . lang . String result = org . languagetool . dev . bigdata . ConfusionFileIndenter . indent ( lines ) ; java . lang . String expected = \"#mir;<sp>mit;<sp>1.50<sp>#<sp>p=0.994,<sp>r=0.658,<sp>tp=775,<sp>tn=1173,<sp>fp=5,<sp>fn=403,<sp>178+1000,<sp>2017-10-23\\n\" + \"nach;<sp>noch;<sp>1.75<sp>#<sp>p=0.990,<sp>r=0.504,<sp>tp=1009,<sp>tn=1990,<sp>fp=10,<sp>fn=991,<sp>1000+1000,<sp>2017-10-23\\n\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "indentCommentedLineTest ( ) { java . util . List < java . lang . String > lines = java . util . Arrays . asList ( \"#mir;<sp>mit;<sp>1.50<sp>#<sp>p=0.994,<sp>r=0.658,<sp>tp=775,<sp>tn=1173,<sp>fp=5,<sp>fn=403,<sp>178+1000,<sp>2017-10-23\" , \"nach;<sp>noch;<sp>1.75#<sp>p=0.990,<sp>r=0.504,<sp>tp=1009,<sp>tn=1990,<sp>fp=10,<sp>fn=991,<sp>1000+1000,<sp>2017-10-23\" ) ; java . lang . String result = org . languagetool . dev . bigdata . ConfusionFileIndenter . indent ( lines ) ; java . lang . String expected = \"#mir;<sp>mit;<sp>1.50<sp>#<sp>p=0.994,<sp>r=0.658,<sp>tp=775,<sp>tn=1173,<sp>fp=5,<sp>fn=403,<sp>178+1000,<sp>2017-10-23\\n\" + \"nach;<sp>noch;<sp>1.75<sp>#<sp>p=0.990,<sp>r=0.504,<sp>tp=1009,<sp>tn=1990,<sp>fp=10,<sp>fn=991,<sp>1000+1000,<sp>2017-10-23\\n\" ; \"<AssertPlaceHolder>\" ; } indent ( java . util . List ) { java . lang . StringBuilder indentedLines = new java . lang . StringBuilder ( ) ; java . util . Set < java . lang . String > alreadyDone = new java . util . HashSet ( ) ; for ( java . lang . String line : lines ) { if ( ( ! ( line . startsWith ( \"#\" ) ) ) && ( ! ( line . isEmpty ( ) ) ) ) { java . lang . String [ ] parts = line . replaceFirst ( \"\\\\s*#.*\" , \"\" ) . split ( \";\\\\s*\" ) ; java . lang . String key = ( ( parts [ 0 ] ) + \";\" ) + ( parts [ 1 ] ) ; if ( alreadyDone . contains ( key ) ) { continue ; } alreadyDone . add ( key ) ; } int commentPos = line . lastIndexOf ( '#' ) ; if ( commentPos <= 0 ) { indentedLines . append ( line ) . append ( \"\\n\" ) ; } else { int endData = commentPos ; while ( java . lang . Character . isWhitespace ( line . charAt ( ( endData - 1 ) ) ) ) { endData -- ; } java . lang . String spaces = org . apache . commons . lang3 . StringUtils . repeat ( \"<sp>\" , java . lang . Math . max ( 1 , ( 82 - endData ) ) ) ; indentedLines . append ( line , 0 , endData ) . append ( spaces ) . append ( line . substring ( commentPos ) ) . append ( \"\\n\" ) ; } } return indentedLines . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "isEmpty ( ) { org . junit . Assert . assertThat ( net . time4j . tz . model . RulesLikeBerlin1947Test . MODEL . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( false ) ) ; }", "testMethod": "isEmpty ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . tz . model . RulesLikeBerlin1947Test . MODEL . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "isEmpty ( ) { \"<AssertPlaceHolder>\" ; } isEmpty ( ) { org . junit . Assert . assertThat ( net . time4j . tz . model . RulesLikeBerlin1947Test . MODEL . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( false ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . tz . model . RulesLikeBerlin1947Test . MODEL . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "remove ( java . lang . Object ) { return delegate . remove ( object ) ; }", "testMethod": "removeSpecificObject ( ) { com . facebook . buck . util . concurrent . LinkedBlockingStack < java . lang . Integer > stack = new com . facebook . buck . util . concurrent . LinkedBlockingStack ( ) ; stack . addAll ( com . google . common . collect . ImmutableList . of ( 42 , 45 , 43 , 45 , 46 ) ) ; stack . remove ( 45 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( stack , org . hamcrest . Matchers . contains ( 46 , 43 , 45 , 42 ) )", "total": "removeSpecificObject ( ) { com . facebook . buck . util . concurrent . LinkedBlockingStack < java . lang . Integer > stack = new com . facebook . buck . util . concurrent . LinkedBlockingStack ( ) ; stack . addAll ( com . google . common . collect . ImmutableList . of ( 42 , 45 , 43 , 45 , 46 ) ) ; stack . remove ( 45 ) ; \"<AssertPlaceHolder>\" ; } remove ( java . lang . Object ) { return delegate . remove ( object ) ; }", "answer": "org . junit . Assert . assertThat ( stack , org . hamcrest . Matchers . contains ( 46 , 43 , 45 , 42 ) )"}
{"focal": "build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "testMethod": "more_ignore ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withOnMoreInput ( ErrorAction . IGNORE ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" , \"E\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) )", "total": "more_ignore ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withOnMoreInput ( ErrorAction . IGNORE ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" , \"E\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) ; \"<AssertPlaceHolder>\" ; } build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) )"}
{"focal": "populateDatabase ( ) { org . ops4j . pax . exam . sample2 . model . User micha = userService . register ( \"micha\" , \"Micha\" , \"password\" ) ; userService . register ( \"ollie\" , \"Olliver\" , \"password\" ) ; userService . addFriend ( micha , \"ollie\" ) ; java . util . List < java . lang . Integer > ids = asList ( 19995 , 194 , 600 , 601 , 602 , 603 , 604 , 605 , 606 , 607 , 608 , 609 , 13 , 20526 , 11 , 1893 , 1892 , 1894 , 168 , 193 , 200 , 157 , 152 , 201 , 154 , 12155 , 58 , 285 , 118 , 22 , 392 , 5255 , 568 , 9800 , 497 , 101 , 120 , 121 , 122 ) ; java . util . List < org . ops4j . pax . exam . sample2 . model . Movie > result = new java . util . ArrayList < org . ops4j . pax . exam . sample2 . model . Movie > ( ids . size ( ) ) ; for ( java . lang . Integer id : ids ) { result . add ( importService . importMovie ( id ) ) ; } final org . ops4j . pax . exam . sample2 . model . Movie movie = movieService . findById ( 603 ) ; userService . rate ( micha , movie , 5 , \"Best<sp>of<sp>the<sp>series\" ) ; return result ; }", "testMethod": "populateDatabase ( ) { java . util . List < org . ops4j . pax . exam . sample2 . model . Movie > movies = populator . populateDatabase ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( movies . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "populateDatabase ( ) { java . util . List < org . ops4j . pax . exam . sample2 . model . Movie > movies = populator . populateDatabase ( ) ; \"<AssertPlaceHolder>\" ; } populateDatabase ( ) { org . ops4j . pax . exam . sample2 . model . User micha = userService . register ( \"micha\" , \"Micha\" , \"password\" ) ; userService . register ( \"ollie\" , \"Olliver\" , \"password\" ) ; userService . addFriend ( micha , \"ollie\" ) ; java . util . List < java . lang . Integer > ids = asList ( 19995 , 194 , 600 , 601 , 602 , 603 , 604 , 605 , 606 , 607 , 608 , 609 , 13 , 20526 , 11 , 1893 , 1892 , 1894 , 168 , 193 , 200 , 157 , 152 , 201 , 154 , 12155 , 58 , 285 , 118 , 22 , 392 , 5255 , 568 , 9800 , 497 , 101 , 120 , 121 , 122 ) ; java . util . List < org . ops4j . pax . exam . sample2 . model . Movie > result = new java . util . ArrayList < org . ops4j . pax . exam . sample2 . model . Movie > ( ids . size ( ) ) ; for ( java . lang . Integer id : ids ) { result . add ( importService . importMovie ( id ) ) ; } final org . ops4j . pax . exam . sample2 . model . Movie movie = movieService . findById ( 603 ) ; userService . rate ( micha , movie , 5 , \"Best<sp>of<sp>the<sp>series\" ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( movies . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "put ( E ) { java . util . Objects . requireNonNull ( e ) ; while ( isFull ( ) ) { waitForChange ( 0 ) ; } addImpl ( e ) ; }", "testMethod": "putsInt ( ) { int [ ] array = new int [ 4 ] ; java . nio . IntBuffer buffer = java . nio . IntBuffer . wrap ( array ) ; buffer . put ( 2 ) . put ( 3 ) . put ( 5 ) . put ( 7 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( array , org . hamcrest . CoreMatchers . is ( new int [ ] { 2 , 3 , 5 , 7 } ) )", "total": "putsInt ( ) { int [ ] array = new int [ 4 ] ; java . nio . IntBuffer buffer = java . nio . IntBuffer . wrap ( array ) ; buffer . put ( 2 ) . put ( 3 ) . put ( 5 ) . put ( 7 ) ; \"<AssertPlaceHolder>\" ; } put ( E ) { java . util . Objects . requireNonNull ( e ) ; while ( isFull ( ) ) { waitForChange ( 0 ) ; } addImpl ( e ) ; }", "answer": "org . junit . Assert . assertThat ( array , org . hamcrest . CoreMatchers . is ( new int [ ] { 2 , 3 , 5 , 7 } ) )"}
{"focal": "findAll ( ) { unqualifiedRepo . findAll ( ) ; qualifiedRepo . findAll ( ) ; }", "testMethod": "adjustedWllKnownFindAllMethodShouldReturnAnEmptyList ( ) { ollie = repository . save ( ollie ) ; tom = repository . save ( tom ) ; java . util . List < org . springframework . data . jpa . domain . sample . User > result = repository . findAll ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . isEmpty ( ) , is ( true ) )", "total": "adjustedWllKnownFindAllMethodShouldReturnAnEmptyList ( ) { ollie = repository . save ( ollie ) ; tom = repository . save ( tom ) ; java . util . List < org . springframework . data . jpa . domain . sample . User > result = repository . findAll ( ) ; \"<AssertPlaceHolder>\" ; } findAll ( ) { unqualifiedRepo . findAll ( ) ; qualifiedRepo . findAll ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . isEmpty ( ) , is ( true ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"xxdisplay<sp>properties\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"xxdisplay<sp>properties\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "isShowing ( java . time . LocalDate , java . time . LocalDate , java . time . ZoneId ) { return isShowing ( this , startDate , endDate , zoneId ) ; }", "testMethod": "shouldBeShowing ( ) { boolean showing = recurrenceSourceEntry . isShowing ( java . time . LocalDate . now ( ) , java . time . LocalDate . now ( ) . plusDays ( 1 ) , java . time . ZoneId . systemDefault ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( showing , org . hamcrest . Matchers . is ( true ) )", "total": "shouldBeShowing ( ) { boolean showing = recurrenceSourceEntry . isShowing ( java . time . LocalDate . now ( ) , java . time . LocalDate . now ( ) . plusDays ( 1 ) , java . time . ZoneId . systemDefault ( ) ) ; \"<AssertPlaceHolder>\" ; } isShowing ( java . time . LocalDate , java . time . LocalDate , java . time . ZoneId ) { return isShowing ( this , startDate , endDate , zoneId ) ; }", "answer": "org . junit . Assert . assertThat ( showing , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getValue ( int ) { return values . get ( index ) ; }", "testMethod": "shouldIndexNodeAfterChange ( ) { registerValueIndex ( \"ref1\" , \"nt:unstructured\" , \"\" , null , \"ref1\" , PropertyType . STRING ) ; registerValueIndex ( \"ref2\" , \"nt:unstructured\" , \"\" , null , \"ref2\" , PropertyType . STRING ) ; waitForIndexes ( 500L ) ; javax . jcr . Node newNode1 = session . getRootNode ( ) . addNode ( \"nodeWithSysName\" , \"nt:unstructured\" ) ; session . save ( ) ; printMessage ( \"Node<sp>Created<sp>...\" ) ; final java . lang . String uuId1 = \"cccccccccccccccccccccc-0000-1111-1234-123456789abcd\" ; newNode1 . setProperty ( \"ref1\" , uuId1 ) ; newNode1 . setProperty ( \"ref2\" , uuId1 ) ; session . save ( ) ; printMessage ( \"Node<sp>updated<sp>...\" ) ; org . modeshape . jcr . api . query . Query query = jcrSql2Query ( \"SELECT<sp>A.ref1<sp>FROM<sp>[nt:unstructured]<sp>AS<sp>A<sp>WHERE<sp>A.ref2<sp>=<sp>$ref2\" ) ; query . bindValue ( \"ref2\" , session ( ) . getValueFactory ( ) . createValue ( uuId1 ) ) ; validateQuery ( ) . rowCount ( 1L ) . useIndex ( \"ref2\" ) . onEachRow ( new org . modeshape . jcr . ValidateQuery . Predicate ( ) { @ org . modeshape . jcr . Override public void validate ( int rowNumber , javax . jcr . query . Row row ) throws javax . jcr . RepositoryException { if ( rowNumber == 1 ) { \"<AssertPlaceHolder>\" ; } } } ) . validate ( query , query . execute ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( row . getValue ( \"ref1\" ) . getString ( ) , org . hamcrest . core . Is . is ( uuId1 ) )", "total": "shouldIndexNodeAfterChange ( ) { registerValueIndex ( \"ref1\" , \"nt:unstructured\" , \"\" , null , \"ref1\" , PropertyType . STRING ) ; registerValueIndex ( \"ref2\" , \"nt:unstructured\" , \"\" , null , \"ref2\" , PropertyType . STRING ) ; waitForIndexes ( 500L ) ; javax . jcr . Node newNode1 = session . getRootNode ( ) . addNode ( \"nodeWithSysName\" , \"nt:unstructured\" ) ; session . save ( ) ; printMessage ( \"Node<sp>Created<sp>...\" ) ; final java . lang . String uuId1 = \"cccccccccccccccccccccc-0000-1111-1234-123456789abcd\" ; newNode1 . setProperty ( \"ref1\" , uuId1 ) ; newNode1 . setProperty ( \"ref2\" , uuId1 ) ; session . save ( ) ; printMessage ( \"Node<sp>updated<sp>...\" ) ; org . modeshape . jcr . api . query . Query query = jcrSql2Query ( \"SELECT<sp>A.ref1<sp>FROM<sp>[nt:unstructured]<sp>AS<sp>A<sp>WHERE<sp>A.ref2<sp>=<sp>$ref2\" ) ; query . bindValue ( \"ref2\" , session ( ) . getValueFactory ( ) . createValue ( uuId1 ) ) ; validateQuery ( ) . rowCount ( 1L ) . useIndex ( \"ref2\" ) . onEachRow ( new org . modeshape . jcr . ValidateQuery . Predicate ( ) { @ org . modeshape . jcr . Override public void validate ( int rowNumber , javax . jcr . query . Row row ) throws javax . jcr . RepositoryException { if ( rowNumber == 1 ) { \"<AssertPlaceHolder>\" ; } } } ) . validate ( query , query . execute ( ) ) ; } getValue ( int ) { return values . get ( index ) ; }", "answer": "org . junit . Assert . assertThat ( row . getValue ( \"ref1\" ) . getString ( ) , org . hamcrest . core . Is . is ( uuId1 ) )"}
{"focal": "contentTypeApplicationJson ( ) { addHeader ( HttpConstants . HEADER_CONTENT_TYPE , HttpConstants . APPLICATION_JSON_WITH_CHARSET_UTF8 ) ; return this ; }", "testMethod": "testContentTypeApplicationJson ( ) { org . r10r . doctester . testbrowser . Request request = org . r10r . doctester . testbrowser . Request . GET ( ) . contentTypeApplicationJson ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( request . headers . get ( HttpConstants . HEADER_CONTENT_TYPE ) , org . hamcrest . CoreMatchers . equalTo ( HttpConstants . APPLICATION_JSON_WITH_CHARSET_UTF8 ) )", "total": "testContentTypeApplicationJson ( ) { org . r10r . doctester . testbrowser . Request request = org . r10r . doctester . testbrowser . Request . GET ( ) . contentTypeApplicationJson ( ) ; \"<AssertPlaceHolder>\" ; } contentTypeApplicationJson ( ) { addHeader ( HttpConstants . HEADER_CONTENT_TYPE , HttpConstants . APPLICATION_JSON_WITH_CHARSET_UTF8 ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( request . headers . get ( HttpConstants . HEADER_CONTENT_TYPE ) , org . hamcrest . CoreMatchers . equalTo ( HttpConstants . APPLICATION_JSON_WITH_CHARSET_UTF8 ) )"}
{"focal": "resolve ( java . lang . String ) { com . google . common . base . Preconditions . checkNotNull ( fqdn , \"fqdn\" ) ; try { final java . util . List < com . spotify . dns . LookupResult > nodes = delegate . resolve ( fqdn ) ; if ( nodes . isEmpty ( ) ) { java . util . List < com . spotify . dns . LookupResult > cached = cache . getIfPresent ( fqdn ) ; return cached != null ? cached : nodes ; } cache . put ( fqdn , nodes ) ; return nodes ; } catch ( java . lang . Exception e ) { if ( ( cache . getIfPresent ( fqdn ) ) != null ) { return cache . getIfPresent ( fqdn ) ; } throw com . google . common . base . Throwables . propagate ( e ) ; } }", "testMethod": "shouldReturnResultsFromDelegate ( ) { when ( delegate . resolve ( com . spotify . dns . RetainingDnsSrvResolverTest . FQDN ) ) . thenReturn ( nodes1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resolver . resolve ( com . spotify . dns . RetainingDnsSrvResolverTest . FQDN ) , org . hamcrest . Matchers . equalTo ( nodes1 ) )", "total": "shouldReturnResultsFromDelegate ( ) { when ( delegate . resolve ( com . spotify . dns . RetainingDnsSrvResolverTest . FQDN ) ) . thenReturn ( nodes1 ) ; \"<AssertPlaceHolder>\" ; } resolve ( java . lang . String ) { com . google . common . base . Preconditions . checkNotNull ( fqdn , \"fqdn\" ) ; try { final java . util . List < com . spotify . dns . LookupResult > nodes = delegate . resolve ( fqdn ) ; if ( nodes . isEmpty ( ) ) { java . util . List < com . spotify . dns . LookupResult > cached = cache . getIfPresent ( fqdn ) ; return cached != null ? cached : nodes ; } cache . put ( fqdn , nodes ) ; return nodes ; } catch ( java . lang . Exception e ) { if ( ( cache . getIfPresent ( fqdn ) ) != null ) { return cache . getIfPresent ( fqdn ) ; } throw com . google . common . base . Throwables . propagate ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( resolver . resolve ( com . spotify . dns . RetainingDnsSrvResolverTest . FQDN ) , org . hamcrest . Matchers . equalTo ( nodes1 ) )"}
{"focal": "size ( ) { return keySet ( ) . size ( ) ; }", "testMethod": "getEssentialListOfLastDeploymentsForAppServerAndContext_shouldReturnLatestOnlyIfSuccessful ( ) { ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceEntity resource = ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceFactory . createNewResource ( ) ; resource . setName ( \"fooAS\" ) ; entityManager . persist ( resource ) ; ch . puzzle . itc . mobiliar . business . environment . entity . ContextEntity context = new ch . puzzle . itc . mobiliar . business . environment . entity . ContextEntity ( ) ; context . setName ( \"test\" ) ; entityManager . persist ( context ) ; ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity successful = new ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity ( ) ; successful . setResourceGroup ( resource . getResourceGroup ( ) ) ; successful . setContext ( context ) ; successful . setDeploymentDate ( new ch . puzzle . itc . mobiliar . business . deploy . boundary . Date ( ) ) ; successful . setDeploymentState ( DeploymentState . success ) ; persistDeploymentEntityForTest ( successful ) ; ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity failed = new ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity ( ) ; failed . setResourceGroup ( resource . getResourceGroup ( ) ) ; failed . setContext ( context ) ; failed . setDeploymentDate ( new ch . puzzle . itc . mobiliar . business . deploy . boundary . Date ( ) ) ; failed . setDeploymentState ( DeploymentState . failed ) ; persistDeploymentEntityForTest ( failed ) ; ch . puzzle . itc . mobiliar . business . deploy . boundary . List < java . lang . Object [ ] > latest = deploymentBoundary . getEssentialListOfLastDeploymentsForAppServerAndContext ( true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( latest . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "getEssentialListOfLastDeploymentsForAppServerAndContext_shouldReturnLatestOnlyIfSuccessful ( ) { ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceEntity resource = ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceFactory . createNewResource ( ) ; resource . setName ( \"fooAS\" ) ; entityManager . persist ( resource ) ; ch . puzzle . itc . mobiliar . business . environment . entity . ContextEntity context = new ch . puzzle . itc . mobiliar . business . environment . entity . ContextEntity ( ) ; context . setName ( \"test\" ) ; entityManager . persist ( context ) ; ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity successful = new ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity ( ) ; successful . setResourceGroup ( resource . getResourceGroup ( ) ) ; successful . setContext ( context ) ; successful . setDeploymentDate ( new ch . puzzle . itc . mobiliar . business . deploy . boundary . Date ( ) ) ; successful . setDeploymentState ( DeploymentState . success ) ; persistDeploymentEntityForTest ( successful ) ; ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity failed = new ch . puzzle . itc . mobiliar . business . deploy . boundary . DeploymentEntity ( ) ; failed . setResourceGroup ( resource . getResourceGroup ( ) ) ; failed . setContext ( context ) ; failed . setDeploymentDate ( new ch . puzzle . itc . mobiliar . business . deploy . boundary . Date ( ) ) ; failed . setDeploymentState ( DeploymentState . failed ) ; persistDeploymentEntityForTest ( failed ) ; ch . puzzle . itc . mobiliar . business . deploy . boundary . List < java . lang . Object [ ] > latest = deploymentBoundary . getEssentialListOfLastDeploymentsForAppServerAndContext ( true ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return keySet ( ) . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( latest . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "call ( ) { int exitCode = 0 ; try { scheduler ( ) . run ( ) ; } catch ( java . lang . Throwable t ) { log . error ( \"Caught<sp>throwable<sp>while<sp>processing<sp>data\" , t ) ; exitCode = 1 ; } return exitCode ; }", "testMethod": "testInterruptedAfterWorkerShutdown ( ) { java . util . concurrent . Callable < java . lang . Boolean > requestedShutdownCallable = buildRequestedShutdownCallable ( ) ; when ( notificationCompleteLatch . await ( anyLong ( ) , any ( java . util . concurrent . TimeUnit . class ) ) ) . thenReturn ( true ) ; doAnswer ( ( invocation ) -> { java . lang . Thread . currentThread ( ) . interrupt ( ) ; return true ; } ) . when ( scheduler ) . shutdown ( ) ; \"<AssertPlaceHolder>\" ; verifyLatchAwait ( notificationCompleteLatch ) ; verifyLatchAwait ( shutdownCompleteLatch , never ( ) ) ; verify ( scheduler ) . shutdown ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( requestedShutdownCallable . call ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "testInterruptedAfterWorkerShutdown ( ) { java . util . concurrent . Callable < java . lang . Boolean > requestedShutdownCallable = buildRequestedShutdownCallable ( ) ; when ( notificationCompleteLatch . await ( anyLong ( ) , any ( java . util . concurrent . TimeUnit . class ) ) ) . thenReturn ( true ) ; doAnswer ( ( invocation ) -> { java . lang . Thread . currentThread ( ) . interrupt ( ) ; return true ; } ) . when ( scheduler ) . shutdown ( ) ; \"<AssertPlaceHolder>\" ; verifyLatchAwait ( notificationCompleteLatch ) ; verifyLatchAwait ( shutdownCompleteLatch , never ( ) ) ; verify ( scheduler ) . shutdown ( ) ; } call ( ) { int exitCode = 0 ; try { scheduler ( ) . run ( ) ; } catch ( java . lang . Throwable t ) { log . error ( \"Caught<sp>throwable<sp>while<sp>processing<sp>data\" , t ) ; exitCode = 1 ; } return exitCode ; }", "answer": "org . junit . Assert . assertThat ( requestedShutdownCallable . call ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "isJobSucceeded ( ) { return succeeded ; }", "testMethod": "aFailureJobShouldFireACorrespondingSchedulerEvent ( ) { org . silverpeas . core . scheduler . trigger . JobTrigger trigger = org . silverpeas . core . scheduler . trigger . JobTrigger . triggerEvery ( 1 , TimeUnit . SECOND ) ; scheduler . scheduleJob ( new org . silverpeas . core . scheduler . Job ( org . silverpeas . core . scheduler . VolatileSchedulerIT . JOB_NAME ) { @ org . silverpeas . core . scheduler . Override public void execute ( org . silverpeas . core . scheduler . JobExecutionContext context ) { throw new java . lang . UnsupportedOperationException ( \"Not<sp>supported<sp>yet.\" ) ; } } , trigger , eventHandler ) ; await ( ) . atMost ( 2 , org . silverpeas . core . scheduler . SECONDS ) . until ( eventHandlingCompleted ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( eventHandler . isJobSucceeded ( ) , is ( false ) )", "total": "aFailureJobShouldFireACorrespondingSchedulerEvent ( ) { org . silverpeas . core . scheduler . trigger . JobTrigger trigger = org . silverpeas . core . scheduler . trigger . JobTrigger . triggerEvery ( 1 , TimeUnit . SECOND ) ; scheduler . scheduleJob ( new org . silverpeas . core . scheduler . Job ( org . silverpeas . core . scheduler . VolatileSchedulerIT . JOB_NAME ) { @ org . silverpeas . core . scheduler . Override public void execute ( org . silverpeas . core . scheduler . JobExecutionContext context ) { throw new java . lang . UnsupportedOperationException ( \"Not<sp>supported<sp>yet.\" ) ; } } , trigger , eventHandler ) ; await ( ) . atMost ( 2 , org . silverpeas . core . scheduler . SECONDS ) . until ( eventHandlingCompleted ( ) ) ; \"<AssertPlaceHolder>\" ; } isJobSucceeded ( ) { return succeeded ; }", "answer": "org . junit . Assert . assertThat ( eventHandler . isJobSucceeded ( ) , is ( false ) )"}
{"focal": "qName ( ) { return element . getQualifiedName ( ) . toString ( ) ; }", "testMethod": "shouldParentClassFirstTypeArgumentOfInteger ( ) { org . robobinding . codegen . apt . element . WrappedTypeElement parentClassTypeElement = klassTypeElement . findDirectSuperclassOf ( org . robobinding . codegen . apt . element . ParentClass . class ) ; org . robobinding . codegen . apt . element . WrappedTypeElement typeArgument = parentClassTypeElement . firstTypeArgument ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( typeArgument . qName ( ) , org . hamcrest . Matchers . equalTo ( org . robobinding . codegen . apt . element . Integer . class . getName ( ) ) )", "total": "shouldParentClassFirstTypeArgumentOfInteger ( ) { org . robobinding . codegen . apt . element . WrappedTypeElement parentClassTypeElement = klassTypeElement . findDirectSuperclassOf ( org . robobinding . codegen . apt . element . ParentClass . class ) ; org . robobinding . codegen . apt . element . WrappedTypeElement typeArgument = parentClassTypeElement . firstTypeArgument ( ) ; \"<AssertPlaceHolder>\" ; } qName ( ) { return element . getQualifiedName ( ) . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( typeArgument . qName ( ) , org . hamcrest . Matchers . equalTo ( org . robobinding . codegen . apt . element . Integer . class . getName ( ) ) )"}
{"focal": "processAction ( javax . servlet . http . HttpServletRequest , java . lang . String ) { return action ; }", "testMethod": "testProcessActionNoProcessors01 ( ) { compositeRequestDataValueProcessor = new org . terasoluna . gfw . web . mvc . support . CompositeRequestDataValueProcessor ( ) ; java . lang . String result = compositeRequestDataValueProcessor . processAction ( request , \"action\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( \"action\" ) )", "total": "testProcessActionNoProcessors01 ( ) { compositeRequestDataValueProcessor = new org . terasoluna . gfw . web . mvc . support . CompositeRequestDataValueProcessor ( ) ; java . lang . String result = compositeRequestDataValueProcessor . processAction ( request , \"action\" ) ; \"<AssertPlaceHolder>\" ; } processAction ( javax . servlet . http . HttpServletRequest , java . lang . String ) { return action ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( \"action\" ) )"}
{"focal": "toDateAndClearDatePart ( java . lang . Object ) { return org . slim3 . util . DateUtil . clearDatePart ( org . slim3 . util . DateUtil . toDate ( o ) ) ; }", "testMethod": "toDateAndClearDatePart ( ) { java . util . Date date = new java . util . Date ( ) ; java . util . Calendar cal = java . util . Calendar . getInstance ( org . slim3 . util . TimeZoneLocator . get ( ) ) ; cal . setTime ( date ) ; cal . set ( Calendar . YEAR , 1970 ) ; cal . set ( Calendar . MONTH , Calendar . JANUARY ) ; cal . set ( Calendar . DATE , 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . slim3 . util . DateUtil . toDateAndClearDatePart ( date ) , org . hamcrest . CoreMatchers . is ( cal . getTime ( ) ) )", "total": "toDateAndClearDatePart ( ) { java . util . Date date = new java . util . Date ( ) ; java . util . Calendar cal = java . util . Calendar . getInstance ( org . slim3 . util . TimeZoneLocator . get ( ) ) ; cal . setTime ( date ) ; cal . set ( Calendar . YEAR , 1970 ) ; cal . set ( Calendar . MONTH , Calendar . JANUARY ) ; cal . set ( Calendar . DATE , 1 ) ; \"<AssertPlaceHolder>\" ; } toDateAndClearDatePart ( java . lang . Object ) { return org . slim3 . util . DateUtil . clearDatePart ( org . slim3 . util . DateUtil . toDate ( o ) ) ; }", "answer": "org . junit . Assert . assertThat ( org . slim3 . util . DateUtil . toDateAndClearDatePart ( date ) , org . hamcrest . CoreMatchers . is ( cal . getTime ( ) ) )"}
{"focal": "containsPart ( org . eclipse . che . ide . api . parts . PartPresenter ) { for ( org . eclipse . che . ide . api . parts . EditorPartStack partStackPresenter : partStackPresenters ) { if ( partStackPresenter . containsPart ( part ) ) { return true ; } } return false ; }", "testMethod": "partShouldBeContained ( ) { presenter . addPart ( basePresenter ) ; boolean isContained = presenter . containsPart ( basePresenter ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isContained , org . hamcrest . CoreMatchers . is ( true ) )", "total": "partShouldBeContained ( ) { presenter . addPart ( basePresenter ) ; boolean isContained = presenter . containsPart ( basePresenter ) ; \"<AssertPlaceHolder>\" ; } containsPart ( org . eclipse . che . ide . api . parts . PartPresenter ) { for ( org . eclipse . che . ide . api . parts . EditorPartStack partStackPresenter : partStackPresenters ) { if ( partStackPresenter . containsPart ( part ) ) { return true ; } } return false ; }", "answer": "org . junit . Assert . assertThat ( isContained , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "testMethod": "testJsonSerialization ( ) { java . util . SortedSet < org . batfish . datamodel . Ip > bumTransportIps = com . google . common . collect . ImmutableSortedSet . of ( org . batfish . datamodel . Ip . parse ( \"2.2.2.2\" ) , org . batfish . datamodel . Ip . parse ( \"2.2.2.3\" ) ) ; org . batfish . datamodel . VniSettings vs = org . batfish . datamodel . VniSettings . builder ( ) . setBumTransportIps ( bumTransportIps ) . setBumTransportMethod ( BumTransportMethod . UNICAST_FLOOD_GROUP ) . setSourceAddress ( org . batfish . datamodel . Ip . parse ( \"1.2.3.4\" ) ) . setUdpPort ( 2345 ) . setVlan ( 7 ) . setVni ( 10007 ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( vs , org . batfish . datamodel . VniSettings . class ) , org . hamcrest . Matchers . equalTo ( vs ) )", "total": "testJsonSerialization ( ) { java . util . SortedSet < org . batfish . datamodel . Ip > bumTransportIps = com . google . common . collect . ImmutableSortedSet . of ( org . batfish . datamodel . Ip . parse ( \"2.2.2.2\" ) , org . batfish . datamodel . Ip . parse ( \"2.2.2.3\" ) ) ; org . batfish . datamodel . VniSettings vs = org . batfish . datamodel . VniSettings . builder ( ) . setBumTransportIps ( bumTransportIps ) . setBumTransportMethod ( BumTransportMethod . UNICAST_FLOOD_GROUP ) . setSourceAddress ( org . batfish . datamodel . Ip . parse ( \"1.2.3.4\" ) ) . setUdpPort ( 2345 ) . setVlan ( 7 ) . setVni ( 10007 ) . build ( ) ; \"<AssertPlaceHolder>\" ; } clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "answer": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( vs , org . batfish . datamodel . VniSettings . class ) , org . hamcrest . Matchers . equalTo ( vs ) )"}
{"focal": "append_partition_with_environment_context ( java . lang . String , java . lang . String , java . util . List , org . apache . hadoop . hive . metastore . api . EnvironmentContext ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = checkWritePermissions ( db_name ) ; org . apache . hadoop . hive . metastore . api . Partition partition = mapping . getClient ( ) . append_partition_with_environment_context ( mapping . transformInboundDatabaseName ( db_name ) , tbl_name , part_vals , environment_context ) ; return mapping . transformOutboundPartition ( partition ) ; }", "testMethod": "append_partition_with_environment_context ( ) { org . apache . hadoop . hive . metastore . api . EnvironmentContext environmentContext = new org . apache . hadoop . hive . metastore . api . EnvironmentContext ( ) ; org . apache . hadoop . hive . metastore . api . Partition inbound = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; org . apache . hadoop . hive . metastore . api . Partition outbound = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; java . util . List < java . lang . String > partVals = com . google . common . collect . Lists . newArrayList ( ) ; when ( primaryMapping . transformInboundDatabaseName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ) . thenReturn ( \"inbound\" ) ; when ( primaryClient . append_partition_with_environment_context ( \"inbound\" , \"table1\" , partVals , environmentContext ) ) . thenReturn ( inbound ) ; when ( primaryMapping . transformOutboundPartition ( inbound ) ) . thenReturn ( outbound ) ; org . apache . hadoop . hive . metastore . api . Partition result = handler . append_partition_with_environment_context ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P , \"table1\" , partVals , environmentContext ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )", "total": "append_partition_with_environment_context ( ) { org . apache . hadoop . hive . metastore . api . EnvironmentContext environmentContext = new org . apache . hadoop . hive . metastore . api . EnvironmentContext ( ) ; org . apache . hadoop . hive . metastore . api . Partition inbound = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; org . apache . hadoop . hive . metastore . api . Partition outbound = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; java . util . List < java . lang . String > partVals = com . google . common . collect . Lists . newArrayList ( ) ; when ( primaryMapping . transformInboundDatabaseName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ) . thenReturn ( \"inbound\" ) ; when ( primaryClient . append_partition_with_environment_context ( \"inbound\" , \"table1\" , partVals , environmentContext ) ) . thenReturn ( inbound ) ; when ( primaryMapping . transformOutboundPartition ( inbound ) ) . thenReturn ( outbound ) ; org . apache . hadoop . hive . metastore . api . Partition result = handler . append_partition_with_environment_context ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P , \"table1\" , partVals , environmentContext ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; } append_partition_with_environment_context ( java . lang . String , java . lang . String , java . util . List , org . apache . hadoop . hive . metastore . api . EnvironmentContext ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = checkWritePermissions ( db_name ) ; org . apache . hadoop . hive . metastore . api . Partition partition = mapping . getClient ( ) . append_partition_with_environment_context ( mapping . transformInboundDatabaseName ( db_name ) , tbl_name , part_vals , environment_context ) ; return mapping . transformOutboundPartition ( partition ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )"}
{"focal": "convert ( java . lang . Throwable ) { java . util . List < java . lang . String > strList = new java . util . LinkedList < java . lang . String > ( ) ; ch . qos . logback . core . helpers . ThrowableToStringArray . extract ( strList , t , null ) ; return strList . toArray ( new java . lang . String [ 0 ] ) ; }", "testMethod": "skipSelectedLine ( ) { java . lang . String nameOfContainingMethod = \"skipSelectedLine\" ; final java . lang . Throwable t = ch . qos . logback . classic . util . TestHelper . makeNestedException ( 0 ) ; t . printStackTrace ( pw ) ; final ch . qos . logback . classic . spi . ILoggingEvent le = createLoggingEvent ( t ) ; tpc . setOptionList ( java . util . Arrays . asList ( \"full\" , nameOfContainingMethod ) ) ; tpc . start ( ) ; final java . lang . String result = tpc . convert ( le ) ; \"<AssertPlaceHolder>\" . doesNotContain ( nameOfContainingMethod ) ; }", "assertLine": "org . junit . Assert . assertThat ( result )", "total": "skipSelectedLine ( ) { java . lang . String nameOfContainingMethod = \"skipSelectedLine\" ; final java . lang . Throwable t = ch . qos . logback . classic . util . TestHelper . makeNestedException ( 0 ) ; t . printStackTrace ( pw ) ; final ch . qos . logback . classic . spi . ILoggingEvent le = createLoggingEvent ( t ) ; tpc . setOptionList ( java . util . Arrays . asList ( \"full\" , nameOfContainingMethod ) ) ; tpc . start ( ) ; final java . lang . String result = tpc . convert ( le ) ; \"<AssertPlaceHolder>\" . doesNotContain ( nameOfContainingMethod ) ; } convert ( java . lang . Throwable ) { java . util . List < java . lang . String > strList = new java . util . LinkedList < java . lang . String > ( ) ; ch . qos . logback . core . helpers . ThrowableToStringArray . extract ( strList , t , null ) ; return strList . toArray ( new java . lang . String [ 0 ] ) ; }", "answer": "org . junit . Assert . assertThat ( result )"}
{"focal": "getStartIndex ( se . diabol . jenkins . pipeline . domain . Component , boolean , int ) { int startIndex = 0 ; if ( pagingEnabled && ( ! ( component . isFullScreenView ( ) ) ) ) { startIndex = ( ( component . getCurrentPage ( ) ) - 1 ) * noOfPipelines ; } return startIndex ; }", "testMethod": "shouldCalculateStartIndexWhenPagingEnabledAndInNormalView ( ) { se . diabol . jenkins . pipeline . domain . Component component = mock ( se . diabol . jenkins . pipeline . domain . Component . class ) ; when ( component . isFullScreenView ( ) ) . thenReturn ( false ) ; when ( component . getCurrentPage ( ) ) . thenReturn ( 3 ) ; int startIndex = se . diabol . jenkins . pipeline . domain . DownstreamPipeline . getStartIndex ( component , se . diabol . jenkins . pipeline . domain . DownstreamPipelineTest . PAGING_ENABLED , 10 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( startIndex , org . hamcrest . core . Is . is ( 20 ) )", "total": "shouldCalculateStartIndexWhenPagingEnabledAndInNormalView ( ) { se . diabol . jenkins . pipeline . domain . Component component = mock ( se . diabol . jenkins . pipeline . domain . Component . class ) ; when ( component . isFullScreenView ( ) ) . thenReturn ( false ) ; when ( component . getCurrentPage ( ) ) . thenReturn ( 3 ) ; int startIndex = se . diabol . jenkins . pipeline . domain . DownstreamPipeline . getStartIndex ( component , se . diabol . jenkins . pipeline . domain . DownstreamPipelineTest . PAGING_ENABLED , 10 ) ; \"<AssertPlaceHolder>\" ; } getStartIndex ( se . diabol . jenkins . pipeline . domain . Component , boolean , int ) { int startIndex = 0 ; if ( pagingEnabled && ( ! ( component . isFullScreenView ( ) ) ) ) { startIndex = ( ( component . getCurrentPage ( ) ) - 1 ) * noOfPipelines ; } return startIndex ; }", "answer": "org . junit . Assert . assertThat ( startIndex , org . hamcrest . core . Is . is ( 20 ) )"}
{"focal": "minimizeCrossings ( org . eclipse . elk . alg . layered . p3order . BarycenterHeuristic , org . eclipse . elk . alg . layered . graph . LNode [ ] , boolean , boolean , boolean ) { java . util . List < org . eclipse . elk . alg . layered . graph . LNode > nodeList = com . google . common . collect . Lists . newArrayList ( nodes ) ; crossMin . minimizeCrossings ( nodeList , preOrdered , randomized , forward ) ; int i = 0 ; for ( org . eclipse . elk . alg . layered . graph . LNode node : nodeList ) { nodes [ ( i ++ ) ] = node ; } }", "testMethod": "minimizeCrossings_removesCrossingInSimpleCross ( ) { org . eclipse . elk . alg . layered . graph . LNode [ ] leftNodes = addNodesToLayer ( 2 , makeLayer ( ) ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] rightNodes = addNodesToLayer ( 2 , makeLayer ( ) ) ; eastWestEdgeFromTo ( leftNodes [ 0 ] , rightNodes [ 1 ] ) ; eastWestEdgeFromTo ( leftNodes [ 1 ] , rightNodes [ 0 ] ) ; setUpIds ( ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] [ ] nodes = getGraph ( ) . toNodeArray ( ) ; org . eclipse . elk . alg . layered . p3order . NodeRelativePortDistributor portDist = new org . eclipse . elk . alg . layered . p3order . NodeRelativePortDistributor ( nodes . length ) ; org . eclipse . elk . alg . layered . p3order . ForsterConstraintResolver constraintResolver = new org . eclipse . elk . alg . layered . p3order . ForsterConstraintResolver ( nodes ) ; org . eclipse . elk . alg . layered . p3order . counting . IInitializable . init ( java . util . Arrays . asList ( portDist , constraintResolver ) , nodes ) ; org . eclipse . elk . alg . layered . p3order . counting . IInitializable . init ( java . util . Arrays . asList ( portDist , constraintResolver ) , nodes ) ; portDist . calculatePortRanks ( nodes [ 0 ] , PortType . OUTPUT ) ; org . eclipse . elk . alg . layered . p3order . BarycenterHeuristic crossMin = new org . eclipse . elk . alg . layered . p3order . BarycenterHeuristic ( constraintResolver , random , portDist , nodes ) ; org . eclipse . elk . alg . layered . p3order . counting . IInitializable . init ( java . util . Arrays . asList ( crossMin ) , nodes ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] expectedOrder = switchOrderInArray ( 0 , 1 , nodes [ 1 ] ) ; minimizeCrossings ( crossMin , nodes [ 1 ] , false , false , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( expectedOrder , org . hamcrest . CoreMatchers . is ( nodes [ 1 ] ) )", "total": "minimizeCrossings_removesCrossingInSimpleCross ( ) { org . eclipse . elk . alg . layered . graph . LNode [ ] leftNodes = addNodesToLayer ( 2 , makeLayer ( ) ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] rightNodes = addNodesToLayer ( 2 , makeLayer ( ) ) ; eastWestEdgeFromTo ( leftNodes [ 0 ] , rightNodes [ 1 ] ) ; eastWestEdgeFromTo ( leftNodes [ 1 ] , rightNodes [ 0 ] ) ; setUpIds ( ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] [ ] nodes = getGraph ( ) . toNodeArray ( ) ; org . eclipse . elk . alg . layered . p3order . NodeRelativePortDistributor portDist = new org . eclipse . elk . alg . layered . p3order . NodeRelativePortDistributor ( nodes . length ) ; org . eclipse . elk . alg . layered . p3order . ForsterConstraintResolver constraintResolver = new org . eclipse . elk . alg . layered . p3order . ForsterConstraintResolver ( nodes ) ; org . eclipse . elk . alg . layered . p3order . counting . IInitializable . init ( java . util . Arrays . asList ( portDist , constraintResolver ) , nodes ) ; org . eclipse . elk . alg . layered . p3order . counting . IInitializable . init ( java . util . Arrays . asList ( portDist , constraintResolver ) , nodes ) ; portDist . calculatePortRanks ( nodes [ 0 ] , PortType . OUTPUT ) ; org . eclipse . elk . alg . layered . p3order . BarycenterHeuristic crossMin = new org . eclipse . elk . alg . layered . p3order . BarycenterHeuristic ( constraintResolver , random , portDist , nodes ) ; org . eclipse . elk . alg . layered . p3order . counting . IInitializable . init ( java . util . Arrays . asList ( crossMin ) , nodes ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] expectedOrder = switchOrderInArray ( 0 , 1 , nodes [ 1 ] ) ; minimizeCrossings ( crossMin , nodes [ 1 ] , false , false , true ) ; \"<AssertPlaceHolder>\" ; } minimizeCrossings ( org . eclipse . elk . alg . layered . p3order . BarycenterHeuristic , org . eclipse . elk . alg . layered . graph . LNode [ ] , boolean , boolean , boolean ) { java . util . List < org . eclipse . elk . alg . layered . graph . LNode > nodeList = com . google . common . collect . Lists . newArrayList ( nodes ) ; crossMin . minimizeCrossings ( nodeList , preOrdered , randomized , forward ) ; int i = 0 ; for ( org . eclipse . elk . alg . layered . graph . LNode node : nodeList ) { nodes [ ( i ++ ) ] = node ; } }", "answer": "org . junit . Assert . assertThat ( expectedOrder , org . hamcrest . CoreMatchers . is ( nodes [ 1 ] ) )"}
{"focal": "getStoredOffsetPersistenceTimes ( ) { return getStoredOffsetPersistenceTimes ( false ) ; }", "testMethod": "skipReadingDirectory ( ) { long current = 1464992662000L ; java . util . List < java . lang . Long > persistedTimes = new java . util . LinkedList ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { persistedTimes . add ( ( current + ( i * 18000 ) ) ) ; } for ( java . lang . Long t : persistedTimes ) { try { writer . write ( t , java . util . Collections . < org . apache . kafka . common . TopicPartition , java . lang . Long > emptyMap ( ) ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } } fileSystem . mkdirs ( new org . apache . hadoop . fs . Path ( basePath , \"imadirectory\" ) ) ; java . util . List < java . lang . Long > storedTimes = reader . getStoredOffsetPersistenceTimes ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( storedTimes , org . hamcrest . core . Is . is ( persistedTimes ) )", "total": "skipReadingDirectory ( ) { long current = 1464992662000L ; java . util . List < java . lang . Long > persistedTimes = new java . util . LinkedList ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { persistedTimes . add ( ( current + ( i * 18000 ) ) ) ; } for ( java . lang . Long t : persistedTimes ) { try { writer . write ( t , java . util . Collections . < org . apache . kafka . common . TopicPartition , java . lang . Long > emptyMap ( ) ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } } fileSystem . mkdirs ( new org . apache . hadoop . fs . Path ( basePath , \"imadirectory\" ) ) ; java . util . List < java . lang . Long > storedTimes = reader . getStoredOffsetPersistenceTimes ( ) ; \"<AssertPlaceHolder>\" ; } getStoredOffsetPersistenceTimes ( ) { return getStoredOffsetPersistenceTimes ( false ) ; }", "answer": "org . junit . Assert . assertThat ( storedTimes , org . hamcrest . core . Is . is ( persistedTimes ) )"}
{"focal": "interfaceId ( ) { return interfaceId ; }", "testMethod": "testInterfaceId ( ) { deviceInformation . addInterfaceId ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( deviceInformation . interfaceId ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testInterfaceId ( ) { deviceInformation . addInterfaceId ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) ; \"<AssertPlaceHolder>\" ; } interfaceId ( ) { return interfaceId ; }", "answer": "org . junit . Assert . assertThat ( deviceInformation . interfaceId ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "size ( ) { return fieldErrors . size ( ) ; }", "testMethod": "testShouldFindExistingVoluntarySavingsAccountsForGroupsWithCompleteGroupStatusWhenCenterIsTopOfCustomerHierarchy ( ) { savingsProduct = new org . mifos . domain . builders . SavingsProductBuilder ( ) . voluntary ( ) . appliesToGroupsOnly ( ) . buildForIntegrationTests ( ) ; savingsAccount = new org . mifos . domain . builders . SavingsAccountBuilder ( ) . completeGroup ( ) . withSavingsProduct ( savingsProduct ) . withCustomer ( group ) . withCreatedBy ( org . mifos . framework . util . helpers . IntegrationTestObjectMother . testUser ( ) ) . build ( ) ; org . mifos . framework . util . helpers . IntegrationTestObjectMother . saveSavingsProductAndAssociatedSavingsAccounts ( savingsProduct , savingsAccount ) ; java . util . List < org . mifos . application . servicefacade . CollectionSheetCustomerSavingDto > mandatorySavingAccounts = savingsDao . findAllVoluntarySavingAccountsForClientsAndGroupsWithCompleteGroupStatusForCustomerHierarchy ( customerHierarchyParams ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mandatorySavingAccounts . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testShouldFindExistingVoluntarySavingsAccountsForGroupsWithCompleteGroupStatusWhenCenterIsTopOfCustomerHierarchy ( ) { savingsProduct = new org . mifos . domain . builders . SavingsProductBuilder ( ) . voluntary ( ) . appliesToGroupsOnly ( ) . buildForIntegrationTests ( ) ; savingsAccount = new org . mifos . domain . builders . SavingsAccountBuilder ( ) . completeGroup ( ) . withSavingsProduct ( savingsProduct ) . withCustomer ( group ) . withCreatedBy ( org . mifos . framework . util . helpers . IntegrationTestObjectMother . testUser ( ) ) . build ( ) ; org . mifos . framework . util . helpers . IntegrationTestObjectMother . saveSavingsProductAndAssociatedSavingsAccounts ( savingsProduct , savingsAccount ) ; java . util . List < org . mifos . application . servicefacade . CollectionSheetCustomerSavingDto > mandatorySavingAccounts = savingsDao . findAllVoluntarySavingAccountsForClientsAndGroupsWithCompleteGroupStatusForCustomerHierarchy ( customerHierarchyParams ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return fieldErrors . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( mandatorySavingAccounts . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "toUri ( ) { if ( templated ) { throw new java . lang . IllegalStateException ( ( ( \"Cannot<sp>get<sp>URI<sp>of<sp>a<sp>template<sp>link<sp>without<sp>providing<sp>parameters.<sp>Explicitly<sp>pass<sp>an<sp>empty<sp>parameter<sp>map<sp>to<sp>ignore<sp>optional<sp>parameters.<sp>(\" + ( getHref ( ) ) ) + \")\" ) ) ; } else { return java . net . URI . create ( getHref ( ) ) ; } }", "testMethod": "followArbitraryHeaders ( ) { final org . haligate . core . Client client = org . haligate . core . Haligate . defaultClient ( ) ; final org . haligate . core . Link link = client . from ( rootUri ) . followHeader ( \"X-Root-Resource\" ) . asLink ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( link . toUri ( ) , org . hamcrest . CoreMatchers . equalTo ( rootUri ) )", "total": "followArbitraryHeaders ( ) { final org . haligate . core . Client client = org . haligate . core . Haligate . defaultClient ( ) ; final org . haligate . core . Link link = client . from ( rootUri ) . followHeader ( \"X-Root-Resource\" ) . asLink ( ) ; \"<AssertPlaceHolder>\" ; } toUri ( ) { if ( templated ) { throw new java . lang . IllegalStateException ( ( ( \"Cannot<sp>get<sp>URI<sp>of<sp>a<sp>template<sp>link<sp>without<sp>providing<sp>parameters.<sp>Explicitly<sp>pass<sp>an<sp>empty<sp>parameter<sp>map<sp>to<sp>ignore<sp>optional<sp>parameters.<sp>(\" + ( getHref ( ) ) ) + \")\" ) ) ; } else { return java . net . URI . create ( getHref ( ) ) ; } }", "answer": "org . junit . Assert . assertThat ( link . toUri ( ) , org . hamcrest . CoreMatchers . equalTo ( rootUri ) )"}
{"focal": "valueAsShort ( java . lang . String , short ) { java . lang . String val = com . openhtmltopdf . util . Configuration . valueFor ( key ) ; if ( val == null ) { return defaultVal ; } short sval ; try { sval = java . lang . Short . valueOf ( val ) . shortValue ( ) ; } catch ( java . lang . NumberFormatException nex ) { com . openhtmltopdf . util . XRLog . exception ( ( ( ( ( ( \"Property<sp>'\" + key ) + \"'<sp>was<sp>requested<sp>as<sp>a<sp>short,<sp>but<sp>\" ) + \"value<sp>of<sp>'\" ) + val ) + \"'<sp>is<sp>not<sp>a<sp>short.<sp>Check<sp>configuration.\" ) ) ; sval = defaultVal ; } return sval ; }", "testMethod": "testValueAsShort ( ) { java . lang . String key = \"xr.test-config-short\" ; int value = com . openhtmltopdf . util . Configuration . valueAsShort ( key , ( ( short ) ( 0 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . is ( 16 ) )", "total": "testValueAsShort ( ) { java . lang . String key = \"xr.test-config-short\" ; int value = com . openhtmltopdf . util . Configuration . valueAsShort ( key , ( ( short ) ( 0 ) ) ) ; \"<AssertPlaceHolder>\" ; } valueAsShort ( java . lang . String , short ) { java . lang . String val = com . openhtmltopdf . util . Configuration . valueFor ( key ) ; if ( val == null ) { return defaultVal ; } short sval ; try { sval = java . lang . Short . valueOf ( val ) . shortValue ( ) ; } catch ( java . lang . NumberFormatException nex ) { com . openhtmltopdf . util . XRLog . exception ( ( ( ( ( ( \"Property<sp>'\" + key ) + \"'<sp>was<sp>requested<sp>as<sp>a<sp>short,<sp>but<sp>\" ) + \"value<sp>of<sp>'\" ) + val ) + \"'<sp>is<sp>not<sp>a<sp>short.<sp>Check<sp>configuration.\" ) ) ; sval = defaultVal ; } return sval ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . is ( 16 ) )"}
{"focal": "compareTo ( com . github . games647 . lagmonitor . command . timing . Timing ) { return java . lang . Long . compare ( totalTime , other . totalTime ) ; }", "testMethod": "compareEqual ( ) { com . github . games647 . lagmonitor . util . JavaVersion lower = new com . github . games647 . lagmonitor . util . JavaVersion ( \"10-Ubuntu\" ) ; com . github . games647 . lagmonitor . util . JavaVersion higher = new com . github . games647 . lagmonitor . util . JavaVersion ( \"10\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( lower . compareTo ( higher ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "compareEqual ( ) { com . github . games647 . lagmonitor . util . JavaVersion lower = new com . github . games647 . lagmonitor . util . JavaVersion ( \"10-Ubuntu\" ) ; com . github . games647 . lagmonitor . util . JavaVersion higher = new com . github . games647 . lagmonitor . util . JavaVersion ( \"10\" ) ; \"<AssertPlaceHolder>\" ; } compareTo ( com . github . games647 . lagmonitor . command . timing . Timing ) { return java . lang . Long . compare ( totalTime , other . totalTime ) ; }", "answer": "org . junit . Assert . assertThat ( lower . compareTo ( higher ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "size ( ) { return instances . size ( ) ; }", "testMethod": "whenOnlyWhiteSpace ( ) { final java . util . List < java . lang . String > list = org . apache . isis . core . commons . lang . StringExtensions . splitOnCommas ( \"<sp>\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "whenOnlyWhiteSpace ( ) { final java . util . List < java . lang . String > list = org . apache . isis . core . commons . lang . StringExtensions . splitOnCommas ( \"<sp>\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return instances . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter ( ) { state . setInput ( \"selecx<sp>\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter ( ) { state . setInput ( \"selecx<sp>\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "isNull ( ) { return nullValue ; }", "testMethod": "writeNull ( ) { com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; com . asakusafw . runtime . value . LongOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . isNull ( ) , is ( true ) )", "total": "writeNull ( ) { com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; com . asakusafw . runtime . value . LongOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } isNull ( ) { return nullValue ; }", "answer": "org . junit . Assert . assertThat ( restored . isNull ( ) , is ( true ) )"}
{"focal": "isDirty ( ) { return false ; }", "testMethod": "changedValuesShouldBeSaved ( ) { initWidgets ( ) ; when ( widget . getSelectedValue ( ) ) . thenReturn ( org . eclipse . che . ide . ext . java . client . settings . compiler . JavaCompilerPreferencePresenterTest . VALUE_2 ) ; when ( preferencesManager . getValue ( anyString ( ) ) ) . thenReturn ( org . eclipse . che . ide . ext . java . client . settings . compiler . JavaCompilerPreferencePresenterTest . VALUE_1 ) ; presenter . go ( container ) ; verify ( mapPromise ) . then ( operationCaptor . capture ( ) ) ; operationCaptor . getValue ( ) . apply ( getAllProperties ( ) ) ; presenter . storeChanges ( ) ; verify ( preferencesManager , times ( 18 ) ) . setValue ( anyString ( ) , anyString ( ) ) ; verify ( preferencesManager , times ( 36 ) ) . getValue ( anyString ( ) ) ; when ( preferencesManager . getValue ( anyString ( ) ) ) . thenReturn ( org . eclipse . che . ide . ext . java . client . settings . compiler . JavaCompilerPreferencePresenterTest . VALUE_2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( presenter . isDirty ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "changedValuesShouldBeSaved ( ) { initWidgets ( ) ; when ( widget . getSelectedValue ( ) ) . thenReturn ( org . eclipse . che . ide . ext . java . client . settings . compiler . JavaCompilerPreferencePresenterTest . VALUE_2 ) ; when ( preferencesManager . getValue ( anyString ( ) ) ) . thenReturn ( org . eclipse . che . ide . ext . java . client . settings . compiler . JavaCompilerPreferencePresenterTest . VALUE_1 ) ; presenter . go ( container ) ; verify ( mapPromise ) . then ( operationCaptor . capture ( ) ) ; operationCaptor . getValue ( ) . apply ( getAllProperties ( ) ) ; presenter . storeChanges ( ) ; verify ( preferencesManager , times ( 18 ) ) . setValue ( anyString ( ) , anyString ( ) ) ; verify ( preferencesManager , times ( 36 ) ) . getValue ( anyString ( ) ) ; when ( preferencesManager . getValue ( anyString ( ) ) ) . thenReturn ( org . eclipse . che . ide . ext . java . client . settings . compiler . JavaCompilerPreferencePresenterTest . VALUE_2 ) ; \"<AssertPlaceHolder>\" ; } isDirty ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( presenter . isDirty ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "exists ( ) { return ( getId ( ) ) != null ; }", "testMethod": "convertANonHTMLDocument ( ) { java . io . File wrongDocument = getDocumentNamed ( org . silverpeas . core . contribution . converter . HTMLConverterIT . WRONG_DOCUMENT_NAME ) ; \"<AssertPlaceHolder>\" ; converter . convert ( wrongDocument , inFormat ( odt ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( wrongDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "convertANonHTMLDocument ( ) { java . io . File wrongDocument = getDocumentNamed ( org . silverpeas . core . contribution . converter . HTMLConverterIT . WRONG_DOCUMENT_NAME ) ; \"<AssertPlaceHolder>\" ; converter . convert ( wrongDocument , inFormat ( odt ) ) ; } exists ( ) { return ( getId ( ) ) != null ; }", "answer": "org . junit . Assert . assertThat ( wrongDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "testMethod": "longPipeExpressionWithoutProjection ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Sequence ( Sequence ( Property ( \"foo\" ) , Property ( \"bar\" ) ) , Property ( \"baz\" ) ) , Property ( \"qux\" ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo<sp>|<sp>bar<sp>|<sp>baz<sp>|<sp>qux\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "longPipeExpressionWithoutProjection ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Sequence ( Sequence ( Property ( \"foo\" ) , Property ( \"bar\" ) ) , Property ( \"baz\" ) ) , Property ( \"qux\" ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo<sp>|<sp>bar<sp>|<sp>baz<sp>|<sp>qux\" ) ; \"<AssertPlaceHolder>\" ; } compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "getMaxFieldSize ( ) { return getRoutedStatements ( ) . isEmpty ( ) ? 0 : getRoutedStatements ( ) . iterator ( ) . next ( ) . getMaxFieldSize ( ) ; }", "testMethod": "assertGetMaxFieldSizeWithoutRoutedStatements ( ) { for ( java . sql . Statement each : statements . values ( ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( each . getMaxFieldSize ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "assertGetMaxFieldSizeWithoutRoutedStatements ( ) { for ( java . sql . Statement each : statements . values ( ) ) { \"<AssertPlaceHolder>\" ; } } getMaxFieldSize ( ) { return getRoutedStatements ( ) . isEmpty ( ) ? 0 : getRoutedStatements ( ) . iterator ( ) . next ( ) . getMaxFieldSize ( ) ; }", "answer": "org . junit . Assert . assertThat ( each . getMaxFieldSize ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "asMap ( ) { final java . util . Map < java . lang . String , java . lang . String > map = com . google . common . collect . Maps . newHashMap ( ) ; for ( java . lang . String propertyName : this . asIterable ( ) ) { final java . lang . String propertyValue = this . getPropertyElseNull ( propertyName ) ; map . put ( propertyName , propertyValue ) ; } return map ; }", "testMethod": "when_string_does_not_contain_equal_signs ( ) { primer = new org . apache . isis . core . commons . configbuilder . PrimerForEnvironmentVariableISIS_OPTS ( ) { @ org . apache . isis . core . commons . configbuilder . Override java . lang . String getEnv ( final java . lang . String optEnv ) { return \"ISIS_OPTS\" . equals ( optEnv ) ? \"isis.persistor.datanucleus.impl.javax.jdo.option.ConnectionURL~foo\" : null ; } } ; primer . prime ( builder ) ; final org . apache . isis . core . commons . config . IsisConfigurationDefault configuration = builder . getConfiguration ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( configuration . asMap ( ) . size ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "when_string_does_not_contain_equal_signs ( ) { primer = new org . apache . isis . core . commons . configbuilder . PrimerForEnvironmentVariableISIS_OPTS ( ) { @ org . apache . isis . core . commons . configbuilder . Override java . lang . String getEnv ( final java . lang . String optEnv ) { return \"ISIS_OPTS\" . equals ( optEnv ) ? \"isis.persistor.datanucleus.impl.javax.jdo.option.ConnectionURL~foo\" : null ; } } ; primer . prime ( builder ) ; final org . apache . isis . core . commons . config . IsisConfigurationDefault configuration = builder . getConfiguration ( ) ; \"<AssertPlaceHolder>\" ; } asMap ( ) { final java . util . Map < java . lang . String , java . lang . String > map = com . google . common . collect . Maps . newHashMap ( ) ; for ( java . lang . String propertyName : this . asIterable ( ) ) { final java . lang . String propertyValue = this . getPropertyElseNull ( propertyName ) ; map . put ( propertyName , propertyValue ) ; } return map ; }", "answer": "org . junit . Assert . assertThat ( configuration . asMap ( ) . size ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "getNewTestCaseSourceCode ( ) { java . lang . StringBuilder buf = new java . lang . StringBuilder ( ) ; if ( ( ( targetClassMeta . packageName ) != null ) && ( ( targetClassMeta . packageName . trim ( ) . length ( ) ) > 0 ) ) { buf . append ( \"package<sp>\" ) ; buf . append ( targetClassMeta . packageName ) ; buf . append ( \";\" ) ; appender . appendLineBreak ( buf ) ; appender . appendLineBreak ( buf ) ; } for ( java . lang . String imported : targetClassMeta . importedList ) { if ( ( imported != null ) && ( ( imported . trim ( ) . length ( ) ) > 0 ) ) { buf . append ( \"package<sp>\" 0 ) ; buf . append ( imported ) ; buf . append ( \";\" ) ; appender . appendLineBreak ( buf ) ; } } if ( ( ( config . testCaseClassNameToExtend ) != null ) && ( ( config . testCaseClassNameToExtend . trim ( ) . length ( ) ) > 0 ) ) { if ( ( ( config . junitVersion ) == ( org . junithelper . core . config . JUnitVersion . version3 ) ) || ( ! ( config . testCaseClassNameToExtend . equals ( \"junit.framework.TestCase\" ) ) ) ) { buf . append ( \"package<sp>\" 0 ) ; buf . append ( config . testCaseClassNameToExtend ) ; buf . append ( \";\" ) ; appender . appendLineBreak ( buf ) ; appender . appendLineBreak ( buf ) ; } } else { appender . appendLineBreak ( buf ) ; } buf . append ( \"public<sp>class<sp>\" ) ; buf . append ( targetClassMeta . name ) ; buf . append ( \"Test<sp>\" ) ; if ( ( ( config . testCaseClassNameToExtend ) != null ) && ( ( config . testCaseClassNameToExtend . trim ( ) . length ( ) ) > 0 ) ) { if ( ( ( config . junitVersion ) == ( org . junithelper . core . config . JUnitVersion . version3 ) ) || ( ! ( config . testCaseClassNameToExtend . equals ( \"junit.framework.TestCase\" ) ) ) ) { buf . append ( \"extends<sp>\" ) ; java . lang . String [ ] splittedArray = config . testCaseClassNameToExtend . split ( \"\\\\.\" ) ; buf . append ( splittedArray [ ( ( splittedArray . length ) - 1 ) ] ) ; buf . append ( \"<sp>\" ) ; } } buf . append ( \"{\" ) ; appender . appendLineBreak ( buf ) ; appender . appendLineBreak ( buf ) ; buf . append ( \"}\" ) ; appender . appendLineBreak ( buf ) ; return getTestCaseSourceCodeWithLackingTestMethod ( buf . toString ( ) ) ; }", "testMethod": "getNewTestCaseSourceCode_A$_testCaseClassNameToExtendIsEmpty ( ) { java . lang . String sourceCodeString = \"package<sp>com.example;<sp>public<sp>class<sp>Sample<sp>{}\" ; org . junithelper . core . meta . ClassMeta targetClassMeta = classMetaExtractor . extract ( sourceCodeString ) ; target . initialize ( targetClassMeta ) ; config . testCaseClassNameToExtend = \"\" ; java . lang . String actual = target . getNewTestCaseSourceCode ( ) ; java . lang . String expected = \"package<sp>com.example;\\r\\n\\r\\nimport<sp>com.example.Sample.*;\\r\\nimport<sp>static<sp>org.hamcrest.CoreMatchers.*;\\r\\nimport<sp>static<sp>org.junit.Assert.*;\\r\\nimport<sp>org.junit.Test;\\r\\n\\r\\n\\r\\npublic<sp>class<sp>SampleTest<sp>{\\r\\n\\r\\n\\t@Test\\r\\n\\tpublic<sp>void<sp>type()<sp>throws<sp>Exception<sp>{\\r\\n\\t\\t//<sp>TODO<sp>auto-generated<sp>by<sp>JUnit<sp>Helper.\\r\\n\\t\\tassertThat(Sample.class,<sp>notNullValue());\\r\\n\\t}\\r\\n\\r\\n\\t@Test\\r\\n\\tpublic<sp>void<sp>instantiation()<sp>throws<sp>Exception<sp>{\\r\\n\\t\\t//<sp>TODO<sp>auto-generated<sp>by<sp>JUnit<sp>Helper.\\r\\n\\t\\tSample<sp>target<sp>=<sp>new<sp>Sample();\\r\\n\\t\\tassertThat(target,<sp>notNullValue());\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "getNewTestCaseSourceCode_A$_testCaseClassNameToExtendIsEmpty ( ) { java . lang . String sourceCodeString = \"package<sp>com.example;<sp>public<sp>class<sp>Sample<sp>{}\" ; org . junithelper . core . meta . ClassMeta targetClassMeta = classMetaExtractor . extract ( sourceCodeString ) ; target . initialize ( targetClassMeta ) ; config . testCaseClassNameToExtend = \"\" ; java . lang . String actual = target . getNewTestCaseSourceCode ( ) ; java . lang . String expected = \"package<sp>com.example;\\r\\n\\r\\nimport<sp>com.example.Sample.*;\\r\\nimport<sp>static<sp>org.hamcrest.CoreMatchers.*;\\r\\nimport<sp>static<sp>org.junit.Assert.*;\\r\\nimport<sp>org.junit.Test;\\r\\n\\r\\n\\r\\npublic<sp>class<sp>SampleTest<sp>{\\r\\n\\r\\n\\t@Test\\r\\n\\tpublic<sp>void<sp>type()<sp>throws<sp>Exception<sp>{\\r\\n\\t\\t//<sp>TODO<sp>auto-generated<sp>by<sp>JUnit<sp>Helper.\\r\\n\\t\\tassertThat(Sample.class,<sp>notNullValue());\\r\\n\\t}\\r\\n\\r\\n\\t@Test\\r\\n\\tpublic<sp>void<sp>instantiation()<sp>throws<sp>Exception<sp>{\\r\\n\\t\\t//<sp>TODO<sp>auto-generated<sp>by<sp>JUnit<sp>Helper.\\r\\n\\t\\tSample<sp>target<sp>=<sp>new<sp>Sample();\\r\\n\\t\\tassertThat(target,<sp>notNullValue());\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\" ; \"<AssertPlaceHolder>\" ; } getNewTestCaseSourceCode ( ) { java . lang . StringBuilder buf = new java . lang . StringBuilder ( ) ; if ( ( ( targetClassMeta . packageName ) != null ) && ( ( targetClassMeta . packageName . trim ( ) . length ( ) ) > 0 ) ) { buf . append ( \"package<sp>\" ) ; buf . append ( targetClassMeta . packageName ) ; buf . append ( \";\" ) ; appender . appendLineBreak ( buf ) ; appender . appendLineBreak ( buf ) ; } for ( java . lang . String imported : targetClassMeta . importedList ) { if ( ( imported != null ) && ( ( imported . trim ( ) . length ( ) ) > 0 ) ) { buf . append ( \"package<sp>\" 0 ) ; buf . append ( imported ) ; buf . append ( \";\" ) ; appender . appendLineBreak ( buf ) ; } } if ( ( ( config . testCaseClassNameToExtend ) != null ) && ( ( config . testCaseClassNameToExtend . trim ( ) . length ( ) ) > 0 ) ) { if ( ( ( config . junitVersion ) == ( org . junithelper . core . config . JUnitVersion . version3 ) ) || ( ! ( config . testCaseClassNameToExtend . equals ( \"junit.framework.TestCase\" ) ) ) ) { buf . append ( \"package<sp>\" 0 ) ; buf . append ( config . testCaseClassNameToExtend ) ; buf . append ( \";\" ) ; appender . appendLineBreak ( buf ) ; appender . appendLineBreak ( buf ) ; } } else { appender . appendLineBreak ( buf ) ; } buf . append ( \"public<sp>class<sp>\" ) ; buf . append ( targetClassMeta . name ) ; buf . append ( \"Test<sp>\" ) ; if ( ( ( config . testCaseClassNameToExtend ) != null ) && ( ( config . testCaseClassNameToExtend . trim ( ) . length ( ) ) > 0 ) ) { if ( ( ( config . junitVersion ) == ( org . junithelper . core . config . JUnitVersion . version3 ) ) || ( ! ( config . testCaseClassNameToExtend . equals ( \"junit.framework.TestCase\" ) ) ) ) { buf . append ( \"extends<sp>\" ) ; java . lang . String [ ] splittedArray = config . testCaseClassNameToExtend . split ( \"\\\\.\" ) ; buf . append ( splittedArray [ ( ( splittedArray . length ) - 1 ) ] ) ; buf . append ( \"<sp>\" ) ; } } buf . append ( \"{\" ) ; appender . appendLineBreak ( buf ) ; appender . appendLineBreak ( buf ) ; buf . append ( \"}\" ) ; appender . appendLineBreak ( buf ) ; return getTestCaseSourceCodeWithLackingTestMethod ( buf . toString ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "getEdgeActions ( java . lang . String ) { return edgeActions . get ( nodeId ) ; }", "testMethod": "testPutEdgeActions ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port1\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port2\" ; } } ) ; } } ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeActions = new java . util . HashMap < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > ( ) ; edgeActions . put ( \"node1\" , actions ) ; target . putEdgeActions ( edgeActions ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getEdgeActions ( \"node1\" ) , org . hamcrest . CoreMatchers . is ( actions ) )", "total": "testPutEdgeActions ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port1\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port2\" ; } } ) ; } } ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeActions = new java . util . HashMap < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > ( ) ; edgeActions . put ( \"node1\" , actions ) ; target . putEdgeActions ( edgeActions ) ; \"<AssertPlaceHolder>\" ; } getEdgeActions ( java . lang . String ) { return edgeActions . get ( nodeId ) ; }", "answer": "org . junit . Assert . assertThat ( target . getEdgeActions ( \"node1\" ) , org . hamcrest . CoreMatchers . is ( actions ) )"}
{"focal": "getParent ( ) { return parent ; }", "testMethod": "shouldGetCorrectParentPathElement3 ( ) { final org . openspotlight . federation . domain . artifact . PathElement pathElement = org . openspotlight . federation . domain . artifact . PathElement . createFromPathString ( \"a/b/c/d/e/\" ) ; final org . openspotlight . federation . domain . artifact . PathElement parentPathElement = org . openspotlight . federation . domain . artifact . PathElement . createFromPathString ( \"a/b/c/d\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pathElement . getParent ( ) , org . hamcrest . core . Is . is ( parentPathElement ) )", "total": "shouldGetCorrectParentPathElement3 ( ) { final org . openspotlight . federation . domain . artifact . PathElement pathElement = org . openspotlight . federation . domain . artifact . PathElement . createFromPathString ( \"a/b/c/d/e/\" ) ; final org . openspotlight . federation . domain . artifact . PathElement parentPathElement = org . openspotlight . federation . domain . artifact . PathElement . createFromPathString ( \"a/b/c/d\" ) ; \"<AssertPlaceHolder>\" ; } getParent ( ) { return parent ; }", "answer": "org . junit . Assert . assertThat ( pathElement . getParent ( ) , org . hamcrest . core . Is . is ( parentPathElement ) )"}
{"focal": "asQueryResultEntityIterable ( ) { ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . AbstQueryTest . MyQuery query = new org . slim3 . datastore . AbstQueryTest . MyQuery ( ds , \"Hoge\" ) ; com . google . appengine . api . datastore . QueryResultIterable < com . google . appengine . api . datastore . Entity > iterable = query . limit ( 1 ) . asQueryResultEntityIterable ( ) ; org . junit . Assert . assertThat ( iterable , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "testMethod": "asQueryResultEntityIterable ( ) { ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . AbstQueryTest . MyQuery query = new org . slim3 . datastore . AbstQueryTest . MyQuery ( ds , \"Hoge\" ) ; com . google . appengine . api . datastore . QueryResultIterable < com . google . appengine . api . datastore . Entity > iterable = query . limit ( 1 ) . asQueryResultEntityIterable ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( iterable , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) )", "total": "asQueryResultEntityIterable ( ) { ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . AbstQueryTest . MyQuery query = new org . slim3 . datastore . AbstQueryTest . MyQuery ( ds , \"Hoge\" ) ; com . google . appengine . api . datastore . QueryResultIterable < com . google . appengine . api . datastore . Entity > iterable = query . limit ( 1 ) . asQueryResultEntityIterable ( ) ; \"<AssertPlaceHolder>\" ; } asQueryResultEntityIterable ( ) { ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; ds . put ( new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . AbstQueryTest . MyQuery query = new org . slim3 . datastore . AbstQueryTest . MyQuery ( ds , \"Hoge\" ) ; com . google . appengine . api . datastore . QueryResultIterable < com . google . appengine . api . datastore . Entity > iterable = query . limit ( 1 ) . asQueryResultEntityIterable ( ) ; org . junit . Assert . assertThat ( iterable , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( iterable , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) )"}
{"focal": "property ( com . asakusafw . directio . hive . serde . PropertyDescriptor ) { this . properties . add ( descriptor ) ; return this ; }", "testMethod": "system ( ) { java . lang . String version = java . lang . System . getProperty ( \"java.version\" ) ; org . junit . Assume . assumeNotNull ( version ) ; com . asakusafw . utils . gradle . BasicProject project = project ( ) . with ( com . asakusafw . utils . gradle . PropertyConfigurator . system ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( project . property ( \"java.version\" ) , is ( version ) )", "total": "system ( ) { java . lang . String version = java . lang . System . getProperty ( \"java.version\" ) ; org . junit . Assume . assumeNotNull ( version ) ; com . asakusafw . utils . gradle . BasicProject project = project ( ) . with ( com . asakusafw . utils . gradle . PropertyConfigurator . system ( ) ) ; \"<AssertPlaceHolder>\" ; } property ( com . asakusafw . directio . hive . serde . PropertyDescriptor ) { this . properties . add ( descriptor ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( project . property ( \"java.version\" ) , is ( version ) )"}
{"focal": "size ( ) { return instances . size ( ) ; }", "testMethod": "whenEmpty ( ) { final java . util . List < java . lang . String > list = org . apache . isis . core . commons . lang . StringExtensions . splitOnCommas ( \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "whenEmpty ( ) { final java . util . List < java . lang . String > list = org . apache . isis . core . commons . lang . StringExtensions . splitOnCommas ( \"\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return instances . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "sliding_A$int_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( ) ; java . lang . Integer size = 3 ; com . m3 . scalaflavor4j . Seq < com . m3 . scalaflavor4j . Seq < java . lang . Integer > > actual = seq . sliding ( size ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "sliding_A$int_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( ) ; java . lang . Integer size = 3 ; com . m3 . scalaflavor4j . Seq < com . m3 . scalaflavor4j . Seq < java . lang . Integer > > actual = seq . sliding ( size ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( actual . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "getHeaders ( ) { return headers ; }", "testMethod": "mapResponse_withHeader ( ) { response . getHeaders ( ) . addHeader ( \"h\" , \"v\" ) ; @ org . apache . servicecomb . swagger . invocation . springmvc . response . SuppressWarnings ( \"unchecked\" ) org . springframework . http . ResponseEntity < java . lang . Integer > responseEntity = ( ( org . springframework . http . ResponseEntity < java . lang . Integer > ) ( mapper . mapResponse ( response ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( responseEntity . getHeaders ( ) . get ( \"h\" ) , org . hamcrest . Matchers . contains ( \"v\" ) )", "total": "mapResponse_withHeader ( ) { response . getHeaders ( ) . addHeader ( \"h\" , \"v\" ) ; @ org . apache . servicecomb . swagger . invocation . springmvc . response . SuppressWarnings ( \"unchecked\" ) org . springframework . http . ResponseEntity < java . lang . Integer > responseEntity = ( ( org . springframework . http . ResponseEntity < java . lang . Integer > ) ( mapper . mapResponse ( response ) ) ) ; \"<AssertPlaceHolder>\" ; } getHeaders ( ) { return headers ; }", "answer": "org . junit . Assert . assertThat ( responseEntity . getHeaders ( ) . get ( \"h\" ) , org . hamcrest . Matchers . contains ( \"v\" ) )"}
{"focal": "isReturningReferencedObjects ( ) { return ! ( ( ( ( ( queryParser . hasOption ( QueryFlag . NO_REFERENCED ) ) || ( isShortHand ( ) ) ) || ( isKeysOnly ( ) ) ) || ( isResource ( ) ) ) || ( isBriefAbuseContact ( ) ) ) ; }", "testMethod": "brief_not_showing_referenced_objects ( ) { final net . ripe . db . whois . query . query . Query query = net . ripe . db . whois . query . query . Query . parse ( \"-b<sp>10.0.0.0\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . isReturningReferencedObjects ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "brief_not_showing_referenced_objects ( ) { final net . ripe . db . whois . query . query . Query query = net . ripe . db . whois . query . query . Query . parse ( \"-b<sp>10.0.0.0\" ) ; \"<AssertPlaceHolder>\" ; } isReturningReferencedObjects ( ) { return ! ( ( ( ( ( queryParser . hasOption ( QueryFlag . NO_REFERENCED ) ) || ( isShortHand ( ) ) ) || ( isKeysOnly ( ) ) ) || ( isResource ( ) ) ) || ( isBriefAbuseContact ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( query . isReturningReferencedObjects ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "build ( java . util . function . Function [ ] ) { java . lang . reflect . Method builderMethod ; try { builderMethod = destinedClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILDER_METHOD_NAME ) ; } catch ( java . lang . NoSuchMethodException e ) { throw new java . lang . RuntimeException ( e ) ; } java . lang . Object source ; try { source = builderMethod . invoke ( null ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } for ( Map . Entry < java . lang . String , java . lang . Object > setValue : values . entrySet ( ) ) { java . lang . Object argument = getArgument ( setValue ) ; java . lang . reflect . Method mutator = properties . get ( setValue . getKey ( ) ) . stream ( ) . filter ( ( t ) -> org . apache . commons . lang3 . ClassUtils . isAssignable ( argument . getClass ( ) , t . type ) ) . findFirst ( ) . map ( ( a ) -> a . builderMethod ) . orElseThrow ( ( ) -> new java . lang . IllegalStateException ( java . lang . String . format ( \"Unable<sp>to<sp>find<sp>mutator<sp>for<sp>%s<sp>of<sp>type<sp>%s\" , setValue . getKey ( ) , argument . getClass ( ) . getName ( ) ) ) ) ; try { source = mutator . invoke ( source , argument ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } } if ( additionalMutators != null ) { for ( java . util . function . Function < java . lang . Object , java . lang . Object > mutator : additionalMutators ) { source = mutator . apply ( source ) ; } } java . lang . reflect . Method buildMethod ; try { buildMethod = builderClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILD_METHOD_NAME ) ; return buildMethod . invoke ( source ) ; } catch ( java . lang . IllegalAccessException | java . lang . NoSuchMethodException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "testMethod": "testEmptyPropertyHandler ( ) { java . lang . String emptyPropertyValue = \"test-property\" ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate expected = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate . create ( emptyPropertyValue , ( ( long ) ( emptyPropertyValue . length ( ) ) ) , ( emptyPropertyValue + \"-vary\" ) ) ; software . amazon . kinesis . multilang . config . BuilderDynaBean builderDynaBean = new software . amazon . kinesis . multilang . config . BuilderDynaBean ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class , convertUtilsBean , ( s ) -> software . amazon . kinesis . multilang . config . TestVariantCreate . create ( s , ( ( long ) ( s . length ( ) ) ) , ( s + \"-vary\" ) ) ) ; utilsBean . setProperty ( builderDynaBean , \"\" , emptyPropertyValue ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface actual = builderDynaBean . build ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "testEmptyPropertyHandler ( ) { java . lang . String emptyPropertyValue = \"test-property\" ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate expected = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate . create ( emptyPropertyValue , ( ( long ) ( emptyPropertyValue . length ( ) ) ) , ( emptyPropertyValue + \"-vary\" ) ) ; software . amazon . kinesis . multilang . config . BuilderDynaBean builderDynaBean = new software . amazon . kinesis . multilang . config . BuilderDynaBean ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class , convertUtilsBean , ( s ) -> software . amazon . kinesis . multilang . config . TestVariantCreate . create ( s , ( ( long ) ( s . length ( ) ) ) , ( s + \"-vary\" ) ) ) ; utilsBean . setProperty ( builderDynaBean , \"\" , emptyPropertyValue ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface actual = builderDynaBean . build ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class ) ; \"<AssertPlaceHolder>\" ; } build ( java . util . function . Function [ ] ) { java . lang . reflect . Method builderMethod ; try { builderMethod = destinedClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILDER_METHOD_NAME ) ; } catch ( java . lang . NoSuchMethodException e ) { throw new java . lang . RuntimeException ( e ) ; } java . lang . Object source ; try { source = builderMethod . invoke ( null ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } for ( Map . Entry < java . lang . String , java . lang . Object > setValue : values . entrySet ( ) ) { java . lang . Object argument = getArgument ( setValue ) ; java . lang . reflect . Method mutator = properties . get ( setValue . getKey ( ) ) . stream ( ) . filter ( ( t ) -> org . apache . commons . lang3 . ClassUtils . isAssignable ( argument . getClass ( ) , t . type ) ) . findFirst ( ) . map ( ( a ) -> a . builderMethod ) . orElseThrow ( ( ) -> new java . lang . IllegalStateException ( java . lang . String . format ( \"Unable<sp>to<sp>find<sp>mutator<sp>for<sp>%s<sp>of<sp>type<sp>%s\" , setValue . getKey ( ) , argument . getClass ( ) . getName ( ) ) ) ) ; try { source = mutator . invoke ( source , argument ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } } if ( additionalMutators != null ) { for ( java . util . function . Function < java . lang . Object , java . lang . Object > mutator : additionalMutators ) { source = mutator . apply ( source ) ; } } java . lang . reflect . Method buildMethod ; try { buildMethod = builderClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILD_METHOD_NAME ) ; return buildMethod . invoke ( source ) ; } catch ( java . lang . IllegalAccessException | java . lang . NoSuchMethodException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "fetchCount ( ) { return ( statistics . getEntityFetchCount ( ) ) - ( fetches ) ; }", "testMethod": "artistCreditNameReferenceDoesNotHitDatabase ( ) { fm . last . musicbrainz . data . model . ArtistCredit artistCredit = ( ( fm . last . musicbrainz . data . model . ArtistCredit ) ( session . load ( fm . last . musicbrainz . data . model . ArtistCredit . class , 1 ) ) ) ; java . util . List < fm . last . musicbrainz . data . model . ArtistCreditName > artistCreditNames = artistCredit . getArtistCreditNames ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fetchCount ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "artistCreditNameReferenceDoesNotHitDatabase ( ) { fm . last . musicbrainz . data . model . ArtistCredit artistCredit = ( ( fm . last . musicbrainz . data . model . ArtistCredit ) ( session . load ( fm . last . musicbrainz . data . model . ArtistCredit . class , 1 ) ) ) ; java . util . List < fm . last . musicbrainz . data . model . ArtistCreditName > artistCreditNames = artistCredit . getArtistCreditNames ( ) ; \"<AssertPlaceHolder>\" ; } fetchCount ( ) { return ( statistics . getEntityFetchCount ( ) ) - ( fetches ) ; }", "answer": "org . junit . Assert . assertThat ( fetchCount ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "unmarshal ( java . lang . String ) { return org . oscm . billingservice . business . org . oscm . billingservice . business . BigDecimalJaxbCustomBinder . parseBigDecimal ( value ) ; }", "testMethod": "marshalAndUnmarshal_withZeros ( ) { java . math . BigDecimal givenValue = new java . math . BigDecimal ( \"5.00\" ) ; java . lang . String valueAsStr = adapter . marshal ( givenValue ) ; java . math . BigDecimal convertedValue = adapter . unmarshal ( valueAsStr ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( givenValue , org . hamcrest . CoreMatchers . is ( convertedValue ) )", "total": "marshalAndUnmarshal_withZeros ( ) { java . math . BigDecimal givenValue = new java . math . BigDecimal ( \"5.00\" ) ; java . lang . String valueAsStr = adapter . marshal ( givenValue ) ; java . math . BigDecimal convertedValue = adapter . unmarshal ( valueAsStr ) ; \"<AssertPlaceHolder>\" ; } unmarshal ( java . lang . String ) { return org . oscm . billingservice . business . org . oscm . billingservice . business . BigDecimalJaxbCustomBinder . parseBigDecimal ( value ) ; }", "answer": "org . junit . Assert . assertThat ( givenValue , org . hamcrest . CoreMatchers . is ( convertedValue ) )"}
{"focal": "string ( java . lang . Object ) { return session . context ( ) . getValueFactories ( ) . getStringFactory ( ) . create ( object ) ; }", "testMethod": "shouldReturnFalseFromCanAddNodeIfUsingProxyNodeTypeAsPrimaryType ( ) { boolean can = ( ( org . modeshape . jcr . AbstractJcrNode ) ( session . getRootNode ( ) ) ) . canAddNode ( \"ShouldNotBePossible\" , string ( ModeShapeLexicon . SHARE ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( can , org . hamcrest . core . Is . is ( false ) )", "total": "shouldReturnFalseFromCanAddNodeIfUsingProxyNodeTypeAsPrimaryType ( ) { boolean can = ( ( org . modeshape . jcr . AbstractJcrNode ) ( session . getRootNode ( ) ) ) . canAddNode ( \"ShouldNotBePossible\" , string ( ModeShapeLexicon . SHARE ) ) ; \"<AssertPlaceHolder>\" ; } string ( java . lang . Object ) { return session . context ( ) . getValueFactories ( ) . getStringFactory ( ) . create ( object ) ; }", "answer": "org . junit . Assert . assertThat ( can , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "testMethod": "testMethodWithDollarSignInName ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"org.apache.flink.streaming.api.scala.DataStream#iterate$default$3[R]()\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"org.apache.flink.streaming.api.scala.DataStream\" ) . addToClassPool ( classPool ) ; javassist . CtMethod ctMethod = japicmp . util . CtMethodBuilder . create ( ) . name ( \"iterate$default$3[R]\" ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filter . matches ( ctMethod ) , org . hamcrest . core . Is . is ( true ) )", "total": "testMethodWithDollarSignInName ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"org.apache.flink.streaming.api.scala.DataStream#iterate$default$3[R]()\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"org.apache.flink.streaming.api.scala.DataStream\" ) . addToClassPool ( classPool ) ; javassist . CtMethod ctMethod = japicmp . util . CtMethodBuilder . create ( ) . name ( \"iterate$default$3[R]\" ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; } matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "answer": "org . junit . Assert . assertThat ( filter . matches ( ctMethod ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "build ( ) { return new com . google . errorprone . ErrorProneTestCompiler ( listener , scannerSupplier , printWriter ) ; }", "testMethod": "shouldReturnNullOnImportOnlyFix ( ) { com . google . errorprone . fixes . AppliedFix fix = com . google . errorprone . fixes . AppliedFix . fromSource ( \"public<sp>class<sp>Foo<sp>{}\" , endPositions ) . apply ( com . google . errorprone . fixes . SuggestedFix . builder ( ) . addImport ( \"foo.bar.Baz\" ) . build ( ) ) ; \"<AssertPlaceHolder>\" . isNull ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( fix )", "total": "shouldReturnNullOnImportOnlyFix ( ) { com . google . errorprone . fixes . AppliedFix fix = com . google . errorprone . fixes . AppliedFix . fromSource ( \"public<sp>class<sp>Foo<sp>{}\" , endPositions ) . apply ( com . google . errorprone . fixes . SuggestedFix . builder ( ) . addImport ( \"foo.bar.Baz\" ) . build ( ) ) ; \"<AssertPlaceHolder>\" . isNull ( ) ; } build ( ) { return new com . google . errorprone . ErrorProneTestCompiler ( listener , scannerSupplier , printWriter ) ; }", "answer": "org . junit . Assert . assertThat ( fix )"}
{"focal": "equals ( java . lang . Object ) { if ( ( this ) == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ( com . hotels . bdp . circustrain . comparator . api . BaseDiff . getClass ( ) ) != ( obj . getClass ( ) ) ) { return false ; } com . hotels . bdp . circustrain . comparator . api . BaseDiff < ? , ? > other = ( ( com . hotels . bdp . circustrain . comparator . api . BaseDiff < ? , ? > ) ( obj ) ) ; return ( ( com . google . common . base . Objects . equal ( message , other . message ) ) && ( com . google . common . base . Objects . equal ( left , other . left ) ) ) && ( com . google . common . base . Objects . equal ( right , other . right ) ) ; }", "testMethod": "checkDifferent ( ) { java . lang . String id1 = EventIdFactory . DEFAULT . newEventId ( \"X\" ) ; java . lang . String id2 = EventIdFactory . DEFAULT . newEventId ( \"X\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( id1 . equals ( id2 ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "checkDifferent ( ) { java . lang . String id1 = EventIdFactory . DEFAULT . newEventId ( \"X\" ) ; java . lang . String id2 = EventIdFactory . DEFAULT . newEventId ( \"X\" ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( ( this ) == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ( com . hotels . bdp . circustrain . comparator . api . BaseDiff . getClass ( ) ) != ( obj . getClass ( ) ) ) { return false ; } com . hotels . bdp . circustrain . comparator . api . BaseDiff < ? , ? > other = ( ( com . hotels . bdp . circustrain . comparator . api . BaseDiff < ? , ? > ) ( obj ) ) ; return ( ( com . google . common . base . Objects . equal ( message , other . message ) ) && ( com . google . common . base . Objects . equal ( left , other . left ) ) ) && ( com . google . common . base . Objects . equal ( right , other . right ) ) ; }", "answer": "org . junit . Assert . assertThat ( id1 . equals ( id2 ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "concat ( java . security . cert . X509Certificate , java . security . cert . X509Certificate [ ] ) { return com . google . common . collect . Iterables . concat ( java . util . Collections . singleton ( certificate ) , java . util . Arrays . asList ( existingChain ) ) ; }", "testMethod": "shouldConcatDenyAllNoneAsDenyAll ( ) { org . dcache . auth . attributes . Restriction denyAll = org . dcache . auth . attributes . Restrictions . denyAll ( ) ; org . dcache . auth . attributes . Restriction none = org . dcache . auth . attributes . Restrictions . none ( ) ; org . dcache . auth . attributes . Restriction concat = org . dcache . auth . attributes . Restrictions . concat ( denyAll , none ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( concat , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( denyAll ) ) )", "total": "shouldConcatDenyAllNoneAsDenyAll ( ) { org . dcache . auth . attributes . Restriction denyAll = org . dcache . auth . attributes . Restrictions . denyAll ( ) ; org . dcache . auth . attributes . Restriction none = org . dcache . auth . attributes . Restrictions . none ( ) ; org . dcache . auth . attributes . Restriction concat = org . dcache . auth . attributes . Restrictions . concat ( denyAll , none ) ; \"<AssertPlaceHolder>\" ; } concat ( java . security . cert . X509Certificate , java . security . cert . X509Certificate [ ] ) { return com . google . common . collect . Iterables . concat ( java . util . Collections . singleton ( certificate ) , java . util . Arrays . asList ( existingChain ) ) ; }", "answer": "org . junit . Assert . assertThat ( concat , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( denyAll ) ) )"}
{"focal": "get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "testMethod": "writeFalse ( ) { com . asakusafw . runtime . value . BooleanOption option = new com . asakusafw . runtime . value . BooleanOption ( ) ; option . modify ( true ) ; com . asakusafw . runtime . value . BooleanOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )", "total": "writeFalse ( ) { com . asakusafw . runtime . value . BooleanOption option = new com . asakusafw . runtime . value . BooleanOption ( ) ; option . modify ( true ) ; com . asakusafw . runtime . value . BooleanOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "answer": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )"}
{"focal": "intersect ( net . time4j . range . IntervalCollection ) { if ( ( this . isEmpty ( ) ) || ( other . isEmpty ( ) ) ) { java . util . List < net . time4j . range . ChronoInterval < T > > zero = java . util . Collections . emptyList ( ) ; return this . create ( zero ) ; } java . util . List < net . time4j . range . ChronoInterval < T > > list = new java . util . ArrayList ( ) ; for ( net . time4j . range . ChronoInterval < T > a : this . intervals ) { for ( net . time4j . range . ChronoInterval < T > b : other . intervals ) { java . util . List < net . time4j . range . ChronoInterval < T > > candidates = new java . util . ArrayList ( 2 ) ; candidates . add ( a ) ; candidates . add ( b ) ; candidates . sort ( this . getComparator ( ) ) ; candidates = this . intersect ( candidates ) ; if ( ! ( candidates . isEmpty ( ) ) ) { list . addAll ( candidates ) ; } } } list . sort ( this . getComparator ( ) ) ; return this . create ( list ) . withBlocks ( ) ; }", "testMethod": "intersect ( ) { net . time4j . range . DateInterval i1 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 2 , 28 ) , net . time4j . PlainDate . of ( 2014 , 5 , 31 ) ) ; net . time4j . range . DateInterval i2 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 3 , 1 ) , net . time4j . PlainDate . of ( 2014 , 3 , 31 ) ) ; net . time4j . range . DateInterval i3 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 4 , 15 ) , net . time4j . PlainDate . of ( 2014 , 6 , 1 ) ) ; net . time4j . range . DateInterval intersection2 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 4 , 15 ) , net . time4j . PlainDate . of ( 2014 , 5 , 31 ) ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > a = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( i1 ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > b = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( i2 ) . plus ( i3 ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > c = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( i2 ) . plus ( intersection2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( a . intersect ( b ) , org . hamcrest . CoreMatchers . is ( c ) )", "total": "intersect ( ) { net . time4j . range . DateInterval i1 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 2 , 28 ) , net . time4j . PlainDate . of ( 2014 , 5 , 31 ) ) ; net . time4j . range . DateInterval i2 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 3 , 1 ) , net . time4j . PlainDate . of ( 2014 , 3 , 31 ) ) ; net . time4j . range . DateInterval i3 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 4 , 15 ) , net . time4j . PlainDate . of ( 2014 , 6 , 1 ) ) ; net . time4j . range . DateInterval intersection2 = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2014 , 4 , 15 ) , net . time4j . PlainDate . of ( 2014 , 5 , 31 ) ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > a = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( i1 ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > b = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( i2 ) . plus ( i3 ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > c = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( i2 ) . plus ( intersection2 ) ; \"<AssertPlaceHolder>\" ; } intersect ( net . time4j . range . IntervalCollection ) { if ( ( this . isEmpty ( ) ) || ( other . isEmpty ( ) ) ) { java . util . List < net . time4j . range . ChronoInterval < T > > zero = java . util . Collections . emptyList ( ) ; return this . create ( zero ) ; } java . util . List < net . time4j . range . ChronoInterval < T > > list = new java . util . ArrayList ( ) ; for ( net . time4j . range . ChronoInterval < T > a : this . intervals ) { for ( net . time4j . range . ChronoInterval < T > b : other . intervals ) { java . util . List < net . time4j . range . ChronoInterval < T > > candidates = new java . util . ArrayList ( 2 ) ; candidates . add ( a ) ; candidates . add ( b ) ; candidates . sort ( this . getComparator ( ) ) ; candidates = this . intersect ( candidates ) ; if ( ! ( candidates . isEmpty ( ) ) ) { list . addAll ( candidates ) ; } } } list . sort ( this . getComparator ( ) ) ; return this . create ( list ) . withBlocks ( ) ; }", "answer": "org . junit . Assert . assertThat ( a . intersect ( b ) , org . hamcrest . CoreMatchers . is ( c ) )"}
{"focal": "locations ( ) { org . junit . Assert . assertThat ( facebook . locations ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . LocationMethods . class ) ) ; }", "testMethod": "locations ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( facebook . locations ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . LocationMethods . class ) )", "total": "locations ( ) { \"<AssertPlaceHolder>\" ; } locations ( ) { org . junit . Assert . assertThat ( facebook . locations ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . LocationMethods . class ) ) ; }", "answer": "org . junit . Assert . assertThat ( facebook . locations ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . LocationMethods . class ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "getAComponentSettingsInPlaceOfLocalizedBundle ( ) { try { java . lang . String settingsURI = \"bundles/com/silverpeas/bundle/web/componentSettings\" ; getAt ( settingsURI , MediaType . TEXT_PLAIN_TYPE , getWebEntityClass ( ) ) ; org . junit . Assert . fail ( \"A<sp>user<sp>shouldn't<sp>get<sp>a<sp>bundle<sp>with<sp>component<sp>settings\" ) ; } catch ( com . sun . jersey . api . client . UniformInterfaceException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int forbidden = Response . Status . BAD_REQUEST . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( forbidden ) )", "total": "getAComponentSettingsInPlaceOfLocalizedBundle ( ) { try { java . lang . String settingsURI = \"bundles/com/silverpeas/bundle/web/componentSettings\" ; getAt ( settingsURI , MediaType . TEXT_PLAIN_TYPE , getWebEntityClass ( ) ) ; org . junit . Assert . fail ( \"A<sp>user<sp>shouldn't<sp>get<sp>a<sp>bundle<sp>with<sp>component<sp>settings\" ) ; } catch ( com . sun . jersey . api . client . UniformInterfaceException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int forbidden = Response . Status . BAD_REQUEST . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( forbidden ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectOtherInstance ( ) { org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput action = new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( action ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsObjectOtherInstance ( ) { org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput action = new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( action ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "testMethod": "shouldCloseRegisteredExecutorService ( ) { final java . util . concurrent . ExecutorService registeredExecutorService = com . spotify . styx . util . CloserUtil . register ( closer , executorService , \"foobar\" ) ; \"<AssertPlaceHolder>\" ; when ( executorService . shutdownNow ( ) ) . thenReturn ( java . util . List . of ( runnable ) ) ; closer . close ( ) ; com . spotify . styx . util . CloserUtilTest . verifyShutdown ( executorService ) ; }", "assertLine": "org . junit . Assert . assertThat ( registeredExecutorService , org . hamcrest . Matchers . is ( executorService ) )", "total": "shouldCloseRegisteredExecutorService ( ) { final java . util . concurrent . ExecutorService registeredExecutorService = com . spotify . styx . util . CloserUtil . register ( closer , executorService , \"foobar\" ) ; \"<AssertPlaceHolder>\" ; when ( executorService . shutdownNow ( ) ) . thenReturn ( java . util . List . of ( runnable ) ) ; closer . close ( ) ; com . spotify . styx . util . CloserUtilTest . verifyShutdown ( executorService ) ; } is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( registeredExecutorService , org . hamcrest . Matchers . is ( executorService ) )"}
{"focal": "getName ( ) { return this . name ; }", "testMethod": "testUncompressedAsciiCommunication ( ) { final java . util . List < kieker . common . record . IMonitoringRecord > records = kieker . test . tools . junit . writeRead . filesystem . AsciiWriterReaderTest . TEST_DATA_REPOSITORY . newTestRecords ( ) ; final java . util . List < kieker . common . record . IMonitoringRecord > analyzedRecords = this . testAsciiCommunication ( records , kieker . monitoring . writer . compression . NoneCompressionFilter . class . getName ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( analyzedRecords , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( records ) ) )", "total": "testUncompressedAsciiCommunication ( ) { final java . util . List < kieker . common . record . IMonitoringRecord > records = kieker . test . tools . junit . writeRead . filesystem . AsciiWriterReaderTest . TEST_DATA_REPOSITORY . newTestRecords ( ) ; final java . util . List < kieker . common . record . IMonitoringRecord > analyzedRecords = this . testAsciiCommunication ( records , kieker . monitoring . writer . compression . NoneCompressionFilter . class . getName ( ) ) ; \"<AssertPlaceHolder>\" ; } getName ( ) { return this . name ; }", "answer": "org . junit . Assert . assertThat ( analyzedRecords , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( records ) ) )"}
{"focal": "size ( ) { return whiteList . size ( ) ; }", "testMethod": "negativePollInterval ( ) { graphiteConfiguration . setPollInterval ( ( - 1 ) ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . waggledance . conf . GraphiteConfiguration > > violations = validator . validate ( graphiteConfiguration ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "negativePollInterval ( ) { graphiteConfiguration . setPollInterval ( ( - 1 ) ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . waggledance . conf . GraphiteConfiguration > > violations = validator . validate ( graphiteConfiguration ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return whiteList . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getGroup ( ) { final org . bonitasoft . engine . identity . Group group = getIdentityAPI ( ) . getGroup ( defaultGroup . getId ( ) ) ; org . junit . Assert . assertNotNull ( group ) ; org . junit . Assert . assertEquals ( \"test\" , group . getName ( ) ) ; org . junit . Assert . assertEquals ( \"label\" , group . getDisplayName ( ) ) ; org . junit . Assert . assertEquals ( \"description\" , group . getDescription ( ) ) ; }", "testMethod": "schedule_should_use_tenant_id_as_group_in_job_details ( ) { final java . lang . String tenantId = \"3\" ; final org . bonitasoft . engine . scheduler . trigger . Trigger trigger = new org . bonitasoft . engine . scheduler . impl . QuartzSchedulerExecutorTest . TestRepeatTrigger ( \"trigger\" , 1 , 1 , org . bonitasoft . engine . scheduler . trigger . Trigger . MisfireRestartPolicy . NONE ) ; quartzSchedulerExecutor . schedule ( 10L , tenantId , \"myJob\" , trigger , true ) ; final org . mockito . ArgumentCaptor < org . quartz . JobDetail > jobDetailCaptor = org . mockito . ArgumentCaptor . forClass ( org . quartz . JobDetail . class ) ; verify ( scheduler , times ( 1 ) ) . scheduleJob ( jobDetailCaptor . capture ( ) , any ( org . bonitasoft . engine . scheduler . trigger . Trigger . class ) ) ; final java . lang . String group = jobDetailCaptor . getValue ( ) . getKey ( ) . getGroup ( ) ; \"<AssertPlaceHolder>\" . isEqualTo ( java . lang . String . valueOf ( tenantId ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( group )", "total": "schedule_should_use_tenant_id_as_group_in_job_details ( ) { final java . lang . String tenantId = \"3\" ; final org . bonitasoft . engine . scheduler . trigger . Trigger trigger = new org . bonitasoft . engine . scheduler . impl . QuartzSchedulerExecutorTest . TestRepeatTrigger ( \"trigger\" , 1 , 1 , org . bonitasoft . engine . scheduler . trigger . Trigger . MisfireRestartPolicy . NONE ) ; quartzSchedulerExecutor . schedule ( 10L , tenantId , \"myJob\" , trigger , true ) ; final org . mockito . ArgumentCaptor < org . quartz . JobDetail > jobDetailCaptor = org . mockito . ArgumentCaptor . forClass ( org . quartz . JobDetail . class ) ; verify ( scheduler , times ( 1 ) ) . scheduleJob ( jobDetailCaptor . capture ( ) , any ( org . bonitasoft . engine . scheduler . trigger . Trigger . class ) ) ; final java . lang . String group = jobDetailCaptor . getValue ( ) . getKey ( ) . getGroup ( ) ; \"<AssertPlaceHolder>\" . isEqualTo ( java . lang . String . valueOf ( tenantId ) ) ; } getGroup ( ) { final org . bonitasoft . engine . identity . Group group = getIdentityAPI ( ) . getGroup ( defaultGroup . getId ( ) ) ; org . junit . Assert . assertNotNull ( group ) ; org . junit . Assert . assertEquals ( \"test\" , group . getName ( ) ) ; org . junit . Assert . assertEquals ( \"label\" , group . getDisplayName ( ) ) ; org . junit . Assert . assertEquals ( \"description\" , group . getDescription ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( group )"}
{"focal": "getWeblogicOperatorImagePullPolicy ( ) { return weblogicOperatorImagePullPolicy ; }", "testMethod": "whenCreatedFromMapWithImagePullPolicy_hasSpecifiedValue ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( \"imagePullPolicy\" , stringValue ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( values . getWeblogicOperatorImagePullPolicy ( ) , org . hamcrest . Matchers . equalTo ( stringValue ) )", "total": "whenCreatedFromMapWithImagePullPolicy_hasSpecifiedValue ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( \"imagePullPolicy\" , stringValue ) ) ; \"<AssertPlaceHolder>\" ; } getWeblogicOperatorImagePullPolicy ( ) { return weblogicOperatorImagePullPolicy ; }", "answer": "org . junit . Assert . assertThat ( values . getWeblogicOperatorImagePullPolicy ( ) , org . hamcrest . Matchers . equalTo ( stringValue ) )"}
{"focal": "render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "testMethod": "testDec ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%decrement<sp>port<sp>%}\" , \"-1\" } , new java . lang . String [ ] { \"{%decrement<sp>port<sp>%}<sp>{%decrement<sp>port%}\" , \"-1<sp>-2\" } , new java . lang . String [ ] { \"{%decrement<sp>port<sp>%}<sp>{%decrement<sp>starboard%}<sp>{%decrement<sp>port<sp>%}<sp>{%decrement<sp>port%}<sp>{%decrement<sp>starboard<sp>%}\" , \"-1<sp>-1<sp>-2<sp>-3<sp>-2\" } , new java . lang . String [ ] { \"{%<sp>assign<sp>x<sp>=<sp>42<sp>%}{{x}}<sp>{%decrement<sp>x<sp>%}<sp>{%decrement<sp>x<sp>%}<sp>{{x}}\" , \"42<sp>-1<sp>-2<sp>42\" } , new java . lang . String [ ] { \"{%<sp>decrement<sp>x<sp>%}<sp>{%<sp>decrement<sp>x<sp>%}<sp>{{x}}\" , \"-1<sp>-2<sp>-2\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "testDec ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%decrement<sp>port<sp>%}\" , \"-1\" } , new java . lang . String [ ] { \"{%decrement<sp>port<sp>%}<sp>{%decrement<sp>port%}\" , \"-1<sp>-2\" } , new java . lang . String [ ] { \"{%decrement<sp>port<sp>%}<sp>{%decrement<sp>starboard%}<sp>{%decrement<sp>port<sp>%}<sp>{%decrement<sp>port%}<sp>{%decrement<sp>starboard<sp>%}\" , \"-1<sp>-1<sp>-2<sp>-3<sp>-2\" } , new java . lang . String [ ] { \"{%<sp>assign<sp>x<sp>=<sp>42<sp>%}{{x}}<sp>{%decrement<sp>x<sp>%}<sp>{%decrement<sp>x<sp>%}<sp>{{x}}\" , \"42<sp>-1<sp>-2<sp>42\" } , new java . lang . String [ ] { \"{%<sp>decrement<sp>x<sp>%}<sp>{%<sp>decrement<sp>x<sp>%}<sp>{{x}}\" , \"-1<sp>-2<sp>-2\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } } render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "minPathSum ( net . neoremind . mycode . argorithm . leetcode . support . TreeNode ) { min = Integer . MAX_VALUE ; minPathDown ( root ) ; return min ; }", "testMethod": "test ( ) { int [ ] [ ] grid = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 , 4 } , new int [ ] { 1 , 2 , 3 , 4 } , new int [ ] { 1 , 2 , 3 , 4 } } ; \"<AssertPlaceHolder>\" ; grid = new int [ ] [ ] { new int [ ] { 1 , 4 , 3 , 4 } , new int [ ] { 1 , 6 , 1 , 2 } , new int [ ] { 1 , 2 , 2 , 7 } } ; System . out . println ( minPathSum ( grid ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( minPathSum ( grid ) , org . hamcrest . Matchers . is ( 12 ) )", "total": "test ( ) { int [ ] [ ] grid = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 , 4 } , new int [ ] { 1 , 2 , 3 , 4 } , new int [ ] { 1 , 2 , 3 , 4 } } ; \"<AssertPlaceHolder>\" ; grid = new int [ ] [ ] { new int [ ] { 1 , 4 , 3 , 4 } , new int [ ] { 1 , 6 , 1 , 2 } , new int [ ] { 1 , 2 , 2 , 7 } } ; System . out . println ( minPathSum ( grid ) ) ; } minPathSum ( net . neoremind . mycode . argorithm . leetcode . support . TreeNode ) { min = Integer . MAX_VALUE ; minPathDown ( root ) ; return min ; }", "answer": "org . junit . Assert . assertThat ( minPathSum ( grid ) , org . hamcrest . Matchers . is ( 12 ) )"}
{"focal": "generateInnerQueryColumns ( annis . sqlgen . TableAccessStrategy , int ) { java . util . List < java . lang . String > columns = new java . util . ArrayList ( ) ; columns . add ( ( ( ( ( tableAccessStrategy . aliasedColumn ( annis . sqlgen . TableAccessStrategy . NODE_TABLE , idColumnName ) ) + \"<sp>AS<sp>\" ) + ( idColumnName ) ) + index ) ) ; return columns ; }", "testMethod": "shouldGenerateColumnsForInnerQuery ( ) { java . lang . String nameAlias = uniqueString ( 3 ) ; given ( tableAccessStrategy . aliasedColumn ( annis . sqlgen . TableAccessStrategy . NODE_TABLE , annis . sqlgen . PostgreSqlArraySolutionKeyTest . idColumnName ) ) . willReturn ( nameAlias ) ; int index = uniqueInt ( 1 , 10 ) ; java . util . List < java . lang . String > actual = key . generateInnerQueryColumns ( tableAccessStrategy , index ) ; java . util . List < java . lang . String > expected = asList ( ( ( ( nameAlias + \"<sp>AS<sp>\" ) + ( annis . sqlgen . PostgreSqlArraySolutionKeyTest . idColumnName ) ) + index ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldGenerateColumnsForInnerQuery ( ) { java . lang . String nameAlias = uniqueString ( 3 ) ; given ( tableAccessStrategy . aliasedColumn ( annis . sqlgen . TableAccessStrategy . NODE_TABLE , annis . sqlgen . PostgreSqlArraySolutionKeyTest . idColumnName ) ) . willReturn ( nameAlias ) ; int index = uniqueInt ( 1 , 10 ) ; java . util . List < java . lang . String > actual = key . generateInnerQueryColumns ( tableAccessStrategy , index ) ; java . util . List < java . lang . String > expected = asList ( ( ( ( nameAlias + \"<sp>AS<sp>\" ) + ( annis . sqlgen . PostgreSqlArraySolutionKeyTest . idColumnName ) ) + index ) ) ; \"<AssertPlaceHolder>\" ; } generateInnerQueryColumns ( annis . sqlgen . TableAccessStrategy , int ) { java . util . List < java . lang . String > columns = new java . util . ArrayList ( ) ; columns . add ( ( ( ( ( tableAccessStrategy . aliasedColumn ( annis . sqlgen . TableAccessStrategy . NODE_TABLE , idColumnName ) ) + \"<sp>AS<sp>\" ) + ( idColumnName ) ) + index ) ) ; return columns ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "copyFileFromResource ( java . io . File , java . lang . String ) { if ( destinationFile . exists ( ) ) { return true ; } else if ( ! ( fr . xephi . authme . util . FileUtils . createDirectory ( destinationFile . getParentFile ( ) ) ) ) { fr . xephi . authme . ConsoleLogger . warning ( ( ( \"Cannot<sp>create<sp>parent<sp>directories<sp>for<sp>'\" + destinationFile ) + \"'\" ) ) ; return false ; } try ( java . io . InputStream is = fr . xephi . authme . util . FileUtils . getResourceFromJar ( resourcePath ) ) { if ( is == null ) { fr . xephi . authme . ConsoleLogger . warning ( java . lang . String . format ( \"Cannot<sp>copy<sp>resource<sp>'%s'<sp>to<sp>file<sp>'%s':<sp>cannot<sp>load<sp>resource\" , resourcePath , destinationFile . getPath ( ) ) ) ; } else { java . nio . file . Files . copy ( is , destinationFile . toPath ( ) ) ; return true ; } } catch ( java . io . IOException e ) { fr . xephi . authme . ConsoleLogger . logException ( java . lang . String . format ( \"Cannot<sp>copy<sp>resource<sp>'%s'<sp>to<sp>file<sp>'%s':\" , resourcePath , destinationFile . getPath ( ) ) , e ) ; } return false ; }", "testMethod": "shouldReturnFalseForParentInvalidParentFolders ( ) { java . io . File folder = temporaryFolder . newFolder ( ) ; new java . io . File ( folder , \"hello\" ) . createNewFile ( ) ; java . io . File fileToCreate = new java . io . File ( folder , \"hello/test\" ) ; boolean result = fr . xephi . authme . util . FileUtils . copyFileFromResource ( fileToCreate , \"welcome.txt\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )", "total": "shouldReturnFalseForParentInvalidParentFolders ( ) { java . io . File folder = temporaryFolder . newFolder ( ) ; new java . io . File ( folder , \"hello\" ) . createNewFile ( ) ; java . io . File fileToCreate = new java . io . File ( folder , \"hello/test\" ) ; boolean result = fr . xephi . authme . util . FileUtils . copyFileFromResource ( fileToCreate , \"welcome.txt\" ) ; \"<AssertPlaceHolder>\" ; } copyFileFromResource ( java . io . File , java . lang . String ) { if ( destinationFile . exists ( ) ) { return true ; } else if ( ! ( fr . xephi . authme . util . FileUtils . createDirectory ( destinationFile . getParentFile ( ) ) ) ) { fr . xephi . authme . ConsoleLogger . warning ( ( ( \"Cannot<sp>create<sp>parent<sp>directories<sp>for<sp>'\" + destinationFile ) + \"'\" ) ) ; return false ; } try ( java . io . InputStream is = fr . xephi . authme . util . FileUtils . getResourceFromJar ( resourcePath ) ) { if ( is == null ) { fr . xephi . authme . ConsoleLogger . warning ( java . lang . String . format ( \"Cannot<sp>copy<sp>resource<sp>'%s'<sp>to<sp>file<sp>'%s':<sp>cannot<sp>load<sp>resource\" , resourcePath , destinationFile . getPath ( ) ) ) ; } else { java . nio . file . Files . copy ( is , destinationFile . toPath ( ) ) ; return true ; } } catch ( java . io . IOException e ) { fr . xephi . authme . ConsoleLogger . logException ( java . lang . String . format ( \"Cannot<sp>copy<sp>resource<sp>'%s'<sp>to<sp>file<sp>'%s':\" , resourcePath , destinationFile . getPath ( ) ) , e ) ; } return false ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "stream ( ) { return java . util . stream . StreamSupport . stream ( java . util . Spliterators . spliteratorUnknownSize ( this , Spliterator . ORDERED ) , false ) ; }", "testMethod": "queryResultsMustNotIncludeNodesDeletedInThisTransaction ( ) { db = createDatabase ( ) ; try ( org . neo4j . graphdb . Transaction tx = db . beginTx ( ) ) { createSimpleNodesIndex ( ) ; tx . success ( ) ; } long nodeIdA ; long nodeIdB ; try ( org . neo4j . graphdb . Transaction tx = db . beginTx ( ) ) { awaitIndexesOnline ( ) ; org . neo4j . graphdb . Node nodeA = db . createNode ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . LABEL ) ; nodeA . setProperty ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . PROP , \"value\" ) ; nodeIdA = nodeA . getId ( ) ; org . neo4j . graphdb . Node nodeB = db . createNode ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . LABEL ) ; nodeB . setProperty ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . PROP , \"value\" ) ; nodeIdB = nodeB . getId ( ) ; tx . success ( ) ; } try ( org . neo4j . graphdb . Transaction tx = db . beginTx ( ) ) { db . getNodeById ( nodeIdA ) . delete ( ) ; db . getNodeById ( nodeIdB ) . delete ( ) ; try ( org . neo4j . graphdb . Result result = db . execute ( java . lang . String . format ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . QUERY_NODES , \"nodes\" , \"value\" ) ) ) { \"<AssertPlaceHolder>\" ; } tx . success ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( result . stream ( ) . count ( ) , org . hamcrest . Matchers . is ( 0L ) )", "total": "queryResultsMustNotIncludeNodesDeletedInThisTransaction ( ) { db = createDatabase ( ) ; try ( org . neo4j . graphdb . Transaction tx = db . beginTx ( ) ) { createSimpleNodesIndex ( ) ; tx . success ( ) ; } long nodeIdA ; long nodeIdB ; try ( org . neo4j . graphdb . Transaction tx = db . beginTx ( ) ) { awaitIndexesOnline ( ) ; org . neo4j . graphdb . Node nodeA = db . createNode ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . LABEL ) ; nodeA . setProperty ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . PROP , \"value\" ) ; nodeIdA = nodeA . getId ( ) ; org . neo4j . graphdb . Node nodeB = db . createNode ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . LABEL ) ; nodeB . setProperty ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . PROP , \"value\" ) ; nodeIdB = nodeB . getId ( ) ; tx . success ( ) ; } try ( org . neo4j . graphdb . Transaction tx = db . beginTx ( ) ) { db . getNodeById ( nodeIdA ) . delete ( ) ; db . getNodeById ( nodeIdB ) . delete ( ) ; try ( org . neo4j . graphdb . Result result = db . execute ( java . lang . String . format ( org . neo4j . kernel . api . impl . fulltext . FulltextProceduresTest . QUERY_NODES , \"nodes\" , \"value\" ) ) ) { \"<AssertPlaceHolder>\" ; } tx . success ( ) ; } } stream ( ) { return java . util . stream . StreamSupport . stream ( java . util . Spliterators . spliteratorUnknownSize ( this , Spliterator . ORDERED ) , false ) ; }", "answer": "org . junit . Assert . assertThat ( result . stream ( ) . count ( ) , org . hamcrest . Matchers . is ( 0L ) )"}
{"focal": "get ( ) { org . neo4j . kernel . recovery . LogTailScanner . LogTailInformation logTailInformation = logTailScanner . getTailInformation ( ) ; org . neo4j . kernel . impl . transaction . log . entry . CheckPoint lastCheckPoint = logTailInformation . lastCheckPoint ; long txIdAfterLastCheckPoint = logTailInformation . firstTxIdAfterLastCheckPoint ; if ( ! ( logTailInformation . commitsAfterLastCheckpoint ( ) ) ) { monitor . noCommitsAfterLastCheckPoint ( ( lastCheckPoint != null ? lastCheckPoint . getLogPosition ( ) : null ) ) ; return createRecoveryInformation ( LogPosition . UNSPECIFIED , txIdAfterLastCheckPoint ) ; } if ( lastCheckPoint != null ) { monitor . commitsAfterLastCheckPoint ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; return createRecoveryInformation ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; } else { if ( ( logTailInformation . oldestLogVersionFound ) != ( INITIAL_LOG_VERSION ) ) { long fromLogVersion = java . lang . Math . max ( org . neo4j . kernel . recovery . INITIAL_LOG_VERSION , logTailInformation . oldestLogVersionFound ) ; throw new org . neo4j . kernel . impl . store . UnderlyingStorageException ( ( ( ( \"No<sp>check<sp>point<sp>found<sp>in<sp>any<sp>log<sp>file<sp>from<sp>version<sp>\" + fromLogVersion ) + \"<sp>to<sp>\" ) + ( logTailInformation . currentLogVersion ) ) ) ; } monitor . noCheckPointFound ( ) ; return createRecoveryInformation ( org . neo4j . kernel . impl . transaction . log . LogPosition . start ( 0 ) , txIdAfterLastCheckPoint ) ; } }", "testMethod": "shouldRunRecurringJob ( ) { long period = 10 ; int count = 5 ; life . start ( ) ; scheduler . scheduleRecurring ( Group . INDEX_POPULATION , countInvocationsJob , period , org . neo4j . kernel . impl . scheduler . MILLISECONDS ) ; awaitInvocationCount ( count ) ; scheduler . shutdown ( ) ; int actualInvocations = invocations . get ( ) ; java . lang . Thread . sleep ( ( period * 5 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( invocations . get ( ) , org . hamcrest . Matchers . equalTo ( actualInvocations ) )", "total": "shouldRunRecurringJob ( ) { long period = 10 ; int count = 5 ; life . start ( ) ; scheduler . scheduleRecurring ( Group . INDEX_POPULATION , countInvocationsJob , period , org . neo4j . kernel . impl . scheduler . MILLISECONDS ) ; awaitInvocationCount ( count ) ; scheduler . shutdown ( ) ; int actualInvocations = invocations . get ( ) ; java . lang . Thread . sleep ( ( period * 5 ) ) ; \"<AssertPlaceHolder>\" ; } get ( ) { org . neo4j . kernel . recovery . LogTailScanner . LogTailInformation logTailInformation = logTailScanner . getTailInformation ( ) ; org . neo4j . kernel . impl . transaction . log . entry . CheckPoint lastCheckPoint = logTailInformation . lastCheckPoint ; long txIdAfterLastCheckPoint = logTailInformation . firstTxIdAfterLastCheckPoint ; if ( ! ( logTailInformation . commitsAfterLastCheckpoint ( ) ) ) { monitor . noCommitsAfterLastCheckPoint ( ( lastCheckPoint != null ? lastCheckPoint . getLogPosition ( ) : null ) ) ; return createRecoveryInformation ( LogPosition . UNSPECIFIED , txIdAfterLastCheckPoint ) ; } if ( lastCheckPoint != null ) { monitor . commitsAfterLastCheckPoint ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; return createRecoveryInformation ( lastCheckPoint . getLogPosition ( ) , txIdAfterLastCheckPoint ) ; } else { if ( ( logTailInformation . oldestLogVersionFound ) != ( INITIAL_LOG_VERSION ) ) { long fromLogVersion = java . lang . Math . max ( org . neo4j . kernel . recovery . INITIAL_LOG_VERSION , logTailInformation . oldestLogVersionFound ) ; throw new org . neo4j . kernel . impl . store . UnderlyingStorageException ( ( ( ( \"No<sp>check<sp>point<sp>found<sp>in<sp>any<sp>log<sp>file<sp>from<sp>version<sp>\" + fromLogVersion ) + \"<sp>to<sp>\" ) + ( logTailInformation . currentLogVersion ) ) ) ; } monitor . noCheckPointFound ( ) ; return createRecoveryInformation ( org . neo4j . kernel . impl . transaction . log . LogPosition . start ( 0 ) , txIdAfterLastCheckPoint ) ; } }", "answer": "org . junit . Assert . assertThat ( invocations . get ( ) , org . hamcrest . Matchers . equalTo ( actualInvocations ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsOtherProperty ( ) { org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork obj = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"ObjectId\" , \"Type\" , \"none\" , \"logicandNewwrok\" , \"network\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsOtherProperty ( ) { org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork obj = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"ObjectId\" , \"Type\" , \"none\" , \"logicandNewwrok\" , \"network\" ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "makeKey ( java . util . UUID , me . gnat008 . perworldinventory . groups . Group , org . bukkit . GameMode ) { java . lang . String key = ( ( ( uuid . toString ( ) ) + \".\" ) + ( group . getName ( ) ) ) + \".\" ; if ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) key += gameMode . toString ( ) . toLowerCase ( ) ; else key += \"survival\" ; return key ; }", "testMethod": "addPlayerShouldHaveSurvivalKeyNoSeparation ( ) { org . bukkit . entity . Player player = mockPlayer ( \"player\" , GameMode . CREATIVE ) ; me . gnat008 . perworldinventory . groups . Group group = me . gnat008 . perworldinventory . TestHelper . mockGroup ( \"test\" ) ; given ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) . willReturn ( false ) ; java . lang . String result = playerManager . makeKey ( player . getUniqueId ( ) , group , GameMode . CREATIVE ) ; java . lang . String expected = ( me . gnat008 . perworldinventory . TestHelper . TEST_UUID ) + \".test.survival\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( expected ) )", "total": "addPlayerShouldHaveSurvivalKeyNoSeparation ( ) { org . bukkit . entity . Player player = mockPlayer ( \"player\" , GameMode . CREATIVE ) ; me . gnat008 . perworldinventory . groups . Group group = me . gnat008 . perworldinventory . TestHelper . mockGroup ( \"test\" ) ; given ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) . willReturn ( false ) ; java . lang . String result = playerManager . makeKey ( player . getUniqueId ( ) , group , GameMode . CREATIVE ) ; java . lang . String expected = ( me . gnat008 . perworldinventory . TestHelper . TEST_UUID ) + \".test.survival\" ; \"<AssertPlaceHolder>\" ; } makeKey ( java . util . UUID , me . gnat008 . perworldinventory . groups . Group , org . bukkit . GameMode ) { java . lang . String key = ( ( ( uuid . toString ( ) ) + \".\" ) + ( group . getName ( ) ) ) + \".\" ; if ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) key += gameMode . toString ( ) . toLowerCase ( ) ; else key += \"survival\" ; return key ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( expected ) )"}
{"focal": "eliminate ( ) { return eliminate ( 0 , 0 ) ; }", "testMethod": "duplicates ( ) { org . openscience . cdk . graph . BitMatrix m = new org . openscience . cdk . graph . BitMatrix ( 9 , 3 ) ; m . add ( org . openscience . cdk . graph . BitMatrixTest . toBitSet ( \"110000000\" ) ) ; m . add ( org . openscience . cdk . graph . BitMatrixTest . toBitSet ( \"110000000\" ) ) ; m . add ( org . openscience . cdk . graph . BitMatrixTest . toBitSet ( \"001100000\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( m . eliminate ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "duplicates ( ) { org . openscience . cdk . graph . BitMatrix m = new org . openscience . cdk . graph . BitMatrix ( 9 , 3 ) ; m . add ( org . openscience . cdk . graph . BitMatrixTest . toBitSet ( \"110000000\" ) ) ; m . add ( org . openscience . cdk . graph . BitMatrixTest . toBitSet ( \"110000000\" ) ) ; m . add ( org . openscience . cdk . graph . BitMatrixTest . toBitSet ( \"001100000\" ) ) ; \"<AssertPlaceHolder>\" ; } eliminate ( ) { return eliminate ( 0 , 0 ) ; }", "answer": "org . junit . Assert . assertThat ( m . eliminate ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "single ( ) { if ( ! ( iterator . hasNext ( ) ) ) { throw new java . util . NoSuchElementException ( \"LongStream<sp>contains<sp>no<sp>element\" ) ; } final long singleCandidate = iterator . nextLong ( ) ; if ( iterator . hasNext ( ) ) { throw new java . lang . IllegalStateException ( \"LongStream<sp>contains<sp>more<sp>than<sp>one<sp>element\" ) ; } return singleCandidate ; }", "testMethod": "testSingleOnOneElementStream ( ) { int result = com . annimon . stream . IntStream . of ( 42 ) . single ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( 42 ) )", "total": "testSingleOnOneElementStream ( ) { int result = com . annimon . stream . IntStream . of ( 42 ) . single ( ) ; \"<AssertPlaceHolder>\" ; } single ( ) { if ( ! ( iterator . hasNext ( ) ) ) { throw new java . util . NoSuchElementException ( \"LongStream<sp>contains<sp>no<sp>element\" ) ; } final long singleCandidate = iterator . nextLong ( ) ; if ( iterator . hasNext ( ) ) { throw new java . lang . IllegalStateException ( \"LongStream<sp>contains<sp>more<sp>than<sp>one<sp>element\" ) ; } return singleCandidate ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( 42 ) )"}
{"focal": "toString ( ) { if ( name ( ) . equals ( \"sessionId\" ) ) { return \"session-id\" ; } else { return name ( ) ; } }", "testMethod": "testHashBaseForItemCorePropertiesPreservesNullsLiterally ( ) { final org . sakaiproject . tool . assessment . data . dao . assessment . ItemData item = new org . sakaiproject . tool . assessment . data . dao . assessment . ItemData ( ) ; item . setTypeId ( TypeIfc . FILL_IN_BLANK ) ; final org . sakaiproject . tool . assessment . data . dao . assessment . ItemText itemText = new org . sakaiproject . tool . assessment . data . dao . assessment . ItemText ( item , 1L , null , null ) ; item . setItemTextSet ( org . mockito . internal . util . collections . Sets . newSet ( itemText ) ) ; final java . lang . StringBuilder expectedHashBase = new java . lang . StringBuilder ( ( ( \"TypeId:\" + ( org . sakaiproject . tool . assessment . data . ifc . shared . TypeIfc . FILL_IN_BLANK ) ) + \"::\" ) ) . append ( \"ItemText:null::\" ) ; final java . lang . StringBuilder actualHashBase = new java . lang . StringBuilder ( ) ; itemHashUtil . hashBaseForItemCoreProperties ( item , actualHashBase ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualHashBase . toString ( ) , org . hamcrest . CoreMatchers . equalTo ( expectedHashBase . toString ( ) ) )", "total": "testHashBaseForItemCorePropertiesPreservesNullsLiterally ( ) { final org . sakaiproject . tool . assessment . data . dao . assessment . ItemData item = new org . sakaiproject . tool . assessment . data . dao . assessment . ItemData ( ) ; item . setTypeId ( TypeIfc . FILL_IN_BLANK ) ; final org . sakaiproject . tool . assessment . data . dao . assessment . ItemText itemText = new org . sakaiproject . tool . assessment . data . dao . assessment . ItemText ( item , 1L , null , null ) ; item . setItemTextSet ( org . mockito . internal . util . collections . Sets . newSet ( itemText ) ) ; final java . lang . StringBuilder expectedHashBase = new java . lang . StringBuilder ( ( ( \"TypeId:\" + ( org . sakaiproject . tool . assessment . data . ifc . shared . TypeIfc . FILL_IN_BLANK ) ) + \"::\" ) ) . append ( \"ItemText:null::\" ) ; final java . lang . StringBuilder actualHashBase = new java . lang . StringBuilder ( ) ; itemHashUtil . hashBaseForItemCoreProperties ( item , actualHashBase ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { if ( name ( ) . equals ( \"sessionId\" ) ) { return \"session-id\" ; } else { return name ( ) ; } }", "answer": "org . junit . Assert . assertThat ( actualHashBase . toString ( ) , org . hamcrest . CoreMatchers . equalTo ( expectedHashBase . toString ( ) ) )"}
{"focal": "apply ( java . lang . Integer ) { return input + ( uk . gov . gchq . gaffer . mapstore . impl . GetElementsHandlerTest . ExampleTransform . INCREMENT_BY ) ; }", "testMethod": "shouldHandleNulls ( ) { final uk . gov . gchq . gaffer . types . function . FreqMapPredicator nullRegPredicator = new uk . gov . gchq . gaffer . types . function . FreqMapPredicator ( null ) ; final uk . gov . gchq . gaffer . types . FreqMap map = nullRegPredicator . apply ( freqMap ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( map , org . hamcrest . CoreMatchers . is ( freqMap ) )", "total": "shouldHandleNulls ( ) { final uk . gov . gchq . gaffer . types . function . FreqMapPredicator nullRegPredicator = new uk . gov . gchq . gaffer . types . function . FreqMapPredicator ( null ) ; final uk . gov . gchq . gaffer . types . FreqMap map = nullRegPredicator . apply ( freqMap ) ; \"<AssertPlaceHolder>\" ; } apply ( java . lang . Integer ) { return input + ( uk . gov . gchq . gaffer . mapstore . impl . GetElementsHandlerTest . ExampleTransform . INCREMENT_BY ) ; }", "answer": "org . junit . Assert . assertThat ( map , org . hamcrest . CoreMatchers . is ( freqMap ) )"}
{"focal": "expectedBuildPerson ( ) { return javax . json . Json . createObjectBuilder ( ) . add ( \"10021\" 1 , \"10021\" 3 ) . add ( \"lastName\" , \"Smith\" ) . add ( \"email\" , \"john@example.com\" ) . add ( \"age\" , 30 ) . add ( \"10021\" 4 , javax . json . Json . createObjectBuilder ( ) . add ( \"lastName\" , \"Smith\" ) . add ( \"streetAddress\" , \"10021\" 0 ) . add ( \"city\" , \"New<sp>York\" ) . add ( \"10021\" 5 , \"NY\" ) . add ( \"10021\" 2 , \"10021\" ) ) . build ( ) ; }", "testMethod": "shouldBuildJsonPatchExpressionUsingJsonPatchBuilder ( ) { javax . json . JsonPatchBuilder patchBuilder = javax . json . Json . createPatchBuilder ( ) ; javax . json . JsonObject result = patchBuilder . add ( \"/email\" , \"john@example.com\" ) . replace ( \"/age\" , 30 ) . remove ( \"/phoneNumber\" ) . test ( \"/firstName\" , \"John\" ) . copy ( \"/address/lastName\" , \"/lastName\" ) . build ( ) . apply ( org . glassfish . json . tests . JsonPatchBuilderTest . buildPerson ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . glassfish . json . tests . JsonPatchBuilderTest . expectedBuildPerson ( ) ) )", "total": "shouldBuildJsonPatchExpressionUsingJsonPatchBuilder ( ) { javax . json . JsonPatchBuilder patchBuilder = javax . json . Json . createPatchBuilder ( ) ; javax . json . JsonObject result = patchBuilder . add ( \"/email\" , \"john@example.com\" ) . replace ( \"/age\" , 30 ) . remove ( \"/phoneNumber\" ) . test ( \"/firstName\" , \"John\" ) . copy ( \"/address/lastName\" , \"/lastName\" ) . build ( ) . apply ( org . glassfish . json . tests . JsonPatchBuilderTest . buildPerson ( ) ) ; \"<AssertPlaceHolder>\" ; } expectedBuildPerson ( ) { return javax . json . Json . createObjectBuilder ( ) . add ( \"10021\" 1 , \"10021\" 3 ) . add ( \"lastName\" , \"Smith\" ) . add ( \"email\" , \"john@example.com\" ) . add ( \"age\" , 30 ) . add ( \"10021\" 4 , javax . json . Json . createObjectBuilder ( ) . add ( \"lastName\" , \"Smith\" ) . add ( \"streetAddress\" , \"10021\" 0 ) . add ( \"city\" , \"New<sp>York\" ) . add ( \"10021\" 5 , \"NY\" ) . add ( \"10021\" 2 , \"10021\" ) ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . glassfish . json . tests . JsonPatchBuilderTest . expectedBuildPerson ( ) ) )"}
{"focal": "empty ( ) { return new org . batfish . datamodel . ospf . OspfTopology ( com . google . common . graph . ValueGraphBuilder . directed ( ) . build ( ) ) ; }", "testMethod": "testAddVniEdgeIncompatible ( ) { java . util . Map < java . lang . String , org . batfish . datamodel . Configuration > configurations = com . google . common . collect . ImmutableMap . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . NODE1 , _c1 , org . batfish . datamodel . vxlan . VxlanTopologyTest . NODE2 , _c2 ) ; com . google . common . graph . MutableNetwork < org . batfish . datamodel . vxlan . VxlanNode , org . batfish . datamodel . vxlan . VxlanEdge > graph = com . google . common . graph . NetworkBuilder . directed ( ) . allowsParallelEdges ( false ) . allowsSelfLoops ( false ) . build ( ) ; java . util . Map < org . batfish . datamodel . Vrf , java . lang . String > vrfHostnames = org . batfish . datamodel . vxlan . VxlanTopology . initVrfHostnameMap ( configurations ) ; org . batfish . datamodel . VniSettings . Builder vniSettingsBuilder = org . batfish . datamodel . VniSettings . builder ( ) . setBumTransportIps ( com . google . common . collect . ImmutableSortedSet . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . MULTICAST_GROUP ) ) . setBumTransportMethod ( BumTransportMethod . MULTICAST_GROUP ) . setUdpPort ( org . batfish . datamodel . vxlan . VxlanTopologyTest . UDP_PORT ) . setVni ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI ) ; org . batfish . datamodel . VniSettings vniSettingsTail = vniSettingsBuilder . setSourceAddress ( org . batfish . datamodel . vxlan . VxlanTopologyTest . SRC_IP1 ) . setVlan ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VLAN1 ) . build ( ) ; _v1 . setVniSettings ( com . google . common . collect . ImmutableSortedMap . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI , vniSettingsTail ) ) ; _v2 . setVniSettings ( com . google . common . collect . ImmutableSortedMap . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI , vniSettingsBuilder . setSourceAddress ( org . batfish . datamodel . vxlan . VxlanTopologyTest . SRC_IP1 ) . setVlan ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VLAN2 ) . build ( ) ) ) ; org . batfish . datamodel . vxlan . VxlanTopology . addVniEdge ( graph , vrfHostnames , org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI , _v1 , vniSettingsTail , _v2 ) ; java . util . Set < org . batfish . datamodel . vxlan . VxlanEdge > edges = graph . edges ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( edges , org . hamcrest . Matchers . empty ( ) )", "total": "testAddVniEdgeIncompatible ( ) { java . util . Map < java . lang . String , org . batfish . datamodel . Configuration > configurations = com . google . common . collect . ImmutableMap . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . NODE1 , _c1 , org . batfish . datamodel . vxlan . VxlanTopologyTest . NODE2 , _c2 ) ; com . google . common . graph . MutableNetwork < org . batfish . datamodel . vxlan . VxlanNode , org . batfish . datamodel . vxlan . VxlanEdge > graph = com . google . common . graph . NetworkBuilder . directed ( ) . allowsParallelEdges ( false ) . allowsSelfLoops ( false ) . build ( ) ; java . util . Map < org . batfish . datamodel . Vrf , java . lang . String > vrfHostnames = org . batfish . datamodel . vxlan . VxlanTopology . initVrfHostnameMap ( configurations ) ; org . batfish . datamodel . VniSettings . Builder vniSettingsBuilder = org . batfish . datamodel . VniSettings . builder ( ) . setBumTransportIps ( com . google . common . collect . ImmutableSortedSet . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . MULTICAST_GROUP ) ) . setBumTransportMethod ( BumTransportMethod . MULTICAST_GROUP ) . setUdpPort ( org . batfish . datamodel . vxlan . VxlanTopologyTest . UDP_PORT ) . setVni ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI ) ; org . batfish . datamodel . VniSettings vniSettingsTail = vniSettingsBuilder . setSourceAddress ( org . batfish . datamodel . vxlan . VxlanTopologyTest . SRC_IP1 ) . setVlan ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VLAN1 ) . build ( ) ; _v1 . setVniSettings ( com . google . common . collect . ImmutableSortedMap . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI , vniSettingsTail ) ) ; _v2 . setVniSettings ( com . google . common . collect . ImmutableSortedMap . of ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI , vniSettingsBuilder . setSourceAddress ( org . batfish . datamodel . vxlan . VxlanTopologyTest . SRC_IP1 ) . setVlan ( org . batfish . datamodel . vxlan . VxlanTopologyTest . VLAN2 ) . build ( ) ) ) ; org . batfish . datamodel . vxlan . VxlanTopology . addVniEdge ( graph , vrfHostnames , org . batfish . datamodel . vxlan . VxlanTopologyTest . VNI , _v1 , vniSettingsTail , _v2 ) ; java . util . Set < org . batfish . datamodel . vxlan . VxlanEdge > edges = graph . edges ( ) ; \"<AssertPlaceHolder>\" ; } empty ( ) { return new org . batfish . datamodel . ospf . OspfTopology ( com . google . common . graph . ValueGraphBuilder . directed ( ) . build ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( edges , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getCurrentPhase ( ) { return currentPhase ; }", "testMethod": "taskErrorsDontStopStartup ( ) { org . mockito . InOrder inOrder = verifyPhases ( ) ; doThrow ( new java . lang . Exception ( \"testing\" ) ) . when ( tasksPhase ) . start ( ) ; underTest . to ( org . sonatype . nexus . extender . TASKS ) ; \"<AssertPlaceHolder>\" ; inOrder . verify ( kernelPhase ) . start ( ) ; inOrder . verify ( storagePhase ) . start ( ) ; inOrder . verify ( restorePhase ) . start ( ) ; inOrder . verify ( upgradePhase ) . start ( ) ; inOrder . verify ( schemasPhase ) . start ( ) ; inOrder . verify ( eventsPhase ) . start ( ) ; inOrder . verify ( securityPhase ) . start ( ) ; inOrder . verify ( servicesPhase ) . start ( ) ; inOrder . verify ( capabilitiesPhase ) . start ( ) ; inOrder . verify ( tasksPhase ) . start ( ) ; inOrder . verifyNoMoreInteractions ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( underTest . getCurrentPhase ( ) , org . hamcrest . CoreMatchers . is ( org . sonatype . nexus . extender . TASKS ) )", "total": "taskErrorsDontStopStartup ( ) { org . mockito . InOrder inOrder = verifyPhases ( ) ; doThrow ( new java . lang . Exception ( \"testing\" ) ) . when ( tasksPhase ) . start ( ) ; underTest . to ( org . sonatype . nexus . extender . TASKS ) ; \"<AssertPlaceHolder>\" ; inOrder . verify ( kernelPhase ) . start ( ) ; inOrder . verify ( storagePhase ) . start ( ) ; inOrder . verify ( restorePhase ) . start ( ) ; inOrder . verify ( upgradePhase ) . start ( ) ; inOrder . verify ( schemasPhase ) . start ( ) ; inOrder . verify ( eventsPhase ) . start ( ) ; inOrder . verify ( securityPhase ) . start ( ) ; inOrder . verify ( servicesPhase ) . start ( ) ; inOrder . verify ( capabilitiesPhase ) . start ( ) ; inOrder . verify ( tasksPhase ) . start ( ) ; inOrder . verifyNoMoreInteractions ( ) ; } getCurrentPhase ( ) { return currentPhase ; }", "answer": "org . junit . Assert . assertThat ( underTest . getCurrentPhase ( ) , org . hamcrest . CoreMatchers . is ( org . sonatype . nexus . extender . TASKS ) )"}
{"focal": "getMember ( ) { return member ; }", "testMethod": "shouldCreateInjectionPointWithGivenMember ( ) { final uk . gov . justice . services . test . utils . common . MemberInjectionPoint injectionPoint = uk . gov . justice . services . test . utils . common . MemberInjectionPoint . injectionPointWith ( uk . gov . justice . services . test . utils . common . MemberInjectionPointTest . FieldClass . class . getDeclaredField ( \"field\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( injectionPoint . getMember ( ) . getName ( ) , org . hamcrest . core . Is . is ( \"field\" ) )", "total": "shouldCreateInjectionPointWithGivenMember ( ) { final uk . gov . justice . services . test . utils . common . MemberInjectionPoint injectionPoint = uk . gov . justice . services . test . utils . common . MemberInjectionPoint . injectionPointWith ( uk . gov . justice . services . test . utils . common . MemberInjectionPointTest . FieldClass . class . getDeclaredField ( \"field\" ) ) ; \"<AssertPlaceHolder>\" ; } getMember ( ) { return member ; }", "answer": "org . junit . Assert . assertThat ( injectionPoint . getMember ( ) . getName ( ) , org . hamcrest . core . Is . is ( \"field\" ) )"}
{"focal": "getCheckpoint ( java . lang . String ) { software . amazon . kinesis . retrieval . kpl . ExtendedSequenceNumber checkpoint = flushpoints . get ( shardId ) ; log . debug ( \"checkpoint<sp>shardId:<sp>{}<sp>checkpoint:<sp>{}\" , shardId , checkpoint ) ; return checkpoint ; }", "testMethod": "testCheckpointSubRecord ( ) { software . amazon . kinesis . checkpoint . ShardRecordProcessorCheckpointer processingCheckpointer = new software . amazon . kinesis . checkpoint . ShardRecordProcessorCheckpointer ( shardInfo , checkpoint ) ; processingCheckpointer . setInitialCheckpointValue ( startingExtendedSequenceNumber ) ; software . amazon . kinesis . retrieval . kpl . ExtendedSequenceNumber extendedSequenceNumber = new software . amazon . kinesis . retrieval . kpl . ExtendedSequenceNumber ( \"5030\" ) ; software . amazon . awssdk . services . kinesis . model . Record record = makeRecord ( \"5030\" ) ; processingCheckpointer . largestPermittedCheckpointValue ( extendedSequenceNumber ) ; processingCheckpointer . checkpoint ( record ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( checkpoint . getCheckpoint ( shardId ) , org . hamcrest . Matchers . equalTo ( extendedSequenceNumber ) )", "total": "testCheckpointSubRecord ( ) { software . amazon . kinesis . checkpoint . ShardRecordProcessorCheckpointer processingCheckpointer = new software . amazon . kinesis . checkpoint . ShardRecordProcessorCheckpointer ( shardInfo , checkpoint ) ; processingCheckpointer . setInitialCheckpointValue ( startingExtendedSequenceNumber ) ; software . amazon . kinesis . retrieval . kpl . ExtendedSequenceNumber extendedSequenceNumber = new software . amazon . kinesis . retrieval . kpl . ExtendedSequenceNumber ( \"5030\" ) ; software . amazon . awssdk . services . kinesis . model . Record record = makeRecord ( \"5030\" ) ; processingCheckpointer . largestPermittedCheckpointValue ( extendedSequenceNumber ) ; processingCheckpointer . checkpoint ( record ) ; \"<AssertPlaceHolder>\" ; } getCheckpoint ( java . lang . String ) { software . amazon . kinesis . retrieval . kpl . ExtendedSequenceNumber checkpoint = flushpoints . get ( shardId ) ; log . debug ( \"checkpoint<sp>shardId:<sp>{}<sp>checkpoint:<sp>{}\" , shardId , checkpoint ) ; return checkpoint ; }", "answer": "org . junit . Assert . assertThat ( checkpoint . getCheckpoint ( shardId ) , org . hamcrest . Matchers . equalTo ( extendedSequenceNumber ) )"}
{"focal": "findLeaves ( ) { final java . util . Set < com . ning . atlas . Host > rs = com . google . common . collect . Sets . newLinkedHashSet ( ) ; for ( com . ning . atlas . Element root : roots ) { rs . addAll ( com . ning . atlas . tree . Trees . findInstancesOf ( root , com . ning . atlas . Host . class ) ) ; } return rs ; }", "testMethod": "testSystemTemplateWithImport ( ) { com . ning . atlas . JRubyTemplateParser p = new com . ning . atlas . JRubyTemplateParser ( ) ; com . ning . atlas . Descriptor t = p . parseDescriptor ( new java . io . File ( \"src/test/ruby/ex1/system-template-with-import.rb\" ) ) ; com . ning . atlas . Descriptor env = p . parseDescriptor ( new java . io . File ( \"src/test/ruby/ex1/env-with-listener.rb\" ) ) ; com . ning . atlas . SystemMap map = t . combine ( env ) . normalize ( \"test\" ) ; java . util . SortedSet < com . ning . atlas . Host > hosts = com . google . common . collect . Sets . newTreeSet ( new java . util . Comparator < com . ning . atlas . Host > ( ) { @ com . ning . atlas . Override public int compare ( com . ning . atlas . Host host , com . ning . atlas . Host host1 ) { return host . getId ( ) . toExternalForm ( ) . compareTo ( host1 . getId ( ) . toExternalForm ( ) ) ; } } ) ; hosts . addAll ( map . findLeaves ( ) ) ; \"<AssertPlaceHolder>\" ; java . util . Iterator < com . ning . atlas . Host > itty = hosts . iterator ( ) ; com . ning . atlas . Host one = itty . next ( ) ; System . out . println ( one . getId ( ) ) ; com . ning . atlas . Host two = itty . next ( ) ; System . out . println ( two . getId ( ) ) ; com . ning . atlas . Host three = itty . next ( ) ; System . out . println ( three . getId ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( hosts . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 3 ) )", "total": "testSystemTemplateWithImport ( ) { com . ning . atlas . JRubyTemplateParser p = new com . ning . atlas . JRubyTemplateParser ( ) ; com . ning . atlas . Descriptor t = p . parseDescriptor ( new java . io . File ( \"src/test/ruby/ex1/system-template-with-import.rb\" ) ) ; com . ning . atlas . Descriptor env = p . parseDescriptor ( new java . io . File ( \"src/test/ruby/ex1/env-with-listener.rb\" ) ) ; com . ning . atlas . SystemMap map = t . combine ( env ) . normalize ( \"test\" ) ; java . util . SortedSet < com . ning . atlas . Host > hosts = com . google . common . collect . Sets . newTreeSet ( new java . util . Comparator < com . ning . atlas . Host > ( ) { @ com . ning . atlas . Override public int compare ( com . ning . atlas . Host host , com . ning . atlas . Host host1 ) { return host . getId ( ) . toExternalForm ( ) . compareTo ( host1 . getId ( ) . toExternalForm ( ) ) ; } } ) ; hosts . addAll ( map . findLeaves ( ) ) ; \"<AssertPlaceHolder>\" ; java . util . Iterator < com . ning . atlas . Host > itty = hosts . iterator ( ) ; com . ning . atlas . Host one = itty . next ( ) ; System . out . println ( one . getId ( ) ) ; com . ning . atlas . Host two = itty . next ( ) ; System . out . println ( two . getId ( ) ) ; com . ning . atlas . Host three = itty . next ( ) ; System . out . println ( three . getId ( ) ) ; } findLeaves ( ) { final java . util . Set < com . ning . atlas . Host > rs = com . google . common . collect . Sets . newLinkedHashSet ( ) ; for ( com . ning . atlas . Element root : roots ) { rs . addAll ( com . ning . atlas . tree . Trees . findInstancesOf ( root , com . ning . atlas . Host . class ) ) ; } return rs ; }", "answer": "org . junit . Assert . assertThat ( hosts . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 3 ) )"}
{"focal": "getValue ( int , int ) { java . lang . String key = keys . get ( column ) ; if ( row == 0 ) { return key ; } int currentRow = row - 1 ; if ( ( mappings . get ( key ) . size ( ) ) > currentRow ) { return mappings . get ( key ) . get ( currentRow ) ; } else { return null ; } }", "testMethod": "testStatusWithSummary ( ) { java . util . Collection < org . springframework . cloud . dataflow . rest . resource . AppStatusResource > data = new java . util . ArrayList ( ) ; data . add ( appStatusResource1 ) ; data . add ( appStatusResource2 ) ; data . add ( appStatusResource3 ) ; org . springframework . hateoas . PagedResources . PageMetadata metadata = new org . springframework . hateoas . PagedResources . PageMetadata ( data . size ( ) , 1 , data . size ( ) , 1 ) ; org . springframework . hateoas . PagedResources < org . springframework . cloud . dataflow . rest . resource . AppStatusResource > result = new org . springframework . hateoas . PagedResources ( data , metadata ) ; when ( runtimeOperations . status ( ) ) . thenReturn ( result ) ; java . lang . Object [ ] [ ] expected = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"1\" , \"deployed\" , \"2\" } , new java . lang . String [ ] { \"2\" , \"undeployed\" , \"0\" } , new java . lang . String [ ] { \"3\" , \"failed\" , \"0\" } } ; org . springframework . shell . table . TableModel model = runtimeCommands . list ( true , null ) . getModel ( ) ; for ( int row = 0 ; row < ( expected . length ) ; row ++ ) { for ( int col = 0 ; col < ( expected [ row ] . length ) ; col ++ ) { \"<AssertPlaceHolder>\" ; } } }", "assertLine": "org . junit . Assert . assertThat ( java . lang . String . valueOf ( model . getValue ( ( row + 1 ) , col ) ) , org . hamcrest . Matchers . is ( expected [ row ] [ col ] ) )", "total": "testStatusWithSummary ( ) { java . util . Collection < org . springframework . cloud . dataflow . rest . resource . AppStatusResource > data = new java . util . ArrayList ( ) ; data . add ( appStatusResource1 ) ; data . add ( appStatusResource2 ) ; data . add ( appStatusResource3 ) ; org . springframework . hateoas . PagedResources . PageMetadata metadata = new org . springframework . hateoas . PagedResources . PageMetadata ( data . size ( ) , 1 , data . size ( ) , 1 ) ; org . springframework . hateoas . PagedResources < org . springframework . cloud . dataflow . rest . resource . AppStatusResource > result = new org . springframework . hateoas . PagedResources ( data , metadata ) ; when ( runtimeOperations . status ( ) ) . thenReturn ( result ) ; java . lang . Object [ ] [ ] expected = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"1\" , \"deployed\" , \"2\" } , new java . lang . String [ ] { \"2\" , \"undeployed\" , \"0\" } , new java . lang . String [ ] { \"3\" , \"failed\" , \"0\" } } ; org . springframework . shell . table . TableModel model = runtimeCommands . list ( true , null ) . getModel ( ) ; for ( int row = 0 ; row < ( expected . length ) ; row ++ ) { for ( int col = 0 ; col < ( expected [ row ] . length ) ; col ++ ) { \"<AssertPlaceHolder>\" ; } } } getValue ( int , int ) { java . lang . String key = keys . get ( column ) ; if ( row == 0 ) { return key ; } int currentRow = row - 1 ; if ( ( mappings . get ( key ) . size ( ) ) > currentRow ) { return mappings . get ( key ) . get ( currentRow ) ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( java . lang . String . valueOf ( model . getValue ( ( row + 1 ) , col ) ) , org . hamcrest . Matchers . is ( expected [ row ] [ col ] ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "testSaveAndFindOne ( ) { org . zalando . catwatch . backend . model . Contributor kim = newContributor ( ) . name ( \"Kim\" ) . save ( ) ; org . zalando . catwatch . backend . model . Contributor loadedContributor = repository . findOne ( kim . getKey ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( loadedContributor . getName ( ) , org . hamcrest . Matchers . equalTo ( \"Kim\" ) )", "total": "testSaveAndFindOne ( ) { org . zalando . catwatch . backend . model . Contributor kim = newContributor ( ) . name ( \"Kim\" ) . save ( ) ; org . zalando . catwatch . backend . model . Contributor loadedContributor = repository . findOne ( kim . getKey ( ) ) ; \"<AssertPlaceHolder>\" ; } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( loadedContributor . getName ( ) , org . hamcrest . Matchers . equalTo ( \"Kim\" ) )"}
{"focal": "remove ( java . lang . Object , java . lang . Object ) { return delegate . remove ( key , value ) ; }", "testMethod": "testGeoRemove ( ) { K key = keyFactory . instance ( ) ; M member1 = valueFactory . instance ( ) ; geoOperations . add ( key , org . springframework . data . redis . core . DefaultGeoOperationsTests . POINT_PALERMO , member1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( geoOperations . remove ( key , member1 ) , org . hamcrest . core . Is . is ( 1L ) )", "total": "testGeoRemove ( ) { K key = keyFactory . instance ( ) ; M member1 = valueFactory . instance ( ) ; geoOperations . add ( key , org . springframework . data . redis . core . DefaultGeoOperationsTests . POINT_PALERMO , member1 ) ; \"<AssertPlaceHolder>\" ; } remove ( java . lang . Object , java . lang . Object ) { return delegate . remove ( key , value ) ; }", "answer": "org . junit . Assert . assertThat ( geoOperations . remove ( key , member1 ) , org . hamcrest . core . Is . is ( 1L ) )"}
{"focal": "sayHello ( ) { return \"Hello<sp>World!\" ; }", "testMethod": "shouldSayHelloToTheWorld ( ) { com . danidemi . tutorial . tdd . helloworld . Greeter greeter = new com . danidemi . tutorial . tdd . helloworld . Greeter ( ) ; java . lang . String helloMsg = greeter . sayHello ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( helloMsg , org . hamcrest . Matchers . equalTo ( \"Hello<sp>World!\" ) )", "total": "shouldSayHelloToTheWorld ( ) { com . danidemi . tutorial . tdd . helloworld . Greeter greeter = new com . danidemi . tutorial . tdd . helloworld . Greeter ( ) ; java . lang . String helloMsg = greeter . sayHello ( ) ; \"<AssertPlaceHolder>\" ; } sayHello ( ) { return \"Hello<sp>World!\" ; }", "answer": "org . junit . Assert . assertThat ( helloMsg , org . hamcrest . Matchers . equalTo ( \"Hello<sp>World!\" ) )"}
{"focal": "isFreshEnough ( ) { if ( ( latestAvailableRollupDate ) == null ) { return false ; } org . joda . time . DateMidnight earliestValidDate = comparisonDate ( ) . minusDays ( getMaxAllowedRollupAgeDays ( ) ) ; return ! ( latestAvailableRollupDate . isBefore ( earliestValidDate ) ) ; }", "testMethod": "rollupFreshEnoughWhenBetweenEarliestAllowedDayAndToday ( ) { final org . joda . time . DateMidnight latestRollupDate = new org . joda . time . DateMidnight ( 2013 , 10 , 7 ) ; final org . joda . time . DateMidnight today = new org . joda . time . DateMidnight ( 2013 , 10 , 8 ) ; final java . util . Date endDate = df . parse ( \"2013-10-12T01:00:00+0000\" ) ; final java . util . Date modifiedDate = df . parse ( \"2013-10-12T23:00:00+0000\" ) ; final com . intuit . wasabi . experimentobjects . Experiment . State state = com . intuit . wasabi . experimentobjects . Experiment . State . RUNNING ; final int maxAgeAllowedInDays = 2 ; com . intuit . wasabi . analytics . impl . Rollup rollup = rollupWith ( latestRollupDate , today , maxAgeAllowedInDays , endDate , modifiedDate , state ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rollup . isFreshEnough ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "rollupFreshEnoughWhenBetweenEarliestAllowedDayAndToday ( ) { final org . joda . time . DateMidnight latestRollupDate = new org . joda . time . DateMidnight ( 2013 , 10 , 7 ) ; final org . joda . time . DateMidnight today = new org . joda . time . DateMidnight ( 2013 , 10 , 8 ) ; final java . util . Date endDate = df . parse ( \"2013-10-12T01:00:00+0000\" ) ; final java . util . Date modifiedDate = df . parse ( \"2013-10-12T23:00:00+0000\" ) ; final com . intuit . wasabi . experimentobjects . Experiment . State state = com . intuit . wasabi . experimentobjects . Experiment . State . RUNNING ; final int maxAgeAllowedInDays = 2 ; com . intuit . wasabi . analytics . impl . Rollup rollup = rollupWith ( latestRollupDate , today , maxAgeAllowedInDays , endDate , modifiedDate , state ) ; \"<AssertPlaceHolder>\" ; } isFreshEnough ( ) { if ( ( latestAvailableRollupDate ) == null ) { return false ; } org . joda . time . DateMidnight earliestValidDate = comparisonDate ( ) . minusDays ( getMaxAllowedRollupAgeDays ( ) ) ; return ! ( latestAvailableRollupDate . isBefore ( earliestValidDate ) ) ; }", "answer": "org . junit . Assert . assertThat ( rollup . isFreshEnough ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "testMethod": "checkJsonSerialization ( ) { org . batfish . datamodel . StaticRoute sr = org . batfish . datamodel . StaticRoute . builder ( ) . setNextHopIp ( org . batfish . datamodel . Ip . parse ( \"192.168.1.1\" ) ) . setNetwork ( Prefix . ZERO ) . setNextHopInterface ( \"Ethernet0\" ) . setAdministrativeCost ( 1 ) . setTag ( 0 ) . setMetric ( 123 ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( sr , org . batfish . datamodel . StaticRoute . class ) , org . hamcrest . Matchers . equalTo ( sr ) )", "total": "checkJsonSerialization ( ) { org . batfish . datamodel . StaticRoute sr = org . batfish . datamodel . StaticRoute . builder ( ) . setNextHopIp ( org . batfish . datamodel . Ip . parse ( \"192.168.1.1\" ) ) . setNetwork ( Prefix . ZERO ) . setNextHopInterface ( \"Ethernet0\" ) . setAdministrativeCost ( 1 ) . setTag ( 0 ) . setMetric ( 123 ) . build ( ) ; \"<AssertPlaceHolder>\" ; } clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "answer": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( sr , org . batfish . datamodel . StaticRoute . class ) , org . hamcrest . Matchers . equalTo ( sr ) )"}
{"focal": "getParent ( ) { return parent ; }", "testMethod": "addingTaskElementToTaskGroupSetsTheParentProperty ( ) { org . libreplan . business . planner . entities . Task child = org . libreplan . business . test . planner . entities . TaskTest . createValidTask ( ) ; taskGroup . addTaskElement ( child ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( child . getParent ( ) , org . hamcrest . CoreMatchers . equalTo ( taskGroup ) )", "total": "addingTaskElementToTaskGroupSetsTheParentProperty ( ) { org . libreplan . business . planner . entities . Task child = org . libreplan . business . test . planner . entities . TaskTest . createValidTask ( ) ; taskGroup . addTaskElement ( child ) ; \"<AssertPlaceHolder>\" ; } getParent ( ) { return parent ; }", "answer": "org . junit . Assert . assertThat ( child . getParent ( ) , org . hamcrest . CoreMatchers . equalTo ( taskGroup ) )"}
{"focal": "create ( com . github . mygreen . supercsv . annotation . constraint . CsvNumberMax , java . util . Optional , com . github . mygreen . supercsv . builder . FieldAccessor , com . github . mygreen . supercsv . cellprocessor . format . TextFormatter , com . github . mygreen . supercsv . builder . Configuration ) { @ com . github . mygreen . supercsv . cellprocessor . constraint . SuppressWarnings ( \"unchecked\" ) final com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > typeFormatter = ( ( com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > ) ( formatter ) ) ; final N max ; try { max = typeFormatter . parse ( anno . value ( ) ) ; } catch ( com . github . mygreen . supercsv . cellprocessor . format . TextParseException e ) { throw new com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException ( anno , com . github . mygreen . supercsv . localization . MessageBuilder . create ( \"anno.attr.invalidType\" ) . var ( \"property\" , field . getNameWithClass ( ) ) . varWithAnno ( \"anno\" , anno . annotationType ( ) ) . var ( \"attrName\" , \"value\" ) . var ( \"attrValue\" , anno . value ( ) ) . varWithClass ( \"type\" , field . getType ( ) ) . var ( \"pattern\" , typeFormatter . getPattern ( ) . orElseGet ( null ) ) . format ( true ) , e ) ; } final com . github . mygreen . supercsv . cellprocessor . constraint . NumberMax < N > processor = next . map ( ( n ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter , n ) ) . orElseGet ( ( ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter ) ) ; processor . setValidationMessage ( anno . message ( ) ) ; return java . util . Optional . of ( processor ) ; }", "testMethod": "testCreate_wrong_maxSize ( ) { com . github . mygreen . supercsv . builder . FieldAccessor field = getFieldAccessor ( com . github . mygreen . supercsv . cellprocessor . conversion . TruncateFactoryTest . ErrorCsv . class , \"col_wrong_maxSize\" , comparator ) ; com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder builder = ( ( com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder ) ( builderResolver . resolve ( java . lang . String . class ) ) ) ; com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < java . lang . String > formatter = builder . getFormatter ( field , config ) ; com . github . mygreen . supercsv . annotation . conversion . CsvTruncate anno = field . getAnnotationsByGroup ( com . github . mygreen . supercsv . annotation . conversion . CsvTruncate . class , groupEmpty ) . get ( 0 ) ; try { factory . create ( anno , java . util . Optional . empty ( ) , field , formatter , config ) ; org . junit . Assert . fail ( ) ; } catch ( java . lang . Exception e ) { \"<AssertPlaceHolder>\" . isInstanceOf ( com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException . class ) . hasMessage ( \"'%s'<sp><sp>@CsvTruncate<sp><sp>'maxSize'<sp>01\" , field . getNameWithClass ( ) ) ; } }", "assertLine": "org . junit . Assert . assertThat ( e )", "total": "testCreate_wrong_maxSize ( ) { com . github . mygreen . supercsv . builder . FieldAccessor field = getFieldAccessor ( com . github . mygreen . supercsv . cellprocessor . conversion . TruncateFactoryTest . ErrorCsv . class , \"col_wrong_maxSize\" , comparator ) ; com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder builder = ( ( com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder ) ( builderResolver . resolve ( java . lang . String . class ) ) ) ; com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < java . lang . String > formatter = builder . getFormatter ( field , config ) ; com . github . mygreen . supercsv . annotation . conversion . CsvTruncate anno = field . getAnnotationsByGroup ( com . github . mygreen . supercsv . annotation . conversion . CsvTruncate . class , groupEmpty ) . get ( 0 ) ; try { factory . create ( anno , java . util . Optional . empty ( ) , field , formatter , config ) ; org . junit . Assert . fail ( ) ; } catch ( java . lang . Exception e ) { \"<AssertPlaceHolder>\" . isInstanceOf ( com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException . class ) . hasMessage ( \"'%s'<sp><sp>@CsvTruncate<sp><sp>'maxSize'<sp>01\" , field . getNameWithClass ( ) ) ; } } create ( com . github . mygreen . supercsv . annotation . constraint . CsvNumberMax , java . util . Optional , com . github . mygreen . supercsv . builder . FieldAccessor , com . github . mygreen . supercsv . cellprocessor . format . TextFormatter , com . github . mygreen . supercsv . builder . Configuration ) { @ com . github . mygreen . supercsv . cellprocessor . constraint . SuppressWarnings ( \"unchecked\" ) final com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > typeFormatter = ( ( com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > ) ( formatter ) ) ; final N max ; try { max = typeFormatter . parse ( anno . value ( ) ) ; } catch ( com . github . mygreen . supercsv . cellprocessor . format . TextParseException e ) { throw new com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException ( anno , com . github . mygreen . supercsv . localization . MessageBuilder . create ( \"anno.attr.invalidType\" ) . var ( \"property\" , field . getNameWithClass ( ) ) . varWithAnno ( \"anno\" , anno . annotationType ( ) ) . var ( \"attrName\" , \"value\" ) . var ( \"attrValue\" , anno . value ( ) ) . varWithClass ( \"type\" , field . getType ( ) ) . var ( \"pattern\" , typeFormatter . getPattern ( ) . orElseGet ( null ) ) . format ( true ) , e ) ; } final com . github . mygreen . supercsv . cellprocessor . constraint . NumberMax < N > processor = next . map ( ( n ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter , n ) ) . orElseGet ( ( ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter ) ) ; processor . setValidationMessage ( anno . message ( ) ) ; return java . util . Optional . of ( processor ) ; }", "answer": "org . junit . Assert . assertThat ( e )"}
{"focal": "firstCoversSecond ( com . fasterxml . jackson . databind . JsonNode , com . fasterxml . jackson . databind . JsonNode ) { if ( first . isValueNode ( ) ) { return ( second . isValueNode ( ) ) && ( first . equals ( second ) ) ; } else if ( first . isArray ( ) ) { if ( ! ( second . isArray ( ) ) ) { return false ; } for ( com . fasterxml . jackson . databind . JsonNode firstElement : first ) { boolean covered = false ; for ( com . fasterxml . jackson . databind . JsonNode secondElement : second ) { if ( org . batfish . datamodel . questions . Exclusion . firstCoversSecond ( firstElement , secondElement ) ) { covered = true ; break ; } } if ( ! covered ) { return false ; } } return true ; } else if ( first . isObject ( ) ) { if ( ! ( second . isObject ( ) ) ) { return false ; } java . util . Iterator < java . lang . String > firstKeys = first . fieldNames ( ) ; while ( firstKeys . hasNext ( ) ) { java . lang . String key = firstKeys . next ( ) ; if ( ( second . get ( key ) ) == null ) { return false ; } if ( ! ( org . batfish . datamodel . questions . Exclusion . firstCoversSecond ( first . get ( key ) , second . get ( key ) ) ) ) { return false ; } } return true ; } else { throw new org . batfish . common . BatfishException ( ( \"Missed<sp>some<sp>JsonNode<sp>type:<sp>\" + ( first . getNodeType ( ) ) ) ) ; } }", "testMethod": "firstCoversSecondArrayCovers ( ) { com . fasterxml . jackson . databind . JsonNode node1 = org . batfish . common . util . BatfishObjectMapper . mapper ( ) . createArrayNode ( ) . add ( new com . fasterxml . jackson . databind . node . TextNode ( \"value\" ) ) ; com . fasterxml . jackson . databind . JsonNode node2 = org . batfish . common . util . BatfishObjectMapper . mapper ( ) . createArrayNode ( ) . add ( new com . fasterxml . jackson . databind . node . TextNode ( \"value2\" ) ) . add ( new com . fasterxml . jackson . databind . node . TextNode ( \"value\" ) ) ; boolean result = org . batfish . datamodel . questions . Exclusion . firstCoversSecond ( node1 , node2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "firstCoversSecondArrayCovers ( ) { com . fasterxml . jackson . databind . JsonNode node1 = org . batfish . common . util . BatfishObjectMapper . mapper ( ) . createArrayNode ( ) . add ( new com . fasterxml . jackson . databind . node . TextNode ( \"value\" ) ) ; com . fasterxml . jackson . databind . JsonNode node2 = org . batfish . common . util . BatfishObjectMapper . mapper ( ) . createArrayNode ( ) . add ( new com . fasterxml . jackson . databind . node . TextNode ( \"value2\" ) ) . add ( new com . fasterxml . jackson . databind . node . TextNode ( \"value\" ) ) ; boolean result = org . batfish . datamodel . questions . Exclusion . firstCoversSecond ( node1 , node2 ) ; \"<AssertPlaceHolder>\" ; } firstCoversSecond ( com . fasterxml . jackson . databind . JsonNode , com . fasterxml . jackson . databind . JsonNode ) { if ( first . isValueNode ( ) ) { return ( second . isValueNode ( ) ) && ( first . equals ( second ) ) ; } else if ( first . isArray ( ) ) { if ( ! ( second . isArray ( ) ) ) { return false ; } for ( com . fasterxml . jackson . databind . JsonNode firstElement : first ) { boolean covered = false ; for ( com . fasterxml . jackson . databind . JsonNode secondElement : second ) { if ( org . batfish . datamodel . questions . Exclusion . firstCoversSecond ( firstElement , secondElement ) ) { covered = true ; break ; } } if ( ! covered ) { return false ; } } return true ; } else if ( first . isObject ( ) ) { if ( ! ( second . isObject ( ) ) ) { return false ; } java . util . Iterator < java . lang . String > firstKeys = first . fieldNames ( ) ; while ( firstKeys . hasNext ( ) ) { java . lang . String key = firstKeys . next ( ) ; if ( ( second . get ( key ) ) == null ) { return false ; } if ( ! ( org . batfish . datamodel . questions . Exclusion . firstCoversSecond ( first . get ( key ) , second . get ( key ) ) ) ) { return false ; } } return true ; } else { throw new org . batfish . common . BatfishException ( ( \"Missed<sp>some<sp>JsonNode<sp>type:<sp>\" + ( first . getNodeType ( ) ) ) ) ; } }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "getPorts ( ) { if ( ( ports ) == null ) { ports = new org . eclipse . emf . ecore . util . EObjectContainmentWithInverseEList < org . eclipse . elk . graph . ElkPort > ( org . eclipse . elk . graph . ElkPort . class , this , org . eclipse . elk . graph . ElkGraphPackage . ELK_NODE__PORTS , org . eclipse . elk . graph . ElkGraphPackage . ELK_PORT__PARENT ) ; } return ports ; }", "testMethod": "distributePortsOfGraph_GivenCrossOnEasternSide_ShouldRemoveCrossing ( ) { org . eclipse . elk . alg . layered . graph . LNode leftNode = addNodeToLayer ( makeLayer ( getGraph ( ) ) ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] rightNodes = addNodesToLayer ( 2 , makeLayer ( getGraph ( ) ) ) ; eastWestEdgeFromTo ( leftNode , rightNodes [ 1 ] ) ; eastWestEdgeFromTo ( leftNode , rightNodes [ 0 ] ) ; java . util . List < org . eclipse . elk . alg . layered . graph . LPort > expectedPortOrderLeftNode = copyPortsInIndexOrder ( leftNode , 1 , 0 ) ; distributePortsInCompleteGraph ( 4 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( leftNode . getPorts ( ) , org . hamcrest . CoreMatchers . is ( expectedPortOrderLeftNode ) )", "total": "distributePortsOfGraph_GivenCrossOnEasternSide_ShouldRemoveCrossing ( ) { org . eclipse . elk . alg . layered . graph . LNode leftNode = addNodeToLayer ( makeLayer ( getGraph ( ) ) ) ; org . eclipse . elk . alg . layered . graph . LNode [ ] rightNodes = addNodesToLayer ( 2 , makeLayer ( getGraph ( ) ) ) ; eastWestEdgeFromTo ( leftNode , rightNodes [ 1 ] ) ; eastWestEdgeFromTo ( leftNode , rightNodes [ 0 ] ) ; java . util . List < org . eclipse . elk . alg . layered . graph . LPort > expectedPortOrderLeftNode = copyPortsInIndexOrder ( leftNode , 1 , 0 ) ; distributePortsInCompleteGraph ( 4 ) ; \"<AssertPlaceHolder>\" ; } getPorts ( ) { if ( ( ports ) == null ) { ports = new org . eclipse . emf . ecore . util . EObjectContainmentWithInverseEList < org . eclipse . elk . graph . ElkPort > ( org . eclipse . elk . graph . ElkPort . class , this , org . eclipse . elk . graph . ElkGraphPackage . ELK_NODE__PORTS , org . eclipse . elk . graph . ElkGraphPackage . ELK_PORT__PARENT ) ; } return ports ; }", "answer": "org . junit . Assert . assertThat ( leftNode . getPorts ( ) , org . hamcrest . CoreMatchers . is ( expectedPortOrderLeftNode ) )"}
{"focal": "getConnectCount ( ) { return connectCount ; }", "testMethod": "testRetryMaxRetriesClassScopeConfig ( javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse ) { try { beanD . connectDMaxRetries2 ( ) ; org . junit . Assert . fail ( \"Exception<sp>not<sp>thrown\" ) ; } catch ( com . ibm . ws . microprofile . faulttolerance_fat . util . ConnectException e ) { } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( beanD . getConnectCount ( ) , org . hamcrest . Matchers . is ( 5 ) )", "total": "testRetryMaxRetriesClassScopeConfig ( javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse ) { try { beanD . connectDMaxRetries2 ( ) ; org . junit . Assert . fail ( \"Exception<sp>not<sp>thrown\" ) ; } catch ( com . ibm . ws . microprofile . faulttolerance_fat . util . ConnectException e ) { } \"<AssertPlaceHolder>\" ; } getConnectCount ( ) { return connectCount ; }", "answer": "org . junit . Assert . assertThat ( beanD . getConnectCount ( ) , org . hamcrest . Matchers . is ( 5 ) )"}
{"focal": "toStringWithoutApiVersion ( ) { return ( this . hostname ) + ( this . path ) ; }", "testMethod": "toStringWithoutApiVersionSuccess ( ) { final java . lang . String iotHubHostname = \"sample.iothubhostname\" ; final java . lang . String deviceId = \"sample-deviceid\" ; final java . lang . String iotHubMethodPath = \"/sample-path\" ; com . microsoft . azure . sdk . iot . device . net . IotHubUri uri = new com . microsoft . azure . sdk . iot . device . net . IotHubUri ( iotHubHostname , deviceId , iotHubMethodPath , null ) ; java . lang . String testUriStr = uri . toStringWithoutApiVersion ( ) ; final java . lang . String expectedUriStr = \"sample.iothubhostname/devices/sample-deviceid/sample-path\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testUriStr , org . hamcrest . CoreMatchers . is ( expectedUriStr ) )", "total": "toStringWithoutApiVersionSuccess ( ) { final java . lang . String iotHubHostname = \"sample.iothubhostname\" ; final java . lang . String deviceId = \"sample-deviceid\" ; final java . lang . String iotHubMethodPath = \"/sample-path\" ; com . microsoft . azure . sdk . iot . device . net . IotHubUri uri = new com . microsoft . azure . sdk . iot . device . net . IotHubUri ( iotHubHostname , deviceId , iotHubMethodPath , null ) ; java . lang . String testUriStr = uri . toStringWithoutApiVersion ( ) ; final java . lang . String expectedUriStr = \"sample.iothubhostname/devices/sample-deviceid/sample-path\" ; \"<AssertPlaceHolder>\" ; } toStringWithoutApiVersion ( ) { return ( this . hostname ) + ( this . path ) ; }", "answer": "org . junit . Assert . assertThat ( testUriStr , org . hamcrest . CoreMatchers . is ( expectedUriStr ) )"}
{"focal": "get ( ) { if ( ( webDriver ) == null ) { webDriver = this . driverBuilder . build ( ) ; this . setDriverTimeout ( ) ; } return webDriver ; }", "testMethod": "resultSQO_should_onlyKeepElementsThatPassThePredicateFunction ( ) { org . openqa . selenium . WebElement spanOne = testinfrastructure . testdouble . org . openqa . selenium . WebElementMother . createWebElementWithTag ( \"span\" ) ; org . openqa . selenium . WebElement notSpan = testinfrastructure . testdouble . org . openqa . selenium . WebElementMother . createWebElementWithTag ( \"div\" ) ; org . openqa . selenium . WebElement spanTwo = testinfrastructure . testdouble . org . openqa . selenium . WebElementMother . createWebElementWithTag ( \"span\" ) ; io . github . seleniumquery . SeleniumQueryObject targetSQO = testinfrastructure . testdouble . io . github . seleniumquery . SeleniumQueryObjectMother . createStubSeleniumQueryObjectWithElements ( spanOne , notSpan , spanTwo ) ; io . github . seleniumquery . SeleniumQueryObject resultSQO = filterPredicateFunction . filter ( targetSQO , ( e ) -> \"span\" . equals ( e . getTagName ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultSQO . get ( ) , contains ( spanOne , spanTwo ) )", "total": "resultSQO_should_onlyKeepElementsThatPassThePredicateFunction ( ) { org . openqa . selenium . WebElement spanOne = testinfrastructure . testdouble . org . openqa . selenium . WebElementMother . createWebElementWithTag ( \"span\" ) ; org . openqa . selenium . WebElement notSpan = testinfrastructure . testdouble . org . openqa . selenium . WebElementMother . createWebElementWithTag ( \"div\" ) ; org . openqa . selenium . WebElement spanTwo = testinfrastructure . testdouble . org . openqa . selenium . WebElementMother . createWebElementWithTag ( \"span\" ) ; io . github . seleniumquery . SeleniumQueryObject targetSQO = testinfrastructure . testdouble . io . github . seleniumquery . SeleniumQueryObjectMother . createStubSeleniumQueryObjectWithElements ( spanOne , notSpan , spanTwo ) ; io . github . seleniumquery . SeleniumQueryObject resultSQO = filterPredicateFunction . filter ( targetSQO , ( e ) -> \"span\" . equals ( e . getTagName ( ) ) ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( ( webDriver ) == null ) { webDriver = this . driverBuilder . build ( ) ; this . setDriverTimeout ( ) ; } return webDriver ; }", "answer": "org . junit . Assert . assertThat ( resultSQO . get ( ) , contains ( spanOne , spanTwo ) )"}
{"focal": "apply ( ) { indoubt ( \"ex1\" ) ; org . junit . Assert . assertThat ( count ( production1 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( count ( production2 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( testee . apply ( \"__UNKNOWN__\" ) , is ( false ) ) ; org . junit . Assert . assertThat ( count ( production1 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( count ( production2 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( testee . apply ( \"ex1\" ) , is ( true ) ) ; org . junit . Assert . assertThat ( count ( production1 ) , is ( 1 ) ) ; org . junit . Assert . assertThat ( count ( production2 ) , is ( 1 ) ) ; org . junit . Assert . assertThat ( testee . apply ( \"ex1\" ) , is ( false ) ) ; }", "testMethod": "plain ( ) { com . asakusafw . runtime . stage . directio . StringTemplateTest . Mock mock = new com . asakusafw . runtime . stage . directio . StringTemplateTest . Mock ( plain ( \"Hello,<sp>world!\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mock . apply ( ) , is ( \"Hello,<sp>world!\" ) )", "total": "plain ( ) { com . asakusafw . runtime . stage . directio . StringTemplateTest . Mock mock = new com . asakusafw . runtime . stage . directio . StringTemplateTest . Mock ( plain ( \"Hello,<sp>world!\" ) ) ; \"<AssertPlaceHolder>\" ; } apply ( ) { indoubt ( \"ex1\" ) ; org . junit . Assert . assertThat ( count ( production1 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( count ( production2 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( testee . apply ( \"__UNKNOWN__\" ) , is ( false ) ) ; org . junit . Assert . assertThat ( count ( production1 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( count ( production2 ) , is ( 0 ) ) ; org . junit . Assert . assertThat ( testee . apply ( \"ex1\" ) , is ( true ) ) ; org . junit . Assert . assertThat ( count ( production1 ) , is ( 1 ) ) ; org . junit . Assert . assertThat ( count ( production2 ) , is ( 1 ) ) ; org . junit . Assert . assertThat ( testee . apply ( \"ex1\" ) , is ( false ) ) ; }", "answer": "org . junit . Assert . assertThat ( mock . apply ( ) , is ( \"Hello,<sp>world!\" ) )"}
{"focal": "size ( ) { return itemRegistry . getAll ( ) . size ( ) ; }", "testMethod": "testGetAll ( ) { java . util . stream . Stream < org . eclipse . smarthome . core . thing . profiles . dto . ProfileTypeDTO > result = ressource . getProfileTypes ( null , null , null ) ; java . util . List < org . eclipse . smarthome . core . thing . profiles . dto . ProfileTypeDTO > list = result . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 4 ) )", "total": "testGetAll ( ) { java . util . stream . Stream < org . eclipse . smarthome . core . thing . profiles . dto . ProfileTypeDTO > result = ressource . getProfileTypes ( null , null , null ) ; java . util . List < org . eclipse . smarthome . core . thing . profiles . dto . ProfileTypeDTO > list = result . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return itemRegistry . getAll ( ) . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 4 ) )"}
{"focal": "getAll ( ) { return list ; }", "testMethod": "testMultple_load_sheet_skip_notFound2 ( ) { com . gh . mygreen . xlsmapper . XlsMapper mapper = new com . gh . mygreen . xlsmapper . XlsMapper ( ) ; mapper . getConiguration ( ) . setContinueTypeBindFailure ( true ) . setIgnoreSheetNotFound ( true ) ; try ( java . io . InputStream in = new java . io . FileInputStream ( inputFile ) ) { com . gh . mygreen . xlsmapper . validation . MultipleSheetBindingErrors < ? > errors = mapper . loadMultipleDetail ( in , new java . lang . Class [ ] { com . gh . mygreen . xlsmapper . fieldprocessor . AnnoSheetTest . NamedSheet2 . class } ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( errors . getAll ( ) )", "total": "testMultple_load_sheet_skip_notFound2 ( ) { com . gh . mygreen . xlsmapper . XlsMapper mapper = new com . gh . mygreen . xlsmapper . XlsMapper ( ) ; mapper . getConiguration ( ) . setContinueTypeBindFailure ( true ) . setIgnoreSheetNotFound ( true ) ; try ( java . io . InputStream in = new java . io . FileInputStream ( inputFile ) ) { com . gh . mygreen . xlsmapper . validation . MultipleSheetBindingErrors < ? > errors = mapper . loadMultipleDetail ( in , new java . lang . Class [ ] { com . gh . mygreen . xlsmapper . fieldprocessor . AnnoSheetTest . NamedSheet2 . class } ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; } } getAll ( ) { return list ; }", "answer": "org . junit . Assert . assertThat ( errors . getAll ( ) )"}
{"focal": "match ( org . mule . runtime . api . message . ErrorType ) { return errorTypeMatchers . stream ( ) . anyMatch ( ( errorTypeMatcher ) -> errorTypeMatcher . match ( errorType ) ) ; }", "testMethod": "noMatch ( ) { org . mule . runtime . api . message . ErrorType mockErrorType = mock ( org . mule . runtime . api . message . ErrorType . class ) ; when ( mockErrorType . getParentErrorType ( ) ) . thenReturn ( anyErrorType ) ; org . mule . runtime . core . api . exception . ErrorTypeMatcher matcherWithTwoTransformation = createMatcher ( transformationErrorType , expressionErrorType ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( matcherWithTwoTransformation . match ( mockErrorType ) , org . hamcrest . Matchers . is ( false ) )", "total": "noMatch ( ) { org . mule . runtime . api . message . ErrorType mockErrorType = mock ( org . mule . runtime . api . message . ErrorType . class ) ; when ( mockErrorType . getParentErrorType ( ) ) . thenReturn ( anyErrorType ) ; org . mule . runtime . core . api . exception . ErrorTypeMatcher matcherWithTwoTransformation = createMatcher ( transformationErrorType , expressionErrorType ) ; \"<AssertPlaceHolder>\" ; } match ( org . mule . runtime . api . message . ErrorType ) { return errorTypeMatchers . stream ( ) . anyMatch ( ( errorTypeMatcher ) -> errorTypeMatcher . match ( errorType ) ) ; }", "answer": "org . junit . Assert . assertThat ( matcherWithTwoTransformation . match ( mockErrorType ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "get ( ) { return java . util . concurrent . CompletableFuture . completedFuture ( value . get ( ) ) ; }", "testMethod": "testValueAs ( ) { org . onosproject . net . resource . DiscreteResource resource = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . resource . DiscreteResourceTest . D1 ) . resource ( ) ; java . util . Optional < org . onosproject . net . DeviceId > volume = resource . valueAs ( org . onosproject . net . DeviceId . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( volume . get ( ) , org . hamcrest . Matchers . is ( org . onosproject . net . resource . DiscreteResourceTest . D1 ) )", "total": "testValueAs ( ) { org . onosproject . net . resource . DiscreteResource resource = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . resource . DiscreteResourceTest . D1 ) . resource ( ) ; java . util . Optional < org . onosproject . net . DeviceId > volume = resource . valueAs ( org . onosproject . net . DeviceId . class ) ; \"<AssertPlaceHolder>\" ; } get ( ) { return java . util . concurrent . CompletableFuture . completedFuture ( value . get ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( volume . get ( ) , org . hamcrest . Matchers . is ( org . onosproject . net . resource . DiscreteResourceTest . D1 ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsNotEqualsGroupId ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetMplsTtl obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetMplsTtl ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsNotEqualsGroupId ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetMplsTtl obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetMplsTtl ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isNotificationNeeded ( ) { return notificationNeeded ; }", "testMethod": "mapSupport3 ( ) { java . util . Map < java . lang . String , java . lang . Object > oldValues = new java . util . HashMap ( ) ; oldValues . put ( \"a\" , \"this\" ) ; java . util . Map < java . lang . String , java . lang . Object > newValues = new java . util . HashMap ( ) ; newValues . put ( \"a\" , \"this\" ) ; org . diirt . datasource . Notification < java . util . Map < java . lang . String , java . lang . Object > > notification = org . diirt . datasource . NotificationSupport . notification ( oldValues , newValues ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( notification . isNotificationNeeded ( ) , equalTo ( false ) )", "total": "mapSupport3 ( ) { java . util . Map < java . lang . String , java . lang . Object > oldValues = new java . util . HashMap ( ) ; oldValues . put ( \"a\" , \"this\" ) ; java . util . Map < java . lang . String , java . lang . Object > newValues = new java . util . HashMap ( ) ; newValues . put ( \"a\" , \"this\" ) ; org . diirt . datasource . Notification < java . util . Map < java . lang . String , java . lang . Object > > notification = org . diirt . datasource . NotificationSupport . notification ( oldValues , newValues ) ; \"<AssertPlaceHolder>\" ; } isNotificationNeeded ( ) { return notificationNeeded ; }", "answer": "org . junit . Assert . assertThat ( notification . isNotificationNeeded ( ) , equalTo ( false ) )"}
{"focal": "sort ( java . util . Comparator ) { throw new java . lang . UnsupportedOperationException ( ( \"This<sp>list<sp>uses<sp>a<sp>fixed<sp>monotonically<sp>increasing<sp>\" + \"order<sp>of<sp>insertion<sp>indexing.\" ) ) ; }", "testMethod": "shouldOrderByQuality ( ) { org . dcache . util . QualityValue qvalue1 = org . dcache . util . QualityValue . of ( \"value1;q=1\" ) ; org . dcache . util . QualityValue qvalue2 = org . dcache . util . QualityValue . of ( \"value2;q=0.5\" ) ; java . util . List < org . dcache . util . QualityValue > expected = java . util . Arrays . asList ( qvalue1 , qvalue2 ) ; java . util . List < org . dcache . util . QualityValue > actual = java . util . Arrays . asList ( qvalue1 , qvalue2 ) ; actual . sort ( java . util . Comparator . naturalOrder ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expected ) ) )", "total": "shouldOrderByQuality ( ) { org . dcache . util . QualityValue qvalue1 = org . dcache . util . QualityValue . of ( \"value1;q=1\" ) ; org . dcache . util . QualityValue qvalue2 = org . dcache . util . QualityValue . of ( \"value2;q=0.5\" ) ; java . util . List < org . dcache . util . QualityValue > expected = java . util . Arrays . asList ( qvalue1 , qvalue2 ) ; java . util . List < org . dcache . util . QualityValue > actual = java . util . Arrays . asList ( qvalue1 , qvalue2 ) ; actual . sort ( java . util . Comparator . naturalOrder ( ) ) ; \"<AssertPlaceHolder>\" ; } sort ( java . util . Comparator ) { throw new java . lang . UnsupportedOperationException ( ( \"This<sp>list<sp>uses<sp>a<sp>fixed<sp>monotonically<sp>increasing<sp>\" + \"order<sp>of<sp>insertion<sp>indexing.\" ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expected ) ) )"}
{"focal": "mkString ( ) { return mkString ( \"\" , \"\" , \"\" ) ; }", "testMethod": "mkString_A$ ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . String actual = nil . mkString ( ) ; java . lang . String expected = \"\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "mkString_A$ ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . String actual = nil . mkString ( ) ; java . lang . String expected = \"\" ; \"<AssertPlaceHolder>\" ; } mkString ( ) { return mkString ( \"\" , \"\" , \"\" ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "is ( T ) { return new com . oracle . bedrock . predicate . Is < T > ( new com . oracle . bedrock . predicate . EqualTo < T > ( value ) ) ; }", "testMethod": "shouldRealizeWithPropertiesBuilderOverrides ( ) { com . oracle . bedrock . runtime . PropertiesBuilder overrides = new com . oracle . bedrock . runtime . PropertiesBuilder ( ) ; overrides . setProperty ( \"Key-1\" , \"Value-1\" ) ; overrides . setProperty ( \"Key-2\" , \"Value-2\" ) ; com . oracle . bedrock . runtime . PropertiesBuilder builder = new com . oracle . bedrock . runtime . PropertiesBuilder ( ) ; builder . setProperty ( \"Key-1\" , \"Value-1-1\" ) ; builder . setProperty ( \"Key-2\" , \"Value-2-1\" ) ; builder . setProperty ( \"Key-3\" , \"Value-3-1\" ) ; java . util . Properties expected = new java . util . Properties ( ) ; expected . setProperty ( \"Key-1\" , \"Value-1\" ) ; expected . setProperty ( \"Key-2\" , \"Value-2\" ) ; expected . setProperty ( \"Key-3\" , \"Value-3-1\" ) ; java . util . Properties properties = builder . realize ( overrides ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( properties , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldRealizeWithPropertiesBuilderOverrides ( ) { com . oracle . bedrock . runtime . PropertiesBuilder overrides = new com . oracle . bedrock . runtime . PropertiesBuilder ( ) ; overrides . setProperty ( \"Key-1\" , \"Value-1\" ) ; overrides . setProperty ( \"Key-2\" , \"Value-2\" ) ; com . oracle . bedrock . runtime . PropertiesBuilder builder = new com . oracle . bedrock . runtime . PropertiesBuilder ( ) ; builder . setProperty ( \"Key-1\" , \"Value-1-1\" ) ; builder . setProperty ( \"Key-2\" , \"Value-2-1\" ) ; builder . setProperty ( \"Key-3\" , \"Value-3-1\" ) ; java . util . Properties expected = new java . util . Properties ( ) ; expected . setProperty ( \"Key-1\" , \"Value-1\" ) ; expected . setProperty ( \"Key-2\" , \"Value-2\" ) ; expected . setProperty ( \"Key-3\" , \"Value-3-1\" ) ; java . util . Properties properties = builder . realize ( overrides ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return new com . oracle . bedrock . predicate . Is < T > ( new com . oracle . bedrock . predicate . EqualTo < T > ( value ) ) ; }", "answer": "org . junit . Assert . assertThat ( properties , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "transform ( java . lang . String ) { java . util . Properties properties = new java . util . Properties ( ) ; try { properties . load ( new java . io . StringReader ( propertiesString ) ) ; } catch ( java . io . IOException e ) { Logger . error ( \"Error<sp>to<sp>load<sp>properties<sp>from<sp>String<sp>\" ) ; } return properties ; }", "testMethod": "whenPropertiesHaveValuesThenReturnStringWithLines ( ) { properties . put ( CT_KEY_VALUE_1 , CT_KEY_VALUE_1 ) ; properties . put ( CT_KEY_VALUE_2 , CT_KEY_VALUE_2 ) ; java . lang . String result = ( ( ( ( ( ( CT_KEY_VALUE_1 ) + \"=\" ) + ( CT_KEY_VALUE_1 ) ) + ( CT_LINE_SEPARATOR ) ) + ( CT_KEY_VALUE_2 ) ) + \"=\" ) + ( CT_KEY_VALUE_2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( converter . transform ( properties ) , org . hamcrest . Matchers . is ( result ) )", "total": "whenPropertiesHaveValuesThenReturnStringWithLines ( ) { properties . put ( CT_KEY_VALUE_1 , CT_KEY_VALUE_1 ) ; properties . put ( CT_KEY_VALUE_2 , CT_KEY_VALUE_2 ) ; java . lang . String result = ( ( ( ( ( ( CT_KEY_VALUE_1 ) + \"=\" ) + ( CT_KEY_VALUE_1 ) ) + ( CT_LINE_SEPARATOR ) ) + ( CT_KEY_VALUE_2 ) ) + \"=\" ) + ( CT_KEY_VALUE_2 ) ; \"<AssertPlaceHolder>\" ; } transform ( java . lang . String ) { java . util . Properties properties = new java . util . Properties ( ) ; try { properties . load ( new java . io . StringReader ( propertiesString ) ) ; } catch ( java . io . IOException e ) { Logger . error ( \"Error<sp>to<sp>load<sp>properties<sp>from<sp>String<sp>\" ) ; } return properties ; }", "answer": "org . junit . Assert . assertThat ( converter . transform ( properties ) , org . hamcrest . Matchers . is ( result ) )"}
{"focal": "compareTo ( com . openpojo . reflection . java . version . Version ) { int idx = 0 ; java . lang . Integer leftPart ; java . lang . Integer rightPart ; do { leftPart = this . getPart ( idx ) ; rightPart = right . getPart ( idx ) ; idx ++ ; if ( ( leftPart == null ) && ( rightPart == null ) ) return 0 ; if ( leftPart == null ) return - 1 ; if ( rightPart == null ) return 1 ; if ( leftPart < rightPart ) return - 1 ; if ( leftPart > rightPart ) return 1 ; } while ( true ) ; }", "testMethod": "compareTwoEmptyVersionsAsEqual ( ) { com . openpojo . reflection . java . version . Version left = com . openpojo . reflection . java . version . VersionFactory . getVersion ( \"\" ) ; com . openpojo . reflection . java . version . Version right = com . openpojo . reflection . java . version . VersionFactory . getVersion ( \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( left . compareTo ( right ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "compareTwoEmptyVersionsAsEqual ( ) { com . openpojo . reflection . java . version . Version left = com . openpojo . reflection . java . version . VersionFactory . getVersion ( \"\" ) ; com . openpojo . reflection . java . version . Version right = com . openpojo . reflection . java . version . VersionFactory . getVersion ( \"\" ) ; \"<AssertPlaceHolder>\" ; } compareTo ( com . openpojo . reflection . java . version . Version ) { int idx = 0 ; java . lang . Integer leftPart ; java . lang . Integer rightPart ; do { leftPart = this . getPart ( idx ) ; rightPart = right . getPart ( idx ) ; idx ++ ; if ( ( leftPart == null ) && ( rightPart == null ) ) return 0 ; if ( leftPart == null ) return - 1 ; if ( rightPart == null ) return 1 ; if ( leftPart < rightPart ) return - 1 ; if ( leftPart > rightPart ) return 1 ; } while ( true ) ; }", "answer": "org . junit . Assert . assertThat ( left . compareTo ( right ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "toString ( ) { return ( ( ( ( \"JavaParserTypeSolver{\" + \"srcDir=\" ) + ( srcDir ) ) + \",<sp>parent=\" ) + ( parent ) ) + '}' ; }", "testMethod": "testPostgreSQLText ( ) { for ( java . lang . String [ ] test : sqlTransformTests ) { java . lang . String expected = test [ 1 ] ; com . impossibl . postgres . jdbc . SQLText sqlText = new com . impossibl . postgres . jdbc . SQLText ( test [ 0 ] ) ; com . impossibl . postgres . jdbc . SQLTextEscapes . processEscapes ( sqlText , null ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( sqlText . toString ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "testPostgreSQLText ( ) { for ( java . lang . String [ ] test : sqlTransformTests ) { java . lang . String expected = test [ 1 ] ; com . impossibl . postgres . jdbc . SQLText sqlText = new com . impossibl . postgres . jdbc . SQLText ( test [ 0 ] ) ; com . impossibl . postgres . jdbc . SQLTextEscapes . processEscapes ( sqlText , null ) ; \"<AssertPlaceHolder>\" ; } } toString ( ) { return ( ( ( ( \"JavaParserTypeSolver{\" + \"srcDir=\" ) + ( srcDir ) ) + \",<sp>parent=\" ) + ( parent ) ) + '}' ; }", "answer": "org . junit . Assert . assertThat ( sqlText . toString ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "getDiscount ( io . redutan . antioop . noif . DiscountRequest ) { long productAmt = request . getProductAmt ( ) ; java . lang . String discountCode = request . getDiscountCode ( ) ; long discountAmt = getDiscountAmt ( discountCode , productAmt ) ; return io . redutan . antioop . noif . Discount . of ( discountAmt ) ; }", "testMethod": "getDiscount_Invalid ( ) { io . redutan . antioop . noif . DiscountRequest request1 = new io . redutan . antioop . noif . DiscountRequest ( \"ABCDEFG\" , 10000 ) ; io . redutan . antioop . noif . Discount discount1 = service . getDiscount ( request1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( discount1 . getDiscountAmt ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "getDiscount_Invalid ( ) { io . redutan . antioop . noif . DiscountRequest request1 = new io . redutan . antioop . noif . DiscountRequest ( \"ABCDEFG\" , 10000 ) ; io . redutan . antioop . noif . Discount discount1 = service . getDiscount ( request1 ) ; \"<AssertPlaceHolder>\" ; } getDiscount ( io . redutan . antioop . noif . DiscountRequest ) { long productAmt = request . getProductAmt ( ) ; java . lang . String discountCode = request . getDiscountCode ( ) ; long discountAmt = getDiscountAmt ( discountCode , productAmt ) ; return io . redutan . antioop . noif . Discount . of ( discountAmt ) ; }", "answer": "org . junit . Assert . assertThat ( discount1 . getDiscountAmt ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "not ( com . asakusafw . testdriver . rule . ValuePredicate ) { if ( predicate == null ) { throw new java . lang . IllegalArgumentException ( \"predicate<sp>must<sp>not<sp>be<sp>null\" ) ; } return new com . asakusafw . testdriver . rule . Not ( predicate ) ; }", "testMethod": "simple ( ) { java . io . File root = add ( \"root\" , \"/\" , \"a.txt\" ) ; invoke ( \"delete\" , \"a.txt\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( root , not ( exists ( \"a.txt\" ) ) )", "total": "simple ( ) { java . io . File root = add ( \"root\" , \"/\" , \"a.txt\" ) ; invoke ( \"delete\" , \"a.txt\" ) ; \"<AssertPlaceHolder>\" ; } not ( com . asakusafw . testdriver . rule . ValuePredicate ) { if ( predicate == null ) { throw new java . lang . IllegalArgumentException ( \"predicate<sp>must<sp>not<sp>be<sp>null\" ) ; } return new com . asakusafw . testdriver . rule . Not ( predicate ) ; }", "answer": "org . junit . Assert . assertThat ( root , not ( exists ( \"a.txt\" ) ) )"}
{"focal": "size ( ) { return fieldErrors . size ( ) ; }", "testMethod": "shouldRetrieveAllParentOfficesOfLevelAsOfficeDtos ( ) { java . util . List < org . mifos . dto . domain . OfficeDto > allOffices = officeDao . findActiveParents ( OfficeLevel . HEADOFFICE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allOffices . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "shouldRetrieveAllParentOfficesOfLevelAsOfficeDtos ( ) { java . util . List < org . mifos . dto . domain . OfficeDto > allOffices = officeDao . findActiveParents ( OfficeLevel . HEADOFFICE ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return fieldErrors . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( allOffices . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getOrElse ( T ) { return defaultValue ; }", "testMethod": "__A$Long ( ) { com . m3 . scalaflavor4j . SLong actual = com . m3 . scalaflavor4j . SLong . apply ( 123L ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . getOrElse ( 0L ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 123L ) ) )", "total": "__A$Long ( ) { com . m3 . scalaflavor4j . SLong actual = com . m3 . scalaflavor4j . SLong . apply ( 123L ) ; \"<AssertPlaceHolder>\" ; } getOrElse ( T ) { return defaultValue ; }", "answer": "org . junit . Assert . assertThat ( actual . getOrElse ( 0L ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 123L ) ) )"}
{"focal": "exportsResource ( java . lang . String ) { checkArgument ( ( name != null ) , \"Resource<sp>name<sp>cannot<sp>be<sp>null\" ) ; final java . lang . String sanitizeResourceName = sanitizeResourceName ( name ) ; return exportedResources . contains ( sanitizeResourceName ) ; }", "testMethod": "validatesEmptyResourceName ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filter . exportsResource ( \"\" ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "validatesEmptyResourceName ( ) { \"<AssertPlaceHolder>\" ; } exportsResource ( java . lang . String ) { checkArgument ( ( name != null ) , \"Resource<sp>name<sp>cannot<sp>be<sp>null\" ) ; final java . lang . String sanitizeResourceName = sanitizeResourceName ( name ) ; return exportedResources . contains ( sanitizeResourceName ) ; }", "answer": "org . junit . Assert . assertThat ( filter . exportsResource ( \"\" ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "getConnection ( ) { return null ; }", "testMethod": "doNotInsertAMovieWithUnknownPublisher ( ) { java . io . InputStream initialDataSetResource = getClass ( ) . getResourceAsStream ( ( ( ( ( getClass ( ) . getSimpleName ( ) ) + \".\" ) + ( testName . getMethodName ( ) ) ) + \".xml\" ) ) ; org . dbunit . dataset . xml . XmlDataSet initialDataSet = new org . dbunit . dataset . xml . XmlDataSet ( initialDataSetResource ) ; org . dbunit . database . IDatabaseConnection conn = dbTester . getConnection ( ) ; DatabaseOperation . CLEAN_INSERT . execute ( conn , initialDataSet ) ; int originalNumberOfMovies = initialDataSet . getTable ( \"Movie\" ) . getRowCount ( ) ; com . danidemi . tutorial . tdd . showcase . dbunit . MovieDao tested = new com . danidemi . tutorial . tdd . showcase . dbunit . MovieDao ( ) ; try { tested . createMovie ( dbTester . getConnection ( ) . getConnection ( ) , \"MyMovie\" , 1999 , \"Unknow<sp>Movies<sp>Production\" ) ; } catch ( java . lang . IllegalArgumentException iae ) { } catch ( java . lang . Exception e ) { org . junit . Assert . fail ( ) ; } int moviesCount = conn . getRowCount ( \"Movie\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( moviesCount , org . hamcrest . Matchers . equalTo ( originalNumberOfMovies ) )", "total": "doNotInsertAMovieWithUnknownPublisher ( ) { java . io . InputStream initialDataSetResource = getClass ( ) . getResourceAsStream ( ( ( ( ( getClass ( ) . getSimpleName ( ) ) + \".\" ) + ( testName . getMethodName ( ) ) ) + \".xml\" ) ) ; org . dbunit . dataset . xml . XmlDataSet initialDataSet = new org . dbunit . dataset . xml . XmlDataSet ( initialDataSetResource ) ; org . dbunit . database . IDatabaseConnection conn = dbTester . getConnection ( ) ; DatabaseOperation . CLEAN_INSERT . execute ( conn , initialDataSet ) ; int originalNumberOfMovies = initialDataSet . getTable ( \"Movie\" ) . getRowCount ( ) ; com . danidemi . tutorial . tdd . showcase . dbunit . MovieDao tested = new com . danidemi . tutorial . tdd . showcase . dbunit . MovieDao ( ) ; try { tested . createMovie ( dbTester . getConnection ( ) . getConnection ( ) , \"MyMovie\" , 1999 , \"Unknow<sp>Movies<sp>Production\" ) ; } catch ( java . lang . IllegalArgumentException iae ) { } catch ( java . lang . Exception e ) { org . junit . Assert . fail ( ) ; } int moviesCount = conn . getRowCount ( \"Movie\" ) ; \"<AssertPlaceHolder>\" ; } getConnection ( ) { return null ; }", "answer": "org . junit . Assert . assertThat ( moviesCount , org . hamcrest . Matchers . equalTo ( originalNumberOfMovies ) )"}
{"focal": "submitComments ( hudson . model . Run , java . io . PrintStream , java . lang . String , java . util . Set , hudson . plugins . jira . JiraSession , boolean , boolean , java . lang . String , java . lang . String ) { java . util . Set < hudson . plugins . jira . model . JiraIssue > copy = com . google . common . collect . ImmutableSet . copyOf ( issues ) ; for ( hudson . plugins . jira . model . JiraIssue issue : copy ) { logger . println ( hudson . plugins . jira . Messages . UpdatingIssue (", "testMethod": "issueIsRemovedFromCarryOverListAfterSubmission ( ) { hudson . model . FreeStyleBuild build = mock ( hudson . model . FreeStyleBuild . class ) ; hudson . model . FreeStyleProject project = mock ( hudson . model . FreeStyleProject . class ) ; when ( build . getProject ( ) ) . thenReturn ( project ) ; hudson . scm . ChangeLogSet changeLogSet = hudson . scm . ChangeLogSet . createEmpty ( build ) ; when ( build . getChangeSet ( ) ) . thenReturn ( changeLogSet ) ; when ( build . getResult ( ) ) . thenReturn ( Result . SUCCESS ) ; final hudson . plugins . jira . model . JiraIssue firstIssue = new hudson . plugins . jira . model . JiraIssue ( \"FOOBAR-1\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue secondIssue = new hudson . plugins . jira . model . JiraIssue ( \"ALIBA-1\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue thirdIssue = new hudson . plugins . jira . model . JiraIssue ( \"MOONA-1\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue deletedIssue = new hudson . plugins . jira . model . JiraIssue ( \"FOOBAR-2\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue forbiddenIssue = new hudson . plugins . jira . model . JiraIssue ( \"LASSO-17\" , \"Title\" ) ; java . util . Set < hudson . plugins . jira . model . JiraIssue > issues = com . google . common . collect . Sets . newHashSet ( firstIssue , secondIssue , forbiddenIssue , thirdIssue ) ; hudson . plugins . jira . JiraSession session = mock ( hudson . plugins . jira . JiraSession . class ) ; final java . util . List < com . atlassian . jira . rest . client . api . domain . Comment > comments = new java . util . ArrayList ( ) ; org . mockito . stubbing . Answer answer = ( ( org . mockito . stubbing . Answer < java . lang . Object > ) ( ( invocation ) -> { com . atlassian . jira . rest . client . api . domain . Comment c = com . atlassian . jira . rest . client . api . domain . Comment . createWithGroupLevel ( ( ( java . lang . String ) ( invocation . getArguments ( ) [ 0 ] ) ) , ( ( java . lang . String ) ( invocation . getArguments ( ) [ 1 ] ) ) ) ; comments . add ( c ) ; return null ; } ) ) ; doAnswer ( answer ) . when ( session ) . addComment ( eq ( firstIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doAnswer ( answer ) . when ( session ) . addComment ( eq ( secondIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doAnswer ( answer ) . when ( session ) . addComment ( eq ( thirdIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doThrow ( new com . atlassian . jira . rest . client . api . RestClientException ( new java . lang . Throwable ( ) , 404 ) ) . when ( session ) . addComment ( eq ( deletedIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doThrow ( new com . atlassian . jira . rest . client . api . RestClientException ( new java . lang . Throwable ( ) , 403 ) ) . when ( session ) . addComment ( eq ( forbiddenIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; final java . lang . String groupVisibility = \"\" ; final java . lang . String roleVisibility = \"\" ; hudson . plugins . jira . Updater updaterCurrent = new hudson . plugins . jira . Updater ( build . getParent ( ) . getScm ( ) ) ; updaterCurrent . submitComments ( build , System . out , \"http://jenkins\" , issues , session , false , false , groupVisibility , roleVisibility ) ; final java . util . Set < hudson . plugins . jira . model . JiraIssue > expectedIssuesToCarryOver = com . google . common . collect . Sets . newLinkedHashSet ( ) ; expectedIssuesToCarryOver . add ( forbiddenIssue ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( issues , org . hamcrest . CoreMatchers . is ( expectedIssuesToCarryOver ) )", "total": "issueIsRemovedFromCarryOverListAfterSubmission ( ) { hudson . model . FreeStyleBuild build = mock ( hudson . model . FreeStyleBuild . class ) ; hudson . model . FreeStyleProject project = mock ( hudson . model . FreeStyleProject . class ) ; when ( build . getProject ( ) ) . thenReturn ( project ) ; hudson . scm . ChangeLogSet changeLogSet = hudson . scm . ChangeLogSet . createEmpty ( build ) ; when ( build . getChangeSet ( ) ) . thenReturn ( changeLogSet ) ; when ( build . getResult ( ) ) . thenReturn ( Result . SUCCESS ) ; final hudson . plugins . jira . model . JiraIssue firstIssue = new hudson . plugins . jira . model . JiraIssue ( \"FOOBAR-1\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue secondIssue = new hudson . plugins . jira . model . JiraIssue ( \"ALIBA-1\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue thirdIssue = new hudson . plugins . jira . model . JiraIssue ( \"MOONA-1\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue deletedIssue = new hudson . plugins . jira . model . JiraIssue ( \"FOOBAR-2\" , \"Title\" ) ; final hudson . plugins . jira . model . JiraIssue forbiddenIssue = new hudson . plugins . jira . model . JiraIssue ( \"LASSO-17\" , \"Title\" ) ; java . util . Set < hudson . plugins . jira . model . JiraIssue > issues = com . google . common . collect . Sets . newHashSet ( firstIssue , secondIssue , forbiddenIssue , thirdIssue ) ; hudson . plugins . jira . JiraSession session = mock ( hudson . plugins . jira . JiraSession . class ) ; final java . util . List < com . atlassian . jira . rest . client . api . domain . Comment > comments = new java . util . ArrayList ( ) ; org . mockito . stubbing . Answer answer = ( ( org . mockito . stubbing . Answer < java . lang . Object > ) ( ( invocation ) -> { com . atlassian . jira . rest . client . api . domain . Comment c = com . atlassian . jira . rest . client . api . domain . Comment . createWithGroupLevel ( ( ( java . lang . String ) ( invocation . getArguments ( ) [ 0 ] ) ) , ( ( java . lang . String ) ( invocation . getArguments ( ) [ 1 ] ) ) ) ; comments . add ( c ) ; return null ; } ) ) ; doAnswer ( answer ) . when ( session ) . addComment ( eq ( firstIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doAnswer ( answer ) . when ( session ) . addComment ( eq ( secondIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doAnswer ( answer ) . when ( session ) . addComment ( eq ( thirdIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doThrow ( new com . atlassian . jira . rest . client . api . RestClientException ( new java . lang . Throwable ( ) , 404 ) ) . when ( session ) . addComment ( eq ( deletedIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; doThrow ( new com . atlassian . jira . rest . client . api . RestClientException ( new java . lang . Throwable ( ) , 403 ) ) . when ( session ) . addComment ( eq ( forbiddenIssue . getKey ( ) ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) , org . mockito . Mockito . anyString ( ) ) ; final java . lang . String groupVisibility = \"\" ; final java . lang . String roleVisibility = \"\" ; hudson . plugins . jira . Updater updaterCurrent = new hudson . plugins . jira . Updater ( build . getParent ( ) . getScm ( ) ) ; updaterCurrent . submitComments ( build , System . out , \"http://jenkins\" , issues , session , false , false , groupVisibility , roleVisibility ) ; final java . util . Set < hudson . plugins . jira . model . JiraIssue > expectedIssuesToCarryOver = com . google . common . collect . Sets . newLinkedHashSet ( ) ; expectedIssuesToCarryOver . add ( forbiddenIssue ) ; \"<AssertPlaceHolder>\" ; } submitComments ( hudson . model . Run , java . io . PrintStream , java . lang . String , java . util . Set , hudson . plugins . jira . JiraSession , boolean , boolean , java . lang . String , java . lang . String ) { java . util . Set < hudson . plugins . jira . model . JiraIssue > copy = com . google . common . collect . ImmutableSet . copyOf ( issues ) ; for ( hudson . plugins . jira . model . JiraIssue issue : copy ) { logger . println ( hudson . plugins . jira . Messages . UpdatingIssue (", "answer": "org . junit . Assert . assertThat ( issues , org . hamcrest . CoreMatchers . is ( expectedIssuesToCarryOver ) )"}
{"focal": "size ( ) { return ( ( int ) ( filter ( ) . count ( ) ) ) ; }", "testMethod": "generateOccurrencesInRangeWithPeriodicEvents ( ) { java . util . List < com . stratelia . webactiv . almanach . model . EventDetail > events = new java . util . ArrayList < com . stratelia . webactiv . almanach . model . EventDetail > ( ) ; events . add ( anEventDetailOfId ( PERIODIC_EVENTS [ 0 ] ) . build ( ) ) ; events . add ( anEventDetailOfId ( PERIODIC_EVENTS [ 1 ] ) . build ( ) ) ; java . util . List < com . stratelia . webactiv . almanach . model . EventOccurrence > occurrences = generator . generateOccurrencesInRange ( startDate ( ) , endDate ( ) , events ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( occurrences . size ( ) , is ( 10 ) )", "total": "generateOccurrencesInRangeWithPeriodicEvents ( ) { java . util . List < com . stratelia . webactiv . almanach . model . EventDetail > events = new java . util . ArrayList < com . stratelia . webactiv . almanach . model . EventDetail > ( ) ; events . add ( anEventDetailOfId ( PERIODIC_EVENTS [ 0 ] ) . build ( ) ) ; events . add ( anEventDetailOfId ( PERIODIC_EVENTS [ 1 ] ) . build ( ) ) ; java . util . List < com . stratelia . webactiv . almanach . model . EventOccurrence > occurrences = generator . generateOccurrencesInRange ( startDate ( ) , endDate ( ) , events ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return ( ( int ) ( filter ( ) . count ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( occurrences . size ( ) , is ( 10 ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testInterfaceIp ( ) { isisNeighbor . setInterfaceIp ( interfaceIp ) ; result2 = isisNeighbor . interfaceIp ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( interfaceIp ) )", "total": "testInterfaceIp ( ) { isisNeighbor . setInterfaceIp ( interfaceIp ) ; result2 = isisNeighbor . interfaceIp ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( interfaceIp ) )"}
{"focal": "deployPackagedArtifact ( java . net . URI , java . util . Optional ) { java . util . Optional < T > foundMatchingArtifact = org . mule . runtime . module . deployment . internal . DefaultArchiveDeployer . empty ( ) ; try { java . io . File artifactLocation = installArtifact ( artifactAchivedUri ) ; T artifact ; try { artifact = createArtifact ( artifactLocation , appProperties ) ; trackArtifact ( artifact ) ; } catch ( java . lang . Throwable t ) { java . lang . String artifactName = artifactLocation . getName ( ) ; logDeploymentFailure ( t , artifactName ) ; foundMatchingArtifact . ifPresent ( ( a ) -> deploymentListener . onRedeploymentFailure ( a . getArtifactName ( ) , org . mule . runtime . module . deployment . internal . t ) ) ; addZombieFile ( artifactName , artifactLocation ) ; deploymentListener . onDeploymentFailure ( artifactName , t ) ; throw t ; } deployArtifact ( artifact , appProperties ) ; foundMatchingArtifact . ifPresent ( ( a ) -> deploymentListener . onRedeploymentSuccess ( a . getArtifactName ( ) ) ) ; return artifact ; } catch ( java . lang . Throwable t ) { foundMatchingArtifact . ifPresent ( ( a ) -> deploymentListener . onRedeploymentFailure ( a . getArtifactName ( ) , org . mule . runtime . module . deployment . internal . t ) ) ; if ( t instanceof org . mule . runtime . deployment . model . api . DeploymentException ) { throw ( ( org . mule . runtime . deployment . model . api . DeploymentException ) ( t ) ) ; } final java . lang . String msg = \"Failed<sp>to<sp>deploy<sp>from<sp>URI:<sp>\" + artifactAchivedUri ; throw new org . mule . runtime . deployment . model . api . DeploymentException ( createStaticMessage ( msg ) , t ) ; } }", "testMethod": "doNotFailIfNoAppsFolderPresent ( ) { when ( mockDomainDeployer . deployPackagedArtifact ( org . mule . runtime . module . deployment . internal . DomainArchiveDeployerTestCase . DOMAIN_ZIP_PATH , empty ( ) ) ) . thenReturn ( mockDomain ) ; org . mule . runtime . module . deployment . internal . DomainArchiveDeployer domainArchiveDeployer = new org . mule . runtime . module . deployment . internal . DomainArchiveDeployer ( mockDomainDeployer , mockApplicationDeployer , mockDeploymentService ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( domainArchiveDeployer . deployPackagedArtifact ( org . mule . runtime . module . deployment . internal . DomainArchiveDeployerTestCase . DOMAIN_ZIP_PATH , empty ( ) ) , org . hamcrest . core . Is . is ( mockDomain ) )", "total": "doNotFailIfNoAppsFolderPresent ( ) { when ( mockDomainDeployer . deployPackagedArtifact ( org . mule . runtime . module . deployment . internal . DomainArchiveDeployerTestCase . DOMAIN_ZIP_PATH , empty ( ) ) ) . thenReturn ( mockDomain ) ; org . mule . runtime . module . deployment . internal . DomainArchiveDeployer domainArchiveDeployer = new org . mule . runtime . module . deployment . internal . DomainArchiveDeployer ( mockDomainDeployer , mockApplicationDeployer , mockDeploymentService ) ; \"<AssertPlaceHolder>\" ; } deployPackagedArtifact ( java . net . URI , java . util . Optional ) { java . util . Optional < T > foundMatchingArtifact = org . mule . runtime . module . deployment . internal . DefaultArchiveDeployer . empty ( ) ; try { java . io . File artifactLocation = installArtifact ( artifactAchivedUri ) ; T artifact ; try { artifact = createArtifact ( artifactLocation , appProperties ) ; trackArtifact ( artifact ) ; } catch ( java . lang . Throwable t ) { java . lang . String artifactName = artifactLocation . getName ( ) ; logDeploymentFailure ( t , artifactName ) ; foundMatchingArtifact . ifPresent ( ( a ) -> deploymentListener . onRedeploymentFailure ( a . getArtifactName ( ) , org . mule . runtime . module . deployment . internal . t ) ) ; addZombieFile ( artifactName , artifactLocation ) ; deploymentListener . onDeploymentFailure ( artifactName , t ) ; throw t ; } deployArtifact ( artifact , appProperties ) ; foundMatchingArtifact . ifPresent ( ( a ) -> deploymentListener . onRedeploymentSuccess ( a . getArtifactName ( ) ) ) ; return artifact ; } catch ( java . lang . Throwable t ) { foundMatchingArtifact . ifPresent ( ( a ) -> deploymentListener . onRedeploymentFailure ( a . getArtifactName ( ) , org . mule . runtime . module . deployment . internal . t ) ) ; if ( t instanceof org . mule . runtime . deployment . model . api . DeploymentException ) { throw ( ( org . mule . runtime . deployment . model . api . DeploymentException ) ( t ) ) ; } final java . lang . String msg = \"Failed<sp>to<sp>deploy<sp>from<sp>URI:<sp>\" + artifactAchivedUri ; throw new org . mule . runtime . deployment . model . api . DeploymentException ( createStaticMessage ( msg ) , t ) ; } }", "answer": "org . junit . Assert . assertThat ( domainArchiveDeployer . deployPackagedArtifact ( org . mule . runtime . module . deployment . internal . DomainArchiveDeployerTestCase . DOMAIN_ZIP_PATH , empty ( ) ) , org . hamcrest . core . Is . is ( mockDomain ) )"}
{"focal": "getChargingSchedulePeriod ( ) { return chargingSchedulePeriod ; }", "testMethod": "setChargingSchedulePeriod_listOfChargingSchedulePeriods_chargingSchedulePeriodIsSet ( ) { eu . chargetime . ocpp . model . core . ChargingSchedulePeriod [ ] chargingSchedulePeriod = aList ( mock ( eu . chargetime . ocpp . model . core . ChargingSchedulePeriod . class ) ) ; chargingSchedule . setChargingSchedulePeriod ( chargingSchedulePeriod ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chargingSchedule . getChargingSchedulePeriod ( ) , org . hamcrest . CoreMatchers . equalTo ( chargingSchedulePeriod ) )", "total": "setChargingSchedulePeriod_listOfChargingSchedulePeriods_chargingSchedulePeriodIsSet ( ) { eu . chargetime . ocpp . model . core . ChargingSchedulePeriod [ ] chargingSchedulePeriod = aList ( mock ( eu . chargetime . ocpp . model . core . ChargingSchedulePeriod . class ) ) ; chargingSchedule . setChargingSchedulePeriod ( chargingSchedulePeriod ) ; \"<AssertPlaceHolder>\" ; } getChargingSchedulePeriod ( ) { return chargingSchedulePeriod ; }", "answer": "org . junit . Assert . assertThat ( chargingSchedule . getChargingSchedulePeriod ( ) , org . hamcrest . CoreMatchers . equalTo ( chargingSchedulePeriod ) )"}
{"focal": "getMyEnum ( ) { return myEnum ; }", "testMethod": "enumValue ( ) { model . setMyEnum ( SortDirection . ASCENDING ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model2 . getMyEnum ( ) , org . hamcrest . CoreMatchers . is ( SortDirection . ASCENDING ) )", "total": "enumValue ( ) { model . setMyEnum ( SortDirection . ASCENDING ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; } getMyEnum ( ) { return myEnum ; }", "answer": "org . junit . Assert . assertThat ( model2 . getMyEnum ( ) , org . hamcrest . CoreMatchers . is ( SortDirection . ASCENDING ) )"}
{"focal": "unmarshal ( java . lang . String ) { return org . oscm . billingservice . business . org . oscm . billingservice . business . BigDecimalJaxbCustomBinder . parseBigDecimal ( value ) ; }", "testMethod": "marshalAndUnmarshal_smallValue ( ) { java . math . BigDecimal givenValue = new java . math . BigDecimal ( \"0.34\" ) ; java . lang . String valueAsStr = adapter . marshal ( givenValue ) ; java . math . BigDecimal convertedValue = adapter . unmarshal ( valueAsStr ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( givenValue , org . hamcrest . CoreMatchers . is ( convertedValue ) )", "total": "marshalAndUnmarshal_smallValue ( ) { java . math . BigDecimal givenValue = new java . math . BigDecimal ( \"0.34\" ) ; java . lang . String valueAsStr = adapter . marshal ( givenValue ) ; java . math . BigDecimal convertedValue = adapter . unmarshal ( valueAsStr ) ; \"<AssertPlaceHolder>\" ; } unmarshal ( java . lang . String ) { return org . oscm . billingservice . business . org . oscm . billingservice . business . BigDecimalJaxbCustomBinder . parseBigDecimal ( value ) ; }", "answer": "org . junit . Assert . assertThat ( givenValue , org . hamcrest . CoreMatchers . is ( convertedValue ) )"}
{"focal": "games ( ) { org . junit . Assert . assertThat ( facebook . games ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . GameMethods . class ) ) ; }", "testMethod": "games ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( facebook . games ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . GameMethods . class ) )", "total": "games ( ) { \"<AssertPlaceHolder>\" ; } games ( ) { org . junit . Assert . assertThat ( facebook . games ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . GameMethods . class ) ) ; }", "answer": "org . junit . Assert . assertThat ( facebook . games ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . GameMethods . class ) )"}
{"focal": "incrementToken ( ) { boolean incrementToken = input . incrementToken ( ) ; if ( incrementToken == false ) return false ; java . lang . String s = termAtt . term ( ) ; int len = s . length ( ) ; if ( ( ( len > 3 ) && ( ( s . charAt ( ( len - 1 ) ) ) == ( com . github . lucenejapaneseanalyzer . japaneseanalyzer . KatakanaStemFilter . KATAKANA_HIRAGANA_PROLONGED_SOUND_MARK ) ) ) && ( isKatakanaString ( s ) ) ) { termAtt . setTermBuffer ( s . substring ( 0 , ( len - 1 ) ) ) ; } return true ; }", "testMethod": "test ( ) { java . lang . String text = this . input ; org . apache . lucene . analysis . Analyzer analyzer = new com . github . lucenejapaneseanalyzer . japaneseanalyzer . GoSenAnalyzer ( ) ; org . apache . lucene . analysis . TokenStream ts = analyzer . tokenStream ( \"content\" , new java . io . StringReader ( text ) ) ; org . apache . lucene . analysis . tokenattributes . TermAttribute ta = ts . getAttribute ( org . apache . lucene . analysis . tokenattributes . TermAttribute . class ) ; while ( ts . incrementToken ( ) ) { java . lang . String term = ta . term ( ) ; System . out . println ( term ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( term , org . hamcrest . CoreMatchers . is ( this . expected ) )", "total": "test ( ) { java . lang . String text = this . input ; org . apache . lucene . analysis . Analyzer analyzer = new com . github . lucenejapaneseanalyzer . japaneseanalyzer . GoSenAnalyzer ( ) ; org . apache . lucene . analysis . TokenStream ts = analyzer . tokenStream ( \"content\" , new java . io . StringReader ( text ) ) ; org . apache . lucene . analysis . tokenattributes . TermAttribute ta = ts . getAttribute ( org . apache . lucene . analysis . tokenattributes . TermAttribute . class ) ; while ( ts . incrementToken ( ) ) { java . lang . String term = ta . term ( ) ; System . out . println ( term ) ; \"<AssertPlaceHolder>\" ; } } incrementToken ( ) { boolean incrementToken = input . incrementToken ( ) ; if ( incrementToken == false ) return false ; java . lang . String s = termAtt . term ( ) ; int len = s . length ( ) ; if ( ( ( len > 3 ) && ( ( s . charAt ( ( len - 1 ) ) ) == ( com . github . lucenejapaneseanalyzer . japaneseanalyzer . KatakanaStemFilter . KATAKANA_HIRAGANA_PROLONGED_SOUND_MARK ) ) ) && ( isKatakanaString ( s ) ) ) { termAtt . setTermBuffer ( s . substring ( 0 , ( len - 1 ) ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( term , org . hamcrest . CoreMatchers . is ( this . expected ) )"}
{"focal": "getPageNumber ( ) { return ( this . state . getRowIndex ( ) ) / ( getPageSize ( ) ) ; }", "testMethod": "shouldDelegateGetPageNumber ( ) { java . lang . Integer pageNumber = 10 ; given ( this . delegate . getPageNumber ( ) ) . willReturn ( pageNumber ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . request . getPageNumber ( ) , org . hamcrest . CoreMatchers . is ( pageNumber ) )", "total": "shouldDelegateGetPageNumber ( ) { java . lang . Integer pageNumber = 10 ; given ( this . delegate . getPageNumber ( ) ) . willReturn ( pageNumber ) ; \"<AssertPlaceHolder>\" ; } getPageNumber ( ) { return ( this . state . getRowIndex ( ) ) / ( getPageSize ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( this . request . getPageNumber ( ) , org . hamcrest . CoreMatchers . is ( pageNumber ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "shouldFindPenaltyStatusEntityByType ( ) { org . mifos . accounts . penalties . business . PenaltyStatusEntity found = penaltyDao . findPenaltyStatusEntityByType ( statusEntity . getPenaltyStatus ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( found . getId ( ) , org . hamcrest . CoreMatchers . is ( statusEntity . getId ( ) ) )", "total": "shouldFindPenaltyStatusEntityByType ( ) { org . mifos . accounts . penalties . business . PenaltyStatusEntity found = penaltyDao . findPenaltyStatusEntityByType ( statusEntity . getPenaltyStatus ( ) ) ; \"<AssertPlaceHolder>\" ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( found . getId ( ) , org . hamcrest . CoreMatchers . is ( statusEntity . getId ( ) ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsNotEventSubscriptionObject ( ) { org . msgpack . type . Value comp = org . msgpack . type . ValueFactory . createRawValue ( \"subscriberId\" ) ; boolean result = target2 . equals ( comp ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsNotEventSubscriptionObject ( ) { org . msgpack . type . Value comp = org . msgpack . type . ValueFactory . createRawValue ( \"subscriberId\" ) ; boolean result = target2 . equals ( comp ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "binarySearchValueOrLower ( org . diirt . util . array . ListNumber , double ) { if ( value <= ( values . getDouble ( 0 ) ) ) { return 0 ; } if ( value >= ( values . getDouble ( ( ( values . size ( ) ) - 1 ) ) ) ) { return ( values . size ( ) ) - 1 ; } int index = org . diirt . util . array . ListNumbers . binarySearch ( 0 , ( ( values . size ( ) ) - 1 ) , values , value ) ; while ( ( index != 0 ) && ( value == ( values . getDouble ( ( index - 1 ) ) ) ) ) { index -- ; } return index ; }", "testMethod": "binarySearchValueOrLower2 ( ) { org . diirt . util . array . ListNumber values = new org . diirt . util . array . ArrayDouble ( 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . diirt . util . array . ListNumbers . ListNumbers . binarySearchValueOrLower ( values , 2 ) , equalTo ( 1 ) )", "total": "binarySearchValueOrLower2 ( ) { org . diirt . util . array . ListNumber values = new org . diirt . util . array . ArrayDouble ( 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 ) ; \"<AssertPlaceHolder>\" ; } binarySearchValueOrLower ( org . diirt . util . array . ListNumber , double ) { if ( value <= ( values . getDouble ( 0 ) ) ) { return 0 ; } if ( value >= ( values . getDouble ( ( ( values . size ( ) ) - 1 ) ) ) ) { return ( values . size ( ) ) - 1 ; } int index = org . diirt . util . array . ListNumbers . binarySearch ( 0 , ( ( values . size ( ) ) - 1 ) , values , value ) ; while ( ( index != 0 ) && ( value == ( values . getDouble ( ( index - 1 ) ) ) ) ) { index -- ; } return index ; }", "answer": "org . junit . Assert . assertThat ( org . diirt . util . array . ListNumbers . ListNumbers . binarySearchValueOrLower ( values , 2 ) , equalTo ( 1 ) )"}
{"focal": "termMatches ( java . lang . String [ ] ) { querqy . rewrite . commonrules . model . TermMatches result = new querqy . rewrite . commonrules . model . TermMatches ( ) ; for ( java . lang . String value : values ) { result . add ( new querqy . rewrite . commonrules . model . TermMatch ( new querqy . model . Term ( null , value ) ) ) ; } return result ; }", "testMethod": "testSingleInputTwoInstructionsFromSameRule ( ) { querqy . rewrite . commonrules . model . RulesCollectionBuilder builder = new querqy . rewrite . commonrules . model . TrieMapRulesCollectionBuilder ( false ) ; java . lang . String s1 = \"test\" ; querqy . rewrite . commonrules . model . Input input = new querqy . rewrite . commonrules . model . Input ( inputTerms ( null , s1 ) , false , false ) ; querqy . rewrite . commonrules . model . Instructions instructions = instructions ( \"instruction1\" , \"instruction2\" ) ; builder . addRule ( input , instructions ) ; querqy . rewrite . commonrules . model . RulesCollection rulesCollection = builder . build ( ) ; querqy . rewrite . commonrules . model . PositionSequence < querqy . model . InputSequenceElement > sequence = new querqy . rewrite . commonrules . model . PositionSequence ( ) ; sequence . nextPosition ( ) ; sequence . addElement ( new querqy . model . Term ( null , s1 ) ) ; java . util . List < querqy . rewrite . commonrules . model . Action > actions = rulesCollection . getRewriteActions ( sequence ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actions , org . hamcrest . Matchers . contains ( new querqy . rewrite . commonrules . model . Action ( java . util . Arrays . asList ( instructions ) , termMatches ( s1 ) , 0 , 1 ) ) )", "total": "testSingleInputTwoInstructionsFromSameRule ( ) { querqy . rewrite . commonrules . model . RulesCollectionBuilder builder = new querqy . rewrite . commonrules . model . TrieMapRulesCollectionBuilder ( false ) ; java . lang . String s1 = \"test\" ; querqy . rewrite . commonrules . model . Input input = new querqy . rewrite . commonrules . model . Input ( inputTerms ( null , s1 ) , false , false ) ; querqy . rewrite . commonrules . model . Instructions instructions = instructions ( \"instruction1\" , \"instruction2\" ) ; builder . addRule ( input , instructions ) ; querqy . rewrite . commonrules . model . RulesCollection rulesCollection = builder . build ( ) ; querqy . rewrite . commonrules . model . PositionSequence < querqy . model . InputSequenceElement > sequence = new querqy . rewrite . commonrules . model . PositionSequence ( ) ; sequence . nextPosition ( ) ; sequence . addElement ( new querqy . model . Term ( null , s1 ) ) ; java . util . List < querqy . rewrite . commonrules . model . Action > actions = rulesCollection . getRewriteActions ( sequence ) ; \"<AssertPlaceHolder>\" ; } termMatches ( java . lang . String [ ] ) { querqy . rewrite . commonrules . model . TermMatches result = new querqy . rewrite . commonrules . model . TermMatches ( ) ; for ( java . lang . String value : values ) { result . add ( new querqy . rewrite . commonrules . model . TermMatch ( new querqy . model . Term ( null , value ) ) ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( actions , org . hamcrest . Matchers . contains ( new querqy . rewrite . commonrules . model . Action ( java . util . Arrays . asList ( instructions ) , termMatches ( s1 ) , 0 , 1 ) ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "getTheSubGroupsOfAGivenUnaccessibleGroupInAnotherDomain ( ) { try { com . stratelia . webactiv . util . GeneralPropertiesManagerHelper . setDomainVisibility ( DomainProperties . DVIS_EACH ) ; com . stratelia . webactiv . beans . admin . Group actualGroup = getTestResources ( ) . getAGroupNotInAnInternalDomain ( ) ; currentUser . setDomainId ( ( ( actualGroup . getDomainId ( ) ) + \"0\" ) ) ; java . lang . String path = ( buildURIPathOf ( actualGroup ) ) + \"/groups\" ; getAt ( path , getWebEntityClass ( ) ) ; org . junit . Assert . fail ( \"The<sp>group<sp>shouldn't<sp>be<sp>get<sp>as<sp>it<sp>is<sp>unaccessible\" ) ; } catch ( com . sun . jersey . api . client . UniformInterfaceException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int forbidden = Response . Status . FORBIDDEN . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( forbidden ) )", "total": "getTheSubGroupsOfAGivenUnaccessibleGroupInAnotherDomain ( ) { try { com . stratelia . webactiv . util . GeneralPropertiesManagerHelper . setDomainVisibility ( DomainProperties . DVIS_EACH ) ; com . stratelia . webactiv . beans . admin . Group actualGroup = getTestResources ( ) . getAGroupNotInAnInternalDomain ( ) ; currentUser . setDomainId ( ( ( actualGroup . getDomainId ( ) ) + \"0\" ) ) ; java . lang . String path = ( buildURIPathOf ( actualGroup ) ) + \"/groups\" ; getAt ( path , getWebEntityClass ( ) ) ; org . junit . Assert . fail ( \"The<sp>group<sp>shouldn't<sp>be<sp>get<sp>as<sp>it<sp>is<sp>unaccessible\" ) ; } catch ( com . sun . jersey . api . client . UniformInterfaceException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int forbidden = Response . Status . FORBIDDEN . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( forbidden ) )"}
{"focal": "values ( ) { return com . google . common . collect . ImmutableSortedSet . copyOf ( map . values ( ) ) ; }", "testMethod": "testValues ( ) { initState ( ) ; \"<AssertPlaceHolder>\" . containsAll ( initContents ) ; }", "assertLine": "org . junit . Assert . assertThat ( state . values ( ) )", "total": "testValues ( ) { initState ( ) ; \"<AssertPlaceHolder>\" . containsAll ( initContents ) ; } values ( ) { return com . google . common . collect . ImmutableSortedSet . copyOf ( map . values ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( state . values ( ) )"}
{"focal": "getNumberOfMessages ( ) { return messages . size ( ) ; }", "testMethod": "whenNoFacet ( ) { class Child { } context . checking ( new org . jmock . Expectations ( ) { { oneOf ( mockChildType ) . getCorrespondingClass ( ) ; will ( returnValue ( Child . class ) ) ; } } ) ; newValidatorVisitor . visit ( mockChildType , validationFailures ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( validationFailures . getNumberOfMessages ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "whenNoFacet ( ) { class Child { } context . checking ( new org . jmock . Expectations ( ) { { oneOf ( mockChildType ) . getCorrespondingClass ( ) ; will ( returnValue ( Child . class ) ) ; } } ) ; newValidatorVisitor . visit ( mockChildType , validationFailures ) ; \"<AssertPlaceHolder>\" ; } getNumberOfMessages ( ) { return messages . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( validationFailures . getNumberOfMessages ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "createMoney ( java . lang . String ) { return new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , amount ) ; }", "testMethod": "twoDepositWithFirstActivityWithinInterval ( ) { org . mifos . accounts . savings . interest . EndOfDayDetail september13thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september13th ) . withDespoitsOf ( \"12000\" ) . build ( ) ; org . mifos . accounts . savings . interest . EndOfDayDetail september20thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september20th ) . withDespoitsOf ( \"15000\" ) . build ( ) ; interestCalculationPeriodDetail = new org . mifos . accounts . savings . interest . InterestCalculationPeriodBuilder ( ) . from ( august31st ) . to ( september30th ) . isFirstActivity ( ) . withStartingBalance ( \"0\" ) . containing ( september13thDetails , september20thDetails ) . build ( ) ; org . mifos . framework . util . helpers . Money minimumBalancePrincipal = calculationStrategy . calculatePrincipal ( interestCalculationPeriodDetail ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( minimumBalancePrincipal , org . hamcrest . CoreMatchers . is ( org . mifos . framework . TestUtils . createMoney ( \"12000\" ) ) )", "total": "twoDepositWithFirstActivityWithinInterval ( ) { org . mifos . accounts . savings . interest . EndOfDayDetail september13thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september13th ) . withDespoitsOf ( \"12000\" ) . build ( ) ; org . mifos . accounts . savings . interest . EndOfDayDetail september20thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september20th ) . withDespoitsOf ( \"15000\" ) . build ( ) ; interestCalculationPeriodDetail = new org . mifos . accounts . savings . interest . InterestCalculationPeriodBuilder ( ) . from ( august31st ) . to ( september30th ) . isFirstActivity ( ) . withStartingBalance ( \"0\" ) . containing ( september13thDetails , september20thDetails ) . build ( ) ; org . mifos . framework . util . helpers . Money minimumBalancePrincipal = calculationStrategy . calculatePrincipal ( interestCalculationPeriodDetail ) ; \"<AssertPlaceHolder>\" ; } createMoney ( java . lang . String ) { return new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , amount ) ; }", "answer": "org . junit . Assert . assertThat ( minimumBalancePrincipal , org . hamcrest . CoreMatchers . is ( org . mifos . framework . TestUtils . createMoney ( \"12000\" ) ) )"}
{"focal": "getAllLoggingEvents ( ) { uk . org . lidalia . slf4jtest . TestLogger logger1 = uk . org . lidalia . slf4jtest . TestLoggerFactory . getInstance ( ) . getLogger ( \"name1\" ) ; uk . org . lidalia . slf4jtest . TestLogger logger2 = uk . org . lidalia . slf4jtest . TestLoggerFactory . getInstance ( ) . getLogger ( \"name2\" ) ; logger1 . trace ( \"hello\" ) ; logger2 . trace ( \"world\" ) ; logger1 . trace ( \"here\" ) ; logger2 . trace ( \"I<sp>am\" ) ; org . junit . Assert . assertThat ( uk . org . lidalia . slf4jtest . TestLoggerFactory . getLoggingEvents ( ) , org . hamcrest . CoreMatchers . is ( asList ( uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"hello\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"world\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"here\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"I<sp>am\" ) ) ) ) ; }", "testMethod": "getAllLoggingEventsReturnsEventsLoggedInAllThreads ( ) { java . lang . Thread t = new java . lang . Thread ( new java . lang . Runnable ( ) { @ uk . org . lidalia . slf4jtest . Override public void run ( ) { uk . org . lidalia . slf4jtest . TestLoggerFactory . getTestLogger ( \"name1\" ) . info ( \"message1\" ) ; } } ) ; t . start ( ) ; t . join ( ) ; uk . org . lidalia . slf4jtest . TestLoggerFactory . getTestLogger ( \"name1\" ) . info ( \"message2\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uk . org . lidalia . slf4jtest . TestLoggerFactory . getAllLoggingEvents ( ) , org . hamcrest . CoreMatchers . is ( asList ( uk . org . lidalia . slf4jtest . LoggingEvent . info ( \"message1\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . info ( \"message2\" ) ) ) )", "total": "getAllLoggingEventsReturnsEventsLoggedInAllThreads ( ) { java . lang . Thread t = new java . lang . Thread ( new java . lang . Runnable ( ) { @ uk . org . lidalia . slf4jtest . Override public void run ( ) { uk . org . lidalia . slf4jtest . TestLoggerFactory . getTestLogger ( \"name1\" ) . info ( \"message1\" ) ; } } ) ; t . start ( ) ; t . join ( ) ; uk . org . lidalia . slf4jtest . TestLoggerFactory . getTestLogger ( \"name1\" ) . info ( \"message2\" ) ; \"<AssertPlaceHolder>\" ; } getAllLoggingEvents ( ) { uk . org . lidalia . slf4jtest . TestLogger logger1 = uk . org . lidalia . slf4jtest . TestLoggerFactory . getInstance ( ) . getLogger ( \"name1\" ) ; uk . org . lidalia . slf4jtest . TestLogger logger2 = uk . org . lidalia . slf4jtest . TestLoggerFactory . getInstance ( ) . getLogger ( \"name2\" ) ; logger1 . trace ( \"hello\" ) ; logger2 . trace ( \"world\" ) ; logger1 . trace ( \"here\" ) ; logger2 . trace ( \"I<sp>am\" ) ; org . junit . Assert . assertThat ( uk . org . lidalia . slf4jtest . TestLoggerFactory . getLoggingEvents ( ) , org . hamcrest . CoreMatchers . is ( asList ( uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"hello\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"world\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"here\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . trace ( \"I<sp>am\" ) ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( uk . org . lidalia . slf4jtest . TestLoggerFactory . getAllLoggingEvents ( ) , org . hamcrest . CoreMatchers . is ( asList ( uk . org . lidalia . slf4jtest . LoggingEvent . info ( \"message1\" ) , uk . org . lidalia . slf4jtest . LoggingEvent . info ( \"message2\" ) ) ) )"}
{"focal": "getHostname ( ) { return hostname ; }", "testMethod": "synchronizeSlaveServers ( ) { final java . lang . String slaveServerName = \"SharedSlaveServer\" ; org . pentaho . di . job . JobMeta job1 = createJobMeta ( ) ; org . pentaho . di . cluster . SlaveServer slaveServer1 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createSlaveServer ( slaveServerName , true ) ; job1 . setSlaveServers ( java . util . Collections . singletonList ( slaveServer1 ) ) ; spoonDelegates . jobs . addJob ( job1 ) ; org . pentaho . di . job . JobMeta job2 = createJobMeta ( ) ; org . pentaho . di . cluster . SlaveServer slaveServer2 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createSlaveServer ( slaveServerName , true ) ; job2 . setSlaveServers ( java . util . Collections . singletonList ( slaveServer2 ) ) ; spoonDelegates . jobs . addJob ( job2 ) ; slaveServer2 . setHostname ( org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . AFTER_SYNC_VALUE ) ; sharedUtil . synchronizeSlaveServers ( slaveServer2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( slaveServer1 . getHostname ( ) , org . hamcrest . CoreMatchers . equalTo ( org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . AFTER_SYNC_VALUE ) )", "total": "synchronizeSlaveServers ( ) { final java . lang . String slaveServerName = \"SharedSlaveServer\" ; org . pentaho . di . job . JobMeta job1 = createJobMeta ( ) ; org . pentaho . di . cluster . SlaveServer slaveServer1 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createSlaveServer ( slaveServerName , true ) ; job1 . setSlaveServers ( java . util . Collections . singletonList ( slaveServer1 ) ) ; spoonDelegates . jobs . addJob ( job1 ) ; org . pentaho . di . job . JobMeta job2 = createJobMeta ( ) ; org . pentaho . di . cluster . SlaveServer slaveServer2 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createSlaveServer ( slaveServerName , true ) ; job2 . setSlaveServers ( java . util . Collections . singletonList ( slaveServer2 ) ) ; spoonDelegates . jobs . addJob ( job2 ) ; slaveServer2 . setHostname ( org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . AFTER_SYNC_VALUE ) ; sharedUtil . synchronizeSlaveServers ( slaveServer2 ) ; \"<AssertPlaceHolder>\" ; } getHostname ( ) { return hostname ; }", "answer": "org . junit . Assert . assertThat ( slaveServer1 . getHostname ( ) , org . hamcrest . CoreMatchers . equalTo ( org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . AFTER_SYNC_VALUE ) )"}
{"focal": "get ( ) { slim3 . demo . model . Blog blog = new slim3 . demo . model . Blog ( ) ; org . slim3 . datastore . Datastore . put ( blog ) ; org . junit . Assert . assertThat ( service . get ( blog . getKey ( ) , blog . getVersion ( ) ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "testMethod": "getAsyncUsingModelMetaWithVersion ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . DatastoreUtil . put ( ds , null , org . slim3 . datastore . DatastoreUtil . modelToEntity ( ds , new org . slim3 . datastore . model . Hoge ( ) ) ) ; org . slim3 . datastore . model . Hoge model = delegate . getAsync ( ( ( com . google . appengine . api . datastore . Transaction ) ( null ) ) , meta , key , 1L ) . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) )", "total": "getAsyncUsingModelMetaWithVersion ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . DatastoreUtil . put ( ds , null , org . slim3 . datastore . DatastoreUtil . modelToEntity ( ds , new org . slim3 . datastore . model . Hoge ( ) ) ) ; org . slim3 . datastore . model . Hoge model = delegate . getAsync ( ( ( com . google . appengine . api . datastore . Transaction ) ( null ) ) , meta , key , 1L ) . get ( ) ; \"<AssertPlaceHolder>\" ; } get ( ) { slim3 . demo . model . Blog blog = new slim3 . demo . model . Blog ( ) ; org . slim3 . datastore . Datastore . put ( blog ) ; org . junit . Assert . assertThat ( service . get ( blog . getKey ( ) , blog . getVersion ( ) ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( model , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) )"}
{"focal": "containsInAnyOrder ( java . util . Collection ) { @ org . apache . beam . sdk . testing . SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) final java . util . Collection < org . hamcrest . Matcher < ? super T > > matchers = ( ( java . util . Collection ) ( serializableMatchers ) ) ; return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . containsInAnyOrder ( matchers ) ) ; }", "testMethod": "runRead ( ) { org . apache . beam . sdk . io . gcp . spanner . SpannerIO . Read read = org . apache . beam . sdk . io . gcp . spanner . SpannerIO . read ( ) . withProjectId ( \"test\" ) . withInstanceId ( \"123\" ) . withDatabaseId ( \"aaa\" ) . withTable ( \"users\" ) . withColumns ( \"id\" , \"name\" ) . withServiceFactory ( serviceFactory ) ; java . util . List < com . google . cloud . spanner . Partition > fakePartitions = java . util . Arrays . asList ( mock ( com . google . cloud . spanner . Partition . class ) , mock ( com . google . cloud . spanner . Partition . class ) , mock ( com . google . cloud . spanner . Partition . class ) ) ; com . google . cloud . spanner . BatchTransactionId id = mock ( com . google . cloud . spanner . BatchTransactionId . class ) ; org . apache . beam . sdk . io . gcp . spanner . Transaction tx = org . apache . beam . sdk . io . gcp . spanner . Transaction . create ( id ) ; org . apache . beam . sdk . values . PCollectionView < org . apache . beam . sdk . io . gcp . spanner . Transaction > txView = pipeline . apply ( org . apache . beam . sdk . transforms . Create . of ( tx ) ) . apply ( org . apache . beam . sdk . transforms . View . < org . apache . beam . sdk . io . gcp . spanner . Transaction > asSingleton ( ) ) ; org . apache . beam . sdk . io . gcp . spanner . BatchSpannerRead . GeneratePartitionsFn fn = new org . apache . beam . sdk . io . gcp . spanner . BatchSpannerRead . GeneratePartitionsFn ( read . getSpannerConfig ( ) , txView ) ; org . apache . beam . sdk . transforms . DoFnTester < org . apache . beam . sdk . io . gcp . spanner . ReadOperation , com . google . cloud . spanner . Partition > fnTester = org . apache . beam . sdk . transforms . DoFnTester . of ( fn ) ; fnTester . setSideInput ( txView , GlobalWindow . INSTANCE , tx ) ; when ( serviceFactory . mockBatchClient ( ) . batchReadOnlyTransaction ( id ) ) . thenReturn ( mockBatchTx ) ; when ( mockBatchTx . partitionRead ( any ( com . google . cloud . spanner . PartitionOptions . class ) , eq ( \"users\" ) , eq ( com . google . cloud . spanner . KeySet . all ( ) ) , eq ( java . util . Arrays . asList ( \"id\" , \"name\" ) ) ) ) . thenReturn ( fakePartitions ) ; java . util . List < com . google . cloud . spanner . Partition > result = fnTester . processBundle ( read . getReadOperation ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( serviceFactory . mockBatchClient ( ) ) . batchReadOnlyTransaction ( id ) ; verify ( mockBatchTx ) . partitionRead ( any ( com . google . cloud . spanner . PartitionOptions . class ) , eq ( \"users\" ) , eq ( com . google . cloud . spanner . KeySet . all ( ) ) , eq ( java . util . Arrays . asList ( \"id\" , \"name\" ) ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . containsInAnyOrder ( fakePartitions . toArray ( ) ) )", "total": "runRead ( ) { org . apache . beam . sdk . io . gcp . spanner . SpannerIO . Read read = org . apache . beam . sdk . io . gcp . spanner . SpannerIO . read ( ) . withProjectId ( \"test\" ) . withInstanceId ( \"123\" ) . withDatabaseId ( \"aaa\" ) . withTable ( \"users\" ) . withColumns ( \"id\" , \"name\" ) . withServiceFactory ( serviceFactory ) ; java . util . List < com . google . cloud . spanner . Partition > fakePartitions = java . util . Arrays . asList ( mock ( com . google . cloud . spanner . Partition . class ) , mock ( com . google . cloud . spanner . Partition . class ) , mock ( com . google . cloud . spanner . Partition . class ) ) ; com . google . cloud . spanner . BatchTransactionId id = mock ( com . google . cloud . spanner . BatchTransactionId . class ) ; org . apache . beam . sdk . io . gcp . spanner . Transaction tx = org . apache . beam . sdk . io . gcp . spanner . Transaction . create ( id ) ; org . apache . beam . sdk . values . PCollectionView < org . apache . beam . sdk . io . gcp . spanner . Transaction > txView = pipeline . apply ( org . apache . beam . sdk . transforms . Create . of ( tx ) ) . apply ( org . apache . beam . sdk . transforms . View . < org . apache . beam . sdk . io . gcp . spanner . Transaction > asSingleton ( ) ) ; org . apache . beam . sdk . io . gcp . spanner . BatchSpannerRead . GeneratePartitionsFn fn = new org . apache . beam . sdk . io . gcp . spanner . BatchSpannerRead . GeneratePartitionsFn ( read . getSpannerConfig ( ) , txView ) ; org . apache . beam . sdk . transforms . DoFnTester < org . apache . beam . sdk . io . gcp . spanner . ReadOperation , com . google . cloud . spanner . Partition > fnTester = org . apache . beam . sdk . transforms . DoFnTester . of ( fn ) ; fnTester . setSideInput ( txView , GlobalWindow . INSTANCE , tx ) ; when ( serviceFactory . mockBatchClient ( ) . batchReadOnlyTransaction ( id ) ) . thenReturn ( mockBatchTx ) ; when ( mockBatchTx . partitionRead ( any ( com . google . cloud . spanner . PartitionOptions . class ) , eq ( \"users\" ) , eq ( com . google . cloud . spanner . KeySet . all ( ) ) , eq ( java . util . Arrays . asList ( \"id\" , \"name\" ) ) ) ) . thenReturn ( fakePartitions ) ; java . util . List < com . google . cloud . spanner . Partition > result = fnTester . processBundle ( read . getReadOperation ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( serviceFactory . mockBatchClient ( ) ) . batchReadOnlyTransaction ( id ) ; verify ( mockBatchTx ) . partitionRead ( any ( com . google . cloud . spanner . PartitionOptions . class ) , eq ( \"users\" ) , eq ( com . google . cloud . spanner . KeySet . all ( ) ) , eq ( java . util . Arrays . asList ( \"id\" , \"name\" ) ) ) ; } containsInAnyOrder ( java . util . Collection ) { @ org . apache . beam . sdk . testing . SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) final java . util . Collection < org . hamcrest . Matcher < ? super T > > matchers = ( ( java . util . Collection ) ( serializableMatchers ) ) ; return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . containsInAnyOrder ( matchers ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . containsInAnyOrder ( fakePartitions . toArray ( ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testSetInterfaceIp ( ) { isisNeighbor . setInterfaceIp ( interfaceIp ) ; result2 = isisNeighbor . interfaceIp ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( interfaceIp ) )", "total": "testSetInterfaceIp ( ) { isisNeighbor . setInterfaceIp ( interfaceIp ) ; result2 = isisNeighbor . interfaceIp ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( interfaceIp ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "givenUsersInDB_WhenFindUserByStatusAndNameWithQueryAnnotationNamedParamsCustomNames_ThenReturnOneUser ( ) { com . baeldung . domain . user . User user = new com . baeldung . domain . user . User ( ) ; user . setName ( USER_NAME_ADAM ) ; user . setEmail ( USER_EMAIL ) ; user . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user ) ; com . baeldung . domain . user . User user2 = new com . baeldung . domain . user . User ( ) ; user2 . setName ( USER_NAME_PETER ) ; user2 . setEmail ( USER_EMAIL2 ) ; user2 . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user2 ) ; com . baeldung . domain . user . User userByStatus = userRepository . findUserByUserStatusAndUserName ( ACTIVE_STATUS , USER_NAME_ADAM ) ; \"<AssertPlaceHolder>\" . isEqualTo ( USER_NAME_ADAM ) ; }", "assertLine": "org . junit . Assert . assertThat ( userByStatus . getName ( ) )", "total": "givenUsersInDB_WhenFindUserByStatusAndNameWithQueryAnnotationNamedParamsCustomNames_ThenReturnOneUser ( ) { com . baeldung . domain . user . User user = new com . baeldung . domain . user . User ( ) ; user . setName ( USER_NAME_ADAM ) ; user . setEmail ( USER_EMAIL ) ; user . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user ) ; com . baeldung . domain . user . User user2 = new com . baeldung . domain . user . User ( ) ; user2 . setName ( USER_NAME_PETER ) ; user2 . setEmail ( USER_EMAIL2 ) ; user2 . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user2 ) ; com . baeldung . domain . user . User userByStatus = userRepository . findUserByUserStatusAndUserName ( ACTIVE_STATUS , USER_NAME_ADAM ) ; \"<AssertPlaceHolder>\" . isEqualTo ( USER_NAME_ADAM ) ; } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( userByStatus . getName ( ) )"}
{"focal": "resolve ( com . oracle . bedrock . runtime . Platform , com . oracle . bedrock . OptionsByType ) { com . oracle . bedrock . lang . ExpressionEvaluator evaluator = new com . oracle . bedrock . lang . ExpressionEvaluator ( optionsByType ) ; java . util . Properties properties = new java . util . Properties ( ) ; for ( com . oracle . bedrock . runtime . java . options . SystemProperty property : this . properties . values ( ) ) { java . lang . String name = property . getName ( ) ; java . lang . Object value = property . getValue ( ) ; if ( value != null ) { if ( value instanceof com . oracle . bedrock . runtime . java . options . SystemProperty . ContextSensitiveValue ) { com . oracle . bedrock . runtime . java . options . SystemProperty . ContextSensitiveValue contextSensitiveValue = ( ( com . oracle . bedrock . runtime . java . options . SystemProperty . ContextSensitiveValue ) ( value ) ) ; value = contextSensitiveValue . resolve ( name , platform , optionsByType ) ; } if ( value instanceof java . util . Iterator < ? > ) { java . util . Iterator < ? > iterator = ( ( java . util . Iterator < ? > ) ( value ) ) ; if ( iterator . hasNext ( ) ) { value = iterator . next ( ) . toString ( ) ; } else { throw new java . lang . IndexOutOfBoundsException ( java . lang . String . format ( \"No<sp>more<sp>values<sp>available<sp>for<sp>the<sp>property<sp>[%s]\" , name ) ) ; } } if ( value != null ) { java . lang . String expression = value . toString ( ) . trim ( ) ; if ( ! ( expression . isEmpty ( ) ) ) { java . lang . Object result = evaluator . evaluate ( expression , java . lang . Object . class ) ; expression = ( result == null ) ? \"\" : result . toString ( ) ; } com . oracle . bedrock . OptionsByType propertyOptions = property . getOptions ( ) ; java . lang . Iterable < com . oracle . bedrock . runtime . java . options . SystemProperty . ResolveHandler > handlers = propertyOptions . getInstancesOf ( SystemProperty . ResolveHandler . class ) ; for ( com . oracle . bedrock . runtime . java . options . SystemProperty . ResolveHandler handler : handlers ) { try { handler . onResolve ( name , expression , optionsByType ) ; } catch ( java . lang . Throwable t ) { t . printStackTrace ( ) ; } } properties . put ( name , expression ) ; } } } return properties ; }", "testMethod": "shouldCompose ( ) { com . oracle . bedrock . runtime . options . Arguments arguments = com . oracle . bedrock . runtime . options . Arguments . of ( \"1\" , \"2\" ) . with ( com . oracle . bedrock . runtime . options . Arguments . of ( \"3\" , \"4\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( arguments . resolve ( null , null ) , contains ( \"1\" , \"2\" , \"3\" , \"4\" ) )", "total": "shouldCompose ( ) { com . oracle . bedrock . runtime . options . Arguments arguments = com . oracle . bedrock . runtime . options . Arguments . of ( \"1\" , \"2\" ) . with ( com . oracle . bedrock . runtime . options . Arguments . of ( \"3\" , \"4\" ) ) ; \"<AssertPlaceHolder>\" ; } resolve ( com . oracle . bedrock . runtime . Platform , com . oracle . bedrock . OptionsByType ) { com . oracle . bedrock . lang . ExpressionEvaluator evaluator = new com . oracle . bedrock . lang . ExpressionEvaluator ( optionsByType ) ; java . util . Properties properties = new java . util . Properties ( ) ; for ( com . oracle . bedrock . runtime . java . options . SystemProperty property : this . properties . values ( ) ) { java . lang . String name = property . getName ( ) ; java . lang . Object value = property . getValue ( ) ; if ( value != null ) { if ( value instanceof com . oracle . bedrock . runtime . java . options . SystemProperty . ContextSensitiveValue ) { com . oracle . bedrock . runtime . java . options . SystemProperty . ContextSensitiveValue contextSensitiveValue = ( ( com . oracle . bedrock . runtime . java . options . SystemProperty . ContextSensitiveValue ) ( value ) ) ; value = contextSensitiveValue . resolve ( name , platform , optionsByType ) ; } if ( value instanceof java . util . Iterator < ? > ) { java . util . Iterator < ? > iterator = ( ( java . util . Iterator < ? > ) ( value ) ) ; if ( iterator . hasNext ( ) ) { value = iterator . next ( ) . toString ( ) ; } else { throw new java . lang . IndexOutOfBoundsException ( java . lang . String . format ( \"No<sp>more<sp>values<sp>available<sp>for<sp>the<sp>property<sp>[%s]\" , name ) ) ; } } if ( value != null ) { java . lang . String expression = value . toString ( ) . trim ( ) ; if ( ! ( expression . isEmpty ( ) ) ) { java . lang . Object result = evaluator . evaluate ( expression , java . lang . Object . class ) ; expression = ( result == null ) ? \"\" : result . toString ( ) ; } com . oracle . bedrock . OptionsByType propertyOptions = property . getOptions ( ) ; java . lang . Iterable < com . oracle . bedrock . runtime . java . options . SystemProperty . ResolveHandler > handlers = propertyOptions . getInstancesOf ( SystemProperty . ResolveHandler . class ) ; for ( com . oracle . bedrock . runtime . java . options . SystemProperty . ResolveHandler handler : handlers ) { try { handler . onResolve ( name , expression , optionsByType ) ; } catch ( java . lang . Throwable t ) { t . printStackTrace ( ) ; } } properties . put ( name , expression ) ; } } } return properties ; }", "answer": "org . junit . Assert . assertThat ( arguments . resolve ( null , null ) , contains ( \"1\" , \"2\" , \"3\" , \"4\" ) )"}
{"focal": "makeKey ( java . util . UUID , me . gnat008 . perworldinventory . groups . Group , org . bukkit . GameMode ) { java . lang . String key = ( ( ( uuid . toString ( ) ) + \".\" ) + ( group . getName ( ) ) ) + \".\" ; if ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) key += gameMode . toString ( ) . toLowerCase ( ) ; else key += \"survival\" ; return key ; }", "testMethod": "addPlayerShouldHaveAdventureKey ( ) { org . bukkit . entity . Player player = mockPlayer ( \"Bob\" , GameMode . ADVENTURE ) ; me . gnat008 . perworldinventory . groups . Group group = me . gnat008 . perworldinventory . TestHelper . mockGroup ( \"test\" ) ; given ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) . willReturn ( true ) ; java . lang . String result = playerManager . makeKey ( player . getUniqueId ( ) , group , GameMode . ADVENTURE ) ; java . lang . String expected = ( me . gnat008 . perworldinventory . TestHelper . TEST_UUID ) + \".test.adventure\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( expected ) )", "total": "addPlayerShouldHaveAdventureKey ( ) { org . bukkit . entity . Player player = mockPlayer ( \"Bob\" , GameMode . ADVENTURE ) ; me . gnat008 . perworldinventory . groups . Group group = me . gnat008 . perworldinventory . TestHelper . mockGroup ( \"test\" ) ; given ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) . willReturn ( true ) ; java . lang . String result = playerManager . makeKey ( player . getUniqueId ( ) , group , GameMode . ADVENTURE ) ; java . lang . String expected = ( me . gnat008 . perworldinventory . TestHelper . TEST_UUID ) + \".test.adventure\" ; \"<AssertPlaceHolder>\" ; } makeKey ( java . util . UUID , me . gnat008 . perworldinventory . groups . Group , org . bukkit . GameMode ) { java . lang . String key = ( ( ( uuid . toString ( ) ) + \".\" ) + ( group . getName ( ) ) ) + \".\" ; if ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) key += gameMode . toString ( ) . toLowerCase ( ) ; else key += \"survival\" ; return key ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( expected ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "givenUsersInDB_WhenFindUserByStatusAndNameWithQueryAnnotationNamedParams_ThenReturnOneUser ( ) { com . baeldung . domain . user . User user = new com . baeldung . domain . user . User ( ) ; user . setName ( USER_NAME_ADAM ) ; user . setEmail ( USER_EMAIL ) ; user . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user ) ; com . baeldung . domain . user . User user2 = new com . baeldung . domain . user . User ( ) ; user2 . setName ( USER_NAME_PETER ) ; user2 . setEmail ( USER_EMAIL2 ) ; user2 . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user2 ) ; com . baeldung . domain . user . User userByStatus = userRepository . findUserByStatusAndNameNamedParams ( ACTIVE_STATUS , USER_NAME_ADAM ) ; \"<AssertPlaceHolder>\" . isEqualTo ( USER_NAME_ADAM ) ; }", "assertLine": "org . junit . Assert . assertThat ( userByStatus . getName ( ) )", "total": "givenUsersInDB_WhenFindUserByStatusAndNameWithQueryAnnotationNamedParams_ThenReturnOneUser ( ) { com . baeldung . domain . user . User user = new com . baeldung . domain . user . User ( ) ; user . setName ( USER_NAME_ADAM ) ; user . setEmail ( USER_EMAIL ) ; user . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user ) ; com . baeldung . domain . user . User user2 = new com . baeldung . domain . user . User ( ) ; user2 . setName ( USER_NAME_PETER ) ; user2 . setEmail ( USER_EMAIL2 ) ; user2 . setStatus ( ACTIVE_STATUS ) ; userRepository . save ( user2 ) ; com . baeldung . domain . user . User userByStatus = userRepository . findUserByStatusAndNameNamedParams ( ACTIVE_STATUS , USER_NAME_ADAM ) ; \"<AssertPlaceHolder>\" . isEqualTo ( USER_NAME_ADAM ) ; } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( userByStatus . getName ( ) )"}
{"focal": "serialize ( java . lang . String , org . apache . avro . generic . GenericRecord ) { return inner . serialize ( topic , record ) ; }", "testMethod": "shouldRoundTripRecords ( ) { io . confluent . kafka . streams . serdes . avro . SpecificAvroSerde < io . confluent . kafka . example . User > serde = io . confluent . kafka . streams . serdes . avro . SpecificAvroSerdeTest . createConfiguredSerdeForRecordValues ( ) ; io . confluent . kafka . example . User record = io . confluent . kafka . example . User . newBuilder ( ) . setName ( \"alice\" ) . build ( ) ; io . confluent . kafka . example . User roundtrippedRecord = serde . deserializer ( ) . deserialize ( io . confluent . kafka . streams . serdes . avro . SpecificAvroSerdeTest . ANY_TOPIC , serde . serializer ( ) . serialize ( io . confluent . kafka . streams . serdes . avro . SpecificAvroSerdeTest . ANY_TOPIC , record ) ) ; \"<AssertPlaceHolder>\" ; serde . close ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( roundtrippedRecord , org . hamcrest . CoreMatchers . equalTo ( record ) )", "total": "shouldRoundTripRecords ( ) { io . confluent . kafka . streams . serdes . avro . SpecificAvroSerde < io . confluent . kafka . example . User > serde = io . confluent . kafka . streams . serdes . avro . SpecificAvroSerdeTest . createConfiguredSerdeForRecordValues ( ) ; io . confluent . kafka . example . User record = io . confluent . kafka . example . User . newBuilder ( ) . setName ( \"alice\" ) . build ( ) ; io . confluent . kafka . example . User roundtrippedRecord = serde . deserializer ( ) . deserialize ( io . confluent . kafka . streams . serdes . avro . SpecificAvroSerdeTest . ANY_TOPIC , serde . serializer ( ) . serialize ( io . confluent . kafka . streams . serdes . avro . SpecificAvroSerdeTest . ANY_TOPIC , record ) ) ; \"<AssertPlaceHolder>\" ; serde . close ( ) ; } serialize ( java . lang . String , org . apache . avro . generic . GenericRecord ) { return inner . serialize ( topic , record ) ; }", "answer": "org . junit . Assert . assertThat ( roundtrippedRecord , org . hamcrest . CoreMatchers . equalTo ( record ) )"}
{"focal": "read ( ) { return read ( ( ( byte [ ] ) ( null ) ) , ( ( byte [ ] ) ( null ) ) ) ; }", "testMethod": "testBagIsEmptyTrue ( ) { org . apache . beam . runners . core . StateTag < org . apache . beam . sdk . state . BagState < java . lang . String > > addr = org . apache . beam . runners . core . StateTags . bag ( \"bag\" , org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) ) ; org . apache . beam . sdk . state . BagState < java . lang . String > bag = underTest . state ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . NAMESPACE , addr ) ; org . apache . beam . vendor . guava . v20_0 . com . google . common . util . concurrent . SettableFuture < java . lang . Iterable < java . lang . String > > future = org . apache . beam . vendor . guava . v20_0 . com . google . common . util . concurrent . SettableFuture . create ( ) ; when ( mockReader . bagFuture ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . key ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . NAMESPACE , \"bag\" ) , org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . STATE_FAMILY , org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) ) ) . thenReturn ( future ) ; org . apache . beam . sdk . state . ReadableState < java . lang . Boolean > result = bag . isEmpty ( ) . readLater ( ) ; org . mockito . Mockito . verify ( mockReader ) . bagFuture ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . key ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . NAMESPACE , \"bag\" ) , org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . STATE_FAMILY , org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) ) ; waitAndSet ( future , java . util . Arrays . < java . lang . String > asList ( ) , 200 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . read ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "testBagIsEmptyTrue ( ) { org . apache . beam . runners . core . StateTag < org . apache . beam . sdk . state . BagState < java . lang . String > > addr = org . apache . beam . runners . core . StateTags . bag ( \"bag\" , org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) ) ; org . apache . beam . sdk . state . BagState < java . lang . String > bag = underTest . state ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . NAMESPACE , addr ) ; org . apache . beam . vendor . guava . v20_0 . com . google . common . util . concurrent . SettableFuture < java . lang . Iterable < java . lang . String > > future = org . apache . beam . vendor . guava . v20_0 . com . google . common . util . concurrent . SettableFuture . create ( ) ; when ( mockReader . bagFuture ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . key ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . NAMESPACE , \"bag\" ) , org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . STATE_FAMILY , org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) ) ) . thenReturn ( future ) ; org . apache . beam . sdk . state . ReadableState < java . lang . Boolean > result = bag . isEmpty ( ) . readLater ( ) ; org . mockito . Mockito . verify ( mockReader ) . bagFuture ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . key ( org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . NAMESPACE , \"bag\" ) , org . apache . beam . runners . dataflow . worker . WindmillStateInternalsTest . STATE_FAMILY , org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) ) ; waitAndSet ( future , java . util . Arrays . < java . lang . String > asList ( ) , 200 ) ; \"<AssertPlaceHolder>\" ; } read ( ) { return read ( ( ( byte [ ] ) ( null ) ) , ( ( byte [ ] ) ( null ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( result . read ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "sizeOf ( java . sql . ResultSet ) { int tableCount = 0 ; while ( rs . next ( ) ) { tableCount ++ ; } return tableCount ; }", "testMethod": "shouldGetAllTablesFilteredByAllTypes ( ) { java . sql . ResultSet rs = metaData . getTableTypes ( ) ; com . orientechnologies . orient . jdbc . List < java . lang . String > tableTypes = new com . orientechnologies . orient . jdbc . ArrayList ( 2 ) ; while ( rs . next ( ) ) { tableTypes . add ( rs . getString ( 1 ) ) ; } rs = metaData . getTables ( null , null , null , tableTypes . toArray ( new java . lang . String [ 2 ] ) ) ; int tableCount = sizeOf ( rs ) ; \"<AssertPlaceHolder>\" . isEqualTo ( 16 ) ; }", "assertLine": "org . junit . Assert . assertThat ( tableCount )", "total": "shouldGetAllTablesFilteredByAllTypes ( ) { java . sql . ResultSet rs = metaData . getTableTypes ( ) ; com . orientechnologies . orient . jdbc . List < java . lang . String > tableTypes = new com . orientechnologies . orient . jdbc . ArrayList ( 2 ) ; while ( rs . next ( ) ) { tableTypes . add ( rs . getString ( 1 ) ) ; } rs = metaData . getTables ( null , null , null , tableTypes . toArray ( new java . lang . String [ 2 ] ) ) ; int tableCount = sizeOf ( rs ) ; \"<AssertPlaceHolder>\" . isEqualTo ( 16 ) ; } sizeOf ( java . sql . ResultSet ) { int tableCount = 0 ; while ( rs . next ( ) ) { tableCount ++ ; } return tableCount ; }", "answer": "org . junit . Assert . assertThat ( tableCount )"}
{"focal": "size ( ) { return values . size ( ) ; }", "testMethod": "createReferencesEmpty1 ( ) { java . util . GregorianCalendar cal = new java . util . GregorianCalendar ( 2014 , 10 , 22 , 11 , 30 , 1 ) ; cal . set ( GregorianCalendar . MILLISECOND , 1 ) ; java . time . Instant start = cal . getTime ( ) . toInstant ( ) ; org . diirt . util . time . TimeInterval timeInterval = org . diirt . util . time . TimeInterval . between ( start , start . plus ( java . time . Duration . ofMillis ( ( - 5 ) ) ) ) ; java . util . List < java . time . Instant > references = org . diirt . graphene . TimeScales . createReferences ( timeInterval , new org . diirt . graphene . TimeScales . TimePeriod ( MILLISECOND , 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( references . size ( ) , equalTo ( 0 ) )", "total": "createReferencesEmpty1 ( ) { java . util . GregorianCalendar cal = new java . util . GregorianCalendar ( 2014 , 10 , 22 , 11 , 30 , 1 ) ; cal . set ( GregorianCalendar . MILLISECOND , 1 ) ; java . time . Instant start = cal . getTime ( ) . toInstant ( ) ; org . diirt . util . time . TimeInterval timeInterval = org . diirt . util . time . TimeInterval . between ( start , start . plus ( java . time . Duration . ofMillis ( ( - 5 ) ) ) ) ; java . util . List < java . time . Instant > references = org . diirt . graphene . TimeScales . createReferences ( timeInterval , new org . diirt . graphene . TimeScales . TimePeriod ( MILLISECOND , 1 ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return values . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( references . size ( ) , equalTo ( 0 ) )"}
{"focal": "containsInAnyOrder ( java . util . Collection ) { @ org . apache . beam . sdk . testing . SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) final java . util . Collection < org . hamcrest . Matcher < ? super T > > matchers = ( ( java . util . Collection ) ( serializableMatchers ) ) ; return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . containsInAnyOrder ( matchers ) ) ; }", "testMethod": "testReadWithDifferentCodecs ( ) { java . lang . String [ ] codecs = new java . lang . String [ ] { org . apache . avro . file . DataFileConstants . NULL_CODEC , org . apache . avro . file . DataFileConstants . BZIP2_CODEC , org . apache . avro . file . DataFileConstants . DEFLATE_CODEC , org . apache . avro . file . DataFileConstants . SNAPPY_CODEC , org . apache . avro . file . DataFileConstants . XZ_CODEC } ; java . util . List < org . apache . beam . sdk . io . AvroSourceTest . Bird > expected = org . apache . beam . sdk . io . AvroSourceTest . createRandomRecords ( ( 1 << 16 ) ) ; for ( java . lang . String codec : codecs ) { java . lang . String filename = generateTestFile ( codec , expected , org . apache . beam . sdk . io . AvroSourceTest . SyncBehavior . SYNC_DEFAULT , 0 , org . apache . beam . sdk . coders . AvroCoder . of ( org . apache . beam . sdk . io . AvroSourceTest . Bird . class ) , codec ) ; org . apache . beam . sdk . io . AvroSource < org . apache . beam . sdk . io . AvroSourceTest . Bird > source = org . apache . beam . sdk . io . AvroSource . from ( filename ) . withSchema ( org . apache . beam . sdk . io . AvroSourceTest . Bird . class ) ; java . util . List < org . apache . beam . sdk . io . AvroSourceTest . Bird > actual = org . apache . beam . sdk . testing . SourceTestUtils . readFromSource ( source , null ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( expected , org . hamcrest . Matchers . containsInAnyOrder ( actual . toArray ( ) ) )", "total": "testReadWithDifferentCodecs ( ) { java . lang . String [ ] codecs = new java . lang . String [ ] { org . apache . avro . file . DataFileConstants . NULL_CODEC , org . apache . avro . file . DataFileConstants . BZIP2_CODEC , org . apache . avro . file . DataFileConstants . DEFLATE_CODEC , org . apache . avro . file . DataFileConstants . SNAPPY_CODEC , org . apache . avro . file . DataFileConstants . XZ_CODEC } ; java . util . List < org . apache . beam . sdk . io . AvroSourceTest . Bird > expected = org . apache . beam . sdk . io . AvroSourceTest . createRandomRecords ( ( 1 << 16 ) ) ; for ( java . lang . String codec : codecs ) { java . lang . String filename = generateTestFile ( codec , expected , org . apache . beam . sdk . io . AvroSourceTest . SyncBehavior . SYNC_DEFAULT , 0 , org . apache . beam . sdk . coders . AvroCoder . of ( org . apache . beam . sdk . io . AvroSourceTest . Bird . class ) , codec ) ; org . apache . beam . sdk . io . AvroSource < org . apache . beam . sdk . io . AvroSourceTest . Bird > source = org . apache . beam . sdk . io . AvroSource . from ( filename ) . withSchema ( org . apache . beam . sdk . io . AvroSourceTest . Bird . class ) ; java . util . List < org . apache . beam . sdk . io . AvroSourceTest . Bird > actual = org . apache . beam . sdk . testing . SourceTestUtils . readFromSource ( source , null ) ; \"<AssertPlaceHolder>\" ; } } containsInAnyOrder ( java . util . Collection ) { @ org . apache . beam . sdk . testing . SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) final java . util . Collection < org . hamcrest . Matcher < ? super T > > matchers = ( ( java . util . Collection ) ( serializableMatchers ) ) ; return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . containsInAnyOrder ( matchers ) ) ; }", "answer": "org . junit . Assert . assertThat ( expected , org . hamcrest . Matchers . containsInAnyOrder ( actual . toArray ( ) ) )"}
{"focal": "listAndParseSavedQueries ( ) { final org . springframework . test . web . servlet . MvcResult listResult = listSavedQueries ( ) . andExpect ( status ( ) . isOk ( ) ) . andReturn ( ) ; return objectMapper . readValue ( listResult . getResponse ( ) . getContentAsString ( ) , com . hp . autonomy . frontend . find . core . savedsearches . query . AbstractSavedQueryIT . LIST_TYPE_REFERENCE ) ; }", "testMethod": "getAllReturnsNothing ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( listAndParseSavedQueries ( ) , org . hamcrest . CoreMatchers . is ( empty ( ) ) )", "total": "getAllReturnsNothing ( ) { \"<AssertPlaceHolder>\" ; } listAndParseSavedQueries ( ) { final org . springframework . test . web . servlet . MvcResult listResult = listSavedQueries ( ) . andExpect ( status ( ) . isOk ( ) ) . andReturn ( ) ; return objectMapper . readValue ( listResult . getResponse ( ) . getContentAsString ( ) , com . hp . autonomy . frontend . find . core . savedsearches . query . AbstractSavedQueryIT . LIST_TYPE_REFERENCE ) ; }", "answer": "org . junit . Assert . assertThat ( listAndParseSavedQueries ( ) , org . hamcrest . CoreMatchers . is ( empty ( ) ) )"}
{"focal": "getTagName ( ) { return ( ( java . lang . String ) ( execute ( DriverCommand . GET_ELEMENT_TAG_NAME , com . google . common . collect . ImmutableMap . of ( \"id\" , id ) ) . getValue ( ) ) ) ; }", "testMethod": "testShouldBeAbleToFindASingleElementByTagName ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . tagName ( \"input\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( element . getTagName ( ) . toLowerCase ( ) , org . hamcrest . Matchers . is ( \"input\" ) )", "total": "testShouldBeAbleToFindASingleElementByTagName ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . tagName ( \"input\" ) ) ; \"<AssertPlaceHolder>\" ; } getTagName ( ) { return ( ( java . lang . String ) ( execute ( DriverCommand . GET_ELEMENT_TAG_NAME , com . google . common . collect . ImmutableMap . of ( \"id\" , id ) ) . getValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( element . getTagName ( ) . toLowerCase ( ) , org . hamcrest . Matchers . is ( \"input\" ) )"}
{"focal": "handle ( java . lang . Exception , org . springframework . springfaces . mvc . context . SpringFacesContext ) { javax . faces . context . ExternalContext externalContext = context . getFacesContext ( ) . getExternalContext ( ) ; javax . servlet . http . HttpServletRequest request = ( ( javax . servlet . http . HttpServletRequest ) ( externalContext . getRequest ( ) ) ) ; javax . servlet . http . HttpServletResponse response = ( ( javax . servlet . http . HttpServletResponse ) ( externalContext . getResponse ( ) ) ) ; java . lang . Object handler = context . getHandler ( ) ; org . springframework . web . servlet . ModelAndView modelAndView = processHandlerException ( request , response , handler , exception ) ; if ( modelAndView != null ) { org . springframework . web . util . WebUtils . clearErrorRequestAttributes ( request ) ; if ( modelAndView . isReference ( ) ) { java . lang . String viewName = modelAndView . getViewName ( ) ; java . util . Map < java . lang . String , java . lang . Object > model = modelAndView . getModel ( ) ; java . util . Locale locale = org . springframework . springfaces . util . FacesUtils . getLocale ( context . getFacesContext ( ) ) ; org . springframework . web . servlet . View view = this . dispatcher . resolveViewName ( viewName , model , locale , request ) ; modelAndView . setView ( view ) ; } context . render ( modelAndView . getView ( ) , modelAndView . getModel ( ) ) ; return true ; } return false ; }", "testMethod": "shouldNotHandleMissingMessage ( ) { this . handler . setMessageSource ( this . messageSource ) ; given ( this . messageSource . getMessage ( this . exception , null , null ) ) . willThrow ( new org . springframework . springfaces . message . NoSuchObjectMessageException ( this . exception , null ) ) ; boolean result = this . handler . handle ( this . exception , this . event ) ; \"<AssertPlaceHolder>\" ; verify ( this . facesContext , never ( ) ) . addMessage ( anyString ( ) , isA ( javax . faces . application . FacesMessage . class ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )", "total": "shouldNotHandleMissingMessage ( ) { this . handler . setMessageSource ( this . messageSource ) ; given ( this . messageSource . getMessage ( this . exception , null , null ) ) . willThrow ( new org . springframework . springfaces . message . NoSuchObjectMessageException ( this . exception , null ) ) ; boolean result = this . handler . handle ( this . exception , this . event ) ; \"<AssertPlaceHolder>\" ; verify ( this . facesContext , never ( ) ) . addMessage ( anyString ( ) , isA ( javax . faces . application . FacesMessage . class ) ) ; } handle ( java . lang . Exception , org . springframework . springfaces . mvc . context . SpringFacesContext ) { javax . faces . context . ExternalContext externalContext = context . getFacesContext ( ) . getExternalContext ( ) ; javax . servlet . http . HttpServletRequest request = ( ( javax . servlet . http . HttpServletRequest ) ( externalContext . getRequest ( ) ) ) ; javax . servlet . http . HttpServletResponse response = ( ( javax . servlet . http . HttpServletResponse ) ( externalContext . getResponse ( ) ) ) ; java . lang . Object handler = context . getHandler ( ) ; org . springframework . web . servlet . ModelAndView modelAndView = processHandlerException ( request , response , handler , exception ) ; if ( modelAndView != null ) { org . springframework . web . util . WebUtils . clearErrorRequestAttributes ( request ) ; if ( modelAndView . isReference ( ) ) { java . lang . String viewName = modelAndView . getViewName ( ) ; java . util . Map < java . lang . String , java . lang . Object > model = modelAndView . getModel ( ) ; java . util . Locale locale = org . springframework . springfaces . util . FacesUtils . getLocale ( context . getFacesContext ( ) ) ; org . springframework . web . servlet . View view = this . dispatcher . resolveViewName ( viewName , model , locale , request ) ; modelAndView . setView ( view ) ; } context . render ( modelAndView . getView ( ) , modelAndView . getModel ( ) ) ; return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "toCalendar ( java . lang . String ) { java . util . Calendar calendar = java . util . Calendar . getInstance ( ) ; calendar . setTime ( toDate ( dateString ) ) ; return calendar ; }", "testMethod": "shouldGetTheSameDayIfAlreadyWorkingDay ( ) { java . util . Calendar workingDay = toCalendar ( \"01-Nov-2010\" ) ; org . joda . time . DateTime holidayAsDateTime = new org . joda . time . DateTime ( workingDay . getTime ( ) . getTime ( ) ) ; java . lang . String holidayAsString = holidayAsDateTime . toLocalDate ( ) . toString ( ) ; when ( fiscalCalendarRules . isWorkingDay ( workingDay ) ) . thenReturn ( true ) ; when ( holidayDao . isHoliday ( officeId , holidayAsString ) ) . thenReturn ( false ) ; java . util . Calendar nextWorkingDay = holidayService . getNextWorkingDay ( toCalendar ( \"01-Nov-2010\" ) , officeId ) ; \"<AssertPlaceHolder>\" ; verify ( fiscalCalendarRules , times ( 1 ) ) . isWorkingDay ( workingDay ) ; verify ( holidayDao ) . isHoliday ( officeId , holidayAsString ) ; }", "assertLine": "org . junit . Assert . assertThat ( nextWorkingDay , org . hamcrest . Matchers . is ( workingDay ) )", "total": "shouldGetTheSameDayIfAlreadyWorkingDay ( ) { java . util . Calendar workingDay = toCalendar ( \"01-Nov-2010\" ) ; org . joda . time . DateTime holidayAsDateTime = new org . joda . time . DateTime ( workingDay . getTime ( ) . getTime ( ) ) ; java . lang . String holidayAsString = holidayAsDateTime . toLocalDate ( ) . toString ( ) ; when ( fiscalCalendarRules . isWorkingDay ( workingDay ) ) . thenReturn ( true ) ; when ( holidayDao . isHoliday ( officeId , holidayAsString ) ) . thenReturn ( false ) ; java . util . Calendar nextWorkingDay = holidayService . getNextWorkingDay ( toCalendar ( \"01-Nov-2010\" ) , officeId ) ; \"<AssertPlaceHolder>\" ; verify ( fiscalCalendarRules , times ( 1 ) ) . isWorkingDay ( workingDay ) ; verify ( holidayDao ) . isHoliday ( officeId , holidayAsString ) ; } toCalendar ( java . lang . String ) { java . util . Calendar calendar = java . util . Calendar . getInstance ( ) ; calendar . setTime ( toDate ( dateString ) ) ; return calendar ; }", "answer": "org . junit . Assert . assertThat ( nextWorkingDay , org . hamcrest . Matchers . is ( workingDay ) )"}
{"focal": "equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "testMethod": "windowedValueCoderComponentsToConstructor ( ) { org . apache . beam . sdk . util . WindowedValue . FullWindowedValueCoder < java . lang . Iterable < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Integer > > > javaCoder = org . apache . beam . sdk . util . WindowedValue . FullWindowedValueCoder . of ( org . apache . beam . sdk . coders . IterableCoder . of ( org . apache . beam . sdk . coders . KvCoder . of ( org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) , org . apache . beam . sdk . coders . VarIntCoder . of ( ) ) ) , org . apache . beam . sdk . transforms . windowing . IntervalWindow . IntervalWindowCoder . of ( ) ) ; org . apache . beam . model . pipeline . v1 . RunnerApi . MessageWithComponents coderAndComponents = org . apache . beam . runners . core . construction . CoderTranslation . toProto ( javaCoder ) ; org . apache . beam . runners . core . construction . ModelCoders . WindowedValueCoderComponents windowedValueCoderComponents = org . apache . beam . runners . core . construction . ModelCoders . getWindowedValueCoderComponents ( coderAndComponents . getCoder ( ) ) ; org . apache . beam . model . pipeline . v1 . RunnerApi . Coder windowedCoder = org . apache . beam . runners . core . construction . ModelCoders . windowedValueCoder ( windowedValueCoderComponents . elementCoderId ( ) , windowedValueCoderComponents . windowCoderId ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( windowedCoder , org . hamcrest . Matchers . equalTo ( coderAndComponents . getCoder ( ) ) )", "total": "windowedValueCoderComponentsToConstructor ( ) { org . apache . beam . sdk . util . WindowedValue . FullWindowedValueCoder < java . lang . Iterable < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Integer > > > javaCoder = org . apache . beam . sdk . util . WindowedValue . FullWindowedValueCoder . of ( org . apache . beam . sdk . coders . IterableCoder . of ( org . apache . beam . sdk . coders . KvCoder . of ( org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) , org . apache . beam . sdk . coders . VarIntCoder . of ( ) ) ) , org . apache . beam . sdk . transforms . windowing . IntervalWindow . IntervalWindowCoder . of ( ) ) ; org . apache . beam . model . pipeline . v1 . RunnerApi . MessageWithComponents coderAndComponents = org . apache . beam . runners . core . construction . CoderTranslation . toProto ( javaCoder ) ; org . apache . beam . runners . core . construction . ModelCoders . WindowedValueCoderComponents windowedValueCoderComponents = org . apache . beam . runners . core . construction . ModelCoders . getWindowedValueCoderComponents ( coderAndComponents . getCoder ( ) ) ; org . apache . beam . model . pipeline . v1 . RunnerApi . Coder windowedCoder = org . apache . beam . runners . core . construction . ModelCoders . windowedValueCoder ( windowedValueCoderComponents . elementCoderId ( ) , windowedValueCoderComponents . windowCoderId ( ) ) ; \"<AssertPlaceHolder>\" ; } equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( windowedCoder , org . hamcrest . Matchers . equalTo ( coderAndComponents . getCoder ( ) ) )"}
{"focal": "getParameters ( ) { return this . parameters ; }", "testMethod": "getParameterValueInBodyURLEncoded ( ) { final net . jadler . Request req = net . jadler . Request . builder ( ) . method ( \"POST\" ) . requestURI ( java . net . URI . create ( \"http://localhost/\" ) ) . body ( java . lang . String . format ( \"%s=%s\" , net . jadler . RequestTest . PARAM_NAME_URL_ENCODED , net . jadler . RequestTest . PARAM_VALUE_URL_ENCODED ) . getBytes ( ) ) . header ( \"content-type\" , \"application/x-www-form-urlencoded\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( req . getParameters ( ) . getValue ( net . jadler . RequestTest . PARAM_NAME_URL_ENCODED ) , is ( net . jadler . RequestTest . PARAM_VALUE_URL_ENCODED ) )", "total": "getParameterValueInBodyURLEncoded ( ) { final net . jadler . Request req = net . jadler . Request . builder ( ) . method ( \"POST\" ) . requestURI ( java . net . URI . create ( \"http://localhost/\" ) ) . body ( java . lang . String . format ( \"%s=%s\" , net . jadler . RequestTest . PARAM_NAME_URL_ENCODED , net . jadler . RequestTest . PARAM_VALUE_URL_ENCODED ) . getBytes ( ) ) . header ( \"content-type\" , \"application/x-www-form-urlencoded\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getParameters ( ) { return this . parameters ; }", "answer": "org . junit . Assert . assertThat ( req . getParameters ( ) . getValue ( net . jadler . RequestTest . PARAM_NAME_URL_ENCODED ) , is ( net . jadler . RequestTest . PARAM_VALUE_URL_ENCODED ) )"}
{"focal": "read ( com . asakusafw . runtime . io . json . JsonFormat , byte [ ] ) { return com . asakusafw . runtime . io . json . JsonFormatTest . read ( format , bytes , ( d ) -> d . object ) ; }", "testMethod": "v_double ( ) { com . asakusafw . runtime . io . json . JsonFormat < com . asakusafw . runtime . io . json . JsonFormatTest . Data > format = builder ( ( r , d ) -> d . object = r . readDouble ( ) , ( w , d ) -> w . writeDouble ( d . doubleValue ) ) . build ( ) ; byte [ ] written = com . asakusafw . runtime . io . json . JsonFormatTest . write ( format , ( data , v ) -> data . doubleValue = v , 1.25 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . asakusafw . runtime . io . json . JsonFormatTest . read ( format , written ) , contains ( 1.25 ) )", "total": "v_double ( ) { com . asakusafw . runtime . io . json . JsonFormat < com . asakusafw . runtime . io . json . JsonFormatTest . Data > format = builder ( ( r , d ) -> d . object = r . readDouble ( ) , ( w , d ) -> w . writeDouble ( d . doubleValue ) ) . build ( ) ; byte [ ] written = com . asakusafw . runtime . io . json . JsonFormatTest . write ( format , ( data , v ) -> data . doubleValue = v , 1.25 ) ; \"<AssertPlaceHolder>\" ; } read ( com . asakusafw . runtime . io . json . JsonFormat , byte [ ] ) { return com . asakusafw . runtime . io . json . JsonFormatTest . read ( format , bytes , ( d ) -> d . object ) ; }", "answer": "org . junit . Assert . assertThat ( com . asakusafw . runtime . io . json . JsonFormatTest . read ( format , written ) , contains ( 1.25 ) )"}
{"focal": "size ( ) { return elements . size ( ) ; }", "testMethod": "givenEmployeeList_andNameFilterList_thenObtainFilteredEmployeeList_usingForEachLoop ( ) { java . util . List < com . baeldung . collection . filtering . Employee > filteredList = new java . util . ArrayList ( ) ; java . util . List < com . baeldung . collection . filtering . Employee > originalList = buildEmployeeList ( ) ; java . util . List < java . lang . String > nameFilter = employeeNameFilter ( ) ; for ( com . baeldung . collection . filtering . Employee employee : originalList ) { for ( java . lang . String name : nameFilter ) { if ( employee . getName ( ) . equalsIgnoreCase ( name ) ) { filteredList . add ( employee ) ; } } } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filteredList . size ( ) , org . hamcrest . Matchers . is ( nameFilter . size ( ) ) )", "total": "givenEmployeeList_andNameFilterList_thenObtainFilteredEmployeeList_usingForEachLoop ( ) { java . util . List < com . baeldung . collection . filtering . Employee > filteredList = new java . util . ArrayList ( ) ; java . util . List < com . baeldung . collection . filtering . Employee > originalList = buildEmployeeList ( ) ; java . util . List < java . lang . String > nameFilter = employeeNameFilter ( ) ; for ( com . baeldung . collection . filtering . Employee employee : originalList ) { for ( java . lang . String name : nameFilter ) { if ( employee . getName ( ) . equalsIgnoreCase ( name ) ) { filteredList . add ( employee ) ; } } } \"<AssertPlaceHolder>\" ; } size ( ) { return elements . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( filteredList . size ( ) , org . hamcrest . Matchers . is ( nameFilter . size ( ) ) )"}
{"focal": "hasSize ( org . hamcrest . Matcher ) { return new org . batfish . datamodel . matchers . RowsMatchersImpl . HasSize ( subMatcher ) ; }", "testMethod": "autoCompleteEmptyString ( ) { java . util . Set < java . lang . String > nodes = new java . util . HashSet ( ) ; nodes . add ( \"node1\" ) ; java . lang . String query = \"\" ; java . util . List < org . batfish . datamodel . answers . AutocompleteSuggestion > suggestions = org . batfish . datamodel . questions . NodesSpecifier . autoComplete ( query , nodes , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( suggestions , org . hamcrest . Matchers . hasSize ( 4 ) )", "total": "autoCompleteEmptyString ( ) { java . util . Set < java . lang . String > nodes = new java . util . HashSet ( ) ; nodes . add ( \"node1\" ) ; java . lang . String query = \"\" ; java . util . List < org . batfish . datamodel . answers . AutocompleteSuggestion > suggestions = org . batfish . datamodel . questions . NodesSpecifier . autoComplete ( query , nodes , null ) ; \"<AssertPlaceHolder>\" ; } hasSize ( org . hamcrest . Matcher ) { return new org . batfish . datamodel . matchers . RowsMatchersImpl . HasSize ( subMatcher ) ; }", "answer": "org . junit . Assert . assertThat ( suggestions , org . hamcrest . Matchers . hasSize ( 4 ) )"}
{"focal": "size ( ) { assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Animal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Mammal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Lion . class ) ) . hasSize ( 5 ) ; }", "testMethod": "findByLease ( ) { org . estatio . module . lease . dom . Lease lease = Lease_enum . OxfTopModel001Gb . findUsing ( serviceRegistry ) ; java . util . List < org . estatio . module . lease . dom . breaks . BreakOption > result = breakOptionRepository . findByLease ( lease ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "findByLease ( ) { org . estatio . module . lease . dom . Lease lease = Lease_enum . OxfTopModel001Gb . findUsing ( serviceRegistry ) ; java . util . List < org . estatio . module . lease . dom . breaks . BreakOption > result = breakOptionRepository . findByLease ( lease ) ; \"<AssertPlaceHolder>\" ; } size ( ) { assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Animal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Mammal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Lion . class ) ) . hasSize ( 5 ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "test ( T extends com . oracle . bedrock . predicate . Comparable ) { return value == null ? false : ( value . compareTo ( this . value ) ) < 0 ; }", "testMethod": "shouldEvaluateFalseIfIncludesDoNotMatchAndExcludesEmpty ( ) { java . util . function . Predicate < java . lang . Class < ? > > inner = mock ( java . util . function . Predicate . class ) ; com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher include1 = mock ( TestClasses . TestMatcher . class ) ; com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher include2 = mock ( TestClasses . TestMatcher . class ) ; java . util . Set < com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher > includes = new java . util . HashSet ( java . util . Arrays . asList ( include1 , include2 ) ) ; java . util . Set < com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher > excludes = new java . util . HashSet ( ) ; com . oracle . bedrock . testsupport . junit . options . TestClasses . IncludeExcludePredicate predicate = new com . oracle . bedrock . testsupport . junit . options . TestClasses . IncludeExcludePredicate ( inner , includes , excludes ) ; when ( inner . test ( any ( java . lang . Class . class ) ) ) . thenReturn ( true ) ; when ( include1 . hasClassPattern ( ) ) . thenReturn ( true ) ; when ( include1 . matches ( anyString ( ) ) ) . thenReturn ( false ) ; when ( include2 . hasClassPattern ( ) ) . thenReturn ( true ) ; when ( include2 . matches ( anyString ( ) ) ) . thenReturn ( false ) ; \"<AssertPlaceHolder>\" ; verify ( include1 ) . matches ( com . oracle . bedrock . testsupport . junit . options . Integer . class . getCanonicalName ( ) ) ; verify ( include2 ) . matches ( com . oracle . bedrock . testsupport . junit . options . Integer . class . getCanonicalName ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( predicate . test ( com . oracle . bedrock . testsupport . junit . options . Integer . class ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "shouldEvaluateFalseIfIncludesDoNotMatchAndExcludesEmpty ( ) { java . util . function . Predicate < java . lang . Class < ? > > inner = mock ( java . util . function . Predicate . class ) ; com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher include1 = mock ( TestClasses . TestMatcher . class ) ; com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher include2 = mock ( TestClasses . TestMatcher . class ) ; java . util . Set < com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher > includes = new java . util . HashSet ( java . util . Arrays . asList ( include1 , include2 ) ) ; java . util . Set < com . oracle . bedrock . testsupport . junit . options . TestClasses . TestMatcher > excludes = new java . util . HashSet ( ) ; com . oracle . bedrock . testsupport . junit . options . TestClasses . IncludeExcludePredicate predicate = new com . oracle . bedrock . testsupport . junit . options . TestClasses . IncludeExcludePredicate ( inner , includes , excludes ) ; when ( inner . test ( any ( java . lang . Class . class ) ) ) . thenReturn ( true ) ; when ( include1 . hasClassPattern ( ) ) . thenReturn ( true ) ; when ( include1 . matches ( anyString ( ) ) ) . thenReturn ( false ) ; when ( include2 . hasClassPattern ( ) ) . thenReturn ( true ) ; when ( include2 . matches ( anyString ( ) ) ) . thenReturn ( false ) ; \"<AssertPlaceHolder>\" ; verify ( include1 ) . matches ( com . oracle . bedrock . testsupport . junit . options . Integer . class . getCanonicalName ( ) ) ; verify ( include2 ) . matches ( com . oracle . bedrock . testsupport . junit . options . Integer . class . getCanonicalName ( ) ) ; } test ( T extends com . oracle . bedrock . predicate . Comparable ) { return value == null ? false : ( value . compareTo ( this . value ) ) < 0 ; }", "answer": "org . junit . Assert . assertThat ( predicate . test ( com . oracle . bedrock . testsupport . junit . options . Integer . class ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isPermitted ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType ) { boolean permitted ; oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . ResponseType xacmlResponse ; try { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Calling<sp>PDP<sp>to<sp>evaluate<sp>XACML<sp>request.\" ) ; xacmlResponse = pdp . evaluate ( xacmlRequest ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Received<sp>response<sp>from<sp>PDP.\" ) ; permitted = ( xacmlResponse != null ) && ( ( xacmlResponse . getResult ( ) . get ( 0 ) . getDecision ( ) ) == ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . DecisionType . PERMIT ) ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Permitted:<sp>{}\" , permitted ) ; } catch ( ddf . security . pdp . realm . xacml . processor . PdpException e ) { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( e . getMessage ( ) , e ) ; permitted = false ; } return permitted ; }", "testMethod": "testSameAccessRedaction ( ) { java . util . HashMap < java . lang . String , java . util . List < java . lang . String > > security = new java . util . HashMap < java . lang . String , java . util . List < java . lang . String > > ( ) ; security . put ( ddf . security . pdp . realm . xacml . XacmlPdpTest . RESOURCE_ACCESS , java . util . Arrays . asList ( ddf . security . pdp . realm . xacml . XacmlPdpTest . ACCESS_TYPE_A , ddf . security . pdp . realm . xacml . XacmlPdpTest . ACCESS_TYPE_B ) ) ; ddf . security . permission . KeyValueCollectionPermission resourcePermissions = new ddf . security . permission . KeyValueCollectionPermission ( ddf . security . permission . CollectionPermission . READ_ACTION , security ) ; oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType request = ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . createXACMLRequest ( ddf . security . pdp . realm . xacml . XacmlPdpTest . USER_NAME , generateSubjectInfo ( ddf . security . pdp . realm . xacml . XacmlPdpTest . TEST_COUNTRY ) , resourcePermissions ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . isPermitted ( request ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "testSameAccessRedaction ( ) { java . util . HashMap < java . lang . String , java . util . List < java . lang . String > > security = new java . util . HashMap < java . lang . String , java . util . List < java . lang . String > > ( ) ; security . put ( ddf . security . pdp . realm . xacml . XacmlPdpTest . RESOURCE_ACCESS , java . util . Arrays . asList ( ddf . security . pdp . realm . xacml . XacmlPdpTest . ACCESS_TYPE_A , ddf . security . pdp . realm . xacml . XacmlPdpTest . ACCESS_TYPE_B ) ) ; ddf . security . permission . KeyValueCollectionPermission resourcePermissions = new ddf . security . permission . KeyValueCollectionPermission ( ddf . security . permission . CollectionPermission . READ_ACTION , security ) ; oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType request = ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . createXACMLRequest ( ddf . security . pdp . realm . xacml . XacmlPdpTest . USER_NAME , generateSubjectInfo ( ddf . security . pdp . realm . xacml . XacmlPdpTest . TEST_COUNTRY ) , resourcePermissions ) ; \"<AssertPlaceHolder>\" ; } isPermitted ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType ) { boolean permitted ; oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . ResponseType xacmlResponse ; try { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Calling<sp>PDP<sp>to<sp>evaluate<sp>XACML<sp>request.\" ) ; xacmlResponse = pdp . evaluate ( xacmlRequest ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Received<sp>response<sp>from<sp>PDP.\" ) ; permitted = ( xacmlResponse != null ) && ( ( xacmlResponse . getResult ( ) . get ( 0 ) . getDecision ( ) ) == ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . DecisionType . PERMIT ) ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Permitted:<sp>{}\" , permitted ) ; } catch ( ddf . security . pdp . realm . xacml . processor . PdpException e ) { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( e . getMessage ( ) , e ) ; permitted = false ; } return permitted ; }", "answer": "org . junit . Assert . assertThat ( ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . isPermitted ( request ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "onFinally ( ) { }", "testMethod": "shouldCallOnExceptionForExceptionInDoInBackground ( ) { final org . robolectric . shadows . ShadowLooper looper = org . robolectric . Robolectric . shadowOf ( android . os . Looper . getMainLooper ( ) ) ; final boolean [ ] callRecord = new boolean [ ] { false , false , false , false } ; final boolean [ ] correctAnswer = new boolean [ ] { true , false , true , true } ; java . util . concurrent . Executors . newSingleThreadExecutor ( ) . submit ( new roboguice . util . AndroidCallable < java . lang . String > ( ) { @ roboguice . util . Override public void onPreCall ( ) { callRecord [ 0 ] = true ; } @ roboguice . util . Override public java . lang . String doInBackground ( ) throws roboguice . util . Exception { throw new java . lang . Exception ( ) ; } @ roboguice . util . Override public void onSuccess ( java . lang . String result ) { callRecord [ 1 ] = true ; } @ roboguice . util . Override public void onException ( java . lang . Exception e ) { callRecord [ 2 ] = true ; } @ roboguice . util . Override public void onFinally ( ) { callRecord [ 3 ] = true ; } } ) ; while ( ! ( callRecord [ ( ( callRecord . length ) - 1 ) ] ) ) looper . runToEndOfTasks ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( callRecord , org . hamcrest . CoreMatchers . equalTo ( correctAnswer ) )", "total": "shouldCallOnExceptionForExceptionInDoInBackground ( ) { final org . robolectric . shadows . ShadowLooper looper = org . robolectric . Robolectric . shadowOf ( android . os . Looper . getMainLooper ( ) ) ; final boolean [ ] callRecord = new boolean [ ] { false , false , false , false } ; final boolean [ ] correctAnswer = new boolean [ ] { true , false , true , true } ; java . util . concurrent . Executors . newSingleThreadExecutor ( ) . submit ( new roboguice . util . AndroidCallable < java . lang . String > ( ) { @ roboguice . util . Override public void onPreCall ( ) { callRecord [ 0 ] = true ; } @ roboguice . util . Override public java . lang . String doInBackground ( ) throws roboguice . util . Exception { throw new java . lang . Exception ( ) ; } @ roboguice . util . Override public void onSuccess ( java . lang . String result ) { callRecord [ 1 ] = true ; } @ roboguice . util . Override public void onException ( java . lang . Exception e ) { callRecord [ 2 ] = true ; } @ roboguice . util . Override public void onFinally ( ) { callRecord [ 3 ] = true ; } } ) ; while ( ! ( callRecord [ ( ( callRecord . length ) - 1 ) ] ) ) looper . runToEndOfTasks ( ) ; \"<AssertPlaceHolder>\" ; } onFinally ( ) { }", "answer": "org . junit . Assert . assertThat ( callRecord , org . hamcrest . CoreMatchers . equalTo ( correctAnswer ) )"}
{"focal": "isAuditViewEntryRelevant ( ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry , ch . puzzle . itc . mobiliar . business . auditview . control . Map ) { if ( entry == null ) { return false ; } if ( ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . ADD ) ) || ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . DEL ) ) ) { return true ; } if ( ( allAuditViewEntries . get ( entry . hashCode ( ) ) ) != null ) { return false ; } if ( entry . getType ( ) . equals ( Auditable . TYPE_TEMPLATE_DESCRIPTOR ) ) { return true ; } if ( entry . isObfuscatedValue ( ) ) { return true ; } return ! ( org . apache . commons . lang . StringUtils . equals ( entry . getOldValue ( ) , entry . getValue ( ) ) ) ; }", "testMethod": "shouldReturnFalseIfEntryIsAlreadyInList ( ) { java . lang . String oldValue = \"Technical<sp>Key:<sp>appLogLevel-tmp\" ; java . lang . String newValue = \"Technical<sp>Key:<sp>appLogLevel\" ; ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity revisionEntity = new ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity ( ) ; ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry entryInList = ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry . builder ( revisionEntity , RevisionType . MOD ) . oldValue ( oldValue ) . value ( newValue ) . type ( ch . puzzle . itc . mobiliar . business . auditview . control . EMPTY ) . build ( ) ; java . util . Map < java . lang . Integer , ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry > allAuditViewEntries = new java . util . HashMap ( 1 ) ; allAuditViewEntries . put ( entryInList . hashCode ( ) , entryInList ) ; boolean relevant = auditService . isAuditViewEntryRelevant ( entryInList , allAuditViewEntries ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( relevant , org . hamcrest . Matchers . is ( false ) )", "total": "shouldReturnFalseIfEntryIsAlreadyInList ( ) { java . lang . String oldValue = \"Technical<sp>Key:<sp>appLogLevel-tmp\" ; java . lang . String newValue = \"Technical<sp>Key:<sp>appLogLevel\" ; ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity revisionEntity = new ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity ( ) ; ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry entryInList = ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry . builder ( revisionEntity , RevisionType . MOD ) . oldValue ( oldValue ) . value ( newValue ) . type ( ch . puzzle . itc . mobiliar . business . auditview . control . EMPTY ) . build ( ) ; java . util . Map < java . lang . Integer , ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry > allAuditViewEntries = new java . util . HashMap ( 1 ) ; allAuditViewEntries . put ( entryInList . hashCode ( ) , entryInList ) ; boolean relevant = auditService . isAuditViewEntryRelevant ( entryInList , allAuditViewEntries ) ; \"<AssertPlaceHolder>\" ; } isAuditViewEntryRelevant ( ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry , ch . puzzle . itc . mobiliar . business . auditview . control . Map ) { if ( entry == null ) { return false ; } if ( ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . ADD ) ) || ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . DEL ) ) ) { return true ; } if ( ( allAuditViewEntries . get ( entry . hashCode ( ) ) ) != null ) { return false ; } if ( entry . getType ( ) . equals ( Auditable . TYPE_TEMPLATE_DESCRIPTOR ) ) { return true ; } if ( entry . isObfuscatedValue ( ) ) { return true ; } return ! ( org . apache . commons . lang . StringUtils . equals ( entry . getOldValue ( ) , entry . getValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( relevant , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "testMethod": "testMatchExactlyVlanNull ( ) { actions = new java . util . HashMap < java . lang . String , java . lang . String > ( ) { { put ( \"type\" , \"aaa\" ) ; put ( \"ip_ttl\" , \"12\" ) ; } } ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowActionSetIpTtlQuery ( actions ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetIpTtl action = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetIpTtl ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . matchExactly ( ( ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) ( action ) ) ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testMatchExactlyVlanNull ( ) { actions = new java . util . HashMap < java . lang . String , java . lang . String > ( ) { { put ( \"type\" , \"aaa\" ) ; put ( \"ip_ttl\" , \"12\" ) ; } } ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowActionSetIpTtlQuery ( actions ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetIpTtl action = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionSetIpTtl ( ) ; \"<AssertPlaceHolder>\" ; } matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . matchExactly ( ( ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) ( action ) ) ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "parse ( com . asakusafw . testdriver . core . TestToolRepository , java . lang . ClassLoader , java . net . URI ) { if ( ( java . util . Objects . equals ( uri . getScheme ( ) , com . asakusafw . testdriver . tools . runner . BatchTestTool . DirectIoInfo . SCHEME_DIRECTIO ) ) == false ) { return java . util . Optional . empty ( ) ; } java . lang . String body = uri . getSchemeSpecificPart ( ) ; java . lang . String [ ] elements = body . split ( \":\" , 2 ) ; if ( ( elements . length ) != 2 ) { return java . util . Optional . empty ( ) ; } java . lang . String className = elements [ 0 ] ; java . lang . String dataPath = elements [ 1 ] ; try { @ com . asakusafw . testdriver . tools . runner . SuppressWarnings ( \"unchecked\" ) java . lang . Class < ? extends com . asakusafw . runtime . directio . DataFormat < T > > formatClass = ( ( java . lang . Class < ? extends com . asakusafw . runtime . directio . DataFormat < T > > ) ( java . lang . Class . forName ( className , false , classLoader ) ) ) ; com . asakusafw . runtime . directio . DataFormat < T > format = formatClass . newInstance ( ) ; com . asakusafw . testdriver . core . DataModelDefinition < T > definition = tools . toDataModelDefinition ( format . getSupportedType ( ) ) ; return java . util . Optional . of ( new com . asakusafw . testdriver . tools . runner . BatchTestTool . DirectIoInfo ( definition , formatClass , dataPath ) ) ; } catch ( java . lang . ClassCastException | java . lang . ReflectiveOperationException e ) { throw new java . io . IOException ( java . text . MessageFormat . format ( com . asakusafw . testdriver . tools . runner . Messages . getString ( \"BatchTestTool.errorInvalidDataFormatClass\" ) , className ) , e ) ; } }", "testMethod": "implicit_field_name ( ) { com . asakusafw . dmdl . windgate . csv . driver . ModelLoader loaded = generateJava ( \"implicit_field_name\" ) ; com . asakusafw . windgate . core . vocabulary . DataModelStreamSupport < java . lang . Object > support = unsafe ( loaded . newObject ( \"csv\" , \"ModelCsvSupport\" ) ) ; com . asakusafw . dmdl . windgate . csv . driver . ModelWrapper model = loaded . newModel ( \"Model\" ) ; model . set ( \"value\" , new org . apache . hadoop . io . Text ( \"Hello,<sp>world!\" ) ) ; byte [ ] data = write ( support , model ) ; java . lang . String [ ] [ ] results = parse ( 1 , new java . lang . String ( data , \"UTF-8\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"value\" } , new java . lang . String [ ] { \"Hello,<sp>world!\" } } ) )", "total": "implicit_field_name ( ) { com . asakusafw . dmdl . windgate . csv . driver . ModelLoader loaded = generateJava ( \"implicit_field_name\" ) ; com . asakusafw . windgate . core . vocabulary . DataModelStreamSupport < java . lang . Object > support = unsafe ( loaded . newObject ( \"csv\" , \"ModelCsvSupport\" ) ) ; com . asakusafw . dmdl . windgate . csv . driver . ModelWrapper model = loaded . newModel ( \"Model\" ) ; model . set ( \"value\" , new org . apache . hadoop . io . Text ( \"Hello,<sp>world!\" ) ) ; byte [ ] data = write ( support , model ) ; java . lang . String [ ] [ ] results = parse ( 1 , new java . lang . String ( data , \"UTF-8\" ) ) ; \"<AssertPlaceHolder>\" ; } parse ( com . asakusafw . testdriver . core . TestToolRepository , java . lang . ClassLoader , java . net . URI ) { if ( ( java . util . Objects . equals ( uri . getScheme ( ) , com . asakusafw . testdriver . tools . runner . BatchTestTool . DirectIoInfo . SCHEME_DIRECTIO ) ) == false ) { return java . util . Optional . empty ( ) ; } java . lang . String body = uri . getSchemeSpecificPart ( ) ; java . lang . String [ ] elements = body . split ( \":\" , 2 ) ; if ( ( elements . length ) != 2 ) { return java . util . Optional . empty ( ) ; } java . lang . String className = elements [ 0 ] ; java . lang . String dataPath = elements [ 1 ] ; try { @ com . asakusafw . testdriver . tools . runner . SuppressWarnings ( \"unchecked\" ) java . lang . Class < ? extends com . asakusafw . runtime . directio . DataFormat < T > > formatClass = ( ( java . lang . Class < ? extends com . asakusafw . runtime . directio . DataFormat < T > > ) ( java . lang . Class . forName ( className , false , classLoader ) ) ) ; com . asakusafw . runtime . directio . DataFormat < T > format = formatClass . newInstance ( ) ; com . asakusafw . testdriver . core . DataModelDefinition < T > definition = tools . toDataModelDefinition ( format . getSupportedType ( ) ) ; return java . util . Optional . of ( new com . asakusafw . testdriver . tools . runner . BatchTestTool . DirectIoInfo ( definition , formatClass , dataPath ) ) ; } catch ( java . lang . ClassCastException | java . lang . ReflectiveOperationException e ) { throw new java . io . IOException ( java . text . MessageFormat . format ( com . asakusafw . testdriver . tools . runner . Messages . getString ( \"BatchTestTool.errorInvalidDataFormatClass\" ) , className ) , e ) ; } }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"value\" } , new java . lang . String [ ] { \"Hello,<sp>world!\" } } ) )"}
{"focal": "getCheckedItemPosition ( ) { return view . getCheckedItemPosition ( ) ; }", "testMethod": "whenUpdateView_thenViewShouldReflectChanges ( ) { attribute . updateView ( view , checkedItemPosition , viewAddOn ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( view . getCheckedItemPosition ( ) , org . hamcrest . CoreMatchers . equalTo ( checkedItemPosition ) )", "total": "whenUpdateView_thenViewShouldReflectChanges ( ) { attribute . updateView ( view , checkedItemPosition , viewAddOn ) ; \"<AssertPlaceHolder>\" ; } getCheckedItemPosition ( ) { return view . getCheckedItemPosition ( ) ; }", "answer": "org . junit . Assert . assertThat ( view . getCheckedItemPosition ( ) , org . hamcrest . CoreMatchers . equalTo ( checkedItemPosition ) )"}
{"focal": "print ( java . lang . String ) { out . print ( s ) ; }", "testMethod": "testAtom ( ) { final org . apache . calcite . util . PrecedenceClimbingParser p = new org . apache . calcite . util . PrecedenceClimbingParser . Builder ( ) . atom ( \"a\" ) . build ( ) ; final org . apache . calcite . util . PrecedenceClimbingParser . Token token = p . parse ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( p . print ( token ) , org . hamcrest . CoreMatchers . is ( \"a\" ) )", "total": "testAtom ( ) { final org . apache . calcite . util . PrecedenceClimbingParser p = new org . apache . calcite . util . PrecedenceClimbingParser . Builder ( ) . atom ( \"a\" ) . build ( ) ; final org . apache . calcite . util . PrecedenceClimbingParser . Token token = p . parse ( ) ; \"<AssertPlaceHolder>\" ; } print ( java . lang . String ) { out . print ( s ) ; }", "answer": "org . junit . Assert . assertThat ( p . print ( token ) , org . hamcrest . CoreMatchers . is ( \"a\" ) )"}
{"focal": "call ( ) { int exitCode = 0 ; try { scheduler ( ) . run ( ) ; } catch ( java . lang . Throwable t ) { log . error ( \"Caught<sp>throwable<sp>while<sp>processing<sp>data\" , t ) ; exitCode = 1 ; } return exitCode ; }", "testMethod": "testInterruptedAfterNotification ( ) { java . util . concurrent . Callable < java . lang . Boolean > requestedShutdownCallable = buildRequestedShutdownCallable ( ) ; when ( notificationCompleteLatch . await ( anyLong ( ) , any ( java . util . concurrent . TimeUnit . class ) ) ) . thenAnswer ( ( invocation ) -> { java . lang . Thread . currentThread ( ) . interrupt ( ) ; return true ; } ) ; \"<AssertPlaceHolder>\" ; verifyLatchAwait ( notificationCompleteLatch ) ; verifyLatchAwait ( shutdownCompleteLatch , never ( ) ) ; verify ( scheduler , never ( ) ) . shutdown ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( requestedShutdownCallable . call ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "testInterruptedAfterNotification ( ) { java . util . concurrent . Callable < java . lang . Boolean > requestedShutdownCallable = buildRequestedShutdownCallable ( ) ; when ( notificationCompleteLatch . await ( anyLong ( ) , any ( java . util . concurrent . TimeUnit . class ) ) ) . thenAnswer ( ( invocation ) -> { java . lang . Thread . currentThread ( ) . interrupt ( ) ; return true ; } ) ; \"<AssertPlaceHolder>\" ; verifyLatchAwait ( notificationCompleteLatch ) ; verifyLatchAwait ( shutdownCompleteLatch , never ( ) ) ; verify ( scheduler , never ( ) ) . shutdown ( ) ; } call ( ) { int exitCode = 0 ; try { scheduler ( ) . run ( ) ; } catch ( java . lang . Throwable t ) { log . error ( \"Caught<sp>throwable<sp>while<sp>processing<sp>data\" , t ) ; exitCode = 1 ; } return exitCode ; }", "answer": "org . junit . Assert . assertThat ( requestedShutdownCallable . call ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEquals ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPushPbb obj = target ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testEquals ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPushPbb obj = target ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testRouterType ( ) { isisNeighbor . setRouterType ( IsisRouterType . L1 ) ; isisRouterType = isisNeighbor . routerType ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isisRouterType , org . hamcrest . CoreMatchers . is ( IsisRouterType . L1 ) )", "total": "testRouterType ( ) { isisNeighbor . setRouterType ( IsisRouterType . L1 ) ; isisRouterType = isisNeighbor . routerType ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( isisRouterType , org . hamcrest . CoreMatchers . is ( IsisRouterType . L1 ) )"}
{"focal": "id ( java . lang . String ) { this . sqlId = sqlId ; return this ; }", "testMethod": "testParams1 ( ) { java . lang . Integer result = new org . n3r . eql . Eql ( ) . id ( \"testParams1\" ) . params ( 100323 , \"D\" , \"xxxyyy\" , new java . sql . Timestamp ( 1383122146000L ) , 132938 ) . execute ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testParams1 ( ) { java . lang . Integer result = new org . n3r . eql . Eql ( ) . id ( \"testParams1\" ) . params ( 100323 , \"D\" , \"xxxyyy\" , new java . sql . Timestamp ( 1383122146000L ) , 132938 ) . execute ( ) ; \"<AssertPlaceHolder>\" ; } id ( java . lang . String ) { this . sqlId = sqlId ; return this ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getCurrentContextId ( ) { return currentContextId . get ( ) ; }", "testMethod": "testGetContext_shouldReturnCurrentContext ( ) { org . openengsb . core . api . context . ContextHolder context = org . openengsb . core . api . context . ContextHolder . get ( ) ; context . setCurrentContextId ( \"foo\" ) ; java . lang . String contextId = context . getCurrentContextId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( contextId , org . hamcrest . CoreMatchers . is ( \"foo\" ) )", "total": "testGetContext_shouldReturnCurrentContext ( ) { org . openengsb . core . api . context . ContextHolder context = org . openengsb . core . api . context . ContextHolder . get ( ) ; context . setCurrentContextId ( \"foo\" ) ; java . lang . String contextId = context . getCurrentContextId ( ) ; \"<AssertPlaceHolder>\" ; } getCurrentContextId ( ) { return currentContextId . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( contextId , org . hamcrest . CoreMatchers . is ( \"foo\" ) )"}
{"focal": "getFileCharsetName ( net . pms . util . File ) { if ( file == null ) { return null ; } com . ibm . icu . text . CharsetMatch match = net . pms . util . FileUtil . getFileCharsetMatch ( file ) ; try { if ( java . nio . charset . Charset . isSupported ( match . getName ( ) ) ) { net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return match . getName ( ) . toUpperCase ( Locale . ROOT ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\",<sp>but<sp>cannot<sp>use<sp>it<sp>because<sp>it\\'s<sp>not<sp>supported<sp>by<sp>the<sp>Java<sp>Virual<sp>Machine\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return null ; } catch ( java . nio . charset . IllegalCharsetNameException e ) { net . pms . util . FileUtil . LOGGER . debug ( \"Illegal<sp>charset<sp>\\\"{}\\\"<sp>deteceted<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Found<sp>no<sp>matching<sp>charset<sp>for<sp>file<sp>\\\"{}\\\"\" , file . getAbsolutePath ( ) ) ; return null ; }", "testMethod": "testGetFileCharset_UTF8_with_BOM ( ) { java . io . File file = org . apache . commons . io . FileUtils . toFile ( CLASS . getResource ( \"russian-utf8-with-bom.srt\" ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( net . pms . util . CHARSET_UTF_8 ) ; }", "assertLine": "org . junit . Assert . assertThat ( net . pms . util . FileUtil . getFileCharsetName ( file ) )", "total": "testGetFileCharset_UTF8_with_BOM ( ) { java . io . File file = org . apache . commons . io . FileUtils . toFile ( CLASS . getResource ( \"russian-utf8-with-bom.srt\" ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( net . pms . util . CHARSET_UTF_8 ) ; } getFileCharsetName ( net . pms . util . File ) { if ( file == null ) { return null ; } com . ibm . icu . text . CharsetMatch match = net . pms . util . FileUtil . getFileCharsetMatch ( file ) ; try { if ( java . nio . charset . Charset . isSupported ( match . getName ( ) ) ) { net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return match . getName ( ) . toUpperCase ( Locale . ROOT ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\",<sp>but<sp>cannot<sp>use<sp>it<sp>because<sp>it\\'s<sp>not<sp>supported<sp>by<sp>the<sp>Java<sp>Virual<sp>Machine\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return null ; } catch ( java . nio . charset . IllegalCharsetNameException e ) { net . pms . util . FileUtil . LOGGER . debug ( \"Illegal<sp>charset<sp>\\\"{}\\\"<sp>deteceted<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Found<sp>no<sp>matching<sp>charset<sp>for<sp>file<sp>\\\"{}\\\"\" , file . getAbsolutePath ( ) ) ; return null ; }", "answer": "org . junit . Assert . assertThat ( net . pms . util . FileUtil . getFileCharsetName ( file ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "getByExistingArtistReturnsThreeTracks ( ) { fm . last . musicbrainz . data . model . Artist artist = ( ( fm . last . musicbrainz . data . model . Artist ) ( session . load ( fm . last . musicbrainz . data . model . Artist . class , 5 ) ) ) ; java . util . List < fm . last . musicbrainz . data . model . Track > tracks = dao . getByArtist ( artist ) ; java . util . Set < java . lang . Integer > expectedTrackIds = com . google . common . collect . Sets . newHashSet ( 1 , 2 , 3 ) ; java . util . Set < java . lang . Integer > actualTrackIds = com . google . common . collect . Sets . newHashSet ( ) ; for ( fm . last . musicbrainz . data . model . Track track : tracks ) { actualTrackIds . add ( track . getId ( ) ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualTrackIds , org . hamcrest . CoreMatchers . is ( expectedTrackIds ) )", "total": "getByExistingArtistReturnsThreeTracks ( ) { fm . last . musicbrainz . data . model . Artist artist = ( ( fm . last . musicbrainz . data . model . Artist ) ( session . load ( fm . last . musicbrainz . data . model . Artist . class , 5 ) ) ) ; java . util . List < fm . last . musicbrainz . data . model . Track > tracks = dao . getByArtist ( artist ) ; java . util . Set < java . lang . Integer > expectedTrackIds = com . google . common . collect . Sets . newHashSet ( 1 , 2 , 3 ) ; java . util . Set < java . lang . Integer > actualTrackIds = com . google . common . collect . Sets . newHashSet ( ) ; for ( fm . last . musicbrainz . data . model . Track track : tracks ) { actualTrackIds . add ( track . getId ( ) ) ; } \"<AssertPlaceHolder>\" ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( actualTrackIds , org . hamcrest . CoreMatchers . is ( expectedTrackIds ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testNeighborAreaId ( ) { isisNeighbor . setNeighborAreaId ( areaId ) ; result1 = isisNeighbor . neighborAreaId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( areaId ) )", "total": "testNeighborAreaId ( ) { isisNeighbor . setNeighborAreaId ( areaId ) ; result1 = isisNeighbor . neighborAreaId ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( areaId ) )"}
{"focal": "generate ( ) { java . util . Set < java . lang . Integer > numbers = new java . util . HashSet ( ) ; while ( ( numbers . size ( ) ) < 3 ) { numbers . add ( generateRandNum ( ) ) ; } return numbers . toArray ( new java . lang . Integer [ ] { } ) ; }", "testMethod": "( ) { net . chandol . study . oop . tdd . baseball . RandomNumberGenerator generator = new net . chandol . study . oop . tdd . baseball . RandomNumberGenerator ( ) ; java . lang . Integer [ ] numbers = generator . generate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( numbers . length , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "( ) { net . chandol . study . oop . tdd . baseball . RandomNumberGenerator generator = new net . chandol . study . oop . tdd . baseball . RandomNumberGenerator ( ) ; java . lang . Integer [ ] numbers = generator . generate ( ) ; \"<AssertPlaceHolder>\" ; } generate ( ) { java . util . Set < java . lang . Integer > numbers = new java . util . HashSet ( ) ; while ( ( numbers . size ( ) ) < 3 ) { numbers . add ( generateRandNum ( ) ) ; } return numbers . toArray ( new java . lang . Integer [ ] { } ) ; }", "answer": "org . junit . Assert . assertThat ( numbers . length , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsNotEqualsGroupId ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPopMpls obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPopMpls ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsNotEqualsGroupId ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPopMpls obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPopMpls ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "plus ( net . time4j . engine . CalendarDays ) { long result = java . lang . Math . addExact ( this . getDaysSinceEpochUTC ( ) , days . getAmount ( ) ) ; try { return this . getChronology ( ) . getCalendarSystem ( ) . transform ( result ) ; } catch ( java . lang . IllegalArgumentException iae ) { java . lang . ArithmeticException ex = new java . lang . ArithmeticException ( ( \"Out<sp>of<sp>range:<sp>\" + result ) ) ; ex . initCause ( iae ) ; throw ex ; } }", "testMethod": "assertMonthsDaysInvariant_T1_Plus_T1UntilT2_Eq_T2 ( ) { net . time4j . Duration < net . time4j . CalendarUnit > period = this . start . until ( this . end , net . time4j . Duration . in ( net . time4j . CalendarUnit . MONTHS , net . time4j . CalendarUnit . DAYS ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . start . plus ( period ) , org . hamcrest . CoreMatchers . is ( this . end ) )", "total": "assertMonthsDaysInvariant_T1_Plus_T1UntilT2_Eq_T2 ( ) { net . time4j . Duration < net . time4j . CalendarUnit > period = this . start . until ( this . end , net . time4j . Duration . in ( net . time4j . CalendarUnit . MONTHS , net . time4j . CalendarUnit . DAYS ) ) ; \"<AssertPlaceHolder>\" ; } plus ( net . time4j . engine . CalendarDays ) { long result = java . lang . Math . addExact ( this . getDaysSinceEpochUTC ( ) , days . getAmount ( ) ) ; try { return this . getChronology ( ) . getCalendarSystem ( ) . transform ( result ) ; } catch ( java . lang . IllegalArgumentException iae ) { java . lang . ArithmeticException ex = new java . lang . ArithmeticException ( ( \"Out<sp>of<sp>range:<sp>\" + result ) ) ; ex . initCause ( iae ) ; throw ex ; } }", "answer": "org . junit . Assert . assertThat ( this . start . plus ( period ) , org . hamcrest . CoreMatchers . is ( this . end ) )"}
{"focal": "asJson ( ) { return json ; }", "testMethod": "asJson ( ) { final org . json . JSONObject json = new org . json . JSONObject ( \"{_id:\\\"hello\\\"}\" ) ; final com . github . rnewson . couchdb . lucene . couchdb . CouchDocument doc = new com . github . rnewson . couchdb . lucene . couchdb . CouchDocument ( json ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( doc . asJson ( ) , org . hamcrest . CoreMatchers . is ( json ) )", "total": "asJson ( ) { final org . json . JSONObject json = new org . json . JSONObject ( \"{_id:\\\"hello\\\"}\" ) ; final com . github . rnewson . couchdb . lucene . couchdb . CouchDocument doc = new com . github . rnewson . couchdb . lucene . couchdb . CouchDocument ( json ) ; \"<AssertPlaceHolder>\" ; } asJson ( ) { return json ; }", "answer": "org . junit . Assert . assertThat ( doc . asJson ( ) , org . hamcrest . CoreMatchers . is ( json ) )"}
{"focal": "readFile ( java . lang . String ) { return \"file<sp>content\" ; }", "testMethod": "readItemDescriptionWithoutIOException ( ) { java . lang . String fileName = \"DummyName\" ; mockStatic ( com . codecentric . sample . store . service . tools . StaticService . class ) ; when ( com . codecentric . sample . store . service . tools . StaticService . readFile ( fileName ) ) . thenReturn ( \"Dummy\" ) ; java . lang . String value = itemService . readItemDescription ( fileName ) ; verifyStatic ( times ( 1 ) ) ; com . codecentric . sample . store . service . tools . StaticService . readFile ( fileName ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . equalTo ( \"Dummy\" ) )", "total": "readItemDescriptionWithoutIOException ( ) { java . lang . String fileName = \"DummyName\" ; mockStatic ( com . codecentric . sample . store . service . tools . StaticService . class ) ; when ( com . codecentric . sample . store . service . tools . StaticService . readFile ( fileName ) ) . thenReturn ( \"Dummy\" ) ; java . lang . String value = itemService . readItemDescription ( fileName ) ; verifyStatic ( times ( 1 ) ) ; com . codecentric . sample . store . service . tools . StaticService . readFile ( fileName ) ; \"<AssertPlaceHolder>\" ; } readFile ( java . lang . String ) { return \"file<sp>content\" ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . equalTo ( \"Dummy\" ) )"}
{"focal": "getPostConstructMethods ( java . lang . Class ) { final java . util . Set < java . lang . reflect . Method > postConstructMethods = new java . util . LinkedHashSet < java . lang . reflect . Method > ( ) ; for ( final java . lang . Class < ? extends java . lang . annotation . Annotation > postConstructAnnotation : postConstructAnnotations ) { postConstructMethods . addAll ( de . akquinet . jbosscc . needle . reflection . ReflectionUtil . getAllMethodsWithAnnotation ( type , postConstructAnnotation ) ) ; } return postConstructMethods ; }", "testMethod": "shouldFindTwoPostconstructMethodsForC ( ) { final java . util . Set < java . lang . reflect . Method > methods = postConstructProcessor . getPostConstructMethods ( de . akquinet . jbosscc . needle . postconstruct . PostConstructProcessorTest . C . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( methods . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "shouldFindTwoPostconstructMethodsForC ( ) { final java . util . Set < java . lang . reflect . Method > methods = postConstructProcessor . getPostConstructMethods ( de . akquinet . jbosscc . needle . postconstruct . PostConstructProcessorTest . C . class ) ; \"<AssertPlaceHolder>\" ; } getPostConstructMethods ( java . lang . Class ) { final java . util . Set < java . lang . reflect . Method > postConstructMethods = new java . util . LinkedHashSet < java . lang . reflect . Method > ( ) ; for ( final java . lang . Class < ? extends java . lang . annotation . Annotation > postConstructAnnotation : postConstructAnnotations ) { postConstructMethods . addAll ( de . akquinet . jbosscc . needle . reflection . ReflectionUtil . getAllMethodsWithAnnotation ( type , postConstructAnnotation ) ) ; } return postConstructMethods ; }", "answer": "org . junit . Assert . assertThat ( methods . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "size ( ) { return instances . size ( ) ; }", "testMethod": "size_forNonEmptyList ( ) { jsonRepresentation = new org . apache . isis . viewer . restfulobjects . applib . JsonRepresentation ( org . apache . isis . viewer . restfulobjects . applib . JsonFixture . readJson ( \"list.json\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( jsonRepresentation . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "size_forNonEmptyList ( ) { jsonRepresentation = new org . apache . isis . viewer . restfulobjects . applib . JsonRepresentation ( org . apache . isis . viewer . restfulobjects . applib . JsonFixture . readJson ( \"list.json\" ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return instances . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( jsonRepresentation . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "setClassifier ( java . lang . String ) { this . classifier = ( ( classifier == null ) || ( classifier . isEmpty ( ) ) ) ? null : classifier ; }", "testMethod": "isSameCause_multiArtifact_multiClassifiers_on_secondCause_withBaseVersion_true ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-second-jar:jar:1.0-20100529-1214-1\" ) ; secondArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact sameAsFirstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; sameAsFirstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact sameAsFirstArtifactSources = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; sameAsFirstArtifactSources . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; sameAsFirstArtifactSources . setClassifier ( \"sources\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( sameAsFirstArtifact , sameAsFirstArtifactSources , secondArtifact ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( matchingArtifacts . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "isSameCause_multiArtifact_multiClassifiers_on_secondCause_withBaseVersion_true ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-second-jar:jar:1.0-20100529-1214-1\" ) ; secondArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact sameAsFirstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; sameAsFirstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact sameAsFirstArtifactSources = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; sameAsFirstArtifactSources . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; sameAsFirstArtifactSources . setClassifier ( \"sources\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( sameAsFirstArtifact , sameAsFirstArtifactSources , secondArtifact ) ) ; \"<AssertPlaceHolder>\" ; } setClassifier ( java . lang . String ) { this . classifier = ( ( classifier == null ) || ( classifier . isEmpty ( ) ) ) ? null : classifier ; }", "answer": "org . junit . Assert . assertThat ( matchingArtifacts . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "testMethod": "testParseEnabledErr ( ) { queriesString = \"type=node&enabled=aaa\" ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testParseEnabledErr ( ) { queriesString = \"type=node&enabled=aaa\" ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; } parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getTokenFromHeaders ( java . lang . String , javax . servlet . http . HttpServletRequest ) { java . lang . String header = request . getHeader ( headerName ) ; if ( header == null ) { return null ; } java . lang . String token = header . trim ( ) ; int tokenStart = token . indexOf ( \"<urn:uuid:\" ) ; token = token . substring ( ( tokenStart + ( \"<urn:uuid:\" . length ( ) ) ) , token . length ( ) ) ; int tokenEnd = token . indexOf ( \">\" ) ; token = token . substring ( 0 , tokenEnd ) ; return token ; }", "testMethod": "getTokenFromHeadersReturnsRightToken ( ) { java . lang . String TOKEN = \"tititoto2010\" ; javax . servlet . http . HttpServletRequest request = mock ( javax . servlet . http . HttpServletRequest . class ) ; when ( request . getHeader ( \"If\" ) ) . thenReturn ( ( ( \"<urn:uuid:\" + TOKEN ) + \">\" ) ) ; java . lang . String result = org . nuxeo . ecm . webdav . resource . MiscTest . getTokenFromHeaders ( \"If\" , request ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( TOKEN ) )", "total": "getTokenFromHeadersReturnsRightToken ( ) { java . lang . String TOKEN = \"tititoto2010\" ; javax . servlet . http . HttpServletRequest request = mock ( javax . servlet . http . HttpServletRequest . class ) ; when ( request . getHeader ( \"If\" ) ) . thenReturn ( ( ( \"<urn:uuid:\" + TOKEN ) + \">\" ) ) ; java . lang . String result = org . nuxeo . ecm . webdav . resource . MiscTest . getTokenFromHeaders ( \"If\" , request ) ; \"<AssertPlaceHolder>\" ; } getTokenFromHeaders ( java . lang . String , javax . servlet . http . HttpServletRequest ) { java . lang . String header = request . getHeader ( headerName ) ; if ( header == null ) { return null ; } java . lang . String token = header . trim ( ) ; int tokenStart = token . indexOf ( \"<urn:uuid:\" ) ; token = token . substring ( ( tokenStart + ( \"<urn:uuid:\" . length ( ) ) ) , token . length ( ) ) ; int tokenEnd = token . indexOf ( \">\" ) ; token = token . substring ( 0 , tokenEnd ) ; return token ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( TOKEN ) )"}
{"focal": "getHeaderField ( java . lang . String ) { java . lang . String canonicalizedField = com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse . canonicalizeFieldName ( field ) ; java . lang . String values = this . headerFields . get ( canonicalizedField ) ; if ( values == null ) { java . lang . String errMsg = java . lang . String . format ( ( \"Could<sp>not<sp>find<sp>a<sp>value<sp>\" + \"associated<sp>with<sp>the<sp>header<sp>field<sp>name<sp>\\'%s\\'.\\n\" ) , field ) ; throw new java . lang . IllegalArgumentException ( errMsg ) ; } return values ; }", "testMethod": "sendReturnsHeaderFieldsOnBadStatusException ( com . microsoft . azure . sdk . iot . service . transport . http . HttpConnection , java . net . URL ) { final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final java . lang . String field = \"test-field\" ; final java . util . List < java . lang . String > values = new java . util . LinkedList ( ) ; final java . lang . String value = \"test-value0\" ; values . add ( value ) ; headerFields . put ( field , values ) ; final com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod . POST ; final byte [ ] body = new byte [ 0 ] ; final java . lang . String expectedValues = value ; new tests . unit . com . microsoft . azure . sdk . iot . service . transport . http . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"http\" ; mockConn . connect ( ) ; result = new java . io . IOException ( ) ; mockConn . getResponseHeaders ( ) ; result = headerFields ; } } ; com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest request = new com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest ( mockUrl , httpsMethod , body ) ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = request . send ( ) ; java . lang . String testValues = response . getHeaderField ( field ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testValues , org . hamcrest . CoreMatchers . is ( expectedValues ) )", "total": "sendReturnsHeaderFieldsOnBadStatusException ( com . microsoft . azure . sdk . iot . service . transport . http . HttpConnection , java . net . URL ) { final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final java . lang . String field = \"test-field\" ; final java . util . List < java . lang . String > values = new java . util . LinkedList ( ) ; final java . lang . String value = \"test-value0\" ; values . add ( value ) ; headerFields . put ( field , values ) ; final com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod . POST ; final byte [ ] body = new byte [ 0 ] ; final java . lang . String expectedValues = value ; new tests . unit . com . microsoft . azure . sdk . iot . service . transport . http . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"http\" ; mockConn . connect ( ) ; result = new java . io . IOException ( ) ; mockConn . getResponseHeaders ( ) ; result = headerFields ; } } ; com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest request = new com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest ( mockUrl , httpsMethod , body ) ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = request . send ( ) ; java . lang . String testValues = response . getHeaderField ( field ) ; \"<AssertPlaceHolder>\" ; } getHeaderField ( java . lang . String ) { java . lang . String canonicalizedField = com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse . canonicalizeFieldName ( field ) ; java . lang . String values = this . headerFields . get ( canonicalizedField ) ; if ( values == null ) { java . lang . String errMsg = java . lang . String . format ( ( \"Could<sp>not<sp>find<sp>a<sp>value<sp>\" + \"associated<sp>with<sp>the<sp>header<sp>field<sp>name<sp>\\'%s\\'.\\n\" ) , field ) ; throw new java . lang . IllegalArgumentException ( errMsg ) ; } return values ; }", "answer": "org . junit . Assert . assertThat ( testValues , org . hamcrest . CoreMatchers . is ( expectedValues ) )"}
{"focal": "calculateChecksum ( java . io . InputStream ) { if ( inputStream == null ) { throw new java . lang . IllegalArgumentException ( \"InputStream<sp>cannot<sp>be<sp>null\" ) ; } long checksumValue = 0L ; try ( java . util . zip . CheckedInputStream cis = new java . util . zip . CheckedInputStream ( inputStream , new java . util . zip . Adler32 ( ) ) ) { byte [ ] buf = new byte [ 4096 ] ; while ( ( cis . read ( buf , 0 , ( ( buf . length ) - 1 ) ) ) != ( - 1 ) ) { } checksumValue = cis . getChecksum ( ) . getValue ( ) ; } return java . lang . Long . toHexString ( checksumValue ) ; }", "testMethod": "testCalculateChecksumObject ( ) { org . codice . ddf . checksum . SerializableTestObject obj = new org . codice . ddf . checksum . SerializableTestObject ( ) ; obj . setName ( \"Test<sp>Name\" ) ; obj . setDescription ( \"Test<sp>Description\" ) ; final java . lang . String checksumCompareHash = \"3cb331e\" ; java . io . InputStream stringInputStream = getInputStreamFromObject ( obj ) ; java . lang . String checksumValue = checksumProvider . calculateChecksum ( stringInputStream ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( checksumValue , org . hamcrest . core . Is . is ( checksumCompareHash ) )", "total": "testCalculateChecksumObject ( ) { org . codice . ddf . checksum . SerializableTestObject obj = new org . codice . ddf . checksum . SerializableTestObject ( ) ; obj . setName ( \"Test<sp>Name\" ) ; obj . setDescription ( \"Test<sp>Description\" ) ; final java . lang . String checksumCompareHash = \"3cb331e\" ; java . io . InputStream stringInputStream = getInputStreamFromObject ( obj ) ; java . lang . String checksumValue = checksumProvider . calculateChecksum ( stringInputStream ) ; \"<AssertPlaceHolder>\" ; } calculateChecksum ( java . io . InputStream ) { if ( inputStream == null ) { throw new java . lang . IllegalArgumentException ( \"InputStream<sp>cannot<sp>be<sp>null\" ) ; } long checksumValue = 0L ; try ( java . util . zip . CheckedInputStream cis = new java . util . zip . CheckedInputStream ( inputStream , new java . util . zip . Adler32 ( ) ) ) { byte [ ] buf = new byte [ 4096 ] ; while ( ( cis . read ( buf , 0 , ( ( buf . length ) - 1 ) ) ) != ( - 1 ) ) { } checksumValue = cis . getChecksum ( ) . getValue ( ) ; } return java . lang . Long . toHexString ( checksumValue ) ; }", "answer": "org . junit . Assert . assertThat ( checksumValue , org . hamcrest . core . Is . is ( checksumCompareHash ) )"}
{"focal": "stream ( net . time4j . Duration ) { if ( ( this . isEmpty ( ) ) && ( duration . isPositive ( ) ) ) { return java . util . stream . Stream . empty ( ) ; } net . time4j . range . DateInterval interval = this . toCanonical ( ) ; net . time4j . PlainDate start = interval . getStartAsCalendarDate ( ) ; net . time4j . PlainDate end = interval . getEndAsCalendarDate ( ) ; if ( ( start == null ) || ( end == null ) ) { throw new java . lang . IllegalStateException ( \"Streaming<sp>is<sp>not<sp>supported<sp>for<sp>infinite<sp>intervals.\" ) ; } return net . time4j . range . DateInterval . stream ( duration , start , end ) ; }", "testMethod": "stream2 ( ) { net . time4j . PlainTime start = net . time4j . PlainTime . of ( 15 , 0 ) ; net . time4j . PlainTime end = net . time4j . PlainTime . of ( 20 , 0 ) . plus ( 1 , ClockUnit . NANOS ) ; net . time4j . range . ClockInterval interval = net . time4j . range . ClockInterval . between ( start , end ) ; net . time4j . Duration < net . time4j . ClockUnit > duration = net . time4j . Duration . of ( 1 , ClockUnit . HOURS ) ; java . util . List < net . time4j . PlainTime > expected = new java . util . ArrayList ( ) ; expected . add ( start ) ; expected . add ( net . time4j . PlainTime . of ( 16 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 17 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 18 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 19 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 20 , 0 ) ) ; java . util . List < net . time4j . PlainTime > result = interval . stream ( duration ) . parallel ( ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "stream2 ( ) { net . time4j . PlainTime start = net . time4j . PlainTime . of ( 15 , 0 ) ; net . time4j . PlainTime end = net . time4j . PlainTime . of ( 20 , 0 ) . plus ( 1 , ClockUnit . NANOS ) ; net . time4j . range . ClockInterval interval = net . time4j . range . ClockInterval . between ( start , end ) ; net . time4j . Duration < net . time4j . ClockUnit > duration = net . time4j . Duration . of ( 1 , ClockUnit . HOURS ) ; java . util . List < net . time4j . PlainTime > expected = new java . util . ArrayList ( ) ; expected . add ( start ) ; expected . add ( net . time4j . PlainTime . of ( 16 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 17 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 18 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 19 , 0 ) ) ; expected . add ( net . time4j . PlainTime . of ( 20 , 0 ) ) ; java . util . List < net . time4j . PlainTime > result = interval . stream ( duration ) . parallel ( ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; } stream ( net . time4j . Duration ) { if ( ( this . isEmpty ( ) ) && ( duration . isPositive ( ) ) ) { return java . util . stream . Stream . empty ( ) ; } net . time4j . range . DateInterval interval = this . toCanonical ( ) ; net . time4j . PlainDate start = interval . getStartAsCalendarDate ( ) ; net . time4j . PlainDate end = interval . getEndAsCalendarDate ( ) ; if ( ( start == null ) || ( end == null ) ) { throw new java . lang . IllegalStateException ( \"Streaming<sp>is<sp>not<sp>supported<sp>for<sp>infinite<sp>intervals.\" ) ; } return net . time4j . range . DateInterval . stream ( duration , start , end ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getCustomerAccount ( ) { org . mifos . customers . business . CustomerAccountBO customerAccount = null ; for ( org . mifos . accounts . business . AccountBO account : accounts ) { if ( ( account . getType ( ) ) == ( org . mifos . accounts . util . helpers . AccountTypes . CUSTOMER_ACCOUNT ) ) { customerAccount = ( ( org . mifos . customers . business . CustomerAccountBO ) ( account ) ) ; } } return customerAccount ; }", "testMethod": "createsGroupWithCustomerAccount ( ) { org . mifos . customers . office . business . OfficeBO withOffice = new org . mifos . customers . office . business . OfficeBO ( new java . lang . Short ( \"1\" ) , \"testOffice\" , new java . lang . Integer ( \"1\" ) , new java . lang . Short ( \"1\" ) ) ; org . mifos . customers . center . business . CenterBO parent = new org . mifos . domain . builders . CenterBuilder ( ) . withLoanOfficer ( anyLoanOfficer ( ) ) . with ( withOffice ) . build ( ) ; org . mifos . customers . group . business . GroupBO stubbedGroup = new org . mifos . domain . builders . GroupBuilder ( ) . withName ( \"group\" ) . withParentCustomer ( parent ) . formedBy ( anyLoanOfficer ( ) ) . build ( ) ; java . util . List < org . mifos . accounts . business . AccountFeesEntity > accountFees = new java . util . ArrayList < org . mifos . accounts . business . AccountFeesEntity > ( ) ; org . mifos . calendar . CalendarEvent upcomingCalendarEvents = new org . mifos . domain . builders . CalendarEventBuilder ( ) . build ( ) ; when ( holidayDao . findCalendarEventsForThisYearAndNext ( ( ( short ) ( 1 ) ) ) ) . thenReturn ( upcomingCalendarEvents ) ; when ( customerAccountFactory . create ( stubbedGroup , accountFees , meeting , upcomingCalendarEvents ) ) . thenReturn ( customerAccount ) ; when ( customerAccount . getType ( ) ) . thenReturn ( AccountTypes . CUSTOMER_ACCOUNT ) ; customerService . createGroup ( stubbedGroup , meeting , accountFees ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( stubbedGroup . getCustomerAccount ( ) , org . hamcrest . CoreMatchers . is ( customerAccount ) )", "total": "createsGroupWithCustomerAccount ( ) { org . mifos . customers . office . business . OfficeBO withOffice = new org . mifos . customers . office . business . OfficeBO ( new java . lang . Short ( \"1\" ) , \"testOffice\" , new java . lang . Integer ( \"1\" ) , new java . lang . Short ( \"1\" ) ) ; org . mifos . customers . center . business . CenterBO parent = new org . mifos . domain . builders . CenterBuilder ( ) . withLoanOfficer ( anyLoanOfficer ( ) ) . with ( withOffice ) . build ( ) ; org . mifos . customers . group . business . GroupBO stubbedGroup = new org . mifos . domain . builders . GroupBuilder ( ) . withName ( \"group\" ) . withParentCustomer ( parent ) . formedBy ( anyLoanOfficer ( ) ) . build ( ) ; java . util . List < org . mifos . accounts . business . AccountFeesEntity > accountFees = new java . util . ArrayList < org . mifos . accounts . business . AccountFeesEntity > ( ) ; org . mifos . calendar . CalendarEvent upcomingCalendarEvents = new org . mifos . domain . builders . CalendarEventBuilder ( ) . build ( ) ; when ( holidayDao . findCalendarEventsForThisYearAndNext ( ( ( short ) ( 1 ) ) ) ) . thenReturn ( upcomingCalendarEvents ) ; when ( customerAccountFactory . create ( stubbedGroup , accountFees , meeting , upcomingCalendarEvents ) ) . thenReturn ( customerAccount ) ; when ( customerAccount . getType ( ) ) . thenReturn ( AccountTypes . CUSTOMER_ACCOUNT ) ; customerService . createGroup ( stubbedGroup , meeting , accountFees ) ; \"<AssertPlaceHolder>\" ; } getCustomerAccount ( ) { org . mifos . customers . business . CustomerAccountBO customerAccount = null ; for ( org . mifos . accounts . business . AccountBO account : accounts ) { if ( ( account . getType ( ) ) == ( org . mifos . accounts . util . helpers . AccountTypes . CUSTOMER_ACCOUNT ) ) { customerAccount = ( ( org . mifos . customers . business . CustomerAccountBO ) ( account ) ) ; } } return customerAccount ; }", "answer": "org . junit . Assert . assertThat ( stubbedGroup . getCustomerAccount ( ) , org . hamcrest . CoreMatchers . is ( customerAccount ) )"}
{"focal": "roundtrip ( java . lang . Object ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutputStream oos = new java . io . ObjectOutputStream ( baos ) ; oos . writeObject ( obj ) ; byte [ ] data = baos . toByteArray ( ) ; oos . close ( ) ; java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( data ) ; java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( bais ) ; java . lang . Object ser = ois . readObject ( ) ; ois . close ( ) ; return ser ; }", "testMethod": "roundtripOfDateIntervalHalfOpen ( ) { net . time4j . PlainDate start = net . time4j . PlainDate . of ( 2014 , 2 , 27 ) ; net . time4j . PlainDate end = net . time4j . PlainDate . of ( 2014 , 5 , 14 ) ; java . lang . Object interval = net . time4j . range . DateInterval . between ( start , end ) . withOpenEnd ( ) ; java . lang . Object ser = net . time4j . range . SerializationTest . roundtrip ( interval ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interval , org . hamcrest . CoreMatchers . is ( ser ) )", "total": "roundtripOfDateIntervalHalfOpen ( ) { net . time4j . PlainDate start = net . time4j . PlainDate . of ( 2014 , 2 , 27 ) ; net . time4j . PlainDate end = net . time4j . PlainDate . of ( 2014 , 5 , 14 ) ; java . lang . Object interval = net . time4j . range . DateInterval . between ( start , end ) . withOpenEnd ( ) ; java . lang . Object ser = net . time4j . range . SerializationTest . roundtrip ( interval ) ; \"<AssertPlaceHolder>\" ; } roundtrip ( java . lang . Object ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutputStream oos = new java . io . ObjectOutputStream ( baos ) ; oos . writeObject ( obj ) ; byte [ ] data = baos . toByteArray ( ) ; oos . close ( ) ; java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( data ) ; java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( bais ) ; java . lang . Object ser = ois . readObject ( ) ; ois . close ( ) ; return ser ; }", "answer": "org . junit . Assert . assertThat ( interval , org . hamcrest . CoreMatchers . is ( ser ) )"}
{"focal": "getMinAvailable ( java . lang . String ) { return java . lang . Math . max ( ( ( getReplicaCount ( clusterName ) ) - ( getMaxUnavailable ( clusterName ) ) ) , 0 ) ; }", "testMethod": "afterReplicaCountMaxUnavailableSetForCluster_canReadMinAvailable ( ) { configureCluster ( \"cluster1\" ) . withReplicas ( 5 ) . withMaxUnavailable ( 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( domain . getMinAvailable ( \"cluster1\" ) , org . hamcrest . Matchers . equalTo ( 3 ) )", "total": "afterReplicaCountMaxUnavailableSetForCluster_canReadMinAvailable ( ) { configureCluster ( \"cluster1\" ) . withReplicas ( 5 ) . withMaxUnavailable ( 2 ) ; \"<AssertPlaceHolder>\" ; } getMinAvailable ( java . lang . String ) { return java . lang . Math . max ( ( ( getReplicaCount ( clusterName ) ) - ( getMaxUnavailable ( clusterName ) ) ) , 0 ) ; }", "answer": "org . junit . Assert . assertThat ( domain . getMinAvailable ( \"cluster1\" ) , org . hamcrest . Matchers . equalTo ( 3 ) )"}
{"focal": "shouldResourceBeIncluded ( java . lang . Module , java . net . URL , java . lang . String , java . util . Map ) { boolean include = true ; for ( org . openmrs . module . ModuleConditionalResource conditionalResource : module . getConditionalResources ( ) ) { if ( fileUrl . getPath ( ) . matches ( ( ( \".*\" + ( conditionalResource . getPath ( ) ) ) + \"$\" ) ) ) { include = false ; if ( org . apache . commons . lang3 . StringUtils . isNotBlank ( conditionalResource . getOpenmrsPlatformVersion ( ) ) ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( openmrsVersion , conditionalResource . getOpenmrsPlatformVersion ( ) ) ; if ( ! include ) { return false ; } } if ( ( conditionalResource . getModules ( ) ) != null ) { for ( org . openmrs . module . ModuleConditionalResource . ModuleAndVersion conditionalModuleResource : conditionalResource . getModules ( ) ) { if ( \"!\" . equals ( conditionalModuleResource . getVersion ( ) ) ) { include = ! ( org . openmrs . module . ModuleFactory . isModuleStarted ( conditionalModuleResource . getModuleId ( ) ) ) ; if ( ! include ) { return false ; } } else { java . lang . String moduleVersion = startedRelatedModules . get ( conditionalModuleResource . getModuleId ( ) ) ; if ( moduleVersion != null ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( moduleVersion , conditionalModuleResource . getVersion ( ) ) ; if ( ! include ) { return false ; } } } } } } } return include ; }", "testMethod": "shouldResourceBeIncluded_shouldReturnFalseIfFileMatchesAndOpenmrsVersionMatchesButModuleVersionDoesNotMatch ( ) { org . openmrs . module . ModuleConditionalResource resource = new org . openmrs . module . ModuleConditionalResource ( ) ; resource . setPath ( \"lib/mockmodule-api-1.10.jar\" ) ; resource . setOpenmrsPlatformVersion ( \"1.10\" ) ; org . openmrs . module . ModuleConditionalResource . ModuleAndVersion module = new org . openmrs . module . ModuleConditionalResource . ModuleAndVersion ( ) ; module . setModuleId ( \"module\" ) ; module . setVersion ( \"1.0-2.0,4.0\" ) ; resource . getModules ( ) . add ( module ) ; mockModule . getConditionalResources ( ) . add ( resource ) ; mockModules . put ( \"module\" , \"3.0\" ) ; boolean result = org . openmrs . module . ModuleClassLoader . shouldResourceBeIncluded ( mockModule , java . net . URI . create ( \"file://module/mockmodule/lib/mockmodule-api-1.10.jar\" ) . toURL ( ) , \"1.10.0-SNAPSHOT\" , mockModules ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )", "total": "shouldResourceBeIncluded_shouldReturnFalseIfFileMatchesAndOpenmrsVersionMatchesButModuleVersionDoesNotMatch ( ) { org . openmrs . module . ModuleConditionalResource resource = new org . openmrs . module . ModuleConditionalResource ( ) ; resource . setPath ( \"lib/mockmodule-api-1.10.jar\" ) ; resource . setOpenmrsPlatformVersion ( \"1.10\" ) ; org . openmrs . module . ModuleConditionalResource . ModuleAndVersion module = new org . openmrs . module . ModuleConditionalResource . ModuleAndVersion ( ) ; module . setModuleId ( \"module\" ) ; module . setVersion ( \"1.0-2.0,4.0\" ) ; resource . getModules ( ) . add ( module ) ; mockModule . getConditionalResources ( ) . add ( resource ) ; mockModules . put ( \"module\" , \"3.0\" ) ; boolean result = org . openmrs . module . ModuleClassLoader . shouldResourceBeIncluded ( mockModule , java . net . URI . create ( \"file://module/mockmodule/lib/mockmodule-api-1.10.jar\" ) . toURL ( ) , \"1.10.0-SNAPSHOT\" , mockModules ) ; \"<AssertPlaceHolder>\" ; } shouldResourceBeIncluded ( java . lang . Module , java . net . URL , java . lang . String , java . util . Map ) { boolean include = true ; for ( org . openmrs . module . ModuleConditionalResource conditionalResource : module . getConditionalResources ( ) ) { if ( fileUrl . getPath ( ) . matches ( ( ( \".*\" + ( conditionalResource . getPath ( ) ) ) + \"$\" ) ) ) { include = false ; if ( org . apache . commons . lang3 . StringUtils . isNotBlank ( conditionalResource . getOpenmrsPlatformVersion ( ) ) ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( openmrsVersion , conditionalResource . getOpenmrsPlatformVersion ( ) ) ; if ( ! include ) { return false ; } } if ( ( conditionalResource . getModules ( ) ) != null ) { for ( org . openmrs . module . ModuleConditionalResource . ModuleAndVersion conditionalModuleResource : conditionalResource . getModules ( ) ) { if ( \"!\" . equals ( conditionalModuleResource . getVersion ( ) ) ) { include = ! ( org . openmrs . module . ModuleFactory . isModuleStarted ( conditionalModuleResource . getModuleId ( ) ) ) ; if ( ! include ) { return false ; } } else { java . lang . String moduleVersion = startedRelatedModules . get ( conditionalModuleResource . getModuleId ( ) ) ; if ( moduleVersion != null ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( moduleVersion , conditionalModuleResource . getVersion ( ) ) ; if ( ! include ) { return false ; } } } } } } } return include ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getNumberOfColumns ( ) { return this . columnByName . size ( ) ; }", "testMethod": "numberOfColumns ( ) { com . airhacks . enhydrator . in . VirtualSinkSource source = new com . airhacks . enhydrator . in . VirtualSinkSource . Rows ( ) . addColumn ( \"age1\" , \"25\" ) . addColumn ( \"age2\" , \"42\" ) . addColumn ( \"age3\" , \"15\" ) . addRow ( ) . build ( ) ; com . airhacks . enhydrator . in . Row row = source . getRow ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( row . getNumberOfColumns ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "numberOfColumns ( ) { com . airhacks . enhydrator . in . VirtualSinkSource source = new com . airhacks . enhydrator . in . VirtualSinkSource . Rows ( ) . addColumn ( \"age1\" , \"25\" ) . addColumn ( \"age2\" , \"42\" ) . addColumn ( \"age3\" , \"15\" ) . addRow ( ) . build ( ) ; com . airhacks . enhydrator . in . Row row = source . getRow ( 0 ) ; \"<AssertPlaceHolder>\" ; } getNumberOfColumns ( ) { return this . columnByName . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( row . getNumberOfColumns ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "id ( java . lang . String ) { return new com . redhat . darcy . ui . By . ById ( id ) ; }", "testMethod": "shouldKeepFindingElementsInSequenceUntilNextIsNotPresentStartingFromSomeIndex ( ) { com . redhat . darcy . ui . BySequenceTest . TestContext mockContext = mock ( com . redhat . darcy . ui . BySequenceTest . TestContext . class ) ; com . redhat . darcy . ui . api . elements . Label label1 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; com . redhat . darcy . ui . api . elements . Label label2 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; com . redhat . darcy . ui . api . elements . Label label3 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; com . redhat . darcy . ui . api . elements . Label label4 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"1\" ) ) . thenReturn ( label1 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"2\" ) ) . thenReturn ( label2 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"3\" ) ) . thenReturn ( label3 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"4\" ) ) . thenReturn ( label4 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"5\" ) ) . thenReturn ( new com . redhat . darcy . ui . testing . doubles . NeverFoundLabel ( ) ) ; com . redhat . darcy . ui . By . BySequence bySequence = com . redhat . darcy . ui . By . sequence ( ( i ) -> com . redhat . darcy . ui . By . id ( i . toString ( ) ) , 1 ) ; java . util . List < com . redhat . darcy . ui . api . elements . Label > found = bySequence . findAll ( com . redhat . darcy . ui . api . elements . Label . class , mockContext ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( found , org . hamcrest . Matchers . contains ( label1 , label2 , label3 , label4 ) )", "total": "shouldKeepFindingElementsInSequenceUntilNextIsNotPresentStartingFromSomeIndex ( ) { com . redhat . darcy . ui . BySequenceTest . TestContext mockContext = mock ( com . redhat . darcy . ui . BySequenceTest . TestContext . class ) ; com . redhat . darcy . ui . api . elements . Label label1 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; com . redhat . darcy . ui . api . elements . Label label2 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; com . redhat . darcy . ui . api . elements . Label label3 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; com . redhat . darcy . ui . api . elements . Label label4 = new com . redhat . darcy . ui . testing . doubles . AlwaysDisplayedLabel ( ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"1\" ) ) . thenReturn ( label1 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"2\" ) ) . thenReturn ( label2 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"3\" ) ) . thenReturn ( label3 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"4\" ) ) . thenReturn ( label4 ) ; when ( mockContext . findById ( com . redhat . darcy . ui . api . elements . Label . class , \"5\" ) ) . thenReturn ( new com . redhat . darcy . ui . testing . doubles . NeverFoundLabel ( ) ) ; com . redhat . darcy . ui . By . BySequence bySequence = com . redhat . darcy . ui . By . sequence ( ( i ) -> com . redhat . darcy . ui . By . id ( i . toString ( ) ) , 1 ) ; java . util . List < com . redhat . darcy . ui . api . elements . Label > found = bySequence . findAll ( com . redhat . darcy . ui . api . elements . Label . class , mockContext ) ; \"<AssertPlaceHolder>\" ; } id ( java . lang . String ) { return new com . redhat . darcy . ui . By . ById ( id ) ; }", "answer": "org . junit . Assert . assertThat ( found , org . hamcrest . Matchers . contains ( label1 , label2 , label3 , label4 ) )"}
{"focal": "getBooleanStyleProperty ( org . pentaho . reporting . engine . classic . core . style . StyleKey ) { final java . lang . Boolean b = ( ( java . lang . Boolean ) ( getStyleProperty ( key , null ) ) ) ; if ( b == null ) { return false ; } return b . booleanValue ( ) ; }", "testMethod": "testSetSticky ( ) { org . pentaho . reporting . engine . classic . core . PageHeader header = new org . pentaho . reporting . engine . classic . core . PageHeader ( ) ; header . setSticky ( true ) ; boolean result = header . getStyle ( ) . getBooleanStyleProperty ( BandStyleKeys . STICKY ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )", "total": "testSetSticky ( ) { org . pentaho . reporting . engine . classic . core . PageHeader header = new org . pentaho . reporting . engine . classic . core . PageHeader ( ) ; header . setSticky ( true ) ; boolean result = header . getStyle ( ) . getBooleanStyleProperty ( BandStyleKeys . STICKY ) ; \"<AssertPlaceHolder>\" ; } getBooleanStyleProperty ( org . pentaho . reporting . engine . classic . core . style . StyleKey ) { final java . lang . Boolean b = ( ( java . lang . Boolean ) ( getStyleProperty ( key , null ) ) ) ; if ( b == null ) { return false ; } return b . booleanValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )"}
{"focal": "isEmpty ( ) { return ( this . size ( ) ) == 0 ; }", "testMethod": "fetchEventsDefinedInAMonthForEmptyAlmanach ( ) { java . util . Date month = dateToUseInTests ( ) ; java . util . List < com . stratelia . webactiv . almanach . model . EventDetail > events = new java . util . ArrayList < com . stratelia . webactiv . almanach . model . EventDetail > ( eventDAO . findAllEventsInPeriod ( org . silverpeas . core . date . period . Period . from ( month , PeriodType . month , \"en\" ) , \"0\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( events . isEmpty ( ) , is ( true ) )", "total": "fetchEventsDefinedInAMonthForEmptyAlmanach ( ) { java . util . Date month = dateToUseInTests ( ) ; java . util . List < com . stratelia . webactiv . almanach . model . EventDetail > events = new java . util . ArrayList < com . stratelia . webactiv . almanach . model . EventDetail > ( eventDAO . findAllEventsInPeriod ( org . silverpeas . core . date . period . Period . from ( month , PeriodType . month , \"en\" ) , \"0\" ) ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( this . size ( ) ) == 0 ; }", "answer": "org . junit . Assert . assertThat ( events . isEmpty ( ) , is ( true ) )"}
{"focal": "shouldCancelEvent ( org . bukkit . entity . Player ) { return ( ( player != null ) && ( ! ( checkAuth ( player . getName ( ) ) ) ) ) && ( ! ( fr . xephi . authme . util . PlayerUtils . isNpc ( player ) ) ) ; }", "testMethod": "shouldHandleEventWithNullEntity ( ) { org . bukkit . event . entity . EntityEvent event = mock ( org . bukkit . event . entity . EntityEvent . class ) ; given ( event . getEntity ( ) ) . willReturn ( null ) ; boolean result = listenerService . shouldCancelEvent ( event ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )", "total": "shouldHandleEventWithNullEntity ( ) { org . bukkit . event . entity . EntityEvent event = mock ( org . bukkit . event . entity . EntityEvent . class ) ; given ( event . getEntity ( ) ) . willReturn ( null ) ; boolean result = listenerService . shouldCancelEvent ( event ) ; \"<AssertPlaceHolder>\" ; } shouldCancelEvent ( org . bukkit . entity . Player ) { return ( ( player != null ) && ( ! ( checkAuth ( player . getName ( ) ) ) ) ) && ( ! ( fr . xephi . authme . util . PlayerUtils . isNpc ( player ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "findParameterAt ( int ) { int tokenIndex = getTokenIndexForChar ( ( dot == 0 ? 1 : dot ) ) ; if ( tokenIndex == ( - 1 ) ) { return \"\" ; } java . lang . String token = tokens . get ( tokenIndex ) ; if ( isSeparator ( token ) ) { return tokenIndex < ( ( tokens . size ( ) ) - 1 ) ? tokens . get ( ( tokenIndex + 1 ) ) : \"\" ; } else if ( token . equals ( \"=\" ) ) { return tokenIndex > 1 ? tokens . get ( ( tokenIndex - 1 ) ) : \"\" ; } if ( ( tokenIndex > 1 ) && ( tokens . get ( ( tokenIndex - 1 ) ) . equals ( \"=\" ) ) ) { return tokens . get ( ( tokenIndex - 2 ) ) ; } return token ; }", "testMethod": "handlesClickOnLeadingEqualsSign ( ) { java . lang . String parametersString = \"?=name=Johan&reallyLongOne=value&\" ; com . eviware . soapui . impl . rest . panels . request . ParameterFinder finder = new com . eviware . soapui . impl . rest . panels . request . ParameterFinder ( parametersString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( finder . findParameterAt ( parametersString . indexOf ( \"=\" ) ) , org . hamcrest . core . Is . is ( \"\" ) )", "total": "handlesClickOnLeadingEqualsSign ( ) { java . lang . String parametersString = \"?=name=Johan&reallyLongOne=value&\" ; com . eviware . soapui . impl . rest . panels . request . ParameterFinder finder = new com . eviware . soapui . impl . rest . panels . request . ParameterFinder ( parametersString ) ; \"<AssertPlaceHolder>\" ; } findParameterAt ( int ) { int tokenIndex = getTokenIndexForChar ( ( dot == 0 ? 1 : dot ) ) ; if ( tokenIndex == ( - 1 ) ) { return \"\" ; } java . lang . String token = tokens . get ( tokenIndex ) ; if ( isSeparator ( token ) ) { return tokenIndex < ( ( tokens . size ( ) ) - 1 ) ? tokens . get ( ( tokenIndex + 1 ) ) : \"\" ; } else if ( token . equals ( \"=\" ) ) { return tokenIndex > 1 ? tokens . get ( ( tokenIndex - 1 ) ) : \"\" ; } if ( ( tokenIndex > 1 ) && ( tokens . get ( ( tokenIndex - 1 ) ) . equals ( \"=\" ) ) ) { return tokens . get ( ( tokenIndex - 2 ) ) ; } return token ; }", "answer": "org . junit . Assert . assertThat ( finder . findParameterAt ( parametersString . indexOf ( \"=\" ) ) , org . hamcrest . core . Is . is ( \"\" ) )"}
{"focal": "deserialize ( com . orientechnologies . orient . core . record . impl . ODocument , java . lang . String ) { final byte [ ] bytes = document . field ( fieldName , OType . BINARY ) ; try ( java . io . ObjectInputStream objects = new org . sonatype . nexus . common . io . ObjectInputStreamWithClassLoader ( new java . io . ByteArrayInputStream ( bytes ) , uberClassLoader ) ) { return objects . readObject ( ) ; } catch ( java . io . IOException | java . lang . ClassNotFoundException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "testMethod": "serializes_During_Deserialization ( ) { java . lang . Object deserializedValue = underTest . deserialize ( parser , context ) ; \"<AssertPlaceHolder>\" ; verify ( generator ) . writeFieldName ( eq ( org . sonatype . nexus . repository . json . UntypedObjectDeserializerSerializerTest . FIELD_NAME ) ) ; verify ( generator ) . writeObject ( eq ( org . sonatype . nexus . repository . json . UntypedObjectDeserializerSerializerTest . FIELD_VALUE ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( deserializedValue , org . hamcrest . Matchers . equalTo ( org . sonatype . nexus . repository . json . UntypedObjectDeserializerSerializerTest . FIELD_VALUE ) )", "total": "serializes_During_Deserialization ( ) { java . lang . Object deserializedValue = underTest . deserialize ( parser , context ) ; \"<AssertPlaceHolder>\" ; verify ( generator ) . writeFieldName ( eq ( org . sonatype . nexus . repository . json . UntypedObjectDeserializerSerializerTest . FIELD_NAME ) ) ; verify ( generator ) . writeObject ( eq ( org . sonatype . nexus . repository . json . UntypedObjectDeserializerSerializerTest . FIELD_VALUE ) ) ; } deserialize ( com . orientechnologies . orient . core . record . impl . ODocument , java . lang . String ) { final byte [ ] bytes = document . field ( fieldName , OType . BINARY ) ; try ( java . io . ObjectInputStream objects = new org . sonatype . nexus . common . io . ObjectInputStreamWithClassLoader ( new java . io . ByteArrayInputStream ( bytes ) , uberClassLoader ) ) { return objects . readObject ( ) ; } catch ( java . io . IOException | java . lang . ClassNotFoundException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( deserializedValue , org . hamcrest . Matchers . equalTo ( org . sonatype . nexus . repository . json . UntypedObjectDeserializerSerializerTest . FIELD_VALUE ) )"}
{"focal": "getValidationReport ( ) { return validationReport ; }", "testMethod": "testCannotUpdateEventTriggerForNonEvent ( ) { org . camunda . bpm . engine . repository . ProcessDefinition sourceProcessDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; org . camunda . bpm . engine . repository . ProcessDefinition targetProcessDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; try { runtimeService . createMigrationPlan ( sourceProcessDefinition . getId ( ) , targetProcessDefinition . getId ( ) ) . mapActivities ( \"userTask\" , \"userTask\" ) . updateEventTrigger ( ) . build ( ) ; org . junit . Assert . fail ( \"Should<sp>not<sp>succeed\" ) ; } catch ( org . camunda . bpm . engine . migration . MigrationPlanValidationException e ) { \"<AssertPlaceHolder>\" . hasInstructionFailures ( \"userTask\" , \"Cannot<sp>update<sp>event<sp>trigger<sp>because<sp>the<sp>activity<sp>does<sp>not<sp>define<sp>a<sp>persistent<sp>event<sp>trigger\" ) ; } }", "assertLine": "org . junit . Assert . assertThat ( e . getValidationReport ( ) )", "total": "testCannotUpdateEventTriggerForNonEvent ( ) { org . camunda . bpm . engine . repository . ProcessDefinition sourceProcessDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; org . camunda . bpm . engine . repository . ProcessDefinition targetProcessDefinition = testHelper . deployAndGetDefinition ( ProcessModels . ONE_TASK_PROCESS ) ; try { runtimeService . createMigrationPlan ( sourceProcessDefinition . getId ( ) , targetProcessDefinition . getId ( ) ) . mapActivities ( \"userTask\" , \"userTask\" ) . updateEventTrigger ( ) . build ( ) ; org . junit . Assert . fail ( \"Should<sp>not<sp>succeed\" ) ; } catch ( org . camunda . bpm . engine . migration . MigrationPlanValidationException e ) { \"<AssertPlaceHolder>\" . hasInstructionFailures ( \"userTask\" , \"Cannot<sp>update<sp>event<sp>trigger<sp>because<sp>the<sp>activity<sp>does<sp>not<sp>define<sp>a<sp>persistent<sp>event<sp>trigger\" ) ; } } getValidationReport ( ) { return validationReport ; }", "answer": "org . junit . Assert . assertThat ( e . getValidationReport ( ) )"}
{"focal": "comparePassword ( java . lang . String , java . lang . String ) { fr . xephi . authme . security . crypts . HashedPassword auth = dataSource . getPassword ( playerName ) ; return ( auth != null ) && ( comparePassword ( password , auth , playerName ) ) ; }", "testMethod": "shouldTryLegacyMethodsAndFail ( ) { fr . xephi . authme . security . crypts . HashedPassword password = new fr . xephi . authme . security . crypts . HashedPassword ( \"hashNotMatchingAnyMethod\" , \"someBogusSalt\" ) ; java . lang . String playerName = \"asfd\" ; java . lang . String clearTextPass = \"someInvalidPassword\" ; given ( dataSource . getPassword ( playerName ) ) . willReturn ( password ) ; given ( method . comparePassword ( clearTextPass , password , playerName ) ) . willReturn ( false ) ; given ( settings . getProperty ( SecuritySettings . PASSWORD_HASH ) ) . willReturn ( HashAlgorithm . MD5 ) ; given ( settings . getProperty ( SecuritySettings . LEGACY_HASHES ) ) . willReturn ( newHashSet ( HashAlgorithm . DOUBLEMD5 , HashAlgorithm . JOOMLA , HashAlgorithm . SMF , HashAlgorithm . SHA256 ) ) ; passwordSecurity . reload ( ) ; boolean result = passwordSecurity . comparePassword ( clearTextPass , playerName ) ; \"<AssertPlaceHolder>\" ; verify ( dataSource , never ( ) ) . updatePassword ( anyString ( ) , any ( fr . xephi . authme . security . crypts . HashedPassword . class ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )", "total": "shouldTryLegacyMethodsAndFail ( ) { fr . xephi . authme . security . crypts . HashedPassword password = new fr . xephi . authme . security . crypts . HashedPassword ( \"hashNotMatchingAnyMethod\" , \"someBogusSalt\" ) ; java . lang . String playerName = \"asfd\" ; java . lang . String clearTextPass = \"someInvalidPassword\" ; given ( dataSource . getPassword ( playerName ) ) . willReturn ( password ) ; given ( method . comparePassword ( clearTextPass , password , playerName ) ) . willReturn ( false ) ; given ( settings . getProperty ( SecuritySettings . PASSWORD_HASH ) ) . willReturn ( HashAlgorithm . MD5 ) ; given ( settings . getProperty ( SecuritySettings . LEGACY_HASHES ) ) . willReturn ( newHashSet ( HashAlgorithm . DOUBLEMD5 , HashAlgorithm . JOOMLA , HashAlgorithm . SMF , HashAlgorithm . SHA256 ) ) ; passwordSecurity . reload ( ) ; boolean result = passwordSecurity . comparePassword ( clearTextPass , playerName ) ; \"<AssertPlaceHolder>\" ; verify ( dataSource , never ( ) ) . updatePassword ( anyString ( ) , any ( fr . xephi . authme . security . crypts . HashedPassword . class ) ) ; } comparePassword ( java . lang . String , java . lang . String ) { fr . xephi . authme . security . crypts . HashedPassword auth = dataSource . getPassword ( playerName ) ; return ( auth != null ) && ( comparePassword ( password , auth , playerName ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "findClasses ( ) { return findClasses ( null ) ; }", "testMethod": "findsClassesFromJarManifestClassPathMultpleJars ( ) { createJarToContaining ( new java . io . File ( getTestFolder ( ) ) , com . poolik . classfinder . testClasses . TestInZip . class , \"classes1.jar\" ) ; createJarToContaining ( new java . io . File ( getTestFolder ( ) ) , com . poolik . classfinder . otherTestClasses . ConcreteClass . class , \"classes2.jar\" ) ; org . jboss . shrinkwrap . api . spec . JavaArchive archive = org . jboss . shrinkwrap . api . ShrinkWrap . create ( org . jboss . shrinkwrap . api . spec . JavaArchive . class , \"parent.jar\" ) . addAsManifestResource ( \"MANIFEST_MULTIPLE.MF\" , com . poolik . classfinder . DEFAULT_MANIFEST_NAME ) ; java . io . File target = new java . io . File ( getTestFolder ( ) , \"parent.jar\" ) ; archive . as ( org . jboss . shrinkwrap . api . exporter . ZipExporter . class ) . exportTo ( target , true ) ; java . util . Collection < com . poolik . classfinder . info . ClassInfo > classes = new com . poolik . classfinder . ClassFinder ( ) . add ( target ) . findClasses ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( classes . size ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "findsClassesFromJarManifestClassPathMultpleJars ( ) { createJarToContaining ( new java . io . File ( getTestFolder ( ) ) , com . poolik . classfinder . testClasses . TestInZip . class , \"classes1.jar\" ) ; createJarToContaining ( new java . io . File ( getTestFolder ( ) ) , com . poolik . classfinder . otherTestClasses . ConcreteClass . class , \"classes2.jar\" ) ; org . jboss . shrinkwrap . api . spec . JavaArchive archive = org . jboss . shrinkwrap . api . ShrinkWrap . create ( org . jboss . shrinkwrap . api . spec . JavaArchive . class , \"parent.jar\" ) . addAsManifestResource ( \"MANIFEST_MULTIPLE.MF\" , com . poolik . classfinder . DEFAULT_MANIFEST_NAME ) ; java . io . File target = new java . io . File ( getTestFolder ( ) , \"parent.jar\" ) ; archive . as ( org . jboss . shrinkwrap . api . exporter . ZipExporter . class ) . exportTo ( target , true ) ; java . util . Collection < com . poolik . classfinder . info . ClassInfo > classes = new com . poolik . classfinder . ClassFinder ( ) . add ( target ) . findClasses ( ) ; \"<AssertPlaceHolder>\" ; } findClasses ( ) { return findClasses ( null ) ; }", "answer": "org . junit . Assert . assertThat ( classes . size ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "is ( T ) { return new com . github . drrb . rust . netbeans . util . Option < > ( value ) ; }", "testMethod": "shouldCompileStringToExecutable ( ) { java . io . File file = tempFolder . newFile ( \"test.rs\" ) ; java . util . List < com . github . drrb . rust . netbeans . rustbridge . RustParseMessage > messages = new com . github . drrb . rust . netbeans . rustbridge . RustCompiler ( ) . compile ( file , \"fn<sp>main()<sp>{<sp>}\" , file , com . github . drrb . rust . netbeans . configuration . RustConfiguration . get ( ) . getLibrariesPaths ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( messages , is ( empty ( ) ) )", "total": "shouldCompileStringToExecutable ( ) { java . io . File file = tempFolder . newFile ( \"test.rs\" ) ; java . util . List < com . github . drrb . rust . netbeans . rustbridge . RustParseMessage > messages = new com . github . drrb . rust . netbeans . rustbridge . RustCompiler ( ) . compile ( file , \"fn<sp>main()<sp>{<sp>}\" , file , com . github . drrb . rust . netbeans . configuration . RustConfiguration . get ( ) . getLibrariesPaths ( ) ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return new com . github . drrb . rust . netbeans . util . Option < > ( value ) ; }", "answer": "org . junit . Assert . assertThat ( messages , is ( empty ( ) ) )"}
{"focal": "getDestination ( ) { return \"jms.queue.box\" ; }", "testMethod": "testSendingMessages ( ) { java . util . concurrent . atomic . AtomicReference < io . vertx . ext . stomp . impl . Frame > ref = new java . util . concurrent . atomic . AtomicReference ( ) ; io . vertx . ext . stomp . impl . StompClient client = io . vertx . ext . stomp . impl . StompClient . create ( vertx ) ; client . connect ( ( ar ) -> { if ( ar . failed ( ) ) { return ; } ar . result ( ) . send ( \"/hello\" , io . vertx . core . buffer . Buffer . buffer ( \"this<sp>is<sp>my<sp>content\" ) , ref :: set ) ; } ) ; await ( ) . atMost ( 5 , TimeUnit . SECONDS ) . untilAtomic ( ref , org . hamcrest . Matchers . notNullValue ( io . vertx . ext . stomp . impl . Frame . class ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"/hello\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( ref . get ( ) . getDestination ( ) )", "total": "testSendingMessages ( ) { java . util . concurrent . atomic . AtomicReference < io . vertx . ext . stomp . impl . Frame > ref = new java . util . concurrent . atomic . AtomicReference ( ) ; io . vertx . ext . stomp . impl . StompClient client = io . vertx . ext . stomp . impl . StompClient . create ( vertx ) ; client . connect ( ( ar ) -> { if ( ar . failed ( ) ) { return ; } ar . result ( ) . send ( \"/hello\" , io . vertx . core . buffer . Buffer . buffer ( \"this<sp>is<sp>my<sp>content\" ) , ref :: set ) ; } ) ; await ( ) . atMost ( 5 , TimeUnit . SECONDS ) . untilAtomic ( ref , org . hamcrest . Matchers . notNullValue ( io . vertx . ext . stomp . impl . Frame . class ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"/hello\" ) ; } getDestination ( ) { return \"jms.queue.box\" ; }", "answer": "org . junit . Assert . assertThat ( ref . get ( ) . getDestination ( ) )"}
{"focal": "isSuccess ( ) { return isSuccess ; }", "testMethod": "testStringSimpleResult ( ) { java . lang . String str = \"abc\" ; com . baidu . unbiz . fluentvalidator . Result ret = com . baidu . unbiz . fluentvalidator . FluentValidator . checkAll ( ) . on ( str , new com . baidu . unbiz . fluentvalidator . validator . StringValidator ( ) ) . doValidate ( ) . result ( com . baidu . unbiz . fluentvalidator . ResultCollectors . toSimple ( ) ) ; System . out . println ( ret ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ret . isSuccess ( ) , org . hamcrest . core . Is . is ( true ) )", "total": "testStringSimpleResult ( ) { java . lang . String str = \"abc\" ; com . baidu . unbiz . fluentvalidator . Result ret = com . baidu . unbiz . fluentvalidator . FluentValidator . checkAll ( ) . on ( str , new com . baidu . unbiz . fluentvalidator . validator . StringValidator ( ) ) . doValidate ( ) . result ( com . baidu . unbiz . fluentvalidator . ResultCollectors . toSimple ( ) ) ; System . out . println ( ret ) ; \"<AssertPlaceHolder>\" ; } isSuccess ( ) { return isSuccess ; }", "answer": "org . junit . Assert . assertThat ( ret . isSuccess ( ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "testMethod": "testMatchExactlyActionEdgeNodeErr ( ) { queriesString = org . apache . commons . lang . StringUtils . join ( new java . lang . String [ ] { \"type=node\" , \"enabled=true\" , \"node2\" 1 } , \"&\" ) ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; target . parse ( ) ; java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlow flow = new org . o3project . odenos . core . component . network . flow . basic . BasicFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , path , edgeAction , flowAttributes ) ; @ org . o3project . odenos . core . component . network . flow . query . SuppressWarnings ( \"serial\" ) java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port1\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"node2\" 0 ; } } ) ; } } ; flow . addEdgeAction ( \"node1\" , actions . get ( 0 ) ) ; flow . addEdgeAction ( \"node2\" , actions . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testMatchExactlyActionEdgeNodeErr ( ) { queriesString = org . apache . commons . lang . StringUtils . join ( new java . lang . String [ ] { \"type=node\" , \"enabled=true\" , \"node2\" 1 } , \"&\" ) ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; target . parse ( ) ; java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlow flow = new org . o3project . odenos . core . component . network . flow . basic . BasicFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , path , edgeAction , flowAttributes ) ; @ org . o3project . odenos . core . component . network . flow . query . SuppressWarnings ( \"serial\" ) java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port1\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"node2\" 0 ; } } ) ; } } ; flow . addEdgeAction ( \"node1\" , actions . get ( 0 ) ) ; flow . addEdgeAction ( \"node2\" , actions . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; } matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "entrySet ( ) { return new com . facebook . buck . util . ImmutableMapWithNullValues . EntrySetWithNullValues ( this , delegate . entrySet ( ) ) ; }", "testMethod": "shouldReturnAnEmptyMapIfNoToolchainsFound ( ) { java . nio . file . Path path = temp . newFolder ( ) . toPath ( ) . toAbsolutePath ( ) ; com . google . common . collect . ImmutableMap < java . lang . String , com . facebook . buck . apple . toolchain . AppleToolchain > toolchains = com . facebook . buck . apple . toolchain . impl . AppleToolchainDiscovery . discoverAppleToolchains ( java . util . Optional . of ( path ) , com . google . common . collect . ImmutableList . of ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( toolchains . entrySet ( ) , org . hamcrest . Matchers . empty ( ) )", "total": "shouldReturnAnEmptyMapIfNoToolchainsFound ( ) { java . nio . file . Path path = temp . newFolder ( ) . toPath ( ) . toAbsolutePath ( ) ; com . google . common . collect . ImmutableMap < java . lang . String , com . facebook . buck . apple . toolchain . AppleToolchain > toolchains = com . facebook . buck . apple . toolchain . impl . AppleToolchainDiscovery . discoverAppleToolchains ( java . util . Optional . of ( path ) , com . google . common . collect . ImmutableList . of ( ) ) ; \"<AssertPlaceHolder>\" ; } entrySet ( ) { return new com . facebook . buck . util . ImmutableMapWithNullValues . EntrySetWithNullValues ( this , delegate . entrySet ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( toolchains . entrySet ( ) , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "checkCode ( java . lang . String , java . lang . String ) { boolean correct = false ; if ( code . equals ( verificationCodes . get ( name . toLowerCase ( ) ) ) ) { verify ( name ) ; correct = true ; } return correct ; }", "testMethod": "shouldHandleInvalidNumberInput ( ) { boolean result = totpAuthenticator . checkCode ( \"Some_Secret\" , \"123ZZ\" ) ; \"<AssertPlaceHolder>\" ; verifyZeroInteractions ( googleAuthenticator ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )", "total": "shouldHandleInvalidNumberInput ( ) { boolean result = totpAuthenticator . checkCode ( \"Some_Secret\" , \"123ZZ\" ) ; \"<AssertPlaceHolder>\" ; verifyZeroInteractions ( googleAuthenticator ) ; } checkCode ( java . lang . String , java . lang . String ) { boolean correct = false ; if ( code . equals ( verificationCodes . get ( name . toLowerCase ( ) ) ) ) { verify ( name ) ; correct = true ; } return correct ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "getConventionValue ( T , java . lang . String , boolean ) { if ( isExplicitValue ) { return actualValue ; } T returnValue = actualValue ; if ( _mappings . containsKey ( propertyName ) ) { boolean useMapping = true ; if ( ( actualValue instanceof java . util . Collection ) && ( ! ( ( ( java . util . Collection < ? > ) ( actualValue ) ) . isEmpty ( ) ) ) ) { useMapping = false ; } else if ( ( actualValue instanceof java . util . Map ) && ( ! ( ( ( java . util . Map < ? , ? > ) ( actualValue ) ) . isEmpty ( ) ) ) ) { useMapping = false ; } if ( useMapping ) { returnValue = ( ( T ) ( _mappings . get ( propertyName ) . getValue ( _convention , _source ) ) ) ; } } return returnValue ; }", "testMethod": "canMapPropertiesUsingCallable ( ) { java . util . concurrent . Callable callable = new java . util . concurrent . Callable ( ) { public java . lang . Object call ( ) throws org . gradle . internal . extensibility . Exception { return toList ( \"a\" ) ; } } ; conventionAware . map ( \"list1\" , callable ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( conventionAware . getConventionValue ( null , \"list1\" , false ) , org . hamcrest . Matchers . equalTo ( ( ( java . lang . Object ) ( toList ( \"a\" ) ) ) ) )", "total": "canMapPropertiesUsingCallable ( ) { java . util . concurrent . Callable callable = new java . util . concurrent . Callable ( ) { public java . lang . Object call ( ) throws org . gradle . internal . extensibility . Exception { return toList ( \"a\" ) ; } } ; conventionAware . map ( \"list1\" , callable ) ; \"<AssertPlaceHolder>\" ; } getConventionValue ( T , java . lang . String , boolean ) { if ( isExplicitValue ) { return actualValue ; } T returnValue = actualValue ; if ( _mappings . containsKey ( propertyName ) ) { boolean useMapping = true ; if ( ( actualValue instanceof java . util . Collection ) && ( ! ( ( ( java . util . Collection < ? > ) ( actualValue ) ) . isEmpty ( ) ) ) ) { useMapping = false ; } else if ( ( actualValue instanceof java . util . Map ) && ( ! ( ( ( java . util . Map < ? , ? > ) ( actualValue ) ) . isEmpty ( ) ) ) ) { useMapping = false ; } if ( useMapping ) { returnValue = ( ( T ) ( _mappings . get ( propertyName ) . getValue ( _convention , _source ) ) ) ; } } return returnValue ; }", "answer": "org . junit . Assert . assertThat ( conventionAware . getConventionValue ( null , \"list1\" , false ) , org . hamcrest . Matchers . equalTo ( ( ( java . lang . Object ) ( toList ( \"a\" ) ) ) ) )"}
{"focal": "defineQuestionGroup ( org . mifos . platform . questionnaire . ui . model . QuestionGroupForm , org . springframework . webflow . execution . RequestContext , boolean ) { java . lang . String result = \"success\" ; if ( ! ( questionGroupHasErrors ( questionGroupForm , requestContext ) ) ) { org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail = null ; try { if ( createMode ) { questionGroupForm . setActive ( true ) ; } if ( questionGroupForm . isActive ( ) ) { questionGroupDetail = questionnaireServiceFacade . createActiveQuestionGroup ( questionGroupForm . getQuestionGroupDetail ( ) ) ; } else { questionGroupDetail = questionnaireServiceFacade . createQuestionGroup ( questionGroupForm . getQuestionGroupDetail ( ) ) ; } if ( ( containsCreateLoanEventSource ( questionGroupForm . getEventSources ( ) ) ) && ( questionGroupForm . getApplyToAllLoanProducts ( ) ) ) { questionnaireServiceFacade . applyToAllLoanProducts ( questionGroupDetail . getId ( ) ) ; } java . util . List < org . mifos . platform . questionnaire . service . QuestionLinkDetail > questionLinkDetails = setFilledQuestionDetailForQuestionLinks ( questionGroupForm . getQuestionLinks ( ) , questionGroupDetail ) ; java . util . List < org . mifos . platform . questionnaire . service . SectionLinkDetail > sectionLinkDetails = setFilledSectionDetailForQuestionLinks ( questionGroupForm . getSectionLinks ( ) , questionGroupDetail ) ; questionnaireServiceFacade . createQuestionLinks ( questionLinkDetails ) ; questionnaireServiceFacade . createSectionLinks ( sectionLinkDetails ) ; } catch ( org . springframework . security . access . AccessDeniedException e ) { constructAndLogSystemError ( requestContext . getMessageContext ( ) , new org . mifos . framework . exceptions . SystemException ( org . mifos . platform . questionnaire . QuestionnaireConstants . MISSING_PERMISSION_TO_ACTIVATE_QG , e ) ) ; result = \"failure\" ; } catch ( org . mifos . framework . exceptions . SystemException e ) { constructAndLogSystemError ( requestContext . getMessageContext ( ) , e ) ; result = \"failure\" ; } } else { result = \"failure\" ; } return result ; }", "testMethod": "testCreateQuestionGroupFailureWhenSectionsNotPresent ( ) { when ( requestContext . getMessageContext ( ) ) . thenReturn ( messageContext ) ; org . mifos . platform . questionnaire . ui . model . QuestionGroupForm questionGroupForm = getQuestionGroupForm ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE , \"Create.Client\" ) ; java . lang . String result = questionGroupController . defineQuestionGroup ( questionGroupForm , requestContext , true ) ; \"<AssertPlaceHolder>\" ; verify ( requestContext ) . getMessageContext ( ) ; verify ( messageContext ) . addMessage ( argThat ( new org . mifos . platform . matchers . MessageMatcher ( \"questionnaire.error.section.atLeastOne\" ) ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( \"failure\" ) )", "total": "testCreateQuestionGroupFailureWhenSectionsNotPresent ( ) { when ( requestContext . getMessageContext ( ) ) . thenReturn ( messageContext ) ; org . mifos . platform . questionnaire . ui . model . QuestionGroupForm questionGroupForm = getQuestionGroupForm ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE , \"Create.Client\" ) ; java . lang . String result = questionGroupController . defineQuestionGroup ( questionGroupForm , requestContext , true ) ; \"<AssertPlaceHolder>\" ; verify ( requestContext ) . getMessageContext ( ) ; verify ( messageContext ) . addMessage ( argThat ( new org . mifos . platform . matchers . MessageMatcher ( \"questionnaire.error.section.atLeastOne\" ) ) ) ; } defineQuestionGroup ( org . mifos . platform . questionnaire . ui . model . QuestionGroupForm , org . springframework . webflow . execution . RequestContext , boolean ) { java . lang . String result = \"success\" ; if ( ! ( questionGroupHasErrors ( questionGroupForm , requestContext ) ) ) { org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail = null ; try { if ( createMode ) { questionGroupForm . setActive ( true ) ; } if ( questionGroupForm . isActive ( ) ) { questionGroupDetail = questionnaireServiceFacade . createActiveQuestionGroup ( questionGroupForm . getQuestionGroupDetail ( ) ) ; } else { questionGroupDetail = questionnaireServiceFacade . createQuestionGroup ( questionGroupForm . getQuestionGroupDetail ( ) ) ; } if ( ( containsCreateLoanEventSource ( questionGroupForm . getEventSources ( ) ) ) && ( questionGroupForm . getApplyToAllLoanProducts ( ) ) ) { questionnaireServiceFacade . applyToAllLoanProducts ( questionGroupDetail . getId ( ) ) ; } java . util . List < org . mifos . platform . questionnaire . service . QuestionLinkDetail > questionLinkDetails = setFilledQuestionDetailForQuestionLinks ( questionGroupForm . getQuestionLinks ( ) , questionGroupDetail ) ; java . util . List < org . mifos . platform . questionnaire . service . SectionLinkDetail > sectionLinkDetails = setFilledSectionDetailForQuestionLinks ( questionGroupForm . getSectionLinks ( ) , questionGroupDetail ) ; questionnaireServiceFacade . createQuestionLinks ( questionLinkDetails ) ; questionnaireServiceFacade . createSectionLinks ( sectionLinkDetails ) ; } catch ( org . springframework . security . access . AccessDeniedException e ) { constructAndLogSystemError ( requestContext . getMessageContext ( ) , new org . mifos . framework . exceptions . SystemException ( org . mifos . platform . questionnaire . QuestionnaireConstants . MISSING_PERMISSION_TO_ACTIVATE_QG , e ) ) ; result = \"failure\" ; } catch ( org . mifos . framework . exceptions . SystemException e ) { constructAndLogSystemError ( requestContext . getMessageContext ( ) , e ) ; result = \"failure\" ; } } else { result = \"failure\" ; } return result ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( \"failure\" ) )"}
{"focal": "getInnerChunks ( com . sk89q . worldedit . regions . Region ) { java . util . Set < com . sk89q . worldedit . math . BlockVector2 > chunks = new java . util . HashSet ( ) ; int minX = region . getMinimumPoint ( ) . getBlockX ( ) ; int minZ = region . getMinimumPoint ( ) . getBlockZ ( ) ; int maxX = region . getMaximumPoint ( ) . getBlockX ( ) ; int maxZ = region . getMaximumPoint ( ) . getBlockZ ( ) ; int cx = minX & 15 ; int cz = minZ & 15 ; minX = ( cx != 0 ) ? ( minX - cx ) + 16 : minX ; minZ = ( cz != 0 ) ? ( minZ - cz ) + 16 : minZ ; cx = maxX & 15 ; cz = maxZ & 15 ; maxX = ( cx != 15 ) ? maxX - cx : maxX ; maxZ = ( cz != 15 ) ? maxZ - cz : maxZ ; for ( int x = minX ; x < maxX ; x += 16 ) { for ( int z = minZ ; z < maxZ ; z += 16 ) { chunks . add ( com . sk89q . worldedit . math . BlockVector2 . at ( ( x > > 4 ) , ( z > > 4 ) ) ) ; } } return chunks ; }", "testMethod": "testGetBorderRegionsUnalignedPos ( ) { com . sk89q . worldedit . regions . Region region = new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 1 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 32 , 15 , 32 ) ) ; java . util . Set < com . sk89q . worldedit . regions . Region > borderRegions = us . talabrek . ultimateskyblock . handler . WorldEditHandler . getBorderRegions ( region ) ; java . util . Set < com . sk89q . worldedit . regions . Region > expectedBorder = new java . util . HashSet ( java . util . Arrays . < com . sk89q . worldedit . regions . Region > asList ( new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 1 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 15 , 15 , 32 ) ) , new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 32 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 32 , 15 , 32 ) ) , new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 16 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 31 , 15 , 15 ) ) , new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 16 , 0 , 32 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 31 , 15 , 32 ) ) ) ) ; java . util . Set < com . sk89q . worldedit . math . BlockVector2 > expectedInner = new java . util . HashSet ( java . util . Arrays . asList ( com . sk89q . worldedit . math . BlockVector2 . at ( 1 , 1 ) ) ) ; verifySame ( borderRegions , expectedBorder ) ; java . util . Set < com . sk89q . worldedit . math . BlockVector2 > innerChunks = us . talabrek . ultimateskyblock . handler . WorldEditHandler . getInnerChunks ( region ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( innerChunks , org . hamcrest . CoreMatchers . is ( expectedInner ) )", "total": "testGetBorderRegionsUnalignedPos ( ) { com . sk89q . worldedit . regions . Region region = new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 1 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 32 , 15 , 32 ) ) ; java . util . Set < com . sk89q . worldedit . regions . Region > borderRegions = us . talabrek . ultimateskyblock . handler . WorldEditHandler . getBorderRegions ( region ) ; java . util . Set < com . sk89q . worldedit . regions . Region > expectedBorder = new java . util . HashSet ( java . util . Arrays . < com . sk89q . worldedit . regions . Region > asList ( new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 1 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 15 , 15 , 32 ) ) , new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 32 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 32 , 15 , 32 ) ) , new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 16 , 0 , 1 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 31 , 15 , 15 ) ) , new com . sk89q . worldedit . regions . CuboidRegion ( com . sk89q . worldedit . math . BlockVector3 . at ( 16 , 0 , 32 ) , com . sk89q . worldedit . math . BlockVector3 . at ( 31 , 15 , 32 ) ) ) ) ; java . util . Set < com . sk89q . worldedit . math . BlockVector2 > expectedInner = new java . util . HashSet ( java . util . Arrays . asList ( com . sk89q . worldedit . math . BlockVector2 . at ( 1 , 1 ) ) ) ; verifySame ( borderRegions , expectedBorder ) ; java . util . Set < com . sk89q . worldedit . math . BlockVector2 > innerChunks = us . talabrek . ultimateskyblock . handler . WorldEditHandler . getInnerChunks ( region ) ; \"<AssertPlaceHolder>\" ; } getInnerChunks ( com . sk89q . worldedit . regions . Region ) { java . util . Set < com . sk89q . worldedit . math . BlockVector2 > chunks = new java . util . HashSet ( ) ; int minX = region . getMinimumPoint ( ) . getBlockX ( ) ; int minZ = region . getMinimumPoint ( ) . getBlockZ ( ) ; int maxX = region . getMaximumPoint ( ) . getBlockX ( ) ; int maxZ = region . getMaximumPoint ( ) . getBlockZ ( ) ; int cx = minX & 15 ; int cz = minZ & 15 ; minX = ( cx != 0 ) ? ( minX - cx ) + 16 : minX ; minZ = ( cz != 0 ) ? ( minZ - cz ) + 16 : minZ ; cx = maxX & 15 ; cz = maxZ & 15 ; maxX = ( cx != 15 ) ? maxX - cx : maxX ; maxZ = ( cz != 15 ) ? maxZ - cz : maxZ ; for ( int x = minX ; x < maxX ; x += 16 ) { for ( int z = minZ ; z < maxZ ; z += 16 ) { chunks . add ( com . sk89q . worldedit . math . BlockVector2 . at ( ( x > > 4 ) , ( z > > 4 ) ) ) ; } } return chunks ; }", "answer": "org . junit . Assert . assertThat ( innerChunks , org . hamcrest . CoreMatchers . is ( expectedInner ) )"}
{"focal": "render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "testMethod": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%<sp>if<sp>nil<sp><<sp>42.09<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>false<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>true<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>a<sp><<sp>42.09<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>42.09<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>42.1000001<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"yes\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%<sp>if<sp>nil<sp><<sp>42.09<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>false<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>true<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>a<sp><<sp>42.09<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>42.09<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"no\" } , new java . lang . String [ ] { \"{%<sp>if<sp>42.1<sp><<sp>42.1000001<sp>%}yes{%<sp>else<sp>%}no{%<sp>endif<sp>%}\" , \"yes\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } } render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "evaluate ( T extends org . apache . hadoop . io . WritableComparable ) { if ( value == null ) { return org . apache . hadoop . hive . ql . io . sarg . SearchArgument . TruthValue . NULL ; } if ( ( literal . compareTo ( value ) ) > ( threshold ) ) { return org . apache . hadoop . hive . ql . io . sarg . SearchArgument . TruthValue . YES ; } return org . apache . hadoop . hive . ql . io . sarg . SearchArgument . TruthValue . NO ; }", "testMethod": "lessThanIsNullInput ( ) { when ( corc . getWritable ( com . hotels . corc . sarg . LessThanEvaluatorTest . COL0 ) ) . thenReturn ( null ) ; evaluator = new com . hotels . corc . sarg . LessThanEvaluator ( com . hotels . corc . sarg . LessThanEvaluatorTest . COL0 , com . hotels . corc . sarg . LessThanEvaluatorTest . ONE , org . apache . hadoop . hive . ql . io . sarg . PredicateLeaf . Operator . LESS_THAN ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( evaluator . evaluate ( corc ) , org . hamcrest . CoreMatchers . is ( TruthValue . NULL ) )", "total": "lessThanIsNullInput ( ) { when ( corc . getWritable ( com . hotels . corc . sarg . LessThanEvaluatorTest . COL0 ) ) . thenReturn ( null ) ; evaluator = new com . hotels . corc . sarg . LessThanEvaluator ( com . hotels . corc . sarg . LessThanEvaluatorTest . COL0 , com . hotels . corc . sarg . LessThanEvaluatorTest . ONE , org . apache . hadoop . hive . ql . io . sarg . PredicateLeaf . Operator . LESS_THAN ) ; \"<AssertPlaceHolder>\" ; } evaluate ( T extends org . apache . hadoop . io . WritableComparable ) { if ( value == null ) { return org . apache . hadoop . hive . ql . io . sarg . SearchArgument . TruthValue . NULL ; } if ( ( literal . compareTo ( value ) ) > ( threshold ) ) { return org . apache . hadoop . hive . ql . io . sarg . SearchArgument . TruthValue . YES ; } return org . apache . hadoop . hive . ql . io . sarg . SearchArgument . TruthValue . NO ; }", "answer": "org . junit . Assert . assertThat ( evaluator . evaluate ( corc ) , org . hamcrest . CoreMatchers . is ( TruthValue . NULL ) )"}
{"focal": "convertStringToDate ( java . lang . String ) { if ( value == null ) { return - 1L ; } try { return org . slim3 . tester . HeaderUtil . DATE_FORMAT . parse ( value ) . getTime ( ) ; } catch ( java . text . ParseException ignore ) { } throw new java . lang . IllegalArgumentException ( value ) ; }", "testMethod": "convertStringToDate ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . slim3 . tester . HeaderUtil . convertStringToDate ( null ) , org . hamcrest . CoreMatchers . is ( ( - 1L ) ) )", "total": "convertStringToDate ( ) { \"<AssertPlaceHolder>\" ; } convertStringToDate ( java . lang . String ) { if ( value == null ) { return - 1L ; } try { return org . slim3 . tester . HeaderUtil . DATE_FORMAT . parse ( value ) . getTime ( ) ; } catch ( java . text . ParseException ignore ) { } throw new java . lang . IllegalArgumentException ( value ) ; }", "answer": "org . junit . Assert . assertThat ( org . slim3 . tester . HeaderUtil . convertStringToDate ( null ) , org . hamcrest . CoreMatchers . is ( ( - 1L ) ) )"}
{"focal": "getNanosecond ( net . time4j . scale . TimeScale ) { int nano ; switch ( scale ) { case POSIX : case UTC : return this . getNanosecond ( ) ; case TAI : long tai ; if ( ( this . getElapsedTimeUTC ( ) ) < 0 ) { net . time4j . PlainDate date = this . getDateUTC ( ) ; double ttValue = net . time4j . scale . TimeScale . deltaT ( date ) ; ttValue += ( this . posixTime ) - ( net . time4j . Moment . POSIX_UTC_DELTA ) ; ttValue += ( this . getNanosecond ( ) ) / ( ( net . time4j . Moment . MRD ) * 1.0 ) ; long tv = ( ( long ) ( java . lang . Math . floor ( ttValue ) ) ) ; if ( ( java . lang . Double . compare ( ( ( net . time4j . Moment . MRD ) - ( ( ttValue - tv ) * ( net . time4j . Moment . MRD ) ) ) , 1.0 ) ) < 0 ) { tv ++ ; nano = 0 ; } else { nano = net . time4j . Moment . toNanos ( ttValue , tv ) ; } tai = ( tv - 32 ) + ( net . time4j . Moment . UTC_TAI_DELTA ) ; nano -= 184000000 ; if ( nano < 0 ) { tai -- ; nano += net . time4j . Moment . MRD ; } } else { tai = ( this . getElapsedTimeUTC ( ) ) + ( net . time4j . Moment . UTC_TAI_DELTA ) ; nano = this . getNanosecond ( ) ; } if ( tai < 0 ) { throw new java . lang . IllegalArgumentException ( ( \"TAI<sp>not<sp>supported<sp>before<sp>1958-01-01:<sp>\" + ( this ) ) ) ; } else { return nano ; } case GPS : long utc = this . getElapsedTimeUTC ( ) ; if ( ( net . time4j . scale . LeapSeconds . getInstance ( ) . strip ( utc ) ) < ( net . time4j . Moment . POSIX_GPS_DELTA ) ) { throw new java . lang . IllegalArgumentException ( ( \"GPS<sp>not<sp>supported<sp>before<sp>1980-01-06:<sp>\" + ( this ) ) ) ; } else { return this . getNanosecond ( ) ; } case TT : if ( ( this . posixTime ) < ( net . time4j . Moment . POSIX_UTC_DELTA ) ) { net . time4j . PlainDate date = this . getDateUTC ( ) ; double ttValue = net . time4j . scale . TimeScale . deltaT ( date ) ; ttValue += ( this . posixTime ) - ( net . time4j . Moment . POSIX_UTC_DELTA ) ; ttValue += ( this . getNanosecond ( ) ) / ( ( net . time4j . Moment . MRD ) * 1.0 ) ; long tt = ( ( long ) ( java . lang . Math . floor ( ttValue ) ) ) ; if ( ( java . lang . Double . compare ( ( ( net . time4j . Moment . MRD ) - ( ( ttValue - tt ) * ( net . time4j . Moment . MRD ) ) ) , 1.0 ) ) < 0 ) { nano = 0 ; } else { nano = net . time4j . Moment . toNanos ( ttValue , tt ) ; } } else { nano = ( this . getNanosecond ( ) ) + 184000000 ; if ( nano >= ( net . time4j . Moment . MRD ) ) { nano -= net . time4j . Moment . MRD ; } } return nano ; case UT : if ( ( this . posixTime ) < ( net . time4j . Moment . POSIX_UTC_DELTA ) ) { return this . getNanosecond ( ) ; } else { double utValue = this . getModernUT ( ) ; long ut = ( ( long ) ( java . lang . Math . floor ( utValue ) ) ) ; return net . time4j . Moment . toNanos ( utValue , ut ) ; } default : throw new java . lang . UnsupportedOperationException ( ( \"Not<sp>yet<sp>implemented:<sp>\" + scale ) ) ; } }", "testMethod": "getNanosecondGPS ( ) { net . time4j . Moment utc = net . time4j . PlainTimestamp . of ( net . time4j . PlainDate . of ( 1980 , 1 , 6 ) , net . time4j . PlainTime . of ( 0 , 0 , 0 , 123456789 ) ) . inTimezone ( ZonalOffset . UTC ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( utc . getNanosecond ( TimeScale . GPS ) , org . hamcrest . CoreMatchers . is ( 123456789 ) )", "total": "getNanosecondGPS ( ) { net . time4j . Moment utc = net . time4j . PlainTimestamp . of ( net . time4j . PlainDate . of ( 1980 , 1 , 6 ) , net . time4j . PlainTime . of ( 0 , 0 , 0 , 123456789 ) ) . inTimezone ( ZonalOffset . UTC ) ; \"<AssertPlaceHolder>\" ; } getNanosecond ( net . time4j . scale . TimeScale ) { int nano ; switch ( scale ) { case POSIX : case UTC : return this . getNanosecond ( ) ; case TAI : long tai ; if ( ( this . getElapsedTimeUTC ( ) ) < 0 ) { net . time4j . PlainDate date = this . getDateUTC ( ) ; double ttValue = net . time4j . scale . TimeScale . deltaT ( date ) ; ttValue += ( this . posixTime ) - ( net . time4j . Moment . POSIX_UTC_DELTA ) ; ttValue += ( this . getNanosecond ( ) ) / ( ( net . time4j . Moment . MRD ) * 1.0 ) ; long tv = ( ( long ) ( java . lang . Math . floor ( ttValue ) ) ) ; if ( ( java . lang . Double . compare ( ( ( net . time4j . Moment . MRD ) - ( ( ttValue - tv ) * ( net . time4j . Moment . MRD ) ) ) , 1.0 ) ) < 0 ) { tv ++ ; nano = 0 ; } else { nano = net . time4j . Moment . toNanos ( ttValue , tv ) ; } tai = ( tv - 32 ) + ( net . time4j . Moment . UTC_TAI_DELTA ) ; nano -= 184000000 ; if ( nano < 0 ) { tai -- ; nano += net . time4j . Moment . MRD ; } } else { tai = ( this . getElapsedTimeUTC ( ) ) + ( net . time4j . Moment . UTC_TAI_DELTA ) ; nano = this . getNanosecond ( ) ; } if ( tai < 0 ) { throw new java . lang . IllegalArgumentException ( ( \"TAI<sp>not<sp>supported<sp>before<sp>1958-01-01:<sp>\" + ( this ) ) ) ; } else { return nano ; } case GPS : long utc = this . getElapsedTimeUTC ( ) ; if ( ( net . time4j . scale . LeapSeconds . getInstance ( ) . strip ( utc ) ) < ( net . time4j . Moment . POSIX_GPS_DELTA ) ) { throw new java . lang . IllegalArgumentException ( ( \"GPS<sp>not<sp>supported<sp>before<sp>1980-01-06:<sp>\" + ( this ) ) ) ; } else { return this . getNanosecond ( ) ; } case TT : if ( ( this . posixTime ) < ( net . time4j . Moment . POSIX_UTC_DELTA ) ) { net . time4j . PlainDate date = this . getDateUTC ( ) ; double ttValue = net . time4j . scale . TimeScale . deltaT ( date ) ; ttValue += ( this . posixTime ) - ( net . time4j . Moment . POSIX_UTC_DELTA ) ; ttValue += ( this . getNanosecond ( ) ) / ( ( net . time4j . Moment . MRD ) * 1.0 ) ; long tt = ( ( long ) ( java . lang . Math . floor ( ttValue ) ) ) ; if ( ( java . lang . Double . compare ( ( ( net . time4j . Moment . MRD ) - ( ( ttValue - tt ) * ( net . time4j . Moment . MRD ) ) ) , 1.0 ) ) < 0 ) { nano = 0 ; } else { nano = net . time4j . Moment . toNanos ( ttValue , tt ) ; } } else { nano = ( this . getNanosecond ( ) ) + 184000000 ; if ( nano >= ( net . time4j . Moment . MRD ) ) { nano -= net . time4j . Moment . MRD ; } } return nano ; case UT : if ( ( this . posixTime ) < ( net . time4j . Moment . POSIX_UTC_DELTA ) ) { return this . getNanosecond ( ) ; } else { double utValue = this . getModernUT ( ) ; long ut = ( ( long ) ( java . lang . Math . floor ( utValue ) ) ) ; return net . time4j . Moment . toNanos ( utValue , ut ) ; } default : throw new java . lang . UnsupportedOperationException ( ( \"Not<sp>yet<sp>implemented:<sp>\" + scale ) ) ; } }", "answer": "org . junit . Assert . assertThat ( utc . getNanosecond ( TimeScale . GPS ) , org . hamcrest . CoreMatchers . is ( 123456789 ) )"}
{"focal": "inheritable ( ) { return false ; }", "testMethod": "shouldNotBeInheritable ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( provider . inheritable ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "shouldNotBeInheritable ( ) { \"<AssertPlaceHolder>\" ; } inheritable ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( provider . inheritable ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "fromString ( java . lang . String ) { char firstChar = str . charAt ( 0 ) ; if ( ( firstChar >= '0' ) && ( firstChar <= '9' ) ) { int number = java . lang . Integer . parseInt ( str ) ; return org . batfish . datamodel . IpProtocol . fromNumber ( number ) ; } else { return org . batfish . datamodel . IpProtocol . valueOf ( str . toUpperCase ( ) ) ; } }", "testMethod": "testFromString ( ) { for ( org . batfish . datamodel . IpProtocol ipProtocol : org . batfish . datamodel . IpProtocol . values ( ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( org . batfish . datamodel . IpProtocol . fromString ( ipProtocol . name ( ) ) , org . hamcrest . Matchers . equalTo ( ipProtocol ) )", "total": "testFromString ( ) { for ( org . batfish . datamodel . IpProtocol ipProtocol : org . batfish . datamodel . IpProtocol . values ( ) ) { \"<AssertPlaceHolder>\" ; } } fromString ( java . lang . String ) { char firstChar = str . charAt ( 0 ) ; if ( ( firstChar >= '0' ) && ( firstChar <= '9' ) ) { int number = java . lang . Integer . parseInt ( str ) ; return org . batfish . datamodel . IpProtocol . fromNumber ( number ) ; } else { return org . batfish . datamodel . IpProtocol . valueOf ( str . toUpperCase ( ) ) ; } }", "answer": "org . junit . Assert . assertThat ( org . batfish . datamodel . IpProtocol . fromString ( ipProtocol . name ( ) ) , org . hamcrest . Matchers . equalTo ( ipProtocol ) )"}
{"focal": "put ( E ) { java . util . Objects . requireNonNull ( e ) ; while ( isFull ( ) ) { waitForChange ( 0 ) ; } addImpl ( e ) ; }", "testMethod": "putsShort ( ) { short [ ] array = new short [ 4 ] ; java . nio . ShortBuffer buffer = java . nio . ShortBuffer . wrap ( array ) ; buffer . put ( ( ( short ) ( 2 ) ) ) . put ( ( ( short ) ( 3 ) ) ) . put ( ( ( short ) ( 5 ) ) ) . put ( ( ( short ) ( 7 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( array , org . hamcrest . CoreMatchers . is ( new short [ ] { 2 , 3 , 5 , 7 } ) )", "total": "putsShort ( ) { short [ ] array = new short [ 4 ] ; java . nio . ShortBuffer buffer = java . nio . ShortBuffer . wrap ( array ) ; buffer . put ( ( ( short ) ( 2 ) ) ) . put ( ( ( short ) ( 3 ) ) ) . put ( ( ( short ) ( 5 ) ) ) . put ( ( ( short ) ( 7 ) ) ) ; \"<AssertPlaceHolder>\" ; } put ( E ) { java . util . Objects . requireNonNull ( e ) ; while ( isFull ( ) ) { waitForChange ( 0 ) ; } addImpl ( e ) ; }", "answer": "org . junit . Assert . assertThat ( array , org . hamcrest . CoreMatchers . is ( new short [ ] { 2 , 3 , 5 , 7 } ) )"}
{"focal": "executeBatch ( ) { final boolean isExceptionThrown = org . apache . shardingsphere . core . execute . sql . execute . threadlocal . ExecutorExceptionHandler . isExceptionThrown ( ) ; org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < int [ ] > callback = new org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < int [ ] > ( getDatabaseType ( ) , isExceptionThrown ) { @ org . apache . shardingsphere . shardingjdbc . executor . Override protected int [ ] executeSQL ( final org . apache . shardingsphere . core . route . RouteUnit routeUnit , final java . sql . Statement statement , final org . apache . shardingsphere . core . constant . ConnectionMode connectionMode ) throws java . sql . SQLException { return statement . executeBatch ( ) ; } } ; java . util . List < int [ ] > results = executeCallback ( callback ) ; if ( isAccumulate ( ) ) { return accumulate ( results ) ; } else { return results . get ( 0 ) ; } }", "testMethod": "assertClearBatch ( ) { try ( java . sql . Connection connection = getShardingDataSource ( ) . getConnection ( ) ; java . sql . PreparedStatement preparedStatement = connection . prepareStatement ( JDBCTestSQL . INSERT_ORDER_ITEM_WITH_ALL_PLACEHOLDERS_SQL ) ) { preparedStatement . setInt ( 1 , 3101 ) ; preparedStatement . setInt ( 2 , 11 ) ; preparedStatement . setInt ( 3 , 11 ) ; preparedStatement . setString ( 4 , \"BATCH\" ) ; preparedStatement . addBatch ( ) ; preparedStatement . clearBatch ( ) ; int [ ] result = preparedStatement . executeBatch ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( result . length , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "assertClearBatch ( ) { try ( java . sql . Connection connection = getShardingDataSource ( ) . getConnection ( ) ; java . sql . PreparedStatement preparedStatement = connection . prepareStatement ( JDBCTestSQL . INSERT_ORDER_ITEM_WITH_ALL_PLACEHOLDERS_SQL ) ) { preparedStatement . setInt ( 1 , 3101 ) ; preparedStatement . setInt ( 2 , 11 ) ; preparedStatement . setInt ( 3 , 11 ) ; preparedStatement . setString ( 4 , \"BATCH\" ) ; preparedStatement . addBatch ( ) ; preparedStatement . clearBatch ( ) ; int [ ] result = preparedStatement . executeBatch ( ) ; \"<AssertPlaceHolder>\" ; } } executeBatch ( ) { final boolean isExceptionThrown = org . apache . shardingsphere . core . execute . sql . execute . threadlocal . ExecutorExceptionHandler . isExceptionThrown ( ) ; org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < int [ ] > callback = new org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < int [ ] > ( getDatabaseType ( ) , isExceptionThrown ) { @ org . apache . shardingsphere . shardingjdbc . executor . Override protected int [ ] executeSQL ( final org . apache . shardingsphere . core . route . RouteUnit routeUnit , final java . sql . Statement statement , final org . apache . shardingsphere . core . constant . ConnectionMode connectionMode ) throws java . sql . SQLException { return statement . executeBatch ( ) ; } } ; java . util . List < int [ ] > results = executeCallback ( callback ) ; if ( isAccumulate ( ) ) { return accumulate ( results ) ; } else { return results . get ( 0 ) ; } }", "answer": "org . junit . Assert . assertThat ( result . length , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter3 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"remove<sp>propertyx\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter3 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"remove<sp>propertyx\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "getComponentName ( ) { return ( ( java . lang . String ) ( getInputParameter ( \"component\" ) . orElse ( uk . gov . justice . services . core . interceptor . DefaultInterceptorContext . UNKNOWN_COMPONENT ) ) ) ; }", "testMethod": "shouldGetComponentName ( ) { final uk . gov . justice . services . core . interceptor . InterceptorContext interceptorContext = uk . gov . justice . services . core . interceptor . InterceptorContext . interceptorContextWithInput ( input ) ; interceptorContext . setInputParameter ( \"component\" , \"testComponent\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interceptorContext . getComponentName ( ) , org . hamcrest . core . Is . is ( \"testComponent\" ) )", "total": "shouldGetComponentName ( ) { final uk . gov . justice . services . core . interceptor . InterceptorContext interceptorContext = uk . gov . justice . services . core . interceptor . InterceptorContext . interceptorContextWithInput ( input ) ; interceptorContext . setInputParameter ( \"component\" , \"testComponent\" ) ; \"<AssertPlaceHolder>\" ; } getComponentName ( ) { return ( ( java . lang . String ) ( getInputParameter ( \"component\" ) . orElse ( uk . gov . justice . services . core . interceptor . DefaultInterceptorContext . UNKNOWN_COMPONENT ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( interceptorContext . getComponentName ( ) , org . hamcrest . core . Is . is ( \"testComponent\" ) )"}
{"focal": "size ( ) { return columns . size ( ) ; }", "testMethod": "testCommentSyntax2 ( ) { java . util . List < com . zendesk . maxwell . schema . ddl . SchemaChange > changes = parse ( \"CREATE<sp>DATABASE<sp>if<sp>not<sp>exists<sp>`foo`<sp>--<sp>inline<sp>comment!\\n<sp>default<sp>character<sp>#<sp>another<sp>one\\nset=\\'latin1\\'<sp>--one<sp>at<sp>the<sp>end\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( changes . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testCommentSyntax2 ( ) { java . util . List < com . zendesk . maxwell . schema . ddl . SchemaChange > changes = parse ( \"CREATE<sp>DATABASE<sp>if<sp>not<sp>exists<sp>`foo`<sp>--<sp>inline<sp>comment!\\n<sp>default<sp>character<sp>#<sp>another<sp>one\\nset=\\'latin1\\'<sp>--one<sp>at<sp>the<sp>end\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return columns . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( changes . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "transform ( net . ripe . db . whois . common . rpsl . RpslObject , net . ripe . db . whois . update . domain . Update , net . ripe . db . whois . update . domain . UpdateContext , net . ripe . db . whois . update . domain . Action ) { if ( ( ( rpslObject . getType ( ) ) != ( net . ripe . db . whois . common . rpsl . ObjectType . AUT_NUM ) ) || ( ! ( rpslObject . containsAttribute ( AttributeType . MNT_ROUTES ) ) ) ) { return rpslObject ; } updateContext . addMessage ( update , net . ripe . db . whois . update . domain . UpdateMessages . mntRoutesAttributeRemoved ( ) ) ; return new net . ripe . db . whois . common . rpsl . RpslObjectBuilder ( rpslObject ) . removeAttributeType ( AttributeType . MNT_ROUTES ) . get ( ) ; }", "testMethod": "dont_transform_no_short_format_attributes ( ) { final net . ripe . db . whois . common . rpsl . RpslObject mntner = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"mntner:<sp>MINE-MNT\\n\" + ( ( ( \"admin-c:<sp>AA1-TEST\\n\" + \"auth:<sp>MD5-PW<sp>$1$/7f2XnzQ$p5ddbI7SXq4z4yNrObFS/0<sp>#<sp>emptypassword\\n\" ) + \"mnt-by:<sp>MINE-MNT\\n\" ) + \"source:<sp>TEST\\n\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject updatedObject = subject . transform ( mntner , update , updateContext , Action . MODIFY ) ; \"<AssertPlaceHolder>\" ; verifyNoMoreInteractions ( update ) ; verifyNoMoreInteractions ( updateContext ) ; }", "assertLine": "org . junit . Assert . assertThat ( updatedObject , org . hamcrest . Matchers . is ( mntner ) )", "total": "dont_transform_no_short_format_attributes ( ) { final net . ripe . db . whois . common . rpsl . RpslObject mntner = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"mntner:<sp>MINE-MNT\\n\" + ( ( ( \"admin-c:<sp>AA1-TEST\\n\" + \"auth:<sp>MD5-PW<sp>$1$/7f2XnzQ$p5ddbI7SXq4z4yNrObFS/0<sp>#<sp>emptypassword\\n\" ) + \"mnt-by:<sp>MINE-MNT\\n\" ) + \"source:<sp>TEST\\n\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject updatedObject = subject . transform ( mntner , update , updateContext , Action . MODIFY ) ; \"<AssertPlaceHolder>\" ; verifyNoMoreInteractions ( update ) ; verifyNoMoreInteractions ( updateContext ) ; } transform ( net . ripe . db . whois . common . rpsl . RpslObject , net . ripe . db . whois . update . domain . Update , net . ripe . db . whois . update . domain . UpdateContext , net . ripe . db . whois . update . domain . Action ) { if ( ( ( rpslObject . getType ( ) ) != ( net . ripe . db . whois . common . rpsl . ObjectType . AUT_NUM ) ) || ( ! ( rpslObject . containsAttribute ( AttributeType . MNT_ROUTES ) ) ) ) { return rpslObject ; } updateContext . addMessage ( update , net . ripe . db . whois . update . domain . UpdateMessages . mntRoutesAttributeRemoved ( ) ) ; return new net . ripe . db . whois . common . rpsl . RpslObjectBuilder ( rpslObject ) . removeAttributeType ( AttributeType . MNT_ROUTES ) . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( updatedObject , org . hamcrest . Matchers . is ( mntner ) )"}
{"focal": "getStyleForMetacard ( ddf . catalog . data . Metacard ) { for ( org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntry mapEntry : styleMap ) { if ( mapEntry . metacardMatch ( metacard ) ) { return mapEntry . getStyleUrl ( ) ; } } return \"\" ; }", "testMethod": "testGetStyleForMetacardObjectNoMatch ( ) { ddf . catalog . data . Metacard metacard = new org . codice . ddf . spatial . kml . transformer . MockMetacard ( AttributeFormat . OBJECT . toString ( ) , MockMetacard . DEFAULT_LOCATION ) ; org . codice . ddf . spatial . kml . transformer . KmlStyleMap mapper = new org . codice . ddf . spatial . kml . transformer . KmlStyleMap ( ) ; mapper . addMapEntry ( new org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntryImpl ( AttributeFormat . OBJECT . toString ( ) , MockMetacard . DEFAULT_LOCATION , org . codice . ddf . spatial . kml . transformer . KmlStyleMapTest . DEFAULT_STYLE_URL ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mapper . getStyleForMetacard ( metacard ) , org . hamcrest . Matchers . is ( \"\" ) )", "total": "testGetStyleForMetacardObjectNoMatch ( ) { ddf . catalog . data . Metacard metacard = new org . codice . ddf . spatial . kml . transformer . MockMetacard ( AttributeFormat . OBJECT . toString ( ) , MockMetacard . DEFAULT_LOCATION ) ; org . codice . ddf . spatial . kml . transformer . KmlStyleMap mapper = new org . codice . ddf . spatial . kml . transformer . KmlStyleMap ( ) ; mapper . addMapEntry ( new org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntryImpl ( AttributeFormat . OBJECT . toString ( ) , MockMetacard . DEFAULT_LOCATION , org . codice . ddf . spatial . kml . transformer . KmlStyleMapTest . DEFAULT_STYLE_URL ) ) ; \"<AssertPlaceHolder>\" ; } getStyleForMetacard ( ddf . catalog . data . Metacard ) { for ( org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntry mapEntry : styleMap ) { if ( mapEntry . metacardMatch ( metacard ) ) { return mapEntry . getStyleUrl ( ) ; } } return \"\" ; }", "answer": "org . junit . Assert . assertThat ( mapper . getStyleForMetacard ( metacard ) , org . hamcrest . Matchers . is ( \"\" ) )"}
{"focal": "size ( ) { return featureMap . size ( ) ; }", "testMethod": "size_addOneFeature_ReturnsOne ( ) { context . addFeature ( \"test.feature\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( context . size ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "size_addOneFeature_ReturnsOne ( ) { context . addFeature ( \"test.feature\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return featureMap . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( context . size ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "empty ( ) { return new grakn . core . graql . reasoner . cache . Index ( new java . util . HashSet ( ) ) ; }", "testMethod": "testEntitiesLocatedInThemselves ( ) { try ( grakn . core . server . session . TransactionOLTP tx = grakn . core . graql . reasoner . GeoInferenceIT . geoGraphSession . transaction ( ) . write ( ) ) { java . lang . String queryString = \"match<sp>(geo-entity:<sp>$x,<sp>entity-location:<sp>$x)<sp>isa<sp>is-located-in;<sp>get;\" ; graql . lang . query . GraqlGet query = graql . lang . Graql . parse ( queryString ) . asGet ( ) ; java . util . List < grakn . core . concept . answer . ConceptMap > answers = tx . execute ( query ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( answers , org . hamcrest . Matchers . empty ( ) )", "total": "testEntitiesLocatedInThemselves ( ) { try ( grakn . core . server . session . TransactionOLTP tx = grakn . core . graql . reasoner . GeoInferenceIT . geoGraphSession . transaction ( ) . write ( ) ) { java . lang . String queryString = \"match<sp>(geo-entity:<sp>$x,<sp>entity-location:<sp>$x)<sp>isa<sp>is-located-in;<sp>get;\" ; graql . lang . query . GraqlGet query = graql . lang . Graql . parse ( queryString ) . asGet ( ) ; java . util . List < grakn . core . concept . answer . ConceptMap > answers = tx . execute ( query ) ; \"<AssertPlaceHolder>\" ; } } empty ( ) { return new grakn . core . graql . reasoner . cache . Index ( new java . util . HashSet ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( answers , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "matchesProfile ( com . opera . core . systems . OperaProfile ) { return new org . hamcrest . BaseMatcher ( ) { public boolean matches ( java . lang . Object o ) { com . opera . core . systems . OperaProfile actual = ( ( com . opera . core . systems . OperaProfile ) ( o ) ) ; try { if ( ( expected . toJson ( ) . toString ( ) . equals ( actual . toJson ( ) . toString ( ) ) ) && ( ( expected . preferences ( ) . size ( ) ) == ( actual . preferences ( ) . size ( ) ) ) ) { return true ; } } catch ( java . io . IOException e ) { } return false ; } public void describeTo ( org . hamcrest . Description description ) { description . appendText ( expected . toString ( ) ) ; } } ; }", "testMethod": "testFromJson ( ) { com . opera . core . systems . OperaProfile data = new com . opera . core . systems . OperaProfile ( existingProfile ) ; profile = com . opera . core . systems . OperaProfileTest . TestOperaProfile . fromJson ( temporaryProfile , data . toJson ( ) . getString ( OperaProfile . BASE64_JSON_KEY ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( profile , matchesProfile ( data ) )", "total": "testFromJson ( ) { com . opera . core . systems . OperaProfile data = new com . opera . core . systems . OperaProfile ( existingProfile ) ; profile = com . opera . core . systems . OperaProfileTest . TestOperaProfile . fromJson ( temporaryProfile , data . toJson ( ) . getString ( OperaProfile . BASE64_JSON_KEY ) ) ; \"<AssertPlaceHolder>\" ; } matchesProfile ( com . opera . core . systems . OperaProfile ) { return new org . hamcrest . BaseMatcher ( ) { public boolean matches ( java . lang . Object o ) { com . opera . core . systems . OperaProfile actual = ( ( com . opera . core . systems . OperaProfile ) ( o ) ) ; try { if ( ( expected . toJson ( ) . toString ( ) . equals ( actual . toJson ( ) . toString ( ) ) ) && ( ( expected . preferences ( ) . size ( ) ) == ( actual . preferences ( ) . size ( ) ) ) ) { return true ; } } catch ( java . io . IOException e ) { } return false ; } public void describeTo ( org . hamcrest . Description description ) { description . appendText ( expected . toString ( ) ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( profile , matchesProfile ( data ) )"}
{"focal": "comparePassword ( java . lang . String , fr . xephi . authme . security . crypts . HashedPassword , java . lang . String ) { java . lang . String playerLowerCase = playerName . toLowerCase ( ) ; return ( fr . xephi . authme . security . PasswordSecurity . methodMatches ( encryptionMethod , password , hashedPassword , playerLowerCase ) ) || ( compareWithLegacyHashes ( password , hashedPassword , playerLowerCase ) ) ; }", "testMethod": "shouldDetectMatchForHashWithOtherRoundNumber ( ) { fr . xephi . authme . security . crypts . Pbkdf2 pbkdf2 = new fr . xephi . authme . security . crypts . Pbkdf2 ( fr . xephi . authme . security . crypts . Pbkdf2Test . mockSettings ( ) ) ; java . lang . String hash = \"pbkdf2_sha256$4128$3469b0d48b702046$DC8A54351008C6054E12FB19E0BF8A4EA6D4165E0EDC97A1ECD15231037C382DE5BF85D07D5BC9D1ADF9BBFE4CE257C6059FB1B9FF65DB69D8B205F064BE0DA9\" ; java . lang . String clearText = \"PassWord1\" ; boolean isMatch = pbkdf2 . comparePassword ( clearText , new fr . xephi . authme . security . crypts . HashedPassword ( hash ) , \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isMatch , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldDetectMatchForHashWithOtherRoundNumber ( ) { fr . xephi . authme . security . crypts . Pbkdf2 pbkdf2 = new fr . xephi . authme . security . crypts . Pbkdf2 ( fr . xephi . authme . security . crypts . Pbkdf2Test . mockSettings ( ) ) ; java . lang . String hash = \"pbkdf2_sha256$4128$3469b0d48b702046$DC8A54351008C6054E12FB19E0BF8A4EA6D4165E0EDC97A1ECD15231037C382DE5BF85D07D5BC9D1ADF9BBFE4CE257C6059FB1B9FF65DB69D8B205F064BE0DA9\" ; java . lang . String clearText = \"PassWord1\" ; boolean isMatch = pbkdf2 . comparePassword ( clearText , new fr . xephi . authme . security . crypts . HashedPassword ( hash ) , \"\" ) ; \"<AssertPlaceHolder>\" ; } comparePassword ( java . lang . String , fr . xephi . authme . security . crypts . HashedPassword , java . lang . String ) { java . lang . String playerLowerCase = playerName . toLowerCase ( ) ; return ( fr . xephi . authme . security . PasswordSecurity . methodMatches ( encryptionMethod , password , hashedPassword , playerLowerCase ) ) || ( compareWithLegacyHashes ( password , hashedPassword , playerLowerCase ) ) ; }", "answer": "org . junit . Assert . assertThat ( isMatch , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "getDivForClass ( org . jsoup . nodes . Document , java . lang . String ) { return document . select ( ( ( \"div[id=<sp>\" + className ) + \"]\" ) ) ; }", "testMethod": "publicFilterAccessModifierChangesFromPrivateToPublicVisible ( ) { org . jsoup . select . Elements divForClass = japicmp . test . output . xml . XmlHelper . getDivForClass ( japicmp . test . output . xml . XmlOutputGeneratorAccessModifierTest . documentPublic , replaceLastDotWith$ ( AccessModifierLevel . AccessModifierChangesFromPrivateToPublic . class . getCanonicalName ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( divForClass . isEmpty ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "publicFilterAccessModifierChangesFromPrivateToPublicVisible ( ) { org . jsoup . select . Elements divForClass = japicmp . test . output . xml . XmlHelper . getDivForClass ( japicmp . test . output . xml . XmlOutputGeneratorAccessModifierTest . documentPublic , replaceLastDotWith$ ( AccessModifierLevel . AccessModifierChangesFromPrivateToPublic . class . getCanonicalName ( ) ) ) ; \"<AssertPlaceHolder>\" ; } getDivForClass ( org . jsoup . nodes . Document , java . lang . String ) { return document . select ( ( ( \"div[id=<sp>\" + className ) + \"]\" ) ) ; }", "answer": "org . junit . Assert . assertThat ( divForClass . isEmpty ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "publish ( java . util . List , java . lang . String ) { com . spotify . google . cloud . pubsub . client . Topic . validateCanonicalTopic ( canonicalTopic ) ; return publish0 ( messages , canonicalTopic ) ; }", "testMethod": "testLatencyBoundedBatchingTwoMessages ( ) { final java . util . concurrent . LinkedBlockingQueue < com . spotify . google . cloud . pubsub . client . PublisherTest . Request > t = new java . util . concurrent . LinkedBlockingQueue ( ) ; topics . put ( \"t\" , t ) ; final com . spotify . google . cloud . pubsub . client . Message m1 = com . spotify . google . cloud . pubsub . client . Message . of ( \"1\" ) ; final com . spotify . google . cloud . pubsub . client . Message m2 = com . spotify . google . cloud . pubsub . client . Message . of ( \"2\" ) ; publisher . publish ( \"t\" , m1 ) ; publisher . publish ( \"t\" , m2 ) ; final com . spotify . google . cloud . pubsub . client . PublisherTest . Request request = t . take ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( request . messages . size ( ) , org . hamcrest . Matchers . is ( 2 ) )", "total": "testLatencyBoundedBatchingTwoMessages ( ) { final java . util . concurrent . LinkedBlockingQueue < com . spotify . google . cloud . pubsub . client . PublisherTest . Request > t = new java . util . concurrent . LinkedBlockingQueue ( ) ; topics . put ( \"t\" , t ) ; final com . spotify . google . cloud . pubsub . client . Message m1 = com . spotify . google . cloud . pubsub . client . Message . of ( \"1\" ) ; final com . spotify . google . cloud . pubsub . client . Message m2 = com . spotify . google . cloud . pubsub . client . Message . of ( \"2\" ) ; publisher . publish ( \"t\" , m1 ) ; publisher . publish ( \"t\" , m2 ) ; final com . spotify . google . cloud . pubsub . client . PublisherTest . Request request = t . take ( ) ; \"<AssertPlaceHolder>\" ; } publish ( java . util . List , java . lang . String ) { com . spotify . google . cloud . pubsub . client . Topic . validateCanonicalTopic ( canonicalTopic ) ; return publish0 ( messages , canonicalTopic ) ; }", "answer": "org . junit . Assert . assertThat ( request . messages . size ( ) , org . hamcrest . Matchers . is ( 2 ) )"}
{"focal": "getChecksums ( ) { guard ( org . dcache . vehicles . CHECKSUM ) ; return _checksums ; }", "testMethod": "shouldReturnNullDigestOnDoubleWrites ( ) { chksumChannel . write ( buffers [ 0 ] , 0 ) ; buffers [ 0 ] . rewind ( ) ; chksumChannel . write ( buffers [ 0 ] , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chksumChannel . getChecksums ( ) , is ( empty ( ) ) )", "total": "shouldReturnNullDigestOnDoubleWrites ( ) { chksumChannel . write ( buffers [ 0 ] , 0 ) ; buffers [ 0 ] . rewind ( ) ; chksumChannel . write ( buffers [ 0 ] , 0 ) ; \"<AssertPlaceHolder>\" ; } getChecksums ( ) { guard ( org . dcache . vehicles . CHECKSUM ) ; return _checksums ; }", "answer": "org . junit . Assert . assertThat ( chksumChannel . getChecksums ( ) , is ( empty ( ) ) )"}
{"focal": "is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "testMethod": "whenEquivalentAndNoVersionInfoForLeftHand ( ) { oid1 = org . apache . isis . core . metamodel . adapter . oid . RootOid . create ( cusObjectSpecId , \"123\" ) ; oid2 = org . apache . isis . core . metamodel . adapter . oid . RootOid . create ( cusObjectSpecId , \"123\" , 90808L ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( oid1 , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( oid2 ) ) )", "total": "whenEquivalentAndNoVersionInfoForLeftHand ( ) { oid1 = org . apache . isis . core . metamodel . adapter . oid . RootOid . create ( cusObjectSpecId , \"123\" ) ; oid2 = org . apache . isis . core . metamodel . adapter . oid . RootOid . create ( cusObjectSpecId , \"123\" , 90808L ) ; \"<AssertPlaceHolder>\" ; } is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( oid1 , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( oid2 ) ) )"}
{"focal": "parseFlavorString ( java . lang . String ) { return com . google . common . collect . Iterables . transform ( com . google . common . base . Splitter . on ( \",\" ) . omitEmptyStrings ( ) . trimResults ( ) . split ( flavorString ) , ( flavor ) -> { java . lang . String mapped = com . facebook . buck . core . parser . buildtargetparser . FlavorParser . DEPRECATED_FLAVORS . get ( flavor ) ; if ( mapped != null ) { if ( deprecatedFlavorWarningShown . add ( flavor ) ) { com . facebook . buck . core . parser . buildtargetparser . FlavorParser . LOG . warn ( \"Flavor<sp>%s<sp>is<sp>deprecated;<sp>use<sp>%s<sp>instead.\" , flavor , mapped ) ; } return mapped ; } else { return flavor ; } } ) ; }", "testMethod": "testParseSingle ( ) { com . facebook . buck . core . parser . buildtargetparser . FlavorParser flavorParser = new com . facebook . buck . core . parser . buildtargetparser . FlavorParser ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( flavorParser . parseFlavorString ( \"foo\" ) , org . hamcrest . Matchers . contains ( \"foo\" ) )", "total": "testParseSingle ( ) { com . facebook . buck . core . parser . buildtargetparser . FlavorParser flavorParser = new com . facebook . buck . core . parser . buildtargetparser . FlavorParser ( ) ; \"<AssertPlaceHolder>\" ; } parseFlavorString ( java . lang . String ) { return com . google . common . collect . Iterables . transform ( com . google . common . base . Splitter . on ( \",\" ) . omitEmptyStrings ( ) . trimResults ( ) . split ( flavorString ) , ( flavor ) -> { java . lang . String mapped = com . facebook . buck . core . parser . buildtargetparser . FlavorParser . DEPRECATED_FLAVORS . get ( flavor ) ; if ( mapped != null ) { if ( deprecatedFlavorWarningShown . add ( flavor ) ) { com . facebook . buck . core . parser . buildtargetparser . FlavorParser . LOG . warn ( \"Flavor<sp>%s<sp>is<sp>deprecated;<sp>use<sp>%s<sp>instead.\" , flavor , mapped ) ; } return mapped ; } else { return flavor ; } } ) ; }", "answer": "org . junit . Assert . assertThat ( flavorParser . parseFlavorString ( \"foo\" ) , org . hamcrest . Matchers . contains ( \"foo\" ) )"}
{"focal": "hasResult ( ) { return ! ( results . isEmpty ( ) ) ; }", "testMethod": "doesNotHaveResultOnNullResult ( ) { org . jenkinsci . plugins . postbuildscript . model . PostBuildItem postBuildItem = new org . jenkinsci . plugins . postbuildscript . model . PostBuildItem ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( postBuildItem . hasResult ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "doesNotHaveResultOnNullResult ( ) { org . jenkinsci . plugins . postbuildscript . model . PostBuildItem postBuildItem = new org . jenkinsci . plugins . postbuildscript . model . PostBuildItem ( null ) ; \"<AssertPlaceHolder>\" ; } hasResult ( ) { return ! ( results . isEmpty ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( postBuildItem . hasResult ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "h ( java . lang . Object ) { return org . terasoluna . gfw . web . util . HtmlEscapeUtils . htmlEscape ( input ) ; }", "testMethod": "testH14 ( ) { java . lang . Object input = \"a>1\" ; java . lang . Object expct = \"a&gt;1\" ; java . lang . String result = org . terasoluna . gfw . web . el . Functions . h ( input ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expct ) )", "total": "testH14 ( ) { java . lang . Object input = \"a>1\" ; java . lang . Object expct = \"a&gt;1\" ; java . lang . String result = org . terasoluna . gfw . web . el . Functions . h ( input ) ; \"<AssertPlaceHolder>\" ; } h ( java . lang . Object ) { return org . terasoluna . gfw . web . util . HtmlEscapeUtils . htmlEscape ( input ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expct ) )"}
{"focal": "getNumberOfCalls ( ) { return org . openmrs . module . htmlformentry . test . TestCustomSubmissionAction . numberOfCalls ; }", "testMethod": "testCustomPostSubmissionAction ( ) { final java . util . Date date = new java . util . Date ( ) ; new org . openmrs . module . htmlformentry . RegressionTestHelper ( ) { @ org . openmrs . module . htmlformentry . Override public java . lang . String getFormName ( ) { return \"postSubmissionAction\" ; } @ org . openmrs . module . htmlformentry . Override public java . lang . String [ ] widgetLabels ( ) { return new java . lang . String [ ] { \"Date:\" , \"Location:\" , \"Provider:\" } ; } @ org . openmrs . module . htmlformentry . Override public void setupRequest ( org . springframework . mock . web . MockHttpServletRequest request , java . util . Map < java . lang . String , java . lang . String > widgets ) { request . addParameter ( widgets . get ( \"Date:\" ) , dateAsString ( date ) ) ; request . addParameter ( widgets . get ( \"Location:\" ) , \"2\" ) ; request . addParameter ( widgets . get ( \"Provider:\" ) , \"502\" ) ; } @ org . openmrs . module . htmlformentry . Override public void testResults ( org . openmrs . module . htmlformentry . SubmissionResults results ) { \"<AssertPlaceHolder>\" ; } } . run ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( org . openmrs . module . htmlformentry . test . TestCustomSubmissionAction . getNumberOfCalls ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "testCustomPostSubmissionAction ( ) { final java . util . Date date = new java . util . Date ( ) ; new org . openmrs . module . htmlformentry . RegressionTestHelper ( ) { @ org . openmrs . module . htmlformentry . Override public java . lang . String getFormName ( ) { return \"postSubmissionAction\" ; } @ org . openmrs . module . htmlformentry . Override public java . lang . String [ ] widgetLabels ( ) { return new java . lang . String [ ] { \"Date:\" , \"Location:\" , \"Provider:\" } ; } @ org . openmrs . module . htmlformentry . Override public void setupRequest ( org . springframework . mock . web . MockHttpServletRequest request , java . util . Map < java . lang . String , java . lang . String > widgets ) { request . addParameter ( widgets . get ( \"Date:\" ) , dateAsString ( date ) ) ; request . addParameter ( widgets . get ( \"Location:\" ) , \"2\" ) ; request . addParameter ( widgets . get ( \"Provider:\" ) , \"502\" ) ; } @ org . openmrs . module . htmlformentry . Override public void testResults ( org . openmrs . module . htmlformentry . SubmissionResults results ) { \"<AssertPlaceHolder>\" ; } } . run ( ) ; } getNumberOfCalls ( ) { return org . openmrs . module . htmlformentry . test . TestCustomSubmissionAction . numberOfCalls ; }", "answer": "org . junit . Assert . assertThat ( org . openmrs . module . htmlformentry . test . TestCustomSubmissionAction . getNumberOfCalls ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "getDistVersionString ( java . lang . String ) { if ( ( distributionName ) == null ) { distributionName = \"\" ; } lcmc . host . domain . parser . DistributionDetector . LOG . debug2 ( ( ( ( \"getDistVersionString:<sp>dist:<sp>\" + ( distributionName ) ) + \",<sp>version:<sp>\" ) + distributionVersion ) ) ; final java . util . Locale locale = new java . util . Locale ( distributionName , \"\" ) ; final java . util . ResourceBundle resourceCommand = java . util . ResourceBundle . getBundle ( \"lcmc.configs.DistResource\" , locale ) ; java . lang . String distVersion = null ; try { distVersion = resourceCommand . getString ( ( \"version:\" + distributionVersion ) ) ; } catch ( final java . lang . Exception e ) { final java . lang . StringBuilder buf = new java . lang . StringBuilder ( distributionVersion ) ; for ( int i = ( distributionVersion . length ( ) ) - 1 ; i >= 0 ; i -- ) { try { distVersion = resourceCommand . getString ( ( ( \"version:\" + ( buf . toString ( ) ) ) + '*' ) ) ; } catch ( final java . lang . Exception e2 ) { distVersion = null ; } if ( distVersion != null ) { break ; } buf . setLength ( i ) ; } if ( distVersion == null ) { distVersion = distributionVersion ; } } lcmc . host . domain . parser . DistributionDetector . LOG . debug2 ( ( \"getDistVersionString:<sp>dist<sp>version:<sp>\" + distVersion ) ) ; return distVersion ; }", "testMethod": "distVersionShouldBeReturned ( java . lang . String , java . lang . String , java . lang . String ) { final lcmc . host . domain . parser . DistributionDetector distributionDetector = new lcmc . host . domain . parser . DistributionDetector ( null ) ; distributionDetector . detect ( com . google . common . collect . ImmutableList . of ( \"Linux\" , \"\" , \"3.16\" , version , dist ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( distributionDetector . getDistVersionString ( version ) , org . hamcrest . core . Is . is ( distVersion ) )", "total": "distVersionShouldBeReturned ( java . lang . String , java . lang . String , java . lang . String ) { final lcmc . host . domain . parser . DistributionDetector distributionDetector = new lcmc . host . domain . parser . DistributionDetector ( null ) ; distributionDetector . detect ( com . google . common . collect . ImmutableList . of ( \"Linux\" , \"\" , \"3.16\" , version , dist ) ) ; \"<AssertPlaceHolder>\" ; } getDistVersionString ( java . lang . String ) { if ( ( distributionName ) == null ) { distributionName = \"\" ; } lcmc . host . domain . parser . DistributionDetector . LOG . debug2 ( ( ( ( \"getDistVersionString:<sp>dist:<sp>\" + ( distributionName ) ) + \",<sp>version:<sp>\" ) + distributionVersion ) ) ; final java . util . Locale locale = new java . util . Locale ( distributionName , \"\" ) ; final java . util . ResourceBundle resourceCommand = java . util . ResourceBundle . getBundle ( \"lcmc.configs.DistResource\" , locale ) ; java . lang . String distVersion = null ; try { distVersion = resourceCommand . getString ( ( \"version:\" + distributionVersion ) ) ; } catch ( final java . lang . Exception e ) { final java . lang . StringBuilder buf = new java . lang . StringBuilder ( distributionVersion ) ; for ( int i = ( distributionVersion . length ( ) ) - 1 ; i >= 0 ; i -- ) { try { distVersion = resourceCommand . getString ( ( ( \"version:\" + ( buf . toString ( ) ) ) + '*' ) ) ; } catch ( final java . lang . Exception e2 ) { distVersion = null ; } if ( distVersion != null ) { break ; } buf . setLength ( i ) ; } if ( distVersion == null ) { distVersion = distributionVersion ; } } lcmc . host . domain . parser . DistributionDetector . LOG . debug2 ( ( \"getDistVersionString:<sp>dist<sp>version:<sp>\" + distVersion ) ) ; return distVersion ; }", "answer": "org . junit . Assert . assertThat ( distributionDetector . getDistVersionString ( version ) , org . hamcrest . core . Is . is ( distVersion ) )"}
{"focal": "getScenarios ( ) { return transferOrdersModel . getScenarios ( ) ; }", "testMethod": "testRemoveScenarioWithoutOrders ( ) { org . libreplan . business . scenarios . entities . Scenario scenario = givenStoredScenario ( ) ; int previous = scenarioModel . getScenarios ( ) . size ( ) ; scenarioModel . remove ( scenario , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( scenarioModel . getScenarios ( ) . size ( ) , org . hamcrest . CoreMatchers . equalTo ( ( previous - 1 ) ) )", "total": "testRemoveScenarioWithoutOrders ( ) { org . libreplan . business . scenarios . entities . Scenario scenario = givenStoredScenario ( ) ; int previous = scenarioModel . getScenarios ( ) . size ( ) ; scenarioModel . remove ( scenario , false ) ; \"<AssertPlaceHolder>\" ; } getScenarios ( ) { return transferOrdersModel . getScenarios ( ) ; }", "answer": "org . junit . Assert . assertThat ( scenarioModel . getScenarios ( ) . size ( ) , org . hamcrest . CoreMatchers . equalTo ( ( previous - 1 ) ) )"}
{"focal": "getMessage ( ) { return message ; }", "testMethod": "whenCallEnsureThatArgOverloadedShouldThrowIllegalArgumentExceptionUsingSuppliedMessage ( ) { try { org . apache . isis . core . commons . ensure . Ensure . ensureThatArg ( \"foo\" , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . nullValue ( ) ) , \"my<sp>message\" ) ; org . junit . Assert . fail ( ) ; } catch ( final java . lang . IllegalArgumentException ex ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( ex . getMessage ( ) , org . hamcrest . CoreMatchers . is ( \"my<sp>message\" ) )", "total": "whenCallEnsureThatArgOverloadedShouldThrowIllegalArgumentExceptionUsingSuppliedMessage ( ) { try { org . apache . isis . core . commons . ensure . Ensure . ensureThatArg ( \"foo\" , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . nullValue ( ) ) , \"my<sp>message\" ) ; org . junit . Assert . fail ( ) ; } catch ( final java . lang . IllegalArgumentException ex ) { \"<AssertPlaceHolder>\" ; } } getMessage ( ) { return message ; }", "answer": "org . junit . Assert . assertThat ( ex . getMessage ( ) , org . hamcrest . CoreMatchers . is ( \"my<sp>message\" ) )"}
{"focal": "incrementToken ( ) { boolean incrementToken = input . incrementToken ( ) ; if ( incrementToken == false ) return false ; java . lang . String s = termAtt . term ( ) ; int len = s . length ( ) ; if ( ( ( len > 3 ) && ( ( s . charAt ( ( len - 1 ) ) ) == ( com . github . lucenejapaneseanalyzer . japaneseanalyzer . KatakanaStemFilter . KATAKANA_HIRAGANA_PROLONGED_SOUND_MARK ) ) ) && ( isKatakanaString ( s ) ) ) { termAtt . setTermBuffer ( s . substring ( 0 , ( len - 1 ) ) ) ; } return true ; }", "testMethod": "test4 ( ) { java . lang . String text = \"\" ; org . apache . lucene . analysis . Analyzer analyzer = new com . github . lucenejapaneseanalyzer . japaneseanalyzer . GoSenAnalyzer ( ) ; org . apache . lucene . analysis . TokenStream ts = analyzer . tokenStream ( \"content\" , new java . io . StringReader ( text ) ) ; org . apache . lucene . analysis . tokenattributes . TermAttribute ta = ts . getAttribute ( org . apache . lucene . analysis . tokenattributes . TermAttribute . class ) ; while ( ts . incrementToken ( ) ) { java . lang . String term = ta . term ( ) ; System . out . println ( term ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( term , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "test4 ( ) { java . lang . String text = \"\" ; org . apache . lucene . analysis . Analyzer analyzer = new com . github . lucenejapaneseanalyzer . japaneseanalyzer . GoSenAnalyzer ( ) ; org . apache . lucene . analysis . TokenStream ts = analyzer . tokenStream ( \"content\" , new java . io . StringReader ( text ) ) ; org . apache . lucene . analysis . tokenattributes . TermAttribute ta = ts . getAttribute ( org . apache . lucene . analysis . tokenattributes . TermAttribute . class ) ; while ( ts . incrementToken ( ) ) { java . lang . String term = ta . term ( ) ; System . out . println ( term ) ; \"<AssertPlaceHolder>\" ; } } incrementToken ( ) { boolean incrementToken = input . incrementToken ( ) ; if ( incrementToken == false ) return false ; java . lang . String s = termAtt . term ( ) ; int len = s . length ( ) ; if ( ( ( len > 3 ) && ( ( s . charAt ( ( len - 1 ) ) ) == ( com . github . lucenejapaneseanalyzer . japaneseanalyzer . KatakanaStemFilter . KATAKANA_HIRAGANA_PROLONGED_SOUND_MARK ) ) ) && ( isKatakanaString ( s ) ) ) { termAtt . setTermBuffer ( s . substring ( 0 , ( len - 1 ) ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( term , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "getMessage ( ) { return message ; }", "testMethod": "shouldDoUpsertIfDocumentDoesNotExist ( ) { java . lang . String documentId = java . lang . String . valueOf ( java . util . concurrent . ThreadLocalRandom . current ( ) . nextLong ( ) ) . substring ( 1 , 6 ) ; java . lang . String message = \"test<sp>message\" ; org . elasticsearch . action . index . IndexRequest indexRequest = new org . elasticsearch . action . index . IndexRequest ( ) ; indexRequest . source ( \"message\" , message ) ; com . github . vanroy . springdata . jest . UpdateQuery updateQuery = new com . github . vanroy . springdata . jest . UpdateQueryBuilder ( ) . withId ( documentId ) . withDoUpsert ( true ) . withClass ( com . github . vanroy . springdata . jest . SampleEntity . class ) . withIndexRequest ( indexRequest ) . build ( ) ; elasticsearchTemplate . update ( updateQuery ) ; com . github . vanroy . springdata . jest . GetQuery getQuery = new com . github . vanroy . springdata . jest . GetQuery ( ) ; getQuery . setId ( documentId ) ; com . github . vanroy . springdata . jest . SampleEntity indexedEntity = elasticsearchTemplate . queryForObject ( getQuery , com . github . vanroy . springdata . jest . SampleEntity . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( indexedEntity . getMessage ( ) , is ( message ) )", "total": "shouldDoUpsertIfDocumentDoesNotExist ( ) { java . lang . String documentId = java . lang . String . valueOf ( java . util . concurrent . ThreadLocalRandom . current ( ) . nextLong ( ) ) . substring ( 1 , 6 ) ; java . lang . String message = \"test<sp>message\" ; org . elasticsearch . action . index . IndexRequest indexRequest = new org . elasticsearch . action . index . IndexRequest ( ) ; indexRequest . source ( \"message\" , message ) ; com . github . vanroy . springdata . jest . UpdateQuery updateQuery = new com . github . vanroy . springdata . jest . UpdateQueryBuilder ( ) . withId ( documentId ) . withDoUpsert ( true ) . withClass ( com . github . vanroy . springdata . jest . SampleEntity . class ) . withIndexRequest ( indexRequest ) . build ( ) ; elasticsearchTemplate . update ( updateQuery ) ; com . github . vanroy . springdata . jest . GetQuery getQuery = new com . github . vanroy . springdata . jest . GetQuery ( ) ; getQuery . setId ( documentId ) ; com . github . vanroy . springdata . jest . SampleEntity indexedEntity = elasticsearchTemplate . queryForObject ( getQuery , com . github . vanroy . springdata . jest . SampleEntity . class ) ; \"<AssertPlaceHolder>\" ; } getMessage ( ) { return message ; }", "answer": "org . junit . Assert . assertThat ( indexedEntity . getMessage ( ) , is ( message ) )"}
{"focal": "toBuilder ( ) { return new org . batfish . datamodel . GeneratedRoute . Builder ( ) . setNetwork ( getNetwork ( ) ) . setAdmin ( getAdministrativeCost ( ) ) . setNonForwarding ( getNonForwarding ( ) ) . setNonRouting ( getNonRouting ( ) ) . setMetric ( firstNonNull ( getMetric ( ) , 0L ) ) . setNextHopIp ( getNextHopIp ( ) ) . setAsPath ( getAsPath ( ) ) . setAttributePolicy ( getAttributePolicy ( ) ) . setCommunities ( getCommunities ( ) ) . setDiscard ( getDiscard ( ) ) . setGenerationPolicy ( getGenerationPolicy ( ) ) . setNextHopInterface ( getNextHopInterface ( ) ) ; }", "testMethod": "testRoundTripThroughBuilder ( ) { org . batfish . datamodel . IntegerSpace space = _b . including ( org . batfish . datamodel . IntegerSpace . PORTS ) . excluding ( new org . batfish . datamodel . SubRange ( 22 , 22 ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( space . toBuilder ( ) . build ( ) , org . hamcrest . Matchers . equalTo ( space ) )", "total": "testRoundTripThroughBuilder ( ) { org . batfish . datamodel . IntegerSpace space = _b . including ( org . batfish . datamodel . IntegerSpace . PORTS ) . excluding ( new org . batfish . datamodel . SubRange ( 22 , 22 ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; } toBuilder ( ) { return new org . batfish . datamodel . GeneratedRoute . Builder ( ) . setNetwork ( getNetwork ( ) ) . setAdmin ( getAdministrativeCost ( ) ) . setNonForwarding ( getNonForwarding ( ) ) . setNonRouting ( getNonRouting ( ) ) . setMetric ( firstNonNull ( getMetric ( ) , 0L ) ) . setNextHopIp ( getNextHopIp ( ) ) . setAsPath ( getAsPath ( ) ) . setAttributePolicy ( getAttributePolicy ( ) ) . setCommunities ( getCommunities ( ) ) . setDiscard ( getDiscard ( ) ) . setGenerationPolicy ( getGenerationPolicy ( ) ) . setNextHopInterface ( getNextHopInterface ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( space . toBuilder ( ) . build ( ) , org . hamcrest . Matchers . equalTo ( space ) )"}
{"focal": "is ( int ) { return ( get ( ) ) == err ; }", "testMethod": "testResetNonExistentTimer ( ) { boolean rc = timers . reset ( zmq . util . TimersTest . NON_EXISTENT ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rc , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testResetNonExistentTimer ( ) { boolean rc = timers . reset ( zmq . util . TimersTest . NON_EXISTENT ) ; \"<AssertPlaceHolder>\" ; } is ( int ) { return ( get ( ) ) == err ; }", "answer": "org . junit . Assert . assertThat ( rc , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "verify ( org . eclipse . che . ide . ext . java . jdt . internal . compiler . lookup . SourceTypeBinding ) { if ( ( this . type ) == null ) { try { this . type = someType ; verify ( ) ; } finally { this . type = null ; } } else { this . environment . newMethodVerifier ( ) . verify ( someType ) ; } }", "testMethod": "runnerMemoryShouldBeAboveZero ( int , int , int ) { when ( locale . messagesIncorrectValue ( ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . util . RunnerUtilImplTest . SOME_TEXT ) ; boolean isCorrect = util . isRunnerMemoryCorrect ( totalMemory , usedMemory , availableMemory ) ; verifyShowWarning ( ) ; verify ( locale ) . messagesIncorrectValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isCorrect , org . hamcrest . CoreMatchers . is ( false ) )", "total": "runnerMemoryShouldBeAboveZero ( int , int , int ) { when ( locale . messagesIncorrectValue ( ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . util . RunnerUtilImplTest . SOME_TEXT ) ; boolean isCorrect = util . isRunnerMemoryCorrect ( totalMemory , usedMemory , availableMemory ) ; verifyShowWarning ( ) ; verify ( locale ) . messagesIncorrectValue ( ) ; \"<AssertPlaceHolder>\" ; } verify ( org . eclipse . che . ide . ext . java . jdt . internal . compiler . lookup . SourceTypeBinding ) { if ( ( this . type ) == null ) { try { this . type = someType ; verify ( ) ; } finally { this . type = null ; } } else { this . environment . newMethodVerifier ( ) . verify ( someType ) ; } }", "answer": "org . junit . Assert . assertThat ( isCorrect , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "hashCode ( ) { int hash = 3 ; hash = ( 37 * hash ) + ( this . source . hashCode ( ) ) ; hash = ( 37 * hash ) + ( this . pulse . hashCode ( ) ) ; hash = ( 37 * hash ) + ( this . offsetAmount ) ; return ( 37 * hash ) + ( this . offsetUnit . hashCode ( ) ) ; }", "testMethod": "testHashCode ( ) { net . time4j . PlainDate date = net . time4j . PlainDate . of ( 2014 , 5 , 21 ) ; net . time4j . range . Boundary < net . time4j . PlainDate > b1 = net . time4j . range . Boundary . of ( IntervalEdge . OPEN , date ) ; net . time4j . range . Boundary < net . time4j . PlainDate > b2 = net . time4j . range . Boundary . of ( IntervalEdge . OPEN , date ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( b1 . hashCode ( ) , org . hamcrest . CoreMatchers . is ( b2 . hashCode ( ) ) )", "total": "testHashCode ( ) { net . time4j . PlainDate date = net . time4j . PlainDate . of ( 2014 , 5 , 21 ) ; net . time4j . range . Boundary < net . time4j . PlainDate > b1 = net . time4j . range . Boundary . of ( IntervalEdge . OPEN , date ) ; net . time4j . range . Boundary < net . time4j . PlainDate > b2 = net . time4j . range . Boundary . of ( IntervalEdge . OPEN , date ) ; \"<AssertPlaceHolder>\" ; } hashCode ( ) { int hash = 3 ; hash = ( 37 * hash ) + ( this . source . hashCode ( ) ) ; hash = ( 37 * hash ) + ( this . pulse . hashCode ( ) ) ; hash = ( 37 * hash ) + ( this . offsetAmount ) ; return ( 37 * hash ) + ( this . offsetUnit . hashCode ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( b1 . hashCode ( ) , org . hamcrest . CoreMatchers . is ( b2 . hashCode ( ) ) )"}
{"focal": "addInt ( int ) { data [ endOffset ] = value ; ( endOffset ) ++ ; if ( ( endOffset ) == ( data . length ) ) resize ( ) ; }", "testMethod": "add2 ( ) { org . diirt . util . array . BufferInt coll = new org . diirt . util . array . BufferInt ( ) ; for ( int i = 0 ; i < 11 ; i ++ ) { coll . addInt ( i ) ; } org . diirt . util . array . ListInt reference = new org . diirt . util . array . ArrayInt ( new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( coll , equalTo ( reference ) )", "total": "add2 ( ) { org . diirt . util . array . BufferInt coll = new org . diirt . util . array . BufferInt ( ) ; for ( int i = 0 ; i < 11 ; i ++ ) { coll . addInt ( i ) ; } org . diirt . util . array . ListInt reference = new org . diirt . util . array . ArrayInt ( new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; \"<AssertPlaceHolder>\" ; } addInt ( int ) { data [ endOffset ] = value ; ( endOffset ) ++ ; if ( ( endOffset ) == ( data . length ) ) resize ( ) ; }", "answer": "org . junit . Assert . assertThat ( coll , equalTo ( reference ) )"}
{"focal": "handleResponse ( org . apache . http . HttpResponse ) { return response . getStatusLine ( ) . getStatusCode ( ) ; }", "testMethod": "serverConfigurationScenario ( ) { initJadlerUsing ( new net . jadler . stubbing . server . jetty . JettyStubHttpServer ( ) ) ; try { onRequest ( ) . respond ( ) . withStatus ( net . jadler . FacadeIntegrationTest . EXPECTED_STATUS ) ; final int status = org . apache . http . client . fluent . Executor . newInstance ( ) . execute ( org . apache . http . client . fluent . Request . Get ( jadlerUri ( ) ) ) . handleResponse ( net . jadler . STATUS_RETRIEVER ) ; \"<AssertPlaceHolder>\" ; } finally { closeJadler ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( net . jadler . FacadeIntegrationTest . EXPECTED_STATUS ) )", "total": "serverConfigurationScenario ( ) { initJadlerUsing ( new net . jadler . stubbing . server . jetty . JettyStubHttpServer ( ) ) ; try { onRequest ( ) . respond ( ) . withStatus ( net . jadler . FacadeIntegrationTest . EXPECTED_STATUS ) ; final int status = org . apache . http . client . fluent . Executor . newInstance ( ) . execute ( org . apache . http . client . fluent . Request . Get ( jadlerUri ( ) ) ) . handleResponse ( net . jadler . STATUS_RETRIEVER ) ; \"<AssertPlaceHolder>\" ; } finally { closeJadler ( ) ; } } handleResponse ( org . apache . http . HttpResponse ) { return response . getStatusLine ( ) . getStatusCode ( ) ; }", "answer": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( net . jadler . FacadeIntegrationTest . EXPECTED_STATUS ) )"}
{"focal": "toUTF8String ( java . nio . ByteBuffer ) { return com . firefly . utils . io . BufferUtils . toString ( buffer , StandardCharsets . UTF_8 ) ; }", "testMethod": "testResponseBufferUpgradeFrom ( ) { java . nio . ByteBuffer buffer = com . firefly . utils . io . BufferUtils . toBuffer ( ( \"HTTP/1.1<sp>101<sp>Upgrade\\r\\n\" + ( ( ( ( \"Connection:<sp>upgrade\\r\\n\" + \"Content-Length:<sp>0\\r\\n\" ) + \"Sec-WebSocket-Accept:<sp>4GnyoUP4Sc1JD+2pCbNYAhFYVVA\\r\\n\" ) + \"\\r\\n\" ) + \"FOOGRADE\" ) ) ) ; com . firefly . codec . http2 . decode . HttpParser . ResponseHandler handler = new test . codec . http2 . decode . HttpParserTest . Handler ( ) ; com . firefly . codec . http2 . decode . HttpParser parser = new com . firefly . codec . http2 . decode . HttpParser ( handler ) ; while ( ! ( parser . isState ( State . END ) ) ) { parser . parseNext ( buffer ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . firefly . utils . io . BufferUtils . toUTF8String ( buffer ) , org . hamcrest . Matchers . is ( \"FOOGRADE\" ) )", "total": "testResponseBufferUpgradeFrom ( ) { java . nio . ByteBuffer buffer = com . firefly . utils . io . BufferUtils . toBuffer ( ( \"HTTP/1.1<sp>101<sp>Upgrade\\r\\n\" + ( ( ( ( \"Connection:<sp>upgrade\\r\\n\" + \"Content-Length:<sp>0\\r\\n\" ) + \"Sec-WebSocket-Accept:<sp>4GnyoUP4Sc1JD+2pCbNYAhFYVVA\\r\\n\" ) + \"\\r\\n\" ) + \"FOOGRADE\" ) ) ) ; com . firefly . codec . http2 . decode . HttpParser . ResponseHandler handler = new test . codec . http2 . decode . HttpParserTest . Handler ( ) ; com . firefly . codec . http2 . decode . HttpParser parser = new com . firefly . codec . http2 . decode . HttpParser ( handler ) ; while ( ! ( parser . isState ( State . END ) ) ) { parser . parseNext ( buffer ) ; } \"<AssertPlaceHolder>\" ; } toUTF8String ( java . nio . ByteBuffer ) { return com . firefly . utils . io . BufferUtils . toString ( buffer , StandardCharsets . UTF_8 ) ; }", "answer": "org . junit . Assert . assertThat ( com . firefly . utils . io . BufferUtils . toUTF8String ( buffer ) , org . hamcrest . Matchers . is ( \"FOOGRADE\" ) )"}
{"focal": "toString ( ) { if ( name ( ) . equals ( \"sessionId\" ) ) { return \"session-id\" ; } else { return name ( ) ; } }", "testMethod": "testHashBaseForItemMetadataSkipsUnimportantKeys ( ) { final org . sakaiproject . tool . assessment . data . dao . assessment . ItemData item = new org . sakaiproject . tool . assessment . data . dao . assessment . ItemData ( ) ; item . setTypeId ( TypeIfc . FILL_IN_BLANK ) ; final org . sakaiproject . tool . assessment . data . ifc . assessment . ItemMetaDataIfc metaData1 = newItemMetaData ( item , ItemMetaDataIfc . RANDOMIZE , 0 ) ; final org . sakaiproject . tool . assessment . data . ifc . assessment . ItemMetaDataIfc metaData2 = newItemMetaData ( item , ItemMetaDataIfc . OBJECTIVE , 1 ) ; final org . sakaiproject . tool . assessment . data . ifc . assessment . ItemMetaDataIfc metaData3 = newItemMetaData ( item , ItemMetaDataIfc . REQUIRE_ALL_OK , 2 ) ; item . setItemMetaDataSet ( org . mockito . internal . util . collections . Sets . newSet ( metaData1 , metaData2 , metaData3 ) ) ; final java . lang . StringBuilder expectedHashBase = new java . lang . StringBuilder ( ) . append ( ( ( \"RANDOMIZE:\" + ( resourceDocTemplate1 ( fullUrlForContentResource ( org . sakaiproject . tool . assessment . facade . ItemHashUtilTest . CONTENT_RESOURCES [ 0 ] ) ) ) ) + \"::\" ) ) . append ( ( ( \"REQUIRE_ALL_OK:\" + ( resourceDocTemplate1 ( fullUrlForContentResource ( org . sakaiproject . tool . assessment . facade . ItemHashUtilTest . CONTENT_RESOURCES [ 2 ] ) ) ) ) + \"::\" ) ) ; java . util . stream . IntStream . rangeClosed ( 0 , 13 ) . forEach ( ( i ) -> expectedHashBase . append ( \"\" ) ) ; final java . lang . StringBuilder actualHashBase = new java . lang . StringBuilder ( ) ; itemHashUtil . hashBaseForItemMetadata ( item , actualHashBase ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualHashBase . toString ( ) , org . hamcrest . CoreMatchers . equalTo ( expectedHashBase . toString ( ) ) )", "total": "testHashBaseForItemMetadataSkipsUnimportantKeys ( ) { final org . sakaiproject . tool . assessment . data . dao . assessment . ItemData item = new org . sakaiproject . tool . assessment . data . dao . assessment . ItemData ( ) ; item . setTypeId ( TypeIfc . FILL_IN_BLANK ) ; final org . sakaiproject . tool . assessment . data . ifc . assessment . ItemMetaDataIfc metaData1 = newItemMetaData ( item , ItemMetaDataIfc . RANDOMIZE , 0 ) ; final org . sakaiproject . tool . assessment . data . ifc . assessment . ItemMetaDataIfc metaData2 = newItemMetaData ( item , ItemMetaDataIfc . OBJECTIVE , 1 ) ; final org . sakaiproject . tool . assessment . data . ifc . assessment . ItemMetaDataIfc metaData3 = newItemMetaData ( item , ItemMetaDataIfc . REQUIRE_ALL_OK , 2 ) ; item . setItemMetaDataSet ( org . mockito . internal . util . collections . Sets . newSet ( metaData1 , metaData2 , metaData3 ) ) ; final java . lang . StringBuilder expectedHashBase = new java . lang . StringBuilder ( ) . append ( ( ( \"RANDOMIZE:\" + ( resourceDocTemplate1 ( fullUrlForContentResource ( org . sakaiproject . tool . assessment . facade . ItemHashUtilTest . CONTENT_RESOURCES [ 0 ] ) ) ) ) + \"::\" ) ) . append ( ( ( \"REQUIRE_ALL_OK:\" + ( resourceDocTemplate1 ( fullUrlForContentResource ( org . sakaiproject . tool . assessment . facade . ItemHashUtilTest . CONTENT_RESOURCES [ 2 ] ) ) ) ) + \"::\" ) ) ; java . util . stream . IntStream . rangeClosed ( 0 , 13 ) . forEach ( ( i ) -> expectedHashBase . append ( \"\" ) ) ; final java . lang . StringBuilder actualHashBase = new java . lang . StringBuilder ( ) ; itemHashUtil . hashBaseForItemMetadata ( item , actualHashBase ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { if ( name ( ) . equals ( \"sessionId\" ) ) { return \"session-id\" ; } else { return name ( ) ; } }", "answer": "org . junit . Assert . assertThat ( actualHashBase . toString ( ) , org . hamcrest . CoreMatchers . equalTo ( expectedHashBase . toString ( ) ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . PinRemovedEvent event = new com . github . seratch . jslack . api . model . event . PinRemovedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"pin_removed\\\",\\\"has_pins\\\":false}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . PinRemovedEvent event = new com . github . seratch . jslack . api . model . event . PinRemovedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"pin_removed\\\",\\\"has_pins\\\":false}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "getSubReportCount ( ) { return 0 ; }", "testMethod": "testGetSubreportCount ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( header . getSubReportCount ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "testGetSubreportCount ( ) { \"<AssertPlaceHolder>\" ; } getSubReportCount ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( header . getSubReportCount ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "addTrailingSlash ( java . lang . String ) { if ( ( str != null ) && ( ( str . charAt ( ( ( str . length ( ) ) - 1 ) ) ) != '/' ) ) { str += \"/\" ; } return str ; }", "testMethod": "addTrailingSlashOnlyAddsOne ( ) { java . lang . String dummyUri = \"testing/avro/\" ; dummyUri = avroSerDeTransformation . addTrailingSlash ( dummyUri ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dummyUri , org . hamcrest . CoreMatchers . is ( \"testing/avro/\" ) )", "total": "addTrailingSlashOnlyAddsOne ( ) { java . lang . String dummyUri = \"testing/avro/\" ; dummyUri = avroSerDeTransformation . addTrailingSlash ( dummyUri ) ; \"<AssertPlaceHolder>\" ; } addTrailingSlash ( java . lang . String ) { if ( ( str != null ) && ( ( str . charAt ( ( ( str . length ( ) ) - 1 ) ) ) != '/' ) ) { str += \"/\" ; } return str ; }", "answer": "org . junit . Assert . assertThat ( dummyUri , org . hamcrest . CoreMatchers . is ( \"testing/avro/\" ) )"}
{"focal": "values ( ) { org . junit . Assert . assertThat ( net . time4j . calendar . bahai . BadiEra . values ( ) . length , org . hamcrest . CoreMatchers . is ( 1 ) ) ; }", "testMethod": "values ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . calendar . bahai . BadiEra . values ( ) . length , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "values ( ) { \"<AssertPlaceHolder>\" ; } values ( ) { org . junit . Assert . assertThat ( net . time4j . calendar . bahai . BadiEra . values ( ) . length , org . hamcrest . CoreMatchers . is ( 1 ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . calendar . bahai . BadiEra . values ( ) . length , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getStackLevel ( ) { return stackLevel ; }", "testMethod": "setStackLevel_validValue_stackLevelEqualsValue ( ) { java . lang . Integer validValue = 1 ; request . setStackLevel ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( request . getStackLevel ( ) , org . hamcrest . CoreMatchers . is ( validValue ) )", "total": "setStackLevel_validValue_stackLevelEqualsValue ( ) { java . lang . Integer validValue = 1 ; request . setStackLevel ( 1 ) ; \"<AssertPlaceHolder>\" ; } getStackLevel ( ) { return stackLevel ; }", "answer": "org . junit . Assert . assertThat ( request . getStackLevel ( ) , org . hamcrest . CoreMatchers . is ( validValue ) )"}
{"focal": "size ( ) { int size = 0 ; for ( java . util . Enumeration < ? > e = request . getAttributeNames ( ) ; e . hasMoreElements ( ) ; e . nextElement ( ) ) { size ++ ; } return size ; }", "testMethod": "filterInMemory ( ) { java . util . List < org . slim3 . datastore . model . Hoge > list = new java . util . ArrayList < org . slim3 . datastore . model . Hoge > ( ) ; org . slim3 . datastore . model . Hoge hoge = new org . slim3 . datastore . model . Hoge ( ) ; hoge . setMyStringList ( java . util . Arrays . asList ( \"aaa\" ) ) ; list . add ( hoge ) ; java . util . List < org . slim3 . datastore . model . Hoge > filtered = delegate . filterInMemory ( list , org . slim3 . datastore . meta . HogeMeta . get ( ) . myStringList . startsWith ( \"aaa\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filtered . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "filterInMemory ( ) { java . util . List < org . slim3 . datastore . model . Hoge > list = new java . util . ArrayList < org . slim3 . datastore . model . Hoge > ( ) ; org . slim3 . datastore . model . Hoge hoge = new org . slim3 . datastore . model . Hoge ( ) ; hoge . setMyStringList ( java . util . Arrays . asList ( \"aaa\" ) ) ; list . add ( hoge ) ; java . util . List < org . slim3 . datastore . model . Hoge > filtered = delegate . filterInMemory ( list , org . slim3 . datastore . meta . HogeMeta . get ( ) . myStringList . startsWith ( \"aaa\" ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { int size = 0 ; for ( java . util . Enumeration < ? > e = request . getAttributeNames ( ) ; e . hasMoreElements ( ) ; e . nextElement ( ) ) { size ++ ; } return size ; }", "answer": "org . junit . Assert . assertThat ( filtered . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "size ( ) { return this . points . getSize ( ) ; }", "testMethod": "testCurrentStateOfDevelopment ( ) { final java . lang . ClassLoader classLoader = kieker . test . analysisteetime . ExampleConfigurationTest . class . getClassLoader ( ) ; final java . net . URL projectDir = kieker . test . analysisteetime . ExampleConfigurationTest . class . getResource ( \"/\" ) ; final java . net . URL importDirectoryURL = classLoader . getResource ( \"kieker-20170805-132412153-UTC-Nogge-PC-KIEKER-SINGLETON\" ) ; final java . io . File importDirectory = new java . io . File ( importDirectoryURL . toURI ( ) ) ; final java . io . File exportDirectory = new java . io . File ( projectDir . getFile ( ) ) ; final kieker . analysisteetime . ExampleConfiguration configuration = new kieker . analysisteetime . ExampleConfiguration ( importDirectory , exportDirectory ) ; final teetime . framework . Execution < kieker . analysisteetime . ExampleConfiguration > analysis = new teetime . framework . Execution ( configuration ) ; analysis . executeBlocking ( ) ; final kieker . analysisteetime . model . analysismodel . deployment . DeploymentModel deploymentModel = configuration . getDeploymentModel ( ) ; final java . io . File file = new java . io . File ( projectDir . getFile ( ) , \"model.txt\" ) ; final java . io . PrintStream printStream = new java . io . PrintStream ( file , \"UTF-8\" ) ; final kieker . analysisteetime . model . DeploymentModelPrinter deploymentModelPrinter = new kieker . analysisteetime . model . DeploymentModelPrinter ( printStream ) ; deploymentModelPrinter . print ( deploymentModel ) ; final org . eclipse . emf . common . util . EMap < kieker . analysisteetime . util . ComposedKey < kieker . analysisteetime . model . analysismodel . deployment . DeployedOperation , kieker . analysisteetime . model . analysismodel . deployment . DeployedOperation > , kieker . analysisteetime . model . analysismodel . execution . AggregatedInvocation > aggregatedInvocations = configuration . getExecutionModel ( ) . getAggregatedInvocations ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( aggregatedInvocations . values ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "testCurrentStateOfDevelopment ( ) { final java . lang . ClassLoader classLoader = kieker . test . analysisteetime . ExampleConfigurationTest . class . getClassLoader ( ) ; final java . net . URL projectDir = kieker . test . analysisteetime . ExampleConfigurationTest . class . getResource ( \"/\" ) ; final java . net . URL importDirectoryURL = classLoader . getResource ( \"kieker-20170805-132412153-UTC-Nogge-PC-KIEKER-SINGLETON\" ) ; final java . io . File importDirectory = new java . io . File ( importDirectoryURL . toURI ( ) ) ; final java . io . File exportDirectory = new java . io . File ( projectDir . getFile ( ) ) ; final kieker . analysisteetime . ExampleConfiguration configuration = new kieker . analysisteetime . ExampleConfiguration ( importDirectory , exportDirectory ) ; final teetime . framework . Execution < kieker . analysisteetime . ExampleConfiguration > analysis = new teetime . framework . Execution ( configuration ) ; analysis . executeBlocking ( ) ; final kieker . analysisteetime . model . analysismodel . deployment . DeploymentModel deploymentModel = configuration . getDeploymentModel ( ) ; final java . io . File file = new java . io . File ( projectDir . getFile ( ) , \"model.txt\" ) ; final java . io . PrintStream printStream = new java . io . PrintStream ( file , \"UTF-8\" ) ; final kieker . analysisteetime . model . DeploymentModelPrinter deploymentModelPrinter = new kieker . analysisteetime . model . DeploymentModelPrinter ( printStream ) ; deploymentModelPrinter . print ( deploymentModel ) ; final org . eclipse . emf . common . util . EMap < kieker . analysisteetime . util . ComposedKey < kieker . analysisteetime . model . analysismodel . deployment . DeployedOperation , kieker . analysisteetime . model . analysismodel . deployment . DeployedOperation > , kieker . analysisteetime . model . analysismodel . execution . AggregatedInvocation > aggregatedInvocations = configuration . getExecutionModel ( ) . getAggregatedInvocations ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . points . getSize ( ) ; }", "answer": "org . junit . Assert . assertThat ( aggregatedInvocations . values ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "isInSameDatabaseInstance ( org . apache . shardingsphere . core . metadata . datasource . DataSourceMetaData ) { return ( hostName . equals ( dataSourceMetaData . getHostName ( ) ) ) && ( ( port ) == ( dataSourceMetaData . getPort ( ) ) ) ; }", "testMethod": "assertIsInSameDatabaseInstance ( ) { org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData target = new org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData ( \"jdbc:postgresql://127.0.0.1/ds_0\" ) ; org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData actual = new org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData ( \"jdbc:postgresql://127.0.0.1:5432/ds_0\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . isInSameDatabaseInstance ( target ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "assertIsInSameDatabaseInstance ( ) { org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData target = new org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData ( \"jdbc:postgresql://127.0.0.1/ds_0\" ) ; org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData actual = new org . apache . shardingsphere . core . metadata . datasource . dialect . PostgreSQLDataSourceMetaData ( \"jdbc:postgresql://127.0.0.1:5432/ds_0\" ) ; \"<AssertPlaceHolder>\" ; } isInSameDatabaseInstance ( org . apache . shardingsphere . core . metadata . datasource . DataSourceMetaData ) { return ( hostName . equals ( dataSourceMetaData . getHostName ( ) ) ) && ( ( port ) == ( dataSourceMetaData . getPort ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual . isInSameDatabaseInstance ( target ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "testGetOne ( ) { org . springframework . ui . ModelMap model = new org . springframework . ui . ModelMap ( ) ; userController . getOne ( getTestUser ( ) . getUserId ( ) , model ) ; org . ngrinder . model . User user = ( ( org . ngrinder . model . User ) ( model . get ( \"user\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( user . getId ( ) , org . hamcrest . Matchers . is ( getTestUser ( ) . getId ( ) ) )", "total": "testGetOne ( ) { org . springframework . ui . ModelMap model = new org . springframework . ui . ModelMap ( ) ; userController . getOne ( getTestUser ( ) . getUserId ( ) , model ) ; org . ngrinder . model . User user = ( ( org . ngrinder . model . User ) ( model . get ( \"user\" ) ) ) ; \"<AssertPlaceHolder>\" ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( user . getId ( ) , org . hamcrest . Matchers . is ( getTestUser ( ) . getId ( ) ) )"}
{"focal": "map ( K , V , K , V ) { java . util . Map < K , V > map = com . google . common . collect . Maps . newLinkedHashMap ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }", "testMethod": "Missing_Value_Is_Null ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . map ( 1 , 1 , 2 , 2 ) , org . javersion . core . DiffTest . map ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . map ( 1 , null , 2 , null ) ) )", "total": "Missing_Value_Is_Null ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . map ( 1 , 1 , 2 , 2 ) , org . javersion . core . DiffTest . map ( ) ) ; \"<AssertPlaceHolder>\" ; } map ( K , V , K , V ) { java . util . Map < K , V > map = com . google . common . collect . Maps . newLinkedHashMap ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }", "answer": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . map ( 1 , null , 2 , null ) ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "bare_body_eof ( ) { java . lang . String [ ] [ ] result = read ( \"c\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"c\" } } ) )", "total": "bare_body_eof ( ) { java . lang . String [ ] [ ] result = read ( \"c\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"c\" } } ) )"}
{"focal": "addDate ( java . util . Date , long ) { return new java . util . Date ( ( ( date . getTime ( ) ) + ( second * 1000 ) ) ) ; }", "testMethod": "remoteCodeFirstPojo_addDate ( ) { java . util . Date date = new java . util . Date ( ) ; int seconds = 1 ; java . util . Date result = PojoService . codeFirst . addDate ( date , seconds ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( new java . util . Date ( ( ( date . getTime ( ) ) + ( seconds * 1000 ) ) ) ) )", "total": "remoteCodeFirstPojo_addDate ( ) { java . util . Date date = new java . util . Date ( ) ; int seconds = 1 ; java . util . Date result = PojoService . codeFirst . addDate ( date , seconds ) ; \"<AssertPlaceHolder>\" ; } addDate ( java . util . Date , long ) { return new java . util . Date ( ( ( date . getTime ( ) ) + ( second * 1000 ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( new java . util . Date ( ( ( date . getTime ( ) ) + ( seconds * 1000 ) ) ) ) )"}
{"focal": "get ( java . lang . Class ) { return getPage ( pageClass , null ) ; }", "testMethod": "shouldCreateFromExistingModel ( ) { java . util . Map < java . lang . String , java . lang . String > source = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; source . put ( \"k\" , \"v\" ) ; org . springframework . springfaces . mvc . model . SpringFacesModel model = new org . springframework . springfaces . mvc . model . SpringFacesModel ( source ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model . get ( \"k\" ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( ( ( java . lang . Object ) ( \"v\" ) ) ) ) )", "total": "shouldCreateFromExistingModel ( ) { java . util . Map < java . lang . String , java . lang . String > source = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; source . put ( \"k\" , \"v\" ) ; org . springframework . springfaces . mvc . model . SpringFacesModel model = new org . springframework . springfaces . mvc . model . SpringFacesModel ( source ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . Class ) { return getPage ( pageClass , null ) ; }", "answer": "org . junit . Assert . assertThat ( model . get ( \"k\" ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( ( ( java . lang . Object ) ( \"v\" ) ) ) ) )"}
{"focal": "isEmpty ( ) { return map . isEmpty ( ) ; }", "testMethod": "testIsEmptyWhenTasksWereAdded ( ) { tasks . add ( org . codice . ddf . admin . application . service . migratable . TaskListTest . OPERATION_A , org . codice . ddf . admin . application . service . migratable . TaskListTest . ID , task ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tasks . isEmpty ( ) , org . hamcrest . Matchers . equalTo ( false ) )", "total": "testIsEmptyWhenTasksWereAdded ( ) { tasks . add ( org . codice . ddf . admin . application . service . migratable . TaskListTest . OPERATION_A , org . codice . ddf . admin . application . service . migratable . TaskListTest . ID , task ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return map . isEmpty ( ) ; }", "answer": "org . junit . Assert . assertThat ( tasks . isEmpty ( ) , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "apply ( java . lang . String ) { System . out . println ( ( v1 + v1 ) ) ; }", "testMethod": "fold_A$Object ( ) { com . m3 . scalaflavor4j . None < java . lang . String > opt = new com . m3 . scalaflavor4j . None < java . lang . String > ( ) ; java . lang . Integer ifEmpty = - 1 ; java . lang . Integer actual = opt . fold ( ifEmpty ) . apply ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( java . lang . String s ) { return s . length ( ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( ( - 1 ) ) ) )", "total": "fold_A$Object ( ) { com . m3 . scalaflavor4j . None < java . lang . String > opt = new com . m3 . scalaflavor4j . None < java . lang . String > ( ) ; java . lang . Integer ifEmpty = - 1 ; java . lang . Integer actual = opt . fold ( ifEmpty ) . apply ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( java . lang . String s ) { return s . length ( ) ; } } ) ; \"<AssertPlaceHolder>\" ; } apply ( java . lang . String ) { System . out . println ( ( v1 + v1 ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( ( - 1 ) ) ) )"}
{"focal": "calculateNextStartIndex ( int , int , int ) { int nextStartIndex = startIndex + count ; if ( nextStartIndex < hits ) { return nextStartIndex ; } return - 1 ; }", "testMethod": "testCalculateNextStartIndex_NoFeaturesMatched ( ) { int nextStartIndex = org . deegree . services . wfs . util . ResponsePagingUtils . calculateNextStartIndex ( 0 , 10 , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( nextStartIndex , org . hamcrest . CoreMatchers . is ( ( - 1 ) ) )", "total": "testCalculateNextStartIndex_NoFeaturesMatched ( ) { int nextStartIndex = org . deegree . services . wfs . util . ResponsePagingUtils . calculateNextStartIndex ( 0 , 10 , 0 ) ; \"<AssertPlaceHolder>\" ; } calculateNextStartIndex ( int , int , int ) { int nextStartIndex = startIndex + count ; if ( nextStartIndex < hits ) { return nextStartIndex ; } return - 1 ; }", "answer": "org . junit . Assert . assertThat ( nextStartIndex , org . hamcrest . CoreMatchers . is ( ( - 1 ) ) )"}
{"focal": "isVeto ( ) { return ( ( getReason ( ) ) != null ) && ( ( getReason ( ) . length ( ) ) > 0 ) ; }", "testMethod": "shouldInitiallyNotVeto ( ) { interactionEvent = new org . apache . isis . applib . events . InteractionEvent ( source , identifier ) { private static final long serialVersionUID = 1L ; } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interactionEvent . isVeto ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "shouldInitiallyNotVeto ( ) { interactionEvent = new org . apache . isis . applib . events . InteractionEvent ( source , identifier ) { private static final long serialVersionUID = 1L ; } ; \"<AssertPlaceHolder>\" ; } isVeto ( ) { return ( ( getReason ( ) ) != null ) && ( ( getReason ( ) . length ( ) ) > 0 ) ; }", "answer": "org . junit . Assert . assertThat ( interactionEvent . isVeto ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "where ( org . springframework . data . mongodb . core . query . Criteria ) { super . where ( criteria ) ; return this ; }", "testMethod": "nearPoint ( ) { org . springframework . data . geo . Point point = new org . springframework . data . geo . Point ( ( - 73.99171 ) , 40.738868 ) ; java . util . List < org . springframework . data . mongodb . core . Venue > venues = template . find ( query ( where ( \"location\" ) . near ( point ) . maxDistance ( 0.01 ) ) , org . springframework . data . mongodb . core . Venue . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( venues . size ( ) , is ( 7 ) )", "total": "nearPoint ( ) { org . springframework . data . geo . Point point = new org . springframework . data . geo . Point ( ( - 73.99171 ) , 40.738868 ) ; java . util . List < org . springframework . data . mongodb . core . Venue > venues = template . find ( query ( where ( \"location\" ) . near ( point ) . maxDistance ( 0.01 ) ) , org . springframework . data . mongodb . core . Venue . class ) ; \"<AssertPlaceHolder>\" ; } where ( org . springframework . data . mongodb . core . query . Criteria ) { super . where ( criteria ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( venues . size ( ) , is ( 7 ) )"}
{"focal": "getErrorReason ( ) { return this . errorReason ; }", "testMethod": "getErrorReasonReturnsErrorReason ( ) { final int status = 200 ; final byte [ ] body = new byte [ ] { 1 } ; final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final byte [ ] errorReason = new byte [ ] { 2 , 3 , 4 , 5 } ; final byte [ ] expectedErrorReason = errorReason ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpResponse response = new com . microsoft . azure . sdk . iot . deps . transport . http . HttpResponse ( status , body , headerFields , errorReason ) ; byte [ ] testErrorReason = response . getErrorReason ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testErrorReason , org . hamcrest . CoreMatchers . is ( expectedErrorReason ) )", "total": "getErrorReasonReturnsErrorReason ( ) { final int status = 200 ; final byte [ ] body = new byte [ ] { 1 } ; final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final byte [ ] errorReason = new byte [ ] { 2 , 3 , 4 , 5 } ; final byte [ ] expectedErrorReason = errorReason ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpResponse response = new com . microsoft . azure . sdk . iot . deps . transport . http . HttpResponse ( status , body , headerFields , errorReason ) ; byte [ ] testErrorReason = response . getErrorReason ( ) ; \"<AssertPlaceHolder>\" ; } getErrorReason ( ) { return this . errorReason ; }", "answer": "org . junit . Assert . assertThat ( testErrorReason , org . hamcrest . CoreMatchers . is ( expectedErrorReason ) )"}
{"focal": "parseExpr ( java . lang . Class , java . lang . String ) { org . teavm . flavour . expr . EvaluatorBuilder builder = new org . teavm . flavour . expr . InterpretingEvaluatorBuilder ( ) . importPackage ( \"java.lang\" ) . importPackage ( \"java.util\" ) . importClass ( org . teavm . flavour . expr . test . EvaluatorTest . class . getName ( ) ) . importClass ( java . util . stream . Collectors . class . getName ( ) ) ; org . teavm . flavour . expr . Evaluator < T , org . teavm . flavour . expr . test . TestVars > e ; try { e = builder . build ( cls , org . teavm . flavour . expr . test . TestVars . class , str ) ; } catch ( org . teavm . flavour . expr . InvalidExpressionException ex ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"Errors<sp>occurred<sp>compiling<sp>expression:\\n\" ) ; sb . append ( str ) . append ( \"\\n\" ) ; java . util . List < org . teavm . flavour . expr . Diagnostic > diagnostics = ex . getDiagnostics ( ) . stream ( ) . sorted ( java . util . Comparator . comparingInt ( ( d ) -> d . getStart ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( org . teavm . flavour . expr . Diagnostic diagnostic : diagnostics ) { for ( int i = 0 ; i < ( diagnostic . getStart ( ) ) ; ++ i ) { sb . append ( '<sp>' ) ; } sb . append ( \"^\\n\" ) ; sb . append ( diagnostic . getMessage ( ) ) . append ( \"\\n\\n\" ) ; } throw new java . lang . AssertionError ( sb . toString ( ) ) ; } vars = e . getVariables ( ) ; return e . getFunction ( ) ; }", "testMethod": "evaluatesBooleanConstant ( ) { org . teavm . flavour . expr . test . BooleanComputation c = parseExpr ( org . teavm . flavour . expr . test . BooleanComputation . class , \"true\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( c . compute ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "evaluatesBooleanConstant ( ) { org . teavm . flavour . expr . test . BooleanComputation c = parseExpr ( org . teavm . flavour . expr . test . BooleanComputation . class , \"true\" ) ; \"<AssertPlaceHolder>\" ; } parseExpr ( java . lang . Class , java . lang . String ) { org . teavm . flavour . expr . EvaluatorBuilder builder = new org . teavm . flavour . expr . InterpretingEvaluatorBuilder ( ) . importPackage ( \"java.lang\" ) . importPackage ( \"java.util\" ) . importClass ( org . teavm . flavour . expr . test . EvaluatorTest . class . getName ( ) ) . importClass ( java . util . stream . Collectors . class . getName ( ) ) ; org . teavm . flavour . expr . Evaluator < T , org . teavm . flavour . expr . test . TestVars > e ; try { e = builder . build ( cls , org . teavm . flavour . expr . test . TestVars . class , str ) ; } catch ( org . teavm . flavour . expr . InvalidExpressionException ex ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"Errors<sp>occurred<sp>compiling<sp>expression:\\n\" ) ; sb . append ( str ) . append ( \"\\n\" ) ; java . util . List < org . teavm . flavour . expr . Diagnostic > diagnostics = ex . getDiagnostics ( ) . stream ( ) . sorted ( java . util . Comparator . comparingInt ( ( d ) -> d . getStart ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( org . teavm . flavour . expr . Diagnostic diagnostic : diagnostics ) { for ( int i = 0 ; i < ( diagnostic . getStart ( ) ) ; ++ i ) { sb . append ( '<sp>' ) ; } sb . append ( \"^\\n\" ) ; sb . append ( diagnostic . getMessage ( ) ) . append ( \"\\n\\n\" ) ; } throw new java . lang . AssertionError ( sb . toString ( ) ) ; } vars = e . getVariables ( ) ; return e . getFunction ( ) ; }", "answer": "org . junit . Assert . assertThat ( c . compute ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getWeight ( ) { return weight ; }", "testMethod": "doubleMapping ( ) { final double expected = 1.5 ; com . airhacks . enhydrator . in . Row row = new com . airhacks . enhydrator . in . Row ( ) ; row . addColumn ( ( - 1 ) , \"weight\" , expected ) ; this . cut . processRow ( row ) ; com . airhacks . enhydrator . out . Developer dev = getDeveloper ( ) ; double actual = dev . getWeight ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "doubleMapping ( ) { final double expected = 1.5 ; com . airhacks . enhydrator . in . Row row = new com . airhacks . enhydrator . in . Row ( ) ; row . addColumn ( ( - 1 ) , \"weight\" , expected ) ; this . cut . processRow ( row ) ; com . airhacks . enhydrator . out . Developer dev = getDeveloper ( ) ; double actual = dev . getWeight ( ) ; \"<AssertPlaceHolder>\" ; } getWeight ( ) { return weight ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "toFilterGroup ( ) { return new org . batfish . referencelibrary . FilterGroup ( com . google . common . collect . ImmutableList . copyOf ( firstNonNull ( filters , com . google . common . collect . ImmutableSet . of ( ) ) ) , name ) ; }", "testMethod": "conversionToAndFrom ( ) { org . batfish . referencelibrary . FilterGroup group = new org . batfish . referencelibrary . FilterGroup ( com . google . common . collect . ImmutableList . of ( \"abc\" , \"def\" ) , \"fg1\" ) ; org . batfish . coordinator . resources . FilterGroupBean bean = new org . batfish . coordinator . resources . FilterGroupBean ( group ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( new org . batfish . coordinator . resources . FilterGroupBean ( bean . toFilterGroup ( ) ) , org . hamcrest . Matchers . equalTo ( bean ) )", "total": "conversionToAndFrom ( ) { org . batfish . referencelibrary . FilterGroup group = new org . batfish . referencelibrary . FilterGroup ( com . google . common . collect . ImmutableList . of ( \"abc\" , \"def\" ) , \"fg1\" ) ; org . batfish . coordinator . resources . FilterGroupBean bean = new org . batfish . coordinator . resources . FilterGroupBean ( group ) ; \"<AssertPlaceHolder>\" ; } toFilterGroup ( ) { return new org . batfish . referencelibrary . FilterGroup ( com . google . common . collect . ImmutableList . copyOf ( firstNonNull ( filters , com . google . common . collect . ImmutableSet . of ( ) ) ) , name ) ; }", "answer": "org . junit . Assert . assertThat ( new org . batfish . coordinator . resources . FilterGroupBean ( bean . toFilterGroup ( ) ) , org . hamcrest . Matchers . equalTo ( bean ) )"}
{"focal": "incrementToken ( ) { boolean incrementToken = input . incrementToken ( ) ; if ( incrementToken == false ) return false ; java . lang . String s = termAtt . term ( ) ; int len = s . length ( ) ; if ( ( ( len > 3 ) && ( ( s . charAt ( ( len - 1 ) ) ) == ( com . github . lucenejapaneseanalyzer . japaneseanalyzer . KatakanaStemFilter . KATAKANA_HIRAGANA_PROLONGED_SOUND_MARK ) ) ) && ( isKatakanaString ( s ) ) ) { termAtt . setTermBuffer ( s . substring ( 0 , ( len - 1 ) ) ) ; } return true ; }", "testMethod": "test ( ) { java . lang . String text = \"\" ; org . apache . lucene . analysis . Analyzer analyzer = new com . github . lucenejapaneseanalyzer . japaneseanalyzer . GoSenAnalyzer ( ) ; org . apache . lucene . analysis . TokenStream ts = analyzer . tokenStream ( \"content\" , new java . io . StringReader ( text ) ) ; org . apache . lucene . analysis . tokenattributes . TermAttribute ta = ts . getAttribute ( org . apache . lucene . analysis . tokenattributes . TermAttribute . class ) ; while ( ts . incrementToken ( ) ) { java . lang . String term = ta . term ( ) ; System . out . println ( term ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( term , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "test ( ) { java . lang . String text = \"\" ; org . apache . lucene . analysis . Analyzer analyzer = new com . github . lucenejapaneseanalyzer . japaneseanalyzer . GoSenAnalyzer ( ) ; org . apache . lucene . analysis . TokenStream ts = analyzer . tokenStream ( \"content\" , new java . io . StringReader ( text ) ) ; org . apache . lucene . analysis . tokenattributes . TermAttribute ta = ts . getAttribute ( org . apache . lucene . analysis . tokenattributes . TermAttribute . class ) ; while ( ts . incrementToken ( ) ) { java . lang . String term = ta . term ( ) ; System . out . println ( term ) ; \"<AssertPlaceHolder>\" ; } } incrementToken ( ) { boolean incrementToken = input . incrementToken ( ) ; if ( incrementToken == false ) return false ; java . lang . String s = termAtt . term ( ) ; int len = s . length ( ) ; if ( ( ( len > 3 ) && ( ( s . charAt ( ( len - 1 ) ) ) == ( com . github . lucenejapaneseanalyzer . japaneseanalyzer . KatakanaStemFilter . KATAKANA_HIRAGANA_PROLONGED_SOUND_MARK ) ) ) && ( isKatakanaString ( s ) ) ) { termAtt . setTermBuffer ( s . substring ( 0 , ( len - 1 ) ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( term , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "remove ( hudson . plugins . tfs . model . Server ) { hudson . plugins . tfs . model . Workspaces workspaces = server . getWorkspaces ( ) ; if ( workspaces . exists ( workspaceName ) ) { hudson . plugins . tfs . model . Workspace workspace = workspaces . getWorkspace ( workspaceName ) ; workspaces . deleteWorkspace ( workspace ) ; return true ; } return false ; }", "testMethod": "assertWorkspaceIsDeleted ( ) { when ( server . getWorkspaces ( ) ) . thenReturn ( workspaces ) ; when ( workspaces . exists ( anyString ( ) ) ) . thenReturn ( true ) ; when ( workspaces . getWorkspace ( anyString ( ) ) ) . thenReturn ( workspace ) ; hudson . plugins . tfs . actions . RemoveWorkspaceAction action = new hudson . plugins . tfs . actions . RemoveWorkspaceAction ( \"workspace\" ) ; \"<AssertPlaceHolder>\" ; verify ( server ) . getWorkspaces ( ) ; verify ( workspaces ) . exists ( \"workspace\" ) ; verify ( workspaces ) . getWorkspace ( \"workspace\" ) ; verify ( workspaces ) . deleteWorkspace ( workspace ) ; verifyNoMoreInteractions ( workspace ) ; verifyNoMoreInteractions ( workspaces ) ; verifyNoMoreInteractions ( server ) ; }", "assertLine": "org . junit . Assert . assertThat ( action . remove ( server ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "assertWorkspaceIsDeleted ( ) { when ( server . getWorkspaces ( ) ) . thenReturn ( workspaces ) ; when ( workspaces . exists ( anyString ( ) ) ) . thenReturn ( true ) ; when ( workspaces . getWorkspace ( anyString ( ) ) ) . thenReturn ( workspace ) ; hudson . plugins . tfs . actions . RemoveWorkspaceAction action = new hudson . plugins . tfs . actions . RemoveWorkspaceAction ( \"workspace\" ) ; \"<AssertPlaceHolder>\" ; verify ( server ) . getWorkspaces ( ) ; verify ( workspaces ) . exists ( \"workspace\" ) ; verify ( workspaces ) . getWorkspace ( \"workspace\" ) ; verify ( workspaces ) . deleteWorkspace ( workspace ) ; verifyNoMoreInteractions ( workspace ) ; verifyNoMoreInteractions ( workspaces ) ; verifyNoMoreInteractions ( server ) ; } remove ( hudson . plugins . tfs . model . Server ) { hudson . plugins . tfs . model . Workspaces workspaces = server . getWorkspaces ( ) ; if ( workspaces . exists ( workspaceName ) ) { hudson . plugins . tfs . model . Workspace workspace = workspaces . getWorkspace ( workspaceName ) ; workspaces . deleteWorkspace ( workspace ) ; return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( action . remove ( server ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "next ( ) { try { java . lang . Object object = input . readObject ( ) ; next = type . cast ( object ) ; canGet = true ; return true ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . io . IOException ( e ) ; } catch ( java . io . EOFException e ) { next = null ; canGet = true ; return false ; } catch ( java . io . OptionalDataException e ) { if ( e . eof ) { next = null ; canGet = true ; return false ; } throw e ; } }", "testMethod": "only_header ( ) { headers = java . util . Arrays . asList ( \"key\" , \"value\" ) ; com . asakusafw . runtime . io . csv . CsvParser parser = create ( \"key,value\\r\\n\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( parser . next ( ) , is ( false ) )", "total": "only_header ( ) { headers = java . util . Arrays . asList ( \"key\" , \"value\" ) ; com . asakusafw . runtime . io . csv . CsvParser parser = create ( \"key,value\\r\\n\" ) ; \"<AssertPlaceHolder>\" ; } next ( ) { try { java . lang . Object object = input . readObject ( ) ; next = type . cast ( object ) ; canGet = true ; return true ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . io . IOException ( e ) ; } catch ( java . io . EOFException e ) { next = null ; canGet = true ; return false ; } catch ( java . io . OptionalDataException e ) { if ( e . eof ) { next = null ; canGet = true ; return false ; } throw e ; } }", "answer": "org . junit . Assert . assertThat ( parser . next ( ) , is ( false ) )"}
{"focal": "put ( org . baeldung . hbase . Admin , org . baeldung . hbase . Table ) { System . out . println ( \"\\n***<sp>PUT<sp>example<sp>~inserting<sp>\\\"cell-data\\\"<sp>into<sp>Family1:Qualifier1<sp>of<sp>Table1<sp>~<sp>***\" ) ; org . baeldung . hbase . Put p = new org . baeldung . hbase . Put ( row1 ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier1 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier2 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; table . put ( p ) ; p = new org . baeldung . hbase . Put ( row2 ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier1 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; p . addImmutable ( family2 . getBytes ( ) , qualifier3 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; table . put ( p ) ; p = new org . baeldung . hbase . Put ( row3 ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier1 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; p . addImmutable ( family2 . getBytes ( ) , qualifier3 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; table . put ( p ) ; admin . disableTable ( table1 ) ; try { org . apache . hadoop . hbase . HColumnDescriptor desc = new org . apache . hadoop . hbase . HColumnDescriptor ( row1 ) ; admin . addColumn ( table1 , desc ) ; System . out . println ( \"Success.\" ) ; } catch ( java . lang . Exception e ) { System . out . println ( \"Failed.\" ) ; System . out . println ( e . getMessage ( ) ) ; } finally { admin . enableTable ( table1 ) ; } System . out . println ( \"Done.<sp>\" ) ; }", "testMethod": "whenGetOrDefault_thenDefaultGot ( ) { java . util . Hashtable < com . baeldung . hashtable . Word , java . lang . String > table = new java . util . Hashtable < com . baeldung . hashtable . Word , java . lang . String > ( ) ; table . put ( new com . baeldung . hashtable . Word ( \"cat\" ) , \"a<sp>small<sp>domesticated<sp>carnivorous<sp>mammal\" ) ; com . baeldung . hashtable . Word key = new com . baeldung . hashtable . Word ( \"dog\" ) ; java . lang . String definition ; definition = table . getOrDefault ( key , \"not<sp>found\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( definition , is ( \"not<sp>found\" ) )", "total": "whenGetOrDefault_thenDefaultGot ( ) { java . util . Hashtable < com . baeldung . hashtable . Word , java . lang . String > table = new java . util . Hashtable < com . baeldung . hashtable . Word , java . lang . String > ( ) ; table . put ( new com . baeldung . hashtable . Word ( \"cat\" ) , \"a<sp>small<sp>domesticated<sp>carnivorous<sp>mammal\" ) ; com . baeldung . hashtable . Word key = new com . baeldung . hashtable . Word ( \"dog\" ) ; java . lang . String definition ; definition = table . getOrDefault ( key , \"not<sp>found\" ) ; \"<AssertPlaceHolder>\" ; } put ( org . baeldung . hbase . Admin , org . baeldung . hbase . Table ) { System . out . println ( \"\\n***<sp>PUT<sp>example<sp>~inserting<sp>\\\"cell-data\\\"<sp>into<sp>Family1:Qualifier1<sp>of<sp>Table1<sp>~<sp>***\" ) ; org . baeldung . hbase . Put p = new org . baeldung . hbase . Put ( row1 ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier1 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier2 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; table . put ( p ) ; p = new org . baeldung . hbase . Put ( row2 ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier1 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; p . addImmutable ( family2 . getBytes ( ) , qualifier3 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; table . put ( p ) ; p = new org . baeldung . hbase . Put ( row3 ) ; p . addImmutable ( family1 . getBytes ( ) , qualifier1 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; p . addImmutable ( family2 . getBytes ( ) , qualifier3 , org . baeldung . hbase . HBaseClientOperations . cellData ) ; table . put ( p ) ; admin . disableTable ( table1 ) ; try { org . apache . hadoop . hbase . HColumnDescriptor desc = new org . apache . hadoop . hbase . HColumnDescriptor ( row1 ) ; admin . addColumn ( table1 , desc ) ; System . out . println ( \"Success.\" ) ; } catch ( java . lang . Exception e ) { System . out . println ( \"Failed.\" ) ; System . out . println ( e . getMessage ( ) ) ; } finally { admin . enableTable ( table1 ) ; } System . out . println ( \"Done.<sp>\" ) ; }", "answer": "org . junit . Assert . assertThat ( definition , is ( \"not<sp>found\" ) )"}
{"focal": "getMissingRomFiles ( java . util . Set ) { java . util . Set < org . tibennetwork . iarcade . mame . SoftwareRomFile > missingRomFiles = new java . util . HashSet ( ) ; softwareFilesLoop : for ( org . tibennetwork . iarcade . mame . SoftwareRomFile file : this . getNeededRomFiles ( ) ) { for ( java . io . File romPath : romPaths ) { java . io . File zippedFileInRomPath = new java . io . File ( ( ( ( romPath . getAbsolutePath ( ) ) + ( java . io . File . separator ) ) + ( file . getZipRelativePath ( ) ) ) ) ; java . io . File sevenZippedFileInRomPath = new java . io . File ( ( ( ( romPath . getAbsolutePath ( ) ) + ( java . io . File . separator ) ) + ( file . getSevenZipRelativePath ( ) ) ) ) ; if ( ( zippedFileInRomPath . exists ( ) ) || ( sevenZippedFileInRomPath . exists ( ) ) ) { continue softwareFilesLoop ; } } missingRomFiles . add ( file ) ; } return missingRomFiles ; }", "testMethod": "testGetMissingRomFileWithEmptyRomPath ( ) { org . tibennetwork . iarcade . mame . FakeMameRuntime mame = new org . tibennetwork . iarcade . mame . FakeMameRuntime ( ) ; java . util . List < java . io . InputStream > inputStreams = new java . util . ArrayList ( ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/sms.xml\" ) ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/sms-sl.xml\" ) ) ; mame . setInputStreamsToReturn ( inputStreams ) ; org . tibennetwork . iarcade . mame . MachineRepository mr = new org . tibennetwork . iarcade . mame . MachineRepository ( mame ) ; org . tibennetwork . iarcade . mame . Machine m = mr . findByName ( \"sms\" ) ; org . tibennetwork . iarcade . mame . SoftwareRepository sr = new org . tibennetwork . iarcade . mame . SoftwareRepository ( mame ) ; org . tibennetwork . iarcade . mame . Software s = sr . findByMachineAndByName ( m , \"columns\" ) ; java . util . Set < java . io . File > romPaths = new java . util . HashSet ( ) ; romPaths . add ( new java . io . File ( \"src/test/resources/empty-rompath\" ) ) ; java . util . Set < org . tibennetwork . iarcade . mame . SoftwareRomFile > missingRomFiles = s . getMissingRomFiles ( romPaths ) ; java . util . Set < org . tibennetwork . iarcade . mame . SoftwareRomFile > expectedMissingRomFiles = new java . util . HashSet ( ) ; expectedMissingRomFiles . add ( new org . tibennetwork . iarcade . mame . SoftwareRomFile ( \"sms\" , \"columns\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( missingRomFiles , org . hamcrest . CoreMatchers . equalTo ( expectedMissingRomFiles ) )", "total": "testGetMissingRomFileWithEmptyRomPath ( ) { org . tibennetwork . iarcade . mame . FakeMameRuntime mame = new org . tibennetwork . iarcade . mame . FakeMameRuntime ( ) ; java . util . List < java . io . InputStream > inputStreams = new java . util . ArrayList ( ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/sms.xml\" ) ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/sms-sl.xml\" ) ) ; mame . setInputStreamsToReturn ( inputStreams ) ; org . tibennetwork . iarcade . mame . MachineRepository mr = new org . tibennetwork . iarcade . mame . MachineRepository ( mame ) ; org . tibennetwork . iarcade . mame . Machine m = mr . findByName ( \"sms\" ) ; org . tibennetwork . iarcade . mame . SoftwareRepository sr = new org . tibennetwork . iarcade . mame . SoftwareRepository ( mame ) ; org . tibennetwork . iarcade . mame . Software s = sr . findByMachineAndByName ( m , \"columns\" ) ; java . util . Set < java . io . File > romPaths = new java . util . HashSet ( ) ; romPaths . add ( new java . io . File ( \"src/test/resources/empty-rompath\" ) ) ; java . util . Set < org . tibennetwork . iarcade . mame . SoftwareRomFile > missingRomFiles = s . getMissingRomFiles ( romPaths ) ; java . util . Set < org . tibennetwork . iarcade . mame . SoftwareRomFile > expectedMissingRomFiles = new java . util . HashSet ( ) ; expectedMissingRomFiles . add ( new org . tibennetwork . iarcade . mame . SoftwareRomFile ( \"sms\" , \"columns\" ) ) ; \"<AssertPlaceHolder>\" ; } getMissingRomFiles ( java . util . Set ) { java . util . Set < org . tibennetwork . iarcade . mame . SoftwareRomFile > missingRomFiles = new java . util . HashSet ( ) ; softwareFilesLoop : for ( org . tibennetwork . iarcade . mame . SoftwareRomFile file : this . getNeededRomFiles ( ) ) { for ( java . io . File romPath : romPaths ) { java . io . File zippedFileInRomPath = new java . io . File ( ( ( ( romPath . getAbsolutePath ( ) ) + ( java . io . File . separator ) ) + ( file . getZipRelativePath ( ) ) ) ) ; java . io . File sevenZippedFileInRomPath = new java . io . File ( ( ( ( romPath . getAbsolutePath ( ) ) + ( java . io . File . separator ) ) + ( file . getSevenZipRelativePath ( ) ) ) ) ; if ( ( zippedFileInRomPath . exists ( ) ) || ( sevenZippedFileInRomPath . exists ( ) ) ) { continue softwareFilesLoop ; } } missingRomFiles . add ( file ) ; } return missingRomFiles ; }", "answer": "org . junit . Assert . assertThat ( missingRomFiles , org . hamcrest . CoreMatchers . equalTo ( expectedMissingRomFiles ) )"}
{"focal": "getLoanOfficerList ( ) { return this . loanOfficerList ; }", "testMethod": "shouldPopulateDtoWithLoanOfficersWhenOnlyOneActiveBranchExists ( ) { final java . lang . Short branchId = userContext . getBranchId ( ) ; final java . lang . Short levelId = OfficeLevel . BRANCHOFFICE . getValue ( ) ; org . mifos . dto . domain . OfficeDetailsDto officeStub1 = new org . mifos . dto . domain . OfficeDetailsDto ( branchId , \"branchName1\" , levelId , java . lang . Integer . valueOf ( 1 ) ) ; java . util . List < org . mifos . dto . domain . OfficeDetailsDto > onlyOneActiveBranch = java . util . Arrays . asList ( officeStub1 ) ; final org . mifos . dto . domain . PersonnelDto loanOfficer1 = new org . mifos . dto . domain . PersonnelDto ( java . lang . Short . valueOf ( \"1\" ) , \"LoanOfficer1\" ) ; final org . mifos . dto . domain . PersonnelDto loanOfficer2 = new org . mifos . dto . domain . PersonnelDto ( java . lang . Short . valueOf ( \"2\" ) , \"LoanOfficer2\" ) ; java . util . List < org . mifos . dto . domain . PersonnelDto > loanOfficers = java . util . Arrays . asList ( loanOfficer1 , loanOfficer2 ) ; when ( officePersistence . getActiveOffices ( branchId ) ) . thenReturn ( onlyOneActiveBranch ) ; when ( personnelPersistence . getActiveLoanOfficersInBranch ( PersonnelConstants . LOAN_OFFICER , branchId , userContext . getId ( ) , userContext . getLevelId ( ) ) ) . thenReturn ( loanOfficers ) ; org . mifos . application . servicefacade . CollectionSheetEntryFormDto formDto = collectionSheetServiceFacadeWebTier . loadAllActiveBranchesAndSubsequentDataIfApplicable ( userContext ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( formDto . getLoanOfficerList ( ) , org . hamcrest . CoreMatchers . is ( loanOfficers ) )", "total": "shouldPopulateDtoWithLoanOfficersWhenOnlyOneActiveBranchExists ( ) { final java . lang . Short branchId = userContext . getBranchId ( ) ; final java . lang . Short levelId = OfficeLevel . BRANCHOFFICE . getValue ( ) ; org . mifos . dto . domain . OfficeDetailsDto officeStub1 = new org . mifos . dto . domain . OfficeDetailsDto ( branchId , \"branchName1\" , levelId , java . lang . Integer . valueOf ( 1 ) ) ; java . util . List < org . mifos . dto . domain . OfficeDetailsDto > onlyOneActiveBranch = java . util . Arrays . asList ( officeStub1 ) ; final org . mifos . dto . domain . PersonnelDto loanOfficer1 = new org . mifos . dto . domain . PersonnelDto ( java . lang . Short . valueOf ( \"1\" ) , \"LoanOfficer1\" ) ; final org . mifos . dto . domain . PersonnelDto loanOfficer2 = new org . mifos . dto . domain . PersonnelDto ( java . lang . Short . valueOf ( \"2\" ) , \"LoanOfficer2\" ) ; java . util . List < org . mifos . dto . domain . PersonnelDto > loanOfficers = java . util . Arrays . asList ( loanOfficer1 , loanOfficer2 ) ; when ( officePersistence . getActiveOffices ( branchId ) ) . thenReturn ( onlyOneActiveBranch ) ; when ( personnelPersistence . getActiveLoanOfficersInBranch ( PersonnelConstants . LOAN_OFFICER , branchId , userContext . getId ( ) , userContext . getLevelId ( ) ) ) . thenReturn ( loanOfficers ) ; org . mifos . application . servicefacade . CollectionSheetEntryFormDto formDto = collectionSheetServiceFacadeWebTier . loadAllActiveBranchesAndSubsequentDataIfApplicable ( userContext ) ; \"<AssertPlaceHolder>\" ; } getLoanOfficerList ( ) { return this . loanOfficerList ; }", "answer": "org . junit . Assert . assertThat ( formDto . getLoanOfficerList ( ) , org . hamcrest . CoreMatchers . is ( loanOfficers ) )"}
{"focal": "allows ( org . jenkinsci . plugins . postbuildscript . model . PostBuildItem , boolean ) { java . util . Optional < hudson . model . Result > result = java . util . Optional . ofNullable ( build . getResult ( ) ) ; return ( result . isPresent ( ) ) && ( item . shouldBeExecuted ( result . get ( ) . toString ( ) ) ) ; }", "testMethod": "deniesRunningOnMasterWhenBuiltStrIsDefined ( ) { given ( build . getBuiltOnStr ( ) ) . willReturn ( \"builtOnStr\" ) ; given ( item . shouldRunOnSlave ( ) ) . willReturn ( false ) ; boolean actual = roleRule . allows ( item , true ) ; \"<AssertPlaceHolder>\" ; verify ( item , never ( ) ) . shouldRunOnMaster ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( false ) )", "total": "deniesRunningOnMasterWhenBuiltStrIsDefined ( ) { given ( build . getBuiltOnStr ( ) ) . willReturn ( \"builtOnStr\" ) ; given ( item . shouldRunOnSlave ( ) ) . willReturn ( false ) ; boolean actual = roleRule . allows ( item , true ) ; \"<AssertPlaceHolder>\" ; verify ( item , never ( ) ) . shouldRunOnMaster ( ) ; } allows ( org . jenkinsci . plugins . postbuildscript . model . PostBuildItem , boolean ) { java . util . Optional < hudson . model . Result > result = java . util . Optional . ofNullable ( build . getResult ( ) ) ; return ( result . isPresent ( ) ) && ( item . shouldBeExecuted ( result . get ( ) . toString ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getTitle ( ) { return title ; }", "testMethod": "titleShouldBeReturned ( ) { when ( locale . runnerTitle ( ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . manager . RunnerManagerPresenterTest . TEXT ) ; presenter . getTitle ( ) ; verify ( locale ) . runnerTitle ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( presenter . getTitle ( ) , org . hamcrest . core . Is . is ( org . eclipse . che . ide . ext . runner . client . manager . RunnerManagerPresenterTest . TEXT ) )", "total": "titleShouldBeReturned ( ) { when ( locale . runnerTitle ( ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . manager . RunnerManagerPresenterTest . TEXT ) ; presenter . getTitle ( ) ; verify ( locale ) . runnerTitle ( ) ; \"<AssertPlaceHolder>\" ; } getTitle ( ) { return title ; }", "answer": "org . junit . Assert . assertThat ( presenter . getTitle ( ) , org . hamcrest . core . Is . is ( org . eclipse . che . ide . ext . runner . client . manager . RunnerManagerPresenterTest . TEXT ) )"}
{"focal": "constraints ( ) { return constraints ; }", "testMethod": "givenInvalidConstraintInConfigShouldBeParsed ( ) { org . apache . flink . mesos . runtime . clusterframework . MesosTaskManagerParameters mesosTaskManagerParameters = org . apache . flink . mesos . runtime . clusterframework . MesosTaskManagerParameters . create ( org . apache . flink . mesos . runtime . clusterframework . MesosTaskManagerParametersTest . withHardHostAttrConstraintConfiguration ( \",:,\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mesosTaskManagerParameters . constraints ( ) . size ( ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "givenInvalidConstraintInConfigShouldBeParsed ( ) { org . apache . flink . mesos . runtime . clusterframework . MesosTaskManagerParameters mesosTaskManagerParameters = org . apache . flink . mesos . runtime . clusterframework . MesosTaskManagerParameters . create ( org . apache . flink . mesos . runtime . clusterframework . MesosTaskManagerParametersTest . withHardHostAttrConstraintConfiguration ( \",:,\" ) ) ; \"<AssertPlaceHolder>\" ; } constraints ( ) { return constraints ; }", "answer": "org . junit . Assert . assertThat ( mesosTaskManagerParameters . constraints ( ) . size ( ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"save<sp>\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"save<sp>\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "toString ( ) { if ( ( ( resourceId ) != null ) && ( ( externalId ) != null ) ) { return ( ( ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \",<sp>externalId:<sp>\\\"\" ) + ( externalId ) ) + \"\\\"}\" ; } if ( ( resourceId ) != null ) { return ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \"}\" ; } if ( ( externalId ) != null ) { return ( \"{externalId:<sp>\\\"\" + ( externalId ) ) + \"\\\"}\" ; } return \"{}\" ; }", "testMethod": "toString_systemPermission ( ) { for ( java . lang . String systemPermissionName : com . acciente . oacc . ResourcePermissions . getSysPermissionNames ( ) ) { final com . acciente . oacc . ResourcePermission resourcePermission = com . acciente . oacc . ResourcePermissions . getInstance ( systemPermissionName ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( resourcePermission . toString ( ) , org . hamcrest . CoreMatchers . is ( systemPermissionName ) )", "total": "toString_systemPermission ( ) { for ( java . lang . String systemPermissionName : com . acciente . oacc . ResourcePermissions . getSysPermissionNames ( ) ) { final com . acciente . oacc . ResourcePermission resourcePermission = com . acciente . oacc . ResourcePermissions . getInstance ( systemPermissionName ) ; \"<AssertPlaceHolder>\" ; } } toString ( ) { if ( ( ( resourceId ) != null ) && ( ( externalId ) != null ) ) { return ( ( ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \",<sp>externalId:<sp>\\\"\" ) + ( externalId ) ) + \"\\\"}\" ; } if ( ( resourceId ) != null ) { return ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \"}\" ; } if ( ( externalId ) != null ) { return ( \"{externalId:<sp>\\\"\" + ( externalId ) ) + \"\\\"}\" ; } return \"{}\" ; }", "answer": "org . junit . Assert . assertThat ( resourcePermission . toString ( ) , org . hamcrest . CoreMatchers . is ( systemPermissionName ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter4 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"display<sp>properties<sp>?\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter4 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"display<sp>properties<sp>?\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "getMaxRows ( ) { notClosed ( ) ; return ( rowLimit ) == ( - 1 ) ? 0 : rowLimit ; }", "testMethod": "shouldReturnDefaultForMaxRows ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( stmt . getMaxRows ( ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "shouldReturnDefaultForMaxRows ( ) { \"<AssertPlaceHolder>\" ; } getMaxRows ( ) { notClosed ( ) ; return ( rowLimit ) == ( - 1 ) ? 0 : rowLimit ; }", "answer": "org . junit . Assert . assertThat ( stmt . getMaxRows ( ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "getTokenList ( ) { java . util . List < annis . service . ifaces . AnnisToken > result = new java . util . ArrayList < annis . service . ifaces . AnnisToken > ( ) ; for ( annis . model . AnnisNode node : graph . getTokens ( ) ) { annis . service . objects . AnnisTokenImpl annisToken = new annis . service . objects . AnnisTokenImpl ( node . getId ( ) , node . getSpannedText ( ) , node . getLeft ( ) , node . getRight ( ) , node . getTokenIndex ( ) , node . getCorpus ( ) ) ; for ( annis . model . Annotation annotation : node . getNodeAnnotations ( ) ) { annisToken . put ( annotation . getQualifiedName ( ) , annotation . getValue ( ) ) ; } result . add ( annisToken ) ; } return result ; }", "testMethod": "getTokenList ( ) { java . util . List < annis . service . ifaces . AnnisToken > expected = new java . util . ArrayList ( ) ; expected . add ( new annis . service . objects . AnnisTokenImpl ( annis . service . objects . TestAnnisResultImpl . ID1 , annis . service . objects . TestAnnisResultImpl . TEXT1 , annis . service . objects . TestAnnisResultImpl . LEFT , annis . service . objects . TestAnnisResultImpl . RIGHT , annis . service . objects . TestAnnisResultImpl . TOKEN_INDEX1 , 1L ) ) ; expected . add ( new annis . service . objects . AnnisTokenImpl ( annis . service . objects . TestAnnisResultImpl . ID2 , annis . service . objects . TestAnnisResultImpl . TEXT2 , annis . service . objects . TestAnnisResultImpl . LEFT , annis . service . objects . TestAnnisResultImpl . RIGHT , annis . service . objects . TestAnnisResultImpl . TOKEN_INDEX2 , 1L ) ) ; expected . add ( new annis . service . objects . AnnisTokenImpl ( annis . service . objects . TestAnnisResultImpl . ID3 , annis . service . objects . TestAnnisResultImpl . TEXT3 , annis . service . objects . TestAnnisResultImpl . LEFT , annis . service . objects . TestAnnisResultImpl . RIGHT , annis . service . objects . TestAnnisResultImpl . TOKEN_INDEX3 , 1L ) ) ; annis . service . ifaces . AnnisResult annisResult = new annis . service . objects . AnnisResultImpl ( graph ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( annisResult . getTokenList ( ) , org . hamcrest . Matchers . is ( expected ) )", "total": "getTokenList ( ) { java . util . List < annis . service . ifaces . AnnisToken > expected = new java . util . ArrayList ( ) ; expected . add ( new annis . service . objects . AnnisTokenImpl ( annis . service . objects . TestAnnisResultImpl . ID1 , annis . service . objects . TestAnnisResultImpl . TEXT1 , annis . service . objects . TestAnnisResultImpl . LEFT , annis . service . objects . TestAnnisResultImpl . RIGHT , annis . service . objects . TestAnnisResultImpl . TOKEN_INDEX1 , 1L ) ) ; expected . add ( new annis . service . objects . AnnisTokenImpl ( annis . service . objects . TestAnnisResultImpl . ID2 , annis . service . objects . TestAnnisResultImpl . TEXT2 , annis . service . objects . TestAnnisResultImpl . LEFT , annis . service . objects . TestAnnisResultImpl . RIGHT , annis . service . objects . TestAnnisResultImpl . TOKEN_INDEX2 , 1L ) ) ; expected . add ( new annis . service . objects . AnnisTokenImpl ( annis . service . objects . TestAnnisResultImpl . ID3 , annis . service . objects . TestAnnisResultImpl . TEXT3 , annis . service . objects . TestAnnisResultImpl . LEFT , annis . service . objects . TestAnnisResultImpl . RIGHT , annis . service . objects . TestAnnisResultImpl . TOKEN_INDEX3 , 1L ) ) ; annis . service . ifaces . AnnisResult annisResult = new annis . service . objects . AnnisResultImpl ( graph ) ; \"<AssertPlaceHolder>\" ; } getTokenList ( ) { java . util . List < annis . service . ifaces . AnnisToken > result = new java . util . ArrayList < annis . service . ifaces . AnnisToken > ( ) ; for ( annis . model . AnnisNode node : graph . getTokens ( ) ) { annis . service . objects . AnnisTokenImpl annisToken = new annis . service . objects . AnnisTokenImpl ( node . getId ( ) , node . getSpannedText ( ) , node . getLeft ( ) , node . getRight ( ) , node . getTokenIndex ( ) , node . getCorpus ( ) ) ; for ( annis . model . Annotation annotation : node . getNodeAnnotations ( ) ) { annisToken . put ( annotation . getQualifiedName ( ) , annotation . getValue ( ) ) ; } result . add ( annisToken ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( annisResult . getTokenList ( ) , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "activeInterfaces ( ) { return _interfaces . values ( ) . stream ( ) . filter ( Interface :: getActive ) . map ( Interface :: getName ) . collect ( com . google . common . collect . ImmutableSet . toImmutableSet ( ) ) ; }", "testMethod": "testNotIgnoredManagementInterfaces ( ) { java . lang . String notIgnored = \"notIgnored\" ; java . lang . String notIgnored2 = \"them0\" ; java . lang . String notIgnored3 = \"mgt-me0\" ; java . lang . String notIgnored4 = \"manage\" ; java . lang . String notIgnored5 = \"Afxp0\" ; java . util . Map < java . lang . String , org . batfish . datamodel . Configuration > configs = new java . util . HashMap ( ) ; org . batfish . datamodel . Configuration config1 = org . batfish . main . BatfishTestUtils . createTestConfiguration ( \"config1\" , ConfigurationFormat . HOST , notIgnored , notIgnored2 , notIgnored3 , notIgnored4 , notIgnored5 ) ; config1 . getAllInterfaces ( ) . get ( notIgnored ) . setVrfName ( \"vrf-mgmt\" ) ; config1 . getAllInterfaces ( ) . get ( notIgnored2 ) . setVrfName ( \"Manageme\" ) ; config1 . getAllInterfaces ( ) . get ( notIgnored3 ) . setVrfName ( \"fxp0\" ) ; configs . put ( \"config1\" , config1 ) ; org . batfish . main . Batfish . processManagementInterfaces ( configs ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( config1 . activeInterfaces ( ) , org . hamcrest . Matchers . equalTo ( com . google . common . collect . ImmutableSet . of ( notIgnored , notIgnored2 , notIgnored3 , notIgnored4 , notIgnored5 ) ) )", "total": "testNotIgnoredManagementInterfaces ( ) { java . lang . String notIgnored = \"notIgnored\" ; java . lang . String notIgnored2 = \"them0\" ; java . lang . String notIgnored3 = \"mgt-me0\" ; java . lang . String notIgnored4 = \"manage\" ; java . lang . String notIgnored5 = \"Afxp0\" ; java . util . Map < java . lang . String , org . batfish . datamodel . Configuration > configs = new java . util . HashMap ( ) ; org . batfish . datamodel . Configuration config1 = org . batfish . main . BatfishTestUtils . createTestConfiguration ( \"config1\" , ConfigurationFormat . HOST , notIgnored , notIgnored2 , notIgnored3 , notIgnored4 , notIgnored5 ) ; config1 . getAllInterfaces ( ) . get ( notIgnored ) . setVrfName ( \"vrf-mgmt\" ) ; config1 . getAllInterfaces ( ) . get ( notIgnored2 ) . setVrfName ( \"Manageme\" ) ; config1 . getAllInterfaces ( ) . get ( notIgnored3 ) . setVrfName ( \"fxp0\" ) ; configs . put ( \"config1\" , config1 ) ; org . batfish . main . Batfish . processManagementInterfaces ( configs ) ; \"<AssertPlaceHolder>\" ; } activeInterfaces ( ) { return _interfaces . values ( ) . stream ( ) . filter ( Interface :: getActive ) . map ( Interface :: getName ) . collect ( com . google . common . collect . ImmutableSet . toImmutableSet ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( config1 . activeInterfaces ( ) , org . hamcrest . Matchers . equalTo ( com . google . common . collect . ImmutableSet . of ( notIgnored , notIgnored2 , notIgnored3 , notIgnored4 , notIgnored5 ) ) )"}
{"focal": "size ( ) { return ( ( ( historicProcessInstanceIds . size ( ) ) + ( historicDecisionInstanceIds . size ( ) ) ) + ( historicCaseInstanceIds . size ( ) ) ) + ( historicBatchIds . size ( ) ) ; }", "testMethod": "providerCalledForProcessDefinitionWithoutTenantId ( ) { org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . ContextLoggingTenantIdProvider tenantIdProvider = new org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . ContextLoggingTenantIdProvider ( ) ; org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . TestTenantIdProvider . delegate = tenantIdProvider ; testRule . deploy ( org . camunda . bpm . model . bpmn . Bpmn . createExecutableProcess ( org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . PROCESS_DEFINITION_KEY ) . startEvent ( ) . done ( ) ) ; engineRule . getRuntimeService ( ) . startProcessInstanceByKey ( org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . PROCESS_DEFINITION_KEY ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tenantIdProvider . parameters . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "providerCalledForProcessDefinitionWithoutTenantId ( ) { org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . ContextLoggingTenantIdProvider tenantIdProvider = new org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . ContextLoggingTenantIdProvider ( ) ; org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . TestTenantIdProvider . delegate = tenantIdProvider ; testRule . deploy ( org . camunda . bpm . model . bpmn . Bpmn . createExecutableProcess ( org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . PROCESS_DEFINITION_KEY ) . startEvent ( ) . done ( ) ) ; engineRule . getRuntimeService ( ) . startProcessInstanceByKey ( org . camunda . bpm . engine . test . api . multitenancy . TenantIdProviderTest . PROCESS_DEFINITION_KEY ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return ( ( ( historicProcessInstanceIds . size ( ) ) + ( historicDecisionInstanceIds . size ( ) ) ) + ( historicCaseInstanceIds . size ( ) ) ) + ( historicBatchIds . size ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( tenantIdProvider . parameters . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "isNotificationEnabled ( ) { org . junit . Assert . assertThat ( helper . isNotificationEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) ) ; verify ( eventNotificationHandler ) . isNotificationEnabled ( org . mule . runtime . core . api . context . notification . NotificationHelperTestCase . TestServerNotification . class ) ; }", "testMethod": "isNotificationEnabled ( ) { \"<AssertPlaceHolder>\" ; verify ( eventNotificationHandler ) . isNotificationEnabled ( org . mule . runtime . core . api . context . notification . NotificationHelperTestCase . TestServerNotification . class ) ; }", "assertLine": "org . junit . Assert . assertThat ( helper . isNotificationEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "isNotificationEnabled ( ) { \"<AssertPlaceHolder>\" ; verify ( eventNotificationHandler ) . isNotificationEnabled ( org . mule . runtime . core . api . context . notification . NotificationHelperTestCase . TestServerNotification . class ) ; } isNotificationEnabled ( ) { org . junit . Assert . assertThat ( helper . isNotificationEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) ) ; verify ( eventNotificationHandler ) . isNotificationEnabled ( org . mule . runtime . core . api . context . notification . NotificationHelperTestCase . TestServerNotification . class ) ; }", "answer": "org . junit . Assert . assertThat ( helper . isNotificationEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "readActiveState ( com . spotify . styx . model . WorkflowInstance ) { final com . google . cloud . datastore . Entity entity = datastore . get ( activeWorkflowInstanceKey ( instance ) ) ; if ( entity == null ) { return java . util . Optional . empty ( ) ; } else { return java . util . Optional . of ( com . spotify . styx . storage . DatastoreStorage . entityToRunState ( entity , instance ) ) ; } }", "testMethod": "shouldInsertActiveState ( ) { com . spotify . styx . storage . DatastoreStorageTransaction tx = new com . spotify . styx . storage . DatastoreStorageTransaction ( com . spotify . styx . storage . DatastoreStorageTransactionTest . datastore . newTransaction ( ) ) ; tx . writeActiveState ( com . spotify . styx . storage . DatastoreStorageTest . WORKFLOW_INSTANCE1 , com . spotify . styx . storage . DatastoreStorageTest . RUN_STATE ) ; tx . commit ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( storage . readActiveState ( com . spotify . styx . storage . DatastoreStorageTest . WORKFLOW_INSTANCE1 ) , org . hamcrest . Matchers . is ( java . util . Optional . of ( com . spotify . styx . storage . DatastoreStorageTest . RUN_STATE ) ) )", "total": "shouldInsertActiveState ( ) { com . spotify . styx . storage . DatastoreStorageTransaction tx = new com . spotify . styx . storage . DatastoreStorageTransaction ( com . spotify . styx . storage . DatastoreStorageTransactionTest . datastore . newTransaction ( ) ) ; tx . writeActiveState ( com . spotify . styx . storage . DatastoreStorageTest . WORKFLOW_INSTANCE1 , com . spotify . styx . storage . DatastoreStorageTest . RUN_STATE ) ; tx . commit ( ) ; \"<AssertPlaceHolder>\" ; } readActiveState ( com . spotify . styx . model . WorkflowInstance ) { final com . google . cloud . datastore . Entity entity = datastore . get ( activeWorkflowInstanceKey ( instance ) ) ; if ( entity == null ) { return java . util . Optional . empty ( ) ; } else { return java . util . Optional . of ( com . spotify . styx . storage . DatastoreStorage . entityToRunState ( entity , instance ) ) ; } }", "answer": "org . junit . Assert . assertThat ( storage . readActiveState ( com . spotify . styx . storage . DatastoreStorageTest . WORKFLOW_INSTANCE1 ) , org . hamcrest . Matchers . is ( java . util . Optional . of ( com . spotify . styx . storage . DatastoreStorageTest . RUN_STATE ) ) )"}
{"focal": "minus ( net . time4j . engine . CalendarDays ) { return this . plus ( net . time4j . engine . CalendarDays . of ( java . lang . Math . negateExact ( days . getAmount ( ) ) ) ) ; }", "testMethod": "assertYearsMonthsDaysWeakInvariant_T2_Minus_T1UntilT2_Eq_T1 ( ) { if ( ( this . start . getDayOfMonth ( ) ) <= 28 ) { net . time4j . Duration < net . time4j . CalendarUnit > period = this . start . until ( this . end , net . time4j . Duration . in ( net . time4j . CalendarUnit . YEARS , net . time4j . CalendarUnit . MONTHS , net . time4j . CalendarUnit . DAYS ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( this . end . minus ( period ) , org . hamcrest . CoreMatchers . is ( this . start ) )", "total": "assertYearsMonthsDaysWeakInvariant_T2_Minus_T1UntilT2_Eq_T1 ( ) { if ( ( this . start . getDayOfMonth ( ) ) <= 28 ) { net . time4j . Duration < net . time4j . CalendarUnit > period = this . start . until ( this . end , net . time4j . Duration . in ( net . time4j . CalendarUnit . YEARS , net . time4j . CalendarUnit . MONTHS , net . time4j . CalendarUnit . DAYS ) ) ; \"<AssertPlaceHolder>\" ; } } minus ( net . time4j . engine . CalendarDays ) { return this . plus ( net . time4j . engine . CalendarDays . of ( java . lang . Math . negateExact ( days . getAmount ( ) ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( this . end . minus ( period ) , org . hamcrest . CoreMatchers . is ( this . start ) )"}
{"focal": "greaterThan ( java . lang . String ) { myEqualsComparison = null ; myOtherComparisons . put ( ComparisonOperator . GT , new com . allanbank . mongodb . bson . element . StringElement ( ComparisonOperator . GT . getToken ( ) , value ) ) ; return this ; }", "testMethod": "testListCollectionsOnSecondary ( ) { final int numCollections = 1000 ; com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > docsIter = null ; myCollection . insert ( Durability . ACK , com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) . build ( ) ) ; for ( int i = 0 ; i < numCollections ; ++ i ) { myDb . getCollection ( ( \"listCollections_\" + i ) ) . insert ( Durability . ACK , com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ) ; } try { docsIter = myDb . listCollections ( com . allanbank . mongodb . builder . ListCollections . builder ( ) . readPreference ( ReadPreference . PREFER_SECONDARY ) ) ; int count = 0 ; while ( docsIter . hasNext ( ) ) { docsIter . next ( ) ; count += 1 ; } \"<AssertPlaceHolder>\" ; } finally { com . allanbank . mongodb . util . IOUtils . close ( docsIter ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { myDb . getCollection ( ( \"listCollections_\" + i ) ) . drop ( ) ; } } }", "assertLine": "org . junit . Assert . assertThat ( count , org . hamcrest . Matchers . greaterThan ( ( numCollections + 1 ) ) )", "total": "testListCollectionsOnSecondary ( ) { final int numCollections = 1000 ; com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > docsIter = null ; myCollection . insert ( Durability . ACK , com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) . build ( ) ) ; for ( int i = 0 ; i < numCollections ; ++ i ) { myDb . getCollection ( ( \"listCollections_\" + i ) ) . insert ( Durability . ACK , com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ) ; } try { docsIter = myDb . listCollections ( com . allanbank . mongodb . builder . ListCollections . builder ( ) . readPreference ( ReadPreference . PREFER_SECONDARY ) ) ; int count = 0 ; while ( docsIter . hasNext ( ) ) { docsIter . next ( ) ; count += 1 ; } \"<AssertPlaceHolder>\" ; } finally { com . allanbank . mongodb . util . IOUtils . close ( docsIter ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { myDb . getCollection ( ( \"listCollections_\" + i ) ) . drop ( ) ; } } } greaterThan ( java . lang . String ) { myEqualsComparison = null ; myOtherComparisons . put ( ComparisonOperator . GT , new com . allanbank . mongodb . bson . element . StringElement ( ComparisonOperator . GT . getToken ( ) , value ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( count , org . hamcrest . Matchers . greaterThan ( ( numCollections + 1 ) ) )"}
{"focal": "hasErrors ( ) { return ! ( errorEntries . isEmpty ( ) ) ; }", "testMethod": "validateShouldCallFormatListOfAndRulesValidators ( ) { org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment1 = installmentBuilder . reset ( locale ) . withInstallment ( 1 ) . withDueDateValue ( \"01-Nov-2010\" ) . build ( ) ; org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment2 = installmentBuilder . reset ( locale ) . withInstallment ( 2 ) . withDueDateValue ( \"06-Nov-2010\" ) . build ( ) ; org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment3 = installmentBuilder . reset ( locale ) . withInstallment ( 3 ) . withDueDateValue ( \"08-Nov-2010\" ) . build ( ) ; java . util . List < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > installments = asList ( installment1 , installment2 , installment3 ) ; org . mifos . platform . validations . Errors errors = installmentsValidator . validateInputInstallments ( installments , getValidationContext ( null ) ) ; for ( org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment : installments ) { verify ( installmentFormatValidator ) . validateDueDateFormat ( installment ) ; verify ( installmentFormatValidator ) . validateTotalAmountFormat ( installment ) ; } verify ( listOfInstallmentsValidator ) . validateDuplicateDueDates ( installments ) ; verify ( listOfInstallmentsValidator ) . validateOrderingOfDueDates ( installments ) ; verify ( installmentRulesValidator ) . validateForDisbursementDate ( eq ( installments ) , any ( java . util . Date . class ) ) ; verify ( installmentRulesValidator ) . validateDueDatesForVariableInstallments ( eq ( installments ) , any ( org . mifos . accounts . productdefinition . business . VariableInstallmentDetailsBO . class ) , any ( java . util . Date . class ) ) ; verify ( installmentRulesValidator ) . validateForHolidays ( eq ( installments ) , any ( org . mifos . application . admin . servicefacade . HolidayServiceFacade . class ) , eq ( officeId ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( errors . hasErrors ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "validateShouldCallFormatListOfAndRulesValidators ( ) { org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment1 = installmentBuilder . reset ( locale ) . withInstallment ( 1 ) . withDueDateValue ( \"01-Nov-2010\" ) . build ( ) ; org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment2 = installmentBuilder . reset ( locale ) . withInstallment ( 2 ) . withDueDateValue ( \"06-Nov-2010\" ) . build ( ) ; org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment3 = installmentBuilder . reset ( locale ) . withInstallment ( 3 ) . withDueDateValue ( \"08-Nov-2010\" ) . build ( ) ; java . util . List < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > installments = asList ( installment1 , installment2 , installment3 ) ; org . mifos . platform . validations . Errors errors = installmentsValidator . validateInputInstallments ( installments , getValidationContext ( null ) ) ; for ( org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment : installments ) { verify ( installmentFormatValidator ) . validateDueDateFormat ( installment ) ; verify ( installmentFormatValidator ) . validateTotalAmountFormat ( installment ) ; } verify ( listOfInstallmentsValidator ) . validateDuplicateDueDates ( installments ) ; verify ( listOfInstallmentsValidator ) . validateOrderingOfDueDates ( installments ) ; verify ( installmentRulesValidator ) . validateForDisbursementDate ( eq ( installments ) , any ( java . util . Date . class ) ) ; verify ( installmentRulesValidator ) . validateDueDatesForVariableInstallments ( eq ( installments ) , any ( org . mifos . accounts . productdefinition . business . VariableInstallmentDetailsBO . class ) , any ( java . util . Date . class ) ) ; verify ( installmentRulesValidator ) . validateForHolidays ( eq ( installments ) , any ( org . mifos . application . admin . servicefacade . HolidayServiceFacade . class ) , eq ( officeId ) ) ; \"<AssertPlaceHolder>\" ; } hasErrors ( ) { return ! ( errorEntries . isEmpty ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( errors . hasErrors ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getRevision ( jenkins . scm . api . SCMSource , hudson . model . Actionable ) { java . lang . String sourceId = source . getId ( ) ; jenkins . scm . api . SCMRevisionAction fallback = null ; for ( jenkins . scm . api . SCMRevisionAction a : actionable . getActions ( jenkins . scm . api . SCMRevisionAction . class ) ) { if ( sourceId . equals ( a . getSourceId ( ) ) ) { return a . getRevision ( ) ; } if ( ( ( a . getSourceId ( ) ) == null ) && ( fallback == null ) ) { fallback = a ; } } return fallback == null ? null : fallback . getRevision ( ) ; }", "testMethod": "given__legacyData__when__gettingRevision__then__legacyReturned ( ) { try ( jenkins . scm . impl . mock . MockSCMController c = jenkins . scm . impl . mock . MockSCMController . create ( ) ) { jenkins . scm . impl . mock . MockSCMSource source = new jenkins . scm . impl . mock . MockSCMSource ( c , \"test\" , new jenkins . scm . impl . mock . MockSCMDiscoverBranches ( ) ) ; jenkins . scm . api . SCMRevision revision = new jenkins . scm . impl . mock . MockSCMRevision ( new jenkins . scm . impl . mock . MockSCMHead ( \"head\" ) , \"hash\" ) ; hudson . model . Actionable a = new jenkins . scm . api . SCMRevisionActionTest . ActionableImpl ( ) ; a . addAction ( new jenkins . scm . api . SCMRevisionAction ( revision , null ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( jenkins . scm . api . SCMRevisionAction . getRevision ( source , a ) , org . hamcrest . Matchers . is ( revision ) )", "total": "given__legacyData__when__gettingRevision__then__legacyReturned ( ) { try ( jenkins . scm . impl . mock . MockSCMController c = jenkins . scm . impl . mock . MockSCMController . create ( ) ) { jenkins . scm . impl . mock . MockSCMSource source = new jenkins . scm . impl . mock . MockSCMSource ( c , \"test\" , new jenkins . scm . impl . mock . MockSCMDiscoverBranches ( ) ) ; jenkins . scm . api . SCMRevision revision = new jenkins . scm . impl . mock . MockSCMRevision ( new jenkins . scm . impl . mock . MockSCMHead ( \"head\" ) , \"hash\" ) ; hudson . model . Actionable a = new jenkins . scm . api . SCMRevisionActionTest . ActionableImpl ( ) ; a . addAction ( new jenkins . scm . api . SCMRevisionAction ( revision , null ) ) ; \"<AssertPlaceHolder>\" ; } } getRevision ( jenkins . scm . api . SCMSource , hudson . model . Actionable ) { java . lang . String sourceId = source . getId ( ) ; jenkins . scm . api . SCMRevisionAction fallback = null ; for ( jenkins . scm . api . SCMRevisionAction a : actionable . getActions ( jenkins . scm . api . SCMRevisionAction . class ) ) { if ( sourceId . equals ( a . getSourceId ( ) ) ) { return a . getRevision ( ) ; } if ( ( ( a . getSourceId ( ) ) == null ) && ( fallback == null ) ) { fallback = a ; } } return fallback == null ? null : fallback . getRevision ( ) ; }", "answer": "org . junit . Assert . assertThat ( jenkins . scm . api . SCMRevisionAction . getRevision ( source , a ) , org . hamcrest . Matchers . is ( revision ) )"}
{"focal": "subtract ( org . mifos . framework . util . helpers . Money ) { if ( money == null ) { return this ; } org . mifos . framework . util . helpers . Money . checkCurrenciesDifferent ( this , money ) ; return new org . mifos . framework . util . helpers . Money ( money . getCurrency ( ) , amount . subtract ( money . getAmount ( ) ) ) ; }", "testMethod": "whenUnpaidScheduledInstallmentsExistAnyExcessPaymentOverDepositDueShouldBeReturnedAsRemainingAmount ( ) { final org . mifos . framework . util . helpers . Money balanceBeforeDeposit = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"0.0\" ) ; final org . mifos . framework . util . helpers . Money fullDepositAmount = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"100.0\" ) ; final org . mifos . framework . util . helpers . Money recommendedDepositDue = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"36.0\" ) ; final java . util . Date dateOfDeposit = new org . joda . time . DateTime ( ) . toDate ( ) ; final org . mifos . accounts . savings . business . SavingsScheduleEntity unpaidSaving1 = new org . mifos . domain . builders . SavingsScheduleBuilder ( ) . withInstallmentNumber ( 1 ) . withAccount ( savingsAccount ) . withCustomer ( payingCustomer ) . build ( ) ; final org . mifos . accounts . savings . business . SavingsScheduleEntity unpaidSaving2 = new org . mifos . domain . builders . SavingsScheduleBuilder ( ) . withInstallmentNumber ( 2 ) . withAccount ( savingsAccount ) . withCustomer ( payingCustomer ) . withDepositDue ( recommendedDepositDue ) . build ( ) ; final java . util . List < org . mifos . accounts . savings . business . SavingsScheduleEntity > unpaidDepositsForPayingCustomer = java . util . Arrays . asList ( unpaidSaving1 , unpaidSaving2 ) ; when ( accountPayment . getAmount ( ) ) . thenReturn ( fullDepositAmount ) ; when ( accountPayment . getPaymentDate ( ) ) . thenReturn ( dateOfDeposit ) ; final org . mifos . framework . util . helpers . Money remainingAmount = paymentStrategy . makeScheduledPayments ( accountPayment , unpaidDepositsForPayingCustomer , payingCustomer , SavingsType . VOLUNTARY , balanceBeforeDeposit ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( remainingAmount , org . hamcrest . CoreMatchers . is ( fullDepositAmount . subtract ( recommendedDepositDue ) ) )", "total": "whenUnpaidScheduledInstallmentsExistAnyExcessPaymentOverDepositDueShouldBeReturnedAsRemainingAmount ( ) { final org . mifos . framework . util . helpers . Money balanceBeforeDeposit = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"0.0\" ) ; final org . mifos . framework . util . helpers . Money fullDepositAmount = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"100.0\" ) ; final org . mifos . framework . util . helpers . Money recommendedDepositDue = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"36.0\" ) ; final java . util . Date dateOfDeposit = new org . joda . time . DateTime ( ) . toDate ( ) ; final org . mifos . accounts . savings . business . SavingsScheduleEntity unpaidSaving1 = new org . mifos . domain . builders . SavingsScheduleBuilder ( ) . withInstallmentNumber ( 1 ) . withAccount ( savingsAccount ) . withCustomer ( payingCustomer ) . build ( ) ; final org . mifos . accounts . savings . business . SavingsScheduleEntity unpaidSaving2 = new org . mifos . domain . builders . SavingsScheduleBuilder ( ) . withInstallmentNumber ( 2 ) . withAccount ( savingsAccount ) . withCustomer ( payingCustomer ) . withDepositDue ( recommendedDepositDue ) . build ( ) ; final java . util . List < org . mifos . accounts . savings . business . SavingsScheduleEntity > unpaidDepositsForPayingCustomer = java . util . Arrays . asList ( unpaidSaving1 , unpaidSaving2 ) ; when ( accountPayment . getAmount ( ) ) . thenReturn ( fullDepositAmount ) ; when ( accountPayment . getPaymentDate ( ) ) . thenReturn ( dateOfDeposit ) ; final org . mifos . framework . util . helpers . Money remainingAmount = paymentStrategy . makeScheduledPayments ( accountPayment , unpaidDepositsForPayingCustomer , payingCustomer , SavingsType . VOLUNTARY , balanceBeforeDeposit ) ; \"<AssertPlaceHolder>\" ; } subtract ( org . mifos . framework . util . helpers . Money ) { if ( money == null ) { return this ; } org . mifos . framework . util . helpers . Money . checkCurrenciesDifferent ( this , money ) ; return new org . mifos . framework . util . helpers . Money ( money . getCurrency ( ) , amount . subtract ( money . getAmount ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( remainingAmount , org . hamcrest . CoreMatchers . is ( fullDepositAmount . subtract ( recommendedDepositDue ) ) )"}
{"focal": "getTypeInfo ( org . apache . hadoop . conf . Configuration ) { org . apache . hadoop . hive . serde2 . typeinfo . StructTypeInfo inputTypeInfo = ( ( org . apache . hadoop . hive . serde2 . typeinfo . StructTypeInfo ) ( org . apache . hadoop . hive . serde2 . typeinfo . TypeInfoUtils . getTypeInfoFromTypeString ( conf . get ( com . hotels . corc . mapred . CorcInputFormat . INPUT_TYPE_INFO ) ) ) ) ; com . hotels . corc . mapred . CorcInputFormat . LOG . debug ( \"Got<sp>input<sp>typeInfo<sp>from<sp>conf:<sp>{}\" , inputTypeInfo ) ; return inputTypeInfo ; }", "testMethod": "getInputTypeInfo ( ) { conf . set ( CorcInputFormat . INPUT_TYPE_INFO , \"struct<a:string,b:string>\" ) ; org . apache . hadoop . hive . serde2 . typeinfo . StructTypeInfo typeInfo = new com . hotels . corc . StructTypeInfoBuilder ( ) . add ( \"a\" , TypeInfoFactory . stringTypeInfo ) . add ( \"b\" , TypeInfoFactory . stringTypeInfo ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . hotels . corc . mapred . CorcInputFormat . getTypeInfo ( conf ) , org . hamcrest . CoreMatchers . is ( typeInfo ) )", "total": "getInputTypeInfo ( ) { conf . set ( CorcInputFormat . INPUT_TYPE_INFO , \"struct<a:string,b:string>\" ) ; org . apache . hadoop . hive . serde2 . typeinfo . StructTypeInfo typeInfo = new com . hotels . corc . StructTypeInfoBuilder ( ) . add ( \"a\" , TypeInfoFactory . stringTypeInfo ) . add ( \"b\" , TypeInfoFactory . stringTypeInfo ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getTypeInfo ( org . apache . hadoop . conf . Configuration ) { org . apache . hadoop . hive . serde2 . typeinfo . StructTypeInfo inputTypeInfo = ( ( org . apache . hadoop . hive . serde2 . typeinfo . StructTypeInfo ) ( org . apache . hadoop . hive . serde2 . typeinfo . TypeInfoUtils . getTypeInfoFromTypeString ( conf . get ( com . hotels . corc . mapred . CorcInputFormat . INPUT_TYPE_INFO ) ) ) ) ; com . hotels . corc . mapred . CorcInputFormat . LOG . debug ( \"Got<sp>input<sp>typeInfo<sp>from<sp>conf:<sp>{}\" , inputTypeInfo ) ; return inputTypeInfo ; }", "answer": "org . junit . Assert . assertThat ( com . hotels . corc . mapred . CorcInputFormat . getTypeInfo ( conf ) , org . hamcrest . CoreMatchers . is ( typeInfo ) )"}
{"focal": "executeUpdate ( org . apache . shardingsphere . shardingjdbc . executor . StatementExecutor$Updater ) { final boolean isExceptionThrown = org . apache . shardingsphere . core . execute . sql . execute . threadlocal . ExecutorExceptionHandler . isExceptionThrown ( ) ; org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < java . lang . Integer > executeCallback = new org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < java . lang . Integer > ( getDatabaseType ( ) , isExceptionThrown ) { @ org . apache . shardingsphere . shardingjdbc . executor . Override protected org . apache . shardingsphere . shardingjdbc . executor . Integer executeSQL ( final org . apache . shardingsphere . core . route . RouteUnit routeUnit , final java . sql . Statement statement , final org . apache . shardingsphere . core . constant . ConnectionMode connectionMode ) throws java . sql . SQLException { return updater . executeUpdate ( statement , routeUnit . getSqlUnit ( ) . getSql ( ) ) ; } } ; java . util . List < java . lang . Integer > results = executeCallback ( executeCallback ) ; if ( isAccumulate ( ) ) { return accumulate ( results ) ; } else { return null == ( results . get ( 0 ) ) ? 0 : results . get ( 0 ) ; } }", "testMethod": "assertExecuteUpdateWithColumnNames ( ) { java . sql . Statement statement = getStatement ( ) ; when ( statement . executeUpdate ( org . apache . shardingsphere . shardingjdbc . executor . StatementExecutorTest . DML_SQL , new java . lang . String [ ] { \"col\" } ) ) . thenReturn ( 10 ) ; setExecuteGroups ( java . util . Collections . singletonList ( statement ) , SQLType . DML ) ; \"<AssertPlaceHolder>\" ; verify ( statement ) . executeUpdate ( org . apache . shardingsphere . shardingjdbc . executor . StatementExecutorTest . DML_SQL , new java . lang . String [ ] { \"col\" } ) ; }", "assertLine": "org . junit . Assert . assertThat ( actual . executeUpdate ( new java . lang . String [ ] { \"col\" } ) , org . hamcrest . CoreMatchers . is ( 10 ) )", "total": "assertExecuteUpdateWithColumnNames ( ) { java . sql . Statement statement = getStatement ( ) ; when ( statement . executeUpdate ( org . apache . shardingsphere . shardingjdbc . executor . StatementExecutorTest . DML_SQL , new java . lang . String [ ] { \"col\" } ) ) . thenReturn ( 10 ) ; setExecuteGroups ( java . util . Collections . singletonList ( statement ) , SQLType . DML ) ; \"<AssertPlaceHolder>\" ; verify ( statement ) . executeUpdate ( org . apache . shardingsphere . shardingjdbc . executor . StatementExecutorTest . DML_SQL , new java . lang . String [ ] { \"col\" } ) ; } executeUpdate ( org . apache . shardingsphere . shardingjdbc . executor . StatementExecutor$Updater ) { final boolean isExceptionThrown = org . apache . shardingsphere . core . execute . sql . execute . threadlocal . ExecutorExceptionHandler . isExceptionThrown ( ) ; org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < java . lang . Integer > executeCallback = new org . apache . shardingsphere . core . execute . sql . execute . SQLExecuteCallback < java . lang . Integer > ( getDatabaseType ( ) , isExceptionThrown ) { @ org . apache . shardingsphere . shardingjdbc . executor . Override protected org . apache . shardingsphere . shardingjdbc . executor . Integer executeSQL ( final org . apache . shardingsphere . core . route . RouteUnit routeUnit , final java . sql . Statement statement , final org . apache . shardingsphere . core . constant . ConnectionMode connectionMode ) throws java . sql . SQLException { return updater . executeUpdate ( statement , routeUnit . getSqlUnit ( ) . getSql ( ) ) ; } } ; java . util . List < java . lang . Integer > results = executeCallback ( executeCallback ) ; if ( isAccumulate ( ) ) { return accumulate ( results ) ; } else { return null == ( results . get ( 0 ) ) ? 0 : results . get ( 0 ) ; } }", "answer": "org . junit . Assert . assertThat ( actual . executeUpdate ( new java . lang . String [ ] { \"col\" } ) , org . hamcrest . CoreMatchers . is ( 10 ) )"}
{"focal": "onConnectionChangedAddedPre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = true ; } if ( exist ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "testMethod": "testOnConnectionChangedAddedPreSuccessAggregator ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"aggregated\" , \"initializing\" , \"logic_id\" , \"network1\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"aggregated\" , \"running\" , \"logic_id\" , \"network1\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"add\" , prev , curr ) ; when ( target . getObjectId ( ) ) . thenReturn ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . onConnectionChangedAddedPre ( msg ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testOnConnectionChangedAddedPreSuccessAggregator ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"aggregated\" , \"initializing\" , \"logic_id\" , \"network1\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"aggregated\" , \"running\" , \"logic_id\" , \"network1\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"add\" , prev , curr ) ; when ( target . getObjectId ( ) ) . thenReturn ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; \"<AssertPlaceHolder>\" ; } onConnectionChangedAddedPre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = true ; } if ( exist ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . onConnectionChangedAddedPre ( msg ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "toString ( ) { return \"<function5>\" ; }", "testMethod": "toString_A$ ( ) { java . util . Collection < java . lang . Character > list = java . util . Arrays . asList ( 'a' , 'b' , 'c' , '' ) ; com . m3 . scalaflavor4j . StringLike sl = new com . m3 . scalaflavor4j . StringLike ( list ) ; java . lang . String actual = sl . toString ( ) ; java . lang . String expected = \"abc\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "toString_A$ ( ) { java . util . Collection < java . lang . Character > list = java . util . Arrays . asList ( 'a' , 'b' , 'c' , '' ) ; com . m3 . scalaflavor4j . StringLike sl = new com . m3 . scalaflavor4j . StringLike ( list ) ; java . lang . String actual = sl . toString ( ) ; java . lang . String expected = \"abc\" ; \"<AssertPlaceHolder>\" ; } toString ( ) { return \"<function5>\" ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "joinFinishedSplits ( int ) { org . springframework . data . domain . PageRequest pageRequest = new org . springframework . data . domain . PageRequest ( 0 , bulkSize ) ; java . util . List < io . cloudslang . orchestrator . entities . SuspendedExecution > suspendedExecutions = suspendedExecutionsRepository . findFinishedSuspendedExecutions ( pageRequest ) ; return joinAndSendToQueue ( suspendedExecutions ) ; }", "testMethod": "deleteParentJoinFinishedSplitsTest ( ) { java . lang . String splitId = java . util . UUID . randomUUID ( ) . toString ( ) ; io . cloudslang . orchestrator . entities . SuspendedExecution suspendedExecution = createSuspendedExecution ( splitId , 1 ) ; suspendedExecution . getFinishedBranches ( ) . add ( createFinishedBranch ( splitId , ( splitId + \"1\" ) , new java . util . HashMap < java . lang . String , java . io . Serializable > ( ) , new java . util . HashMap < java . lang . String , java . io . Serializable > ( ) ) ) ; org . mockito . Mockito . when ( suspendedExecutionsRepository . findFinishedSuspendedExecutions ( any ( org . springframework . data . domain . Pageable . class ) ) ) . thenReturn ( java . util . Arrays . asList ( suspendedExecution ) ) ; int joinedSplits = splitJoinService . joinFinishedSplits ( 1 ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( suspendedExecutionsRepository ) . delete ( java . util . Arrays . asList ( suspendedExecution ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( joinedSplits , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "deleteParentJoinFinishedSplitsTest ( ) { java . lang . String splitId = java . util . UUID . randomUUID ( ) . toString ( ) ; io . cloudslang . orchestrator . entities . SuspendedExecution suspendedExecution = createSuspendedExecution ( splitId , 1 ) ; suspendedExecution . getFinishedBranches ( ) . add ( createFinishedBranch ( splitId , ( splitId + \"1\" ) , new java . util . HashMap < java . lang . String , java . io . Serializable > ( ) , new java . util . HashMap < java . lang . String , java . io . Serializable > ( ) ) ) ; org . mockito . Mockito . when ( suspendedExecutionsRepository . findFinishedSuspendedExecutions ( any ( org . springframework . data . domain . Pageable . class ) ) ) . thenReturn ( java . util . Arrays . asList ( suspendedExecution ) ) ; int joinedSplits = splitJoinService . joinFinishedSplits ( 1 ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( suspendedExecutionsRepository ) . delete ( java . util . Arrays . asList ( suspendedExecution ) ) ; } joinFinishedSplits ( int ) { org . springframework . data . domain . PageRequest pageRequest = new org . springframework . data . domain . PageRequest ( 0 , bulkSize ) ; java . util . List < io . cloudslang . orchestrator . entities . SuspendedExecution > suspendedExecutions = suspendedExecutionsRepository . findFinishedSuspendedExecutions ( pageRequest ) ; return joinAndSendToQueue ( suspendedExecutions ) ; }", "answer": "org . junit . Assert . assertThat ( joinedSplits , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getAttribute ( java . lang . String ) { return commandProcessor . getString ( \"getAttribute\" , new java . lang . String [ ] { attributeLocator } ) ; }", "testMethod": "testShouldBeAbleToFindAHiddenElementsByName ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . name ( \"hidden\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( element . getAttribute ( \"name\" ) , org . hamcrest . Matchers . is ( \"hidden\" ) )", "total": "testShouldBeAbleToFindAHiddenElementsByName ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . name ( \"hidden\" ) ) ; \"<AssertPlaceHolder>\" ; } getAttribute ( java . lang . String ) { return commandProcessor . getString ( \"getAttribute\" , new java . lang . String [ ] { attributeLocator } ) ; }", "answer": "org . junit . Assert . assertThat ( element . getAttribute ( \"name\" ) , org . hamcrest . Matchers . is ( \"hidden\" ) )"}
{"focal": "getProperties ( ) { return this . properties ; }", "testMethod": "parseHttpsMessageFromResponseDoesNotIncludeNonAppProperties ( com . microsoft . azure . sdk . iot . device . transport . https . HttpsResponse , com . microsoft . azure . sdk . iot . device . MessageProperty ) { final byte [ ] body = new byte [ ] { 97 , 98 , 99 } ; final java . util . Map < java . lang . String , java . lang . String > headerFields = new java . util . HashMap ( ) ; final java . lang . String propertyName = \"test-property-name\" ; final java . lang . String propertyValue = \"test-property-value\" ; headerFields . put ( propertyName , propertyValue ) ; new mockit . NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; com . microsoft . azure . sdk . iot . device . transport . https . HttpsSingleMessage httpsMsg = com . microsoft . azure . sdk . iot . device . transport . https . HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; com . microsoft . azure . sdk . iot . device . MessageProperty [ ] testProperties = httpsMsg . getProperties ( ) ; com . microsoft . azure . sdk . iot . device . MessageProperty [ ] expectedProperties = new com . microsoft . azure . sdk . iot . device . MessageProperty [ ] { } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testProperties , org . hamcrest . CoreMatchers . is ( expectedProperties ) )", "total": "parseHttpsMessageFromResponseDoesNotIncludeNonAppProperties ( com . microsoft . azure . sdk . iot . device . transport . https . HttpsResponse , com . microsoft . azure . sdk . iot . device . MessageProperty ) { final byte [ ] body = new byte [ ] { 97 , 98 , 99 } ; final java . util . Map < java . lang . String , java . lang . String > headerFields = new java . util . HashMap ( ) ; final java . lang . String propertyName = \"test-property-name\" ; final java . lang . String propertyValue = \"test-property-value\" ; headerFields . put ( propertyName , propertyValue ) ; new mockit . NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; com . microsoft . azure . sdk . iot . device . transport . https . HttpsSingleMessage httpsMsg = com . microsoft . azure . sdk . iot . device . transport . https . HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; com . microsoft . azure . sdk . iot . device . MessageProperty [ ] testProperties = httpsMsg . getProperties ( ) ; com . microsoft . azure . sdk . iot . device . MessageProperty [ ] expectedProperties = new com . microsoft . azure . sdk . iot . device . MessageProperty [ ] { } ; \"<AssertPlaceHolder>\" ; } getProperties ( ) { return this . properties ; }", "answer": "org . junit . Assert . assertThat ( testProperties , org . hamcrest . CoreMatchers . is ( expectedProperties ) )"}
{"focal": "getRuleTargets ( ) { java . util . List < T > targets = com . google . common . collect . Lists . newArrayListWithCapacity ( rules . size ( ) ) ; for ( com . spotify . apollo . route . Rule < T > rule : rules ) { targets . add ( rule . getTarget ( ) ) ; } return targets ; }", "testMethod": "shouldReturnAllConfiguredTargets ( ) { java . util . List < com . spotify . apollo . route . Rule < java . lang . String > > rules = com . google . common . collect . ImmutableList . of ( com . spotify . apollo . route . Rule . fromUri ( \"/foo/bar\" , \"POST\" , \"hi\" ) , com . spotify . apollo . route . Rule . fromUri ( \"/foo/bar\" , \"GET\" , \"ho\" ) ) ; final com . spotify . apollo . route . RuleRouter < java . lang . String > router = com . spotify . apollo . route . RuleRouter . of ( rules ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( router . getRuleTargets ( ) , org . hamcrest . CoreMatchers . equalTo ( com . google . common . collect . Lists . transform ( rules , ( rule ) -> rule . getTarget ( ) ) ) )", "total": "shouldReturnAllConfiguredTargets ( ) { java . util . List < com . spotify . apollo . route . Rule < java . lang . String > > rules = com . google . common . collect . ImmutableList . of ( com . spotify . apollo . route . Rule . fromUri ( \"/foo/bar\" , \"POST\" , \"hi\" ) , com . spotify . apollo . route . Rule . fromUri ( \"/foo/bar\" , \"GET\" , \"ho\" ) ) ; final com . spotify . apollo . route . RuleRouter < java . lang . String > router = com . spotify . apollo . route . RuleRouter . of ( rules ) ; \"<AssertPlaceHolder>\" ; } getRuleTargets ( ) { java . util . List < T > targets = com . google . common . collect . Lists . newArrayListWithCapacity ( rules . size ( ) ) ; for ( com . spotify . apollo . route . Rule < T > rule : rules ) { targets . add ( rule . getTarget ( ) ) ; } return targets ; }", "answer": "org . junit . Assert . assertThat ( router . getRuleTargets ( ) , org . hamcrest . CoreMatchers . equalTo ( com . google . common . collect . Lists . transform ( rules , ( rule ) -> rule . getTarget ( ) ) ) )"}
{"focal": "decode ( com . fasterxml . jackson . databind . node . ObjectNode ) { com . fasterxml . jackson . databind . JsonNode ingressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . INGRESS_POINT ) ; if ( ! ( ingressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint ingress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( ingressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode egressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . EGRESS_POINT ) ; if ( ! ( egressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint egress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( egressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode bidirectionalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . BIDIRECTIONAL ) ; boolean bidirectional = ( bidirectionalJson != null ) ? bidirectionalJson . asBoolean ( ) : false ; com . fasterxml . jackson . databind . JsonNode signalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SIGNAL ) ; org . onosproject . net . OchSignal signal = null ; if ( signalJson != null ) { if ( ! ( signalJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } else { signal = org . onosproject . net . optical . json . OchSignalCodec . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( signalJson ) ) ) ; } } java . lang . String appIdString = nullIsIllegal ( json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) , ( ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) + ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . MISSING_MEMBER_MESSAGE ) ) ) . asText ( ) ; org . onosproject . core . CoreService service = getService ( org . onosproject . core . CoreService . class ) ; org . onosproject . core . ApplicationId appId = nullIsNotFound ( service . getAppId ( appIdString ) , org . onosproject . net . optical . rest . OpticalIntentsWebResource . E_APP_ID_NOT_FOUND ) ; org . onosproject . net . intent . Key key = null ; org . onosproject . net . device . DeviceService deviceService = get ( org . onosproject . net . device . DeviceService . class ) ; com . fasterxml . jackson . databind . JsonNode suggestedPathJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SUGGESTEDPATH ) ; org . onosproject . net . DefaultPath suggestedPath = null ; org . onosproject . net . link . LinkService linkService = get (", "testMethod": "testSerializeInstanceContainingEmptyEncodedDiscreteResources ( ) { org . onosproject . net . resource . DiscreteResource device = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; java . util . List < org . onosproject . net . PortNumber > ports = java . util . stream . IntStream . range ( 0 , 1 ) . mapToObj ( PortNumber :: portNumber ) . collect ( java . util . stream . Collectors . toList ( ) ) ; java . util . List < org . onlab . packet . VlanId > vlans = java . util . stream . IntStream . range ( 0 , 2 ) . mapToObj ( ( x ) -> org . onlab . packet . VlanId . vlanId ( ( ( short ) ( x ) ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; java . util . Set < org . onosproject . net . resource . DiscreteResource > originalResources = java . util . stream . Stream . concat ( ports . stream ( ) , vlans . stream ( ) ) . map ( device :: child ) . collect ( java . util . stream . Collectors . toSet ( ) ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . EncodableDiscreteResources . of ( originalResources ) ; java . util . Set < org . onosproject . net . resource . DiscreteResource > portOnlyResources = ports . stream ( ) . map ( device :: child ) . collect ( java . util . stream . Collectors . toSet ( ) ) ; org . onosproject . store . resource . impl . DiscreteResources other = org . onosproject . store . resource . impl . EncodableDiscreteResources . of ( portOnlyResources ) ; org . onosproject . store . resource . impl . DiscreteResources diff = sut . difference ( other ) ; byte [ ] bytes = serializer . encode ( diff ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serializer . decode ( bytes ) , org . hamcrest . Matchers . is ( diff ) )", "total": "testSerializeInstanceContainingEmptyEncodedDiscreteResources ( ) { org . onosproject . net . resource . DiscreteResource device = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; java . util . List < org . onosproject . net . PortNumber > ports = java . util . stream . IntStream . range ( 0 , 1 ) . mapToObj ( PortNumber :: portNumber ) . collect ( java . util . stream . Collectors . toList ( ) ) ; java . util . List < org . onlab . packet . VlanId > vlans = java . util . stream . IntStream . range ( 0 , 2 ) . mapToObj ( ( x ) -> org . onlab . packet . VlanId . vlanId ( ( ( short ) ( x ) ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; java . util . Set < org . onosproject . net . resource . DiscreteResource > originalResources = java . util . stream . Stream . concat ( ports . stream ( ) , vlans . stream ( ) ) . map ( device :: child ) . collect ( java . util . stream . Collectors . toSet ( ) ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . EncodableDiscreteResources . of ( originalResources ) ; java . util . Set < org . onosproject . net . resource . DiscreteResource > portOnlyResources = ports . stream ( ) . map ( device :: child ) . collect ( java . util . stream . Collectors . toSet ( ) ) ; org . onosproject . store . resource . impl . DiscreteResources other = org . onosproject . store . resource . impl . EncodableDiscreteResources . of ( portOnlyResources ) ; org . onosproject . store . resource . impl . DiscreteResources diff = sut . difference ( other ) ; byte [ ] bytes = serializer . encode ( diff ) ; \"<AssertPlaceHolder>\" ; } decode ( com . fasterxml . jackson . databind . node . ObjectNode ) { com . fasterxml . jackson . databind . JsonNode ingressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . INGRESS_POINT ) ; if ( ! ( ingressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint ingress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( ingressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode egressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . EGRESS_POINT ) ; if ( ! ( egressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint egress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( egressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode bidirectionalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . BIDIRECTIONAL ) ; boolean bidirectional = ( bidirectionalJson != null ) ? bidirectionalJson . asBoolean ( ) : false ; com . fasterxml . jackson . databind . JsonNode signalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SIGNAL ) ; org . onosproject . net . OchSignal signal = null ; if ( signalJson != null ) { if ( ! ( signalJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } else { signal = org . onosproject . net . optical . json . OchSignalCodec . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( signalJson ) ) ) ; } } java . lang . String appIdString = nullIsIllegal ( json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) , ( ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) + ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . MISSING_MEMBER_MESSAGE ) ) ) . asText ( ) ; org . onosproject . core . CoreService service = getService ( org . onosproject . core . CoreService . class ) ; org . onosproject . core . ApplicationId appId = nullIsNotFound ( service . getAppId ( appIdString ) , org . onosproject . net . optical . rest . OpticalIntentsWebResource . E_APP_ID_NOT_FOUND ) ; org . onosproject . net . intent . Key key = null ; org . onosproject . net . device . DeviceService deviceService = get ( org . onosproject . net . device . DeviceService . class ) ; com . fasterxml . jackson . databind . JsonNode suggestedPathJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SUGGESTEDPATH ) ; org . onosproject . net . DefaultPath suggestedPath = null ; org . onosproject . net . link . LinkService linkService = get (", "answer": "org . junit . Assert . assertThat ( serializer . decode ( bytes ) , org . hamcrest . Matchers . is ( diff ) )"}
{"focal": "getName ( ) { if ( method . isAnnotationPresent ( egov . data . ibatis . repository . query . Statement . class ) ) return method . getAnnotation ( egov . data . ibatis . repository . query . Statement . class ) . value ( ) ; return super . getName ( ) ; }", "testMethod": "testFindByName ( ) { registerTestSpringSprouts ( ) ; egov . data . ibatis . sample . domain . SpringSprout springSprout = repository . findByName ( first . getName ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( springSprout , org . hamcrest . CoreMatchers . is ( first ) )", "total": "testFindByName ( ) { registerTestSpringSprouts ( ) ; egov . data . ibatis . sample . domain . SpringSprout springSprout = repository . findByName ( first . getName ( ) ) ; \"<AssertPlaceHolder>\" ; } getName ( ) { if ( method . isAnnotationPresent ( egov . data . ibatis . repository . query . Statement . class ) ) return method . getAnnotation ( egov . data . ibatis . repository . query . Statement . class ) . value ( ) ; return super . getName ( ) ; }", "answer": "org . junit . Assert . assertThat ( springSprout , org . hamcrest . CoreMatchers . is ( first ) )"}
{"focal": "findByName ( java . lang . String ) { java . util . Map < java . lang . String , java . lang . Object > queryParameters = new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ; queryParameters . put ( FundConstants . FUND_NAME , fundName ) ; return ( ( org . mifos . accounts . fund . business . FundBO ) ( this . genericDao . executeUniqueResultNamedQuery ( NamedQueryConstants . GET_FUND_FOR_GIVEN_NAME , queryParameters ) ) ) ; }", "testMethod": "shouldFindFundByName ( ) { org . mifos . accounts . fund . business . FundBO returnedFund = fundDao . findByName ( fundName ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( returnedFund , org . hamcrest . CoreMatchers . is ( fund ) )", "total": "shouldFindFundByName ( ) { org . mifos . accounts . fund . business . FundBO returnedFund = fundDao . findByName ( fundName ) ; \"<AssertPlaceHolder>\" ; } findByName ( java . lang . String ) { java . util . Map < java . lang . String , java . lang . Object > queryParameters = new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ; queryParameters . put ( FundConstants . FUND_NAME , fundName ) ; return ( ( org . mifos . accounts . fund . business . FundBO ) ( this . genericDao . executeUniqueResultNamedQuery ( NamedQueryConstants . GET_FUND_FOR_GIVEN_NAME , queryParameters ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( returnedFund , org . hamcrest . CoreMatchers . is ( fund ) )"}
{"focal": "equalTo ( java . util . Collection ) { return new org . mule . tck . util . EnumerationMatcher ( items ) ; }", "testMethod": "loadsResourceFromPluginWhenIsNotDefinedInApp ( ) { pluginClassLoader . addResource ( org . mule . runtime . core . internal . util . CompositeClassLoaderTestCase . RESOURCE_NAME , PLUGIN_LOADED_RESOURCE ) ; org . mule . runtime . core . internal . util . CompositeClassLoader compositeApplicationClassLoader = new org . mule . runtime . core . internal . util . CompositeClassLoader ( appClassLoader , pluginClassLoader ) ; java . net . URL resource = compositeApplicationClassLoader . getResource ( org . mule . runtime . core . internal . util . CompositeClassLoaderTestCase . RESOURCE_NAME ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resource , org . hamcrest . Matchers . equalTo ( PLUGIN_LOADED_RESOURCE ) )", "total": "loadsResourceFromPluginWhenIsNotDefinedInApp ( ) { pluginClassLoader . addResource ( org . mule . runtime . core . internal . util . CompositeClassLoaderTestCase . RESOURCE_NAME , PLUGIN_LOADED_RESOURCE ) ; org . mule . runtime . core . internal . util . CompositeClassLoader compositeApplicationClassLoader = new org . mule . runtime . core . internal . util . CompositeClassLoader ( appClassLoader , pluginClassLoader ) ; java . net . URL resource = compositeApplicationClassLoader . getResource ( org . mule . runtime . core . internal . util . CompositeClassLoaderTestCase . RESOURCE_NAME ) ; \"<AssertPlaceHolder>\" ; } equalTo ( java . util . Collection ) { return new org . mule . tck . util . EnumerationMatcher ( items ) ; }", "answer": "org . junit . Assert . assertThat ( resource , org . hamcrest . Matchers . equalTo ( PLUGIN_LOADED_RESOURCE ) )"}
{"focal": "getType ( ) { return this . type ; }", "testMethod": "canMergeDifferentTypes ( ) { org . ardulink . core . beans . BeanProperties bp = org . ardulink . core . beans . BeanProperties . builder ( new org . ardulink . core . beans . BeanPropertiesTest . BeanWithDifferentTypes ( ) ) . using ( propertyAnnotated ( org . ardulink . core . beans . BeanPropertiesTest . OurOwnTestAnno . class ) ) . build ( ) ; org . ardulink . core . beans . Attribute attribute = bp . getAttribute ( \"weHaveToUseAnnotationsSinceThisWontWorkWithBeans\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( attribute . getType ( ) . getName ( ) , org . hamcrest . core . Is . is ( java . util . Collection . class . getName ( ) ) )", "total": "canMergeDifferentTypes ( ) { org . ardulink . core . beans . BeanProperties bp = org . ardulink . core . beans . BeanProperties . builder ( new org . ardulink . core . beans . BeanPropertiesTest . BeanWithDifferentTypes ( ) ) . using ( propertyAnnotated ( org . ardulink . core . beans . BeanPropertiesTest . OurOwnTestAnno . class ) ) . build ( ) ; org . ardulink . core . beans . Attribute attribute = bp . getAttribute ( \"weHaveToUseAnnotationsSinceThisWontWorkWithBeans\" ) ; \"<AssertPlaceHolder>\" ; } getType ( ) { return this . type ; }", "answer": "org . junit . Assert . assertThat ( attribute . getType ( ) . getName ( ) , org . hamcrest . core . Is . is ( java . util . Collection . class . getName ( ) ) )"}
{"focal": "collect ( com . annimon . stream . Collector ) { A container = collector . supplier ( ) . get ( ) ; while ( iterator . hasNext ( ) ) { final T value = iterator . next ( ) ; collector . accumulator ( ) . accept ( container , value ) ; } return collector . finisher ( ) . apply ( container ) ; }", "testMethod": "testToUnmodifiableList ( ) { java . util . List < java . lang . Integer > list = com . annimon . stream . Stream . range ( 0 , 6 ) . collect ( com . annimon . stream . Collectors . < java . lang . Integer > toUnmodifiableList ( ) ) ; \"<AssertPlaceHolder>\" ; try { list . add ( 1 ) ; org . junit . Assert . fail ( \"Expected<sp>an<sp>UnsupportedOperationException<sp>to<sp>be<sp>thrown<sp>when<sp>add<sp>item<sp>to<sp>list\" ) ; } catch ( java . lang . UnsupportedOperationException expected ) { } try { list . clear ( ) ; org . junit . Assert . fail ( \"Expected<sp>an<sp>UnsupportedOperationException<sp>to<sp>be<sp>thrown<sp>when<sp>clear<sp>the<sp>list\" ) ; } catch ( java . lang . UnsupportedOperationException expected ) { } try { list . subList ( 1 , 2 ) . clear ( ) ; org . junit . Assert . fail ( \"Expected<sp>an<sp>UnsupportedOperationException<sp>to<sp>be<sp>thrown<sp>when<sp>clear<sp>the<sp>sublist\" ) ; } catch ( java . lang . UnsupportedOperationException expected ) { } }", "assertLine": "org . junit . Assert . assertThat ( list , is ( java . util . Arrays . asList ( 0 , 1 , 2 , 3 , 4 , 5 ) ) )", "total": "testToUnmodifiableList ( ) { java . util . List < java . lang . Integer > list = com . annimon . stream . Stream . range ( 0 , 6 ) . collect ( com . annimon . stream . Collectors . < java . lang . Integer > toUnmodifiableList ( ) ) ; \"<AssertPlaceHolder>\" ; try { list . add ( 1 ) ; org . junit . Assert . fail ( \"Expected<sp>an<sp>UnsupportedOperationException<sp>to<sp>be<sp>thrown<sp>when<sp>add<sp>item<sp>to<sp>list\" ) ; } catch ( java . lang . UnsupportedOperationException expected ) { } try { list . clear ( ) ; org . junit . Assert . fail ( \"Expected<sp>an<sp>UnsupportedOperationException<sp>to<sp>be<sp>thrown<sp>when<sp>clear<sp>the<sp>list\" ) ; } catch ( java . lang . UnsupportedOperationException expected ) { } try { list . subList ( 1 , 2 ) . clear ( ) ; org . junit . Assert . fail ( \"Expected<sp>an<sp>UnsupportedOperationException<sp>to<sp>be<sp>thrown<sp>when<sp>clear<sp>the<sp>sublist\" ) ; } catch ( java . lang . UnsupportedOperationException expected ) { } } collect ( com . annimon . stream . Collector ) { A container = collector . supplier ( ) . get ( ) ; while ( iterator . hasNext ( ) ) { final T value = iterator . next ( ) ; collector . accumulator ( ) . accept ( container , value ) ; } return collector . finisher ( ) . apply ( container ) ; }", "answer": "org . junit . Assert . assertThat ( list , is ( java . util . Arrays . asList ( 0 , 1 , 2 , 3 , 4 , 5 ) ) )"}
{"focal": "contains ( java . lang . Object ) { return data . contains ( o ) ; }", "testMethod": "testSearchForExtensionToken ( ) { ca . uhn . fhir . jpa . dao . dstu2 . SearchParameter eyeColourSp = new ca . uhn . fhir . jpa . dao . dstu2 . SearchParameter ( ) ; eyeColourSp . setBase ( ResourceTypeEnum . PATIENT ) ; eyeColourSp . setCode ( \"eyecolour\" ) ; eyeColourSp . setType ( SearchParamTypeEnum . TOKEN ) ; eyeColourSp . setXpath ( \"Patient.extension('http://acme.org/eyecolour')\" ) ; eyeColourSp . setXpathUsage ( XPathUsageTypeEnum . NORMAL ) ; eyeColourSp . setStatus ( ConformanceResourceStatusEnum . ACTIVE ) ; mySearchParameterDao . create ( eyeColourSp , mySrd ) ; mySearchParamRegistry . forceRefresh ( ) ; ca . uhn . fhir . jpa . dao . dstu2 . Patient p1 = new ca . uhn . fhir . jpa . dao . dstu2 . Patient ( ) ; p1 . setActive ( true ) ; p1 . addUndeclaredExtension ( false , \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . dstu2 . CodeDt ( \"blue\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p1id = myPatientDao . create ( p1 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . dao . dstu2 . Patient p2 = new ca . uhn . fhir . jpa . dao . dstu2 . Patient ( ) ; p2 . setActive ( true ) ; p2 . addUndeclaredExtension ( false , \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . dstu2 . CodeDt ( \"green\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p2id = myPatientDao . create ( p2 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . searchparam . SearchParameterMap map = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; map . add ( \"eyecolour\" , new ca . uhn . fhir . jpa . dao . dstu2 . TokenParam ( null , \"blue\" ) ) ; ca . uhn . fhir . rest . api . server . IBundleProvider results = myPatientDao . search ( map ) ; java . util . List < java . lang . String > foundResources = toUnqualifiedVersionlessIdValues ( results ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( foundResources , contains ( p1id . getValue ( ) ) )", "total": "testSearchForExtensionToken ( ) { ca . uhn . fhir . jpa . dao . dstu2 . SearchParameter eyeColourSp = new ca . uhn . fhir . jpa . dao . dstu2 . SearchParameter ( ) ; eyeColourSp . setBase ( ResourceTypeEnum . PATIENT ) ; eyeColourSp . setCode ( \"eyecolour\" ) ; eyeColourSp . setType ( SearchParamTypeEnum . TOKEN ) ; eyeColourSp . setXpath ( \"Patient.extension('http://acme.org/eyecolour')\" ) ; eyeColourSp . setXpathUsage ( XPathUsageTypeEnum . NORMAL ) ; eyeColourSp . setStatus ( ConformanceResourceStatusEnum . ACTIVE ) ; mySearchParameterDao . create ( eyeColourSp , mySrd ) ; mySearchParamRegistry . forceRefresh ( ) ; ca . uhn . fhir . jpa . dao . dstu2 . Patient p1 = new ca . uhn . fhir . jpa . dao . dstu2 . Patient ( ) ; p1 . setActive ( true ) ; p1 . addUndeclaredExtension ( false , \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . dstu2 . CodeDt ( \"blue\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p1id = myPatientDao . create ( p1 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . dao . dstu2 . Patient p2 = new ca . uhn . fhir . jpa . dao . dstu2 . Patient ( ) ; p2 . setActive ( true ) ; p2 . addUndeclaredExtension ( false , \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . dstu2 . CodeDt ( \"green\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p2id = myPatientDao . create ( p2 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . searchparam . SearchParameterMap map = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; map . add ( \"eyecolour\" , new ca . uhn . fhir . jpa . dao . dstu2 . TokenParam ( null , \"blue\" ) ) ; ca . uhn . fhir . rest . api . server . IBundleProvider results = myPatientDao . search ( map ) ; java . util . List < java . lang . String > foundResources = toUnqualifiedVersionlessIdValues ( results ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . Object ) { return data . contains ( o ) ; }", "answer": "org . junit . Assert . assertThat ( foundResources , contains ( p1id . getValue ( ) ) )"}
{"focal": "size ( ) { return count ; }", "testMethod": "find_no_inet6num ( ) { final java . util . List < net . ripe . db . whois . common . dao . RpslObjectInfo > found = subject . findInIndex ( whoisTemplate , rpslObjectInfo . getKey ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( found . size ( ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "find_no_inet6num ( ) { final java . util . List < net . ripe . db . whois . common . dao . RpslObjectInfo > found = subject . findInIndex ( whoisTemplate , rpslObjectInfo . getKey ( ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return count ; }", "answer": "org . junit . Assert . assertThat ( found . size ( ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "isBalancedTree ( ) { boolean result = true ; if ( ( isRecBalance ( this ) ) == ( - 1 ) ) { result = false ; } return result ; }", "testMethod": "whenAddTwoChildAndSecondChildHasOnlyOneSubChildThenNotBalancedTree ( ) { tree . addChild ( nodeOne , \"1\" ) ; tree . addChild ( nodeTwo , \"2\" ) ; nodeOne . addChild ( new vkaretko . TreeNode ( ) , \"3\" ) ; nodeOne . addChild ( new vkaretko . TreeNode ( ) , \"4\" ) ; nodeTwo . addChild ( new vkaretko . TreeNode ( ) , \"6\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tree . isBalancedTree ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "whenAddTwoChildAndSecondChildHasOnlyOneSubChildThenNotBalancedTree ( ) { tree . addChild ( nodeOne , \"1\" ) ; tree . addChild ( nodeTwo , \"2\" ) ; nodeOne . addChild ( new vkaretko . TreeNode ( ) , \"3\" ) ; nodeOne . addChild ( new vkaretko . TreeNode ( ) , \"4\" ) ; nodeTwo . addChild ( new vkaretko . TreeNode ( ) , \"6\" ) ; \"<AssertPlaceHolder>\" ; } isBalancedTree ( ) { boolean result = true ; if ( ( isRecBalance ( this ) ) == ( - 1 ) ) { result = false ; } return result ; }", "answer": "org . junit . Assert . assertThat ( tree . isBalancedTree ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "build ( java . util . function . Function [ ] ) { java . lang . reflect . Method builderMethod ; try { builderMethod = destinedClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILDER_METHOD_NAME ) ; } catch ( java . lang . NoSuchMethodException e ) { throw new java . lang . RuntimeException ( e ) ; } java . lang . Object source ; try { source = builderMethod . invoke ( null ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } for ( Map . Entry < java . lang . String , java . lang . Object > setValue : values . entrySet ( ) ) { java . lang . Object argument = getArgument ( setValue ) ; java . lang . reflect . Method mutator = properties . get ( setValue . getKey ( ) ) . stream ( ) . filter ( ( t ) -> org . apache . commons . lang3 . ClassUtils . isAssignable ( argument . getClass ( ) , t . type ) ) . findFirst ( ) . map ( ( a ) -> a . builderMethod ) . orElseThrow ( ( ) -> new java . lang . IllegalStateException ( java . lang . String . format ( \"Unable<sp>to<sp>find<sp>mutator<sp>for<sp>%s<sp>of<sp>type<sp>%s\" , setValue . getKey ( ) , argument . getClass ( ) . getName ( ) ) ) ) ; try { source = mutator . invoke ( source , argument ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } } if ( additionalMutators != null ) { for ( java . util . function . Function < java . lang . Object , java . lang . Object > mutator : additionalMutators ) { source = mutator . apply ( source ) ; } } java . lang . reflect . Method buildMethod ; try { buildMethod = builderClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILD_METHOD_NAME ) ; return buildMethod . invoke ( source ) ; } catch ( java . lang . IllegalAccessException | java . lang . NoSuchMethodException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "testMethod": "testComplexArrayValuesCreate ( ) { software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate variant1 = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate . create ( \"variant-1\" , 10L , \"vary-1\" ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate variant2 = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate . create ( \"tests[1].[0]\" 3 , 20L , \"vary-2\" ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant expected = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant . builder ( ) . variantName ( \"create-test\" ) . tests ( new software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface [ ] { variant1 , variant2 } ) . build ( ) ; software . amazon . kinesis . multilang . config . BuilderDynaBean builderDynaBean = new software . amazon . kinesis . multilang . config . BuilderDynaBean ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant . class , convertUtilsBean ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" 2 , expected . variantName ) ; utilsBean . setProperty ( builderDynaBean , \"tests[0].class\" , variant1 . getClass ( ) . getName ( ) ) ; utilsBean . setProperty ( builderDynaBean , \"tests[0].[0]\" , variant1 . variantCreateName ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" 0 , variant1 . longClass ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" 1 , variant1 . varyString ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].class\" , variant2 . getClass ( ) . getName ( ) ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" , variant2 . variantCreateName ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[1]\" , variant2 . longClass ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[2]\" , variant2 . varyString ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant actual = builderDynaBean . build ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "testComplexArrayValuesCreate ( ) { software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate variant1 = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate . create ( \"variant-1\" , 10L , \"vary-1\" ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate variant2 = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantCreate . create ( \"tests[1].[0]\" 3 , 20L , \"vary-2\" ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant expected = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant . builder ( ) . variantName ( \"create-test\" ) . tests ( new software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface [ ] { variant1 , variant2 } ) . build ( ) ; software . amazon . kinesis . multilang . config . BuilderDynaBean builderDynaBean = new software . amazon . kinesis . multilang . config . BuilderDynaBean ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant . class , convertUtilsBean ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" 2 , expected . variantName ) ; utilsBean . setProperty ( builderDynaBean , \"tests[0].class\" , variant1 . getClass ( ) . getName ( ) ) ; utilsBean . setProperty ( builderDynaBean , \"tests[0].[0]\" , variant1 . variantCreateName ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" 0 , variant1 . longClass ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" 1 , variant1 . varyString ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].class\" , variant2 . getClass ( ) . getName ( ) ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[0]\" , variant2 . variantCreateName ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[1]\" , variant2 . longClass ) ; utilsBean . setProperty ( builderDynaBean , \"tests[1].[2]\" , variant2 . varyString ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant actual = builderDynaBean . build ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . ComplexArrayClassVariant . class ) ; \"<AssertPlaceHolder>\" ; } build ( java . util . function . Function [ ] ) { java . lang . reflect . Method builderMethod ; try { builderMethod = destinedClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILDER_METHOD_NAME ) ; } catch ( java . lang . NoSuchMethodException e ) { throw new java . lang . RuntimeException ( e ) ; } java . lang . Object source ; try { source = builderMethod . invoke ( null ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } for ( Map . Entry < java . lang . String , java . lang . Object > setValue : values . entrySet ( ) ) { java . lang . Object argument = getArgument ( setValue ) ; java . lang . reflect . Method mutator = properties . get ( setValue . getKey ( ) ) . stream ( ) . filter ( ( t ) -> org . apache . commons . lang3 . ClassUtils . isAssignable ( argument . getClass ( ) , t . type ) ) . findFirst ( ) . map ( ( a ) -> a . builderMethod ) . orElseThrow ( ( ) -> new java . lang . IllegalStateException ( java . lang . String . format ( \"Unable<sp>to<sp>find<sp>mutator<sp>for<sp>%s<sp>of<sp>type<sp>%s\" , setValue . getKey ( ) , argument . getClass ( ) . getName ( ) ) ) ) ; try { source = mutator . invoke ( source , argument ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } } if ( additionalMutators != null ) { for ( java . util . function . Function < java . lang . Object , java . lang . Object > mutator : additionalMutators ) { source = mutator . apply ( source ) ; } } java . lang . reflect . Method buildMethod ; try { buildMethod = builderClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILD_METHOD_NAME ) ; return buildMethod . invoke ( source ) ; } catch ( java . lang . IllegalAccessException | java . lang . NoSuchMethodException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "sayHello ( ) { return \"Hello<sp>World!!\" ; }", "testMethod": "testSayHello ( ) { com . example . Greeting greeting = new com . example . Greeting ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( greeting . sayHello ( ) , org . hamcrest . CoreMatchers . is ( \"Hello<sp>World!!\" ) )", "total": "testSayHello ( ) { com . example . Greeting greeting = new com . example . Greeting ( ) ; \"<AssertPlaceHolder>\" ; } sayHello ( ) { return \"Hello<sp>World!!\" ; }", "answer": "org . junit . Assert . assertThat ( greeting . sayHello ( ) , org . hamcrest . CoreMatchers . is ( \"Hello<sp>World!!\" ) )"}
{"focal": "validate ( ) { return true ; }", "testMethod": "createChangeConfigurationRequest_withVendorId_returnsValidDataTransferRequest ( ) { java . lang . String vendorId = \"some<sp>vendorId\" ; eu . chargetime . ocpp . model . core . DataTransferRequest result = core . createDataTransferRequest ( vendorId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . validate ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "createChangeConfigurationRequest_withVendorId_returnsValidDataTransferRequest ( ) { java . lang . String vendorId = \"some<sp>vendorId\" ; eu . chargetime . ocpp . model . core . DataTransferRequest result = core . createDataTransferRequest ( vendorId ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result . validate ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getHistory ( ) { net . time4j . tz . Timezone tz = net . time4j . tz . PlatformTimezoneTest . loadFromPlatform ( \"Europe/Berlin\" ) ; org . junit . Assert . assertThat ( tz . getHistory ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . nullValue ( ) ) ) ; }", "testMethod": "getHistory ( ) { net . time4j . tz . Timezone tz = net . time4j . tz . PlatformTimezoneTest . loadFromPlatform ( \"Europe/Berlin\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tz . getHistory ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . nullValue ( ) ) )", "total": "getHistory ( ) { net . time4j . tz . Timezone tz = net . time4j . tz . PlatformTimezoneTest . loadFromPlatform ( \"Europe/Berlin\" ) ; \"<AssertPlaceHolder>\" ; } getHistory ( ) { net . time4j . tz . Timezone tz = net . time4j . tz . PlatformTimezoneTest . loadFromPlatform ( \"Europe/Berlin\" ) ; org . junit . Assert . assertThat ( tz . getHistory ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . nullValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( tz . getHistory ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . nullValue ( ) ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldCallXStreamXmlSerialization ( ) { java . lang . String expectedResult = \"<message><message>Just<sp>another<sp>{0}<sp>in<sp>{1}</message><category>success</category></message>\" ; serialization . from ( \"success\" , \"message.cat\" ) . as ( xml ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldCallXStreamXmlSerialization ( ) { java . lang . String expectedResult = \"<message><message>Just<sp>another<sp>{0}<sp>in<sp>{1}</message><category>success</category></message>\" ; serialization . from ( \"success\" , \"message.cat\" ) . as ( xml ( ) ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "loadFromClassPath ( java . lang . String ) { jscover . util . InputStream is = null ; try { is = jscover . util . IoUtils . class . getResourceAsStream ( dataFile ) ; return toString ( is ) ; } catch ( java . lang . Throwable e ) { throw new java . lang . RuntimeException ( java . lang . String . format ( \"Problem<sp>loading<sp>resource:<sp>'%s'\" , dataFile ) , e ) ; } finally { closeQuietly ( is ) ; } }", "testMethod": "shouldMergeFunctionData ( ) { java . lang . String data1 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1-function.json\" ) ; java . lang . String data2 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-3-function.json\" ) ; java . lang . String expected = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1-3-function.json\" ) ; java . lang . String merged = jsonMerger . toJSON ( jsonMerger . mergeJSONCoverageStrings ( data1 , data2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( merged , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "shouldMergeFunctionData ( ) { java . lang . String data1 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1-function.json\" ) ; java . lang . String data2 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-3-function.json\" ) ; java . lang . String expected = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1-3-function.json\" ) ; java . lang . String merged = jsonMerger . toJSON ( jsonMerger . mergeJSONCoverageStrings ( data1 , data2 ) ) ; \"<AssertPlaceHolder>\" ; } loadFromClassPath ( java . lang . String ) { jscover . util . InputStream is = null ; try { is = jscover . util . IoUtils . class . getResourceAsStream ( dataFile ) ; return toString ( is ) ; } catch ( java . lang . Throwable e ) { throw new java . lang . RuntimeException ( java . lang . String . format ( \"Problem<sp>loading<sp>resource:<sp>'%s'\" , dataFile ) , e ) ; } finally { closeQuietly ( is ) ; } }", "answer": "org . junit . Assert . assertThat ( merged , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "getPath ( ) { return getRequest ( ) . getPath ( ) ; }", "testMethod": "shouldReturnPathFromUnderlyingRequest ( ) { java . lang . String expectedPath = \"/2324/lists/43/foo\" ; java . lang . StringBuffer expectedUrl = new java . lang . StringBuffer ( \"https://foo.example.com\" ) . append ( ro . pippo . pac4j . PippoWebContextTest . DEFAULT_APPLICATION_PATH ) . append ( expectedPath ) ; when ( mockRouter . getApplicationPath ( ) ) . thenReturn ( ro . pippo . pac4j . PippoWebContextTest . DEFAULT_APPLICATION_PATH ) ; when ( mockHttpRequest . getRequestURL ( ) ) . thenReturn ( expectedUrl ) ; ro . pippo . pac4j . PippoWebContext context = makePippoWebContext ( ) ; \"<AssertPlaceHolder>\" ; verify ( mockRouter , atLeastOnce ( ) ) . getApplicationPath ( ) ; verify ( mockHttpRequest , times ( 1 ) ) . getRequestURL ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( context . getPath ( ) , org . hamcrest . core . Is . is ( expectedPath ) )", "total": "shouldReturnPathFromUnderlyingRequest ( ) { java . lang . String expectedPath = \"/2324/lists/43/foo\" ; java . lang . StringBuffer expectedUrl = new java . lang . StringBuffer ( \"https://foo.example.com\" ) . append ( ro . pippo . pac4j . PippoWebContextTest . DEFAULT_APPLICATION_PATH ) . append ( expectedPath ) ; when ( mockRouter . getApplicationPath ( ) ) . thenReturn ( ro . pippo . pac4j . PippoWebContextTest . DEFAULT_APPLICATION_PATH ) ; when ( mockHttpRequest . getRequestURL ( ) ) . thenReturn ( expectedUrl ) ; ro . pippo . pac4j . PippoWebContext context = makePippoWebContext ( ) ; \"<AssertPlaceHolder>\" ; verify ( mockRouter , atLeastOnce ( ) ) . getApplicationPath ( ) ; verify ( mockHttpRequest , times ( 1 ) ) . getRequestURL ( ) ; } getPath ( ) { return getRequest ( ) . getPath ( ) ; }", "answer": "org . junit . Assert . assertThat ( context . getPath ( ) , org . hamcrest . core . Is . is ( expectedPath ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testGetIdLength ( ) { defaultIsisInterface . setIdLength ( 8 ) ; resultInt = defaultIsisInterface . getIdLength ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultInt , org . hamcrest . CoreMatchers . is ( 8 ) )", "total": "testGetIdLength ( ) { defaultIsisInterface . setIdLength ( 8 ) ; resultInt = defaultIsisInterface . getIdLength ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( resultInt , org . hamcrest . CoreMatchers . is ( 8 ) )"}
{"focal": "trimLabels ( java . util . List ) { if ( ( labels . size ( ) ) <= 1 ) { return labels ; } int greatestChangingPrecision = org . diirt . graphene . TimeScales . calculateGreatestChangingField ( labels ) ; java . util . ArrayList < java . lang . String > rtn = new java . util . ArrayList < java . lang . String > ( labels . size ( ) ) ; org . diirt . graphene . TimeScales . DateTrimmer firstDate = new org . diirt . graphene . TimeScales . DateTrimmer ( labels . get ( 0 ) ) ; rtn . add ( firstDate . getCompactForm ( org . diirt . graphene . TimeScales . DateTrimmer . NO_PRECISION , greatestChangingPrecision ) ) ; for ( int i = 1 ; i < ( labels . size ( ) ) ; i ++ ) { java . lang . String prevLabel = labels . get ( ( i - 1 ) ) ; java . lang . String nextLabel = labels . get ( i ) ; int redundancePrecision = org . diirt . graphene . TimeScales . greatestRedundancePrecision ( prevLabel , nextLabel ) ; org . diirt . graphene . TimeScales . DateTrimmer f = new org . diirt . graphene . TimeScales . DateTrimmer ( nextLabel ) ; java . lang . String trimmedLabel = f . getCompactForm ( redundancePrecision , greatestChangingPrecision ) ; rtn . add ( trimmedLabel ) ; } return rtn ; }", "testMethod": "trimLabelsMinutes1 ( ) { java . util . List < java . lang . String > input = java . util . Arrays . asList ( \"2014/11/26<sp>09:01:00.000000000\" , \"2014/11/26<sp>09:02:00.000000000\" , \"2014/11/26<sp>09:03:00.000000000\" , \"2014/11/26<sp>09:04:00.000000000\" , \"2014/11/26<sp>09:05:00.000000000\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"2014/11/26<sp>09:01\" , \"09:02\" , \"09:03\" , \"09:04\" , \"09:05\" ) ; java . util . List < java . lang . String > found = org . diirt . graphene . TimeScales . trimLabels ( input ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( found , equalTo ( expected ) )", "total": "trimLabelsMinutes1 ( ) { java . util . List < java . lang . String > input = java . util . Arrays . asList ( \"2014/11/26<sp>09:01:00.000000000\" , \"2014/11/26<sp>09:02:00.000000000\" , \"2014/11/26<sp>09:03:00.000000000\" , \"2014/11/26<sp>09:04:00.000000000\" , \"2014/11/26<sp>09:05:00.000000000\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"2014/11/26<sp>09:01\" , \"09:02\" , \"09:03\" , \"09:04\" , \"09:05\" ) ; java . util . List < java . lang . String > found = org . diirt . graphene . TimeScales . trimLabels ( input ) ; \"<AssertPlaceHolder>\" ; } trimLabels ( java . util . List ) { if ( ( labels . size ( ) ) <= 1 ) { return labels ; } int greatestChangingPrecision = org . diirt . graphene . TimeScales . calculateGreatestChangingField ( labels ) ; java . util . ArrayList < java . lang . String > rtn = new java . util . ArrayList < java . lang . String > ( labels . size ( ) ) ; org . diirt . graphene . TimeScales . DateTrimmer firstDate = new org . diirt . graphene . TimeScales . DateTrimmer ( labels . get ( 0 ) ) ; rtn . add ( firstDate . getCompactForm ( org . diirt . graphene . TimeScales . DateTrimmer . NO_PRECISION , greatestChangingPrecision ) ) ; for ( int i = 1 ; i < ( labels . size ( ) ) ; i ++ ) { java . lang . String prevLabel = labels . get ( ( i - 1 ) ) ; java . lang . String nextLabel = labels . get ( i ) ; int redundancePrecision = org . diirt . graphene . TimeScales . greatestRedundancePrecision ( prevLabel , nextLabel ) ; org . diirt . graphene . TimeScales . DateTrimmer f = new org . diirt . graphene . TimeScales . DateTrimmer ( nextLabel ) ; java . lang . String trimmedLabel = f . getCompactForm ( redundancePrecision , greatestChangingPrecision ) ; rtn . add ( trimmedLabel ) ; } return rtn ; }", "answer": "org . junit . Assert . assertThat ( found , equalTo ( expected ) )"}
{"focal": "couldHoldIgnoringSharedMemory ( org . apache . storm . scheduler . resource . normalization . NormalizedResources , double , double ) { if ( ( this . cpu ) < ( other . getTotalCpu ( ) ) ) { return false ; } return couldHoldIgnoringSharedMemoryAndCpu ( other , thisTotalMemoryMb , otherTotalMemoryMb ) ; }", "testMethod": "testCouldHoldWithTooFewCpus ( ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources resources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . singletonMap ( Constants . COMMON_CPU_RESOURCE_NAME , 1 ) ) ) ; org . apache . storm . scheduler . resource . normalization . NormalizedResources resourcesToCheck = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . singletonMap ( Constants . COMMON_CPU_RESOURCE_NAME , 2 ) ) ) ; boolean couldHold = resources . couldHoldIgnoringSharedMemory ( resourcesToCheck , 100 , 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( couldHold , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testCouldHoldWithTooFewCpus ( ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources resources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . singletonMap ( Constants . COMMON_CPU_RESOURCE_NAME , 1 ) ) ) ; org . apache . storm . scheduler . resource . normalization . NormalizedResources resourcesToCheck = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . singletonMap ( Constants . COMMON_CPU_RESOURCE_NAME , 2 ) ) ) ; boolean couldHold = resources . couldHoldIgnoringSharedMemory ( resourcesToCheck , 100 , 1 ) ; \"<AssertPlaceHolder>\" ; } couldHoldIgnoringSharedMemory ( org . apache . storm . scheduler . resource . normalization . NormalizedResources , double , double ) { if ( ( this . cpu ) < ( other . getTotalCpu ( ) ) ) { return false ; } return couldHoldIgnoringSharedMemoryAndCpu ( other , thisTotalMemoryMb , otherTotalMemoryMb ) ; }", "answer": "org . junit . Assert . assertThat ( couldHold , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "apply ( org . gradle . api . Project ) { hu . advancedweb . scott . ScottPluginExtension extension = project . getExtensions ( ) . create ( hu . advancedweb . scott . ScottPlugin . PLUGIN_EXTENSION_NAME , hu . advancedweb . scott . ScottPluginExtension . class , hu . advancedweb . scott . ScottPlugin . DEFAULT_SCOTT_VERSION ) ; org . gradle . api . artifacts . Configuration configuration = configureAgentDependencies ( project , extension ) ; project . afterEvaluate ( ( p ) -> { org . gradle . api . Task test = p . getTasks ( ) . getByName ( \"test\" ) ; org . gradle . process . JavaForkOptions opts = ( ( org . gradle . process . JavaForkOptions ) ( test ) ) ; opts . getJvmArgumentProviders ( ) . add ( new hu . advancedweb . scott . ScottAgent ( configuration , extension ) ) ; } ) ; }", "testMethod": "lambda_with_single_expression_3 ( ) { java . util . function . Function < java . lang . String , java . lang . String > lambda = ( a ) -> a + a ; java . lang . String result = lambda . apply ( \"1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( \"2\" ) )", "total": "lambda_with_single_expression_3 ( ) { java . util . function . Function < java . lang . String , java . lang . String > lambda = ( a ) -> a + a ; java . lang . String result = lambda . apply ( \"1\" ) ; \"<AssertPlaceHolder>\" ; } apply ( org . gradle . api . Project ) { hu . advancedweb . scott . ScottPluginExtension extension = project . getExtensions ( ) . create ( hu . advancedweb . scott . ScottPlugin . PLUGIN_EXTENSION_NAME , hu . advancedweb . scott . ScottPluginExtension . class , hu . advancedweb . scott . ScottPlugin . DEFAULT_SCOTT_VERSION ) ; org . gradle . api . artifacts . Configuration configuration = configureAgentDependencies ( project , extension ) ; project . afterEvaluate ( ( p ) -> { org . gradle . api . Task test = p . getTasks ( ) . getByName ( \"test\" ) ; org . gradle . process . JavaForkOptions opts = ( ( org . gradle . process . JavaForkOptions ) ( test ) ) ; opts . getJvmArgumentProviders ( ) . add ( new hu . advancedweb . scott . ScottAgent ( configuration , extension ) ) ; } ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( \"2\" ) )"}
{"focal": "getTimeZone ( ) { final java . time . ZoneId timeZone = this . timeZone ; if ( timeZone == null ) { return java . util . TimeZone . getDefault ( ) . toZoneId ( ) ; } return timeZone ; }", "testMethod": "assertThatInvalidTimeZoneFallsbackToDefaultTimeZone ( ) { java . util . Hashtable < java . lang . String , java . lang . Object > conf = new java . util . Hashtable ( ) ; conf . put ( org . eclipse . smarthome . core . internal . i18n . TIMEZONE , \"invalid\" ) ; i18nProviderImpl . modified ( conf ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( i18nProviderImpl . getTimeZone ( ) , org . hamcrest . CoreMatchers . is ( java . util . TimeZone . getDefault ( ) . toZoneId ( ) ) )", "total": "assertThatInvalidTimeZoneFallsbackToDefaultTimeZone ( ) { java . util . Hashtable < java . lang . String , java . lang . Object > conf = new java . util . Hashtable ( ) ; conf . put ( org . eclipse . smarthome . core . internal . i18n . TIMEZONE , \"invalid\" ) ; i18nProviderImpl . modified ( conf ) ; \"<AssertPlaceHolder>\" ; } getTimeZone ( ) { final java . time . ZoneId timeZone = this . timeZone ; if ( timeZone == null ) { return java . util . TimeZone . getDefault ( ) . toZoneId ( ) ; } return timeZone ; }", "answer": "org . junit . Assert . assertThat ( i18nProviderImpl . getTimeZone ( ) , org . hamcrest . CoreMatchers . is ( java . util . TimeZone . getDefault ( ) . toZoneId ( ) ) )"}
{"focal": "isWcInPort ( ) { return wcInPort ; }", "testMethod": "testIsWcInPort ( ) { target = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( ) ; target . setInPort ( \"port_a_01\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . isWcInPort ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testIsWcInPort ( ) { target = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( ) ; target . setInPort ( \"port_a_01\" ) ; \"<AssertPlaceHolder>\" ; } isWcInPort ( ) { return wcInPort ; }", "answer": "org . junit . Assert . assertThat ( target . isWcInPort ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "parse ( java . io . File ) { java . util . List < diskCacheV111 . util . PnfsId > list = new java . util . ArrayList ( ) ; try ( java . io . BufferedReader reader = new java . io . BufferedReader ( new java . io . FileReader ( file ) ) ) { java . lang . String line ; while ( ( line = reader . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( ( line . isEmpty ( ) ) || ( line . startsWith ( \"#\" ) ) ) { continue ; } list . add ( new diskCacheV111 . util . PnfsId ( line ) ) ; } } catch ( java . lang . IllegalArgumentException e ) { throw new java . io . IOException ( ( \"Invalid<sp>file<sp>format:<sp>\" + ( e . getMessage ( ) ) ) ) ; } return list ; }", "testMethod": "shouldParseJedecSymbolNoSpaceByte ( ) { long value = org . dcache . util . ByteSizeParser . using ( jedecSymbol ( ) ) . parse ( \"1B\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( 1L ) ) )", "total": "shouldParseJedecSymbolNoSpaceByte ( ) { long value = org . dcache . util . ByteSizeParser . using ( jedecSymbol ( ) ) . parse ( \"1B\" ) ; \"<AssertPlaceHolder>\" ; } parse ( java . io . File ) { java . util . List < diskCacheV111 . util . PnfsId > list = new java . util . ArrayList ( ) ; try ( java . io . BufferedReader reader = new java . io . BufferedReader ( new java . io . FileReader ( file ) ) ) { java . lang . String line ; while ( ( line = reader . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( ( line . isEmpty ( ) ) || ( line . startsWith ( \"#\" ) ) ) { continue ; } list . add ( new diskCacheV111 . util . PnfsId ( line ) ) ; } } catch ( java . lang . IllegalArgumentException e ) { throw new java . io . IOException ( ( \"Invalid<sp>file<sp>format:<sp>\" + ( e . getMessage ( ) ) ) ) ; } return list ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( 1L ) ) )"}
{"focal": "transform ( java . lang . Object ) { return transform ( src , null ) ; }", "testMethod": "transformInputStream ( ) { java . io . InputStream inputStream = new java . io . ByteArrayInputStream ( org . mule . runtime . core . internal . transformer . simple . InputStreamToByteArrayTestCase . DONKEY . getBytes ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( transformer . transform ( inputStream ) , org . hamcrest . CoreMatchers . equalTo ( org . mule . runtime . core . internal . transformer . simple . InputStreamToByteArrayTestCase . DONKEY . getBytes ( ) ) )", "total": "transformInputStream ( ) { java . io . InputStream inputStream = new java . io . ByteArrayInputStream ( org . mule . runtime . core . internal . transformer . simple . InputStreamToByteArrayTestCase . DONKEY . getBytes ( ) ) ; \"<AssertPlaceHolder>\" ; } transform ( java . lang . Object ) { return transform ( src , null ) ; }", "answer": "org . junit . Assert . assertThat ( transformer . transform ( inputStream ) , org . hamcrest . CoreMatchers . equalTo ( org . mule . runtime . core . internal . transformer . simple . InputStreamToByteArrayTestCase . DONKEY . getBytes ( ) ) )"}
{"focal": "decodeRfc3230 ( java . lang . String ) { java . util . Map < java . lang . String , java . lang . String > parts = org . dcache . util . Checksums . RFC3230_SPLITTER . split ( nullToEmpty ( digest ) ) ; java . util . Map < java . lang . String , org . dcache . util . Checksum > checksums = transformEntries ( parts , org . dcache . util . Checksums . RFC3230_TO_CHECKSUM ) ; return checksums . values ( ) . stream ( ) . filter ( Objects :: nonNull ) . collect ( java . util . stream . Collectors . toSet ( ) ) ; }", "testMethod": "shouldReturnSingleChecksumForAdler32String ( ) { java . util . Set < org . dcache . util . Checksum > result = org . dcache . util . Checksums . decodeRfc3230 ( \"adler32=03da0195\" ) ; java . util . Set < org . dcache . util . Checksum > expected = java . util . Collections . singleton ( new org . dcache . util . Checksum ( org . dcache . util . ChecksumType . ChecksumType . ADLER32 , \"03da0195\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , equalTo ( expected ) )", "total": "shouldReturnSingleChecksumForAdler32String ( ) { java . util . Set < org . dcache . util . Checksum > result = org . dcache . util . Checksums . decodeRfc3230 ( \"adler32=03da0195\" ) ; java . util . Set < org . dcache . util . Checksum > expected = java . util . Collections . singleton ( new org . dcache . util . Checksum ( org . dcache . util . ChecksumType . ChecksumType . ADLER32 , \"03da0195\" ) ) ; \"<AssertPlaceHolder>\" ; } decodeRfc3230 ( java . lang . String ) { java . util . Map < java . lang . String , java . lang . String > parts = org . dcache . util . Checksums . RFC3230_SPLITTER . split ( nullToEmpty ( digest ) ) ; java . util . Map < java . lang . String , org . dcache . util . Checksum > checksums = transformEntries ( parts , org . dcache . util . Checksums . RFC3230_TO_CHECKSUM ) ; return checksums . values ( ) . stream ( ) . filter ( Objects :: nonNull ) . collect ( java . util . stream . Collectors . toSet ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , equalTo ( expected ) )"}
{"focal": "processUninstalledBundleAndPopulateTaskList ( org . osgi . framework . Bundle , org . codice . ddf . admin . application . service . migratable . TaskList ) { final org . codice . ddf . admin . application . service . migratable . JsonBundle . SimpleState state = org . codice . ddf . admin . application . service . migratable . JsonBundle . getSimpleState ( bundle ) ; if ( state != ( JsonBundle . SimpleState . UNINSTALLED ) ) { final java . lang . String name = org . codice . ddf . admin . application . service . migratable . JsonBundle . getFullName ( bundle ) ; tasks . add ( Operation . UNINSTALL , name , ( r ) -> uninstallBundle ( r , bundle ) ) ; return true ; } return false ; }", "testMethod": "testProcessUninstalledBundleAndPopulateTaskListWhenActive ( ) { org . mockito . Mockito . doReturn ( true ) . when ( bundleProcessor ) . uninstallBundle ( report , bundle ) ; org . mockito . Mockito . doReturn ( org . osgi . framework . Bundle . ACTIVE ) . when ( bundle ) . getState ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( tasks ) . add ( org . mockito . Mockito . eq ( Operation . UNINSTALL ) , org . mockito . Mockito . eq ( org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . NAME_VERSION ) , org . mockito . Mockito . notNull ( ) ) ; org . mockito . Mockito . verify ( bundleProcessor ) . uninstallBundle ( report , bundle ) ; }", "assertLine": "org . junit . Assert . assertThat ( bundleProcessor . processUninstalledBundleAndPopulateTaskList ( bundle , tasks ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "testProcessUninstalledBundleAndPopulateTaskListWhenActive ( ) { org . mockito . Mockito . doReturn ( true ) . when ( bundleProcessor ) . uninstallBundle ( report , bundle ) ; org . mockito . Mockito . doReturn ( org . osgi . framework . Bundle . ACTIVE ) . when ( bundle ) . getState ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( tasks ) . add ( org . mockito . Mockito . eq ( Operation . UNINSTALL ) , org . mockito . Mockito . eq ( org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . NAME_VERSION ) , org . mockito . Mockito . notNull ( ) ) ; org . mockito . Mockito . verify ( bundleProcessor ) . uninstallBundle ( report , bundle ) ; } processUninstalledBundleAndPopulateTaskList ( org . osgi . framework . Bundle , org . codice . ddf . admin . application . service . migratable . TaskList ) { final org . codice . ddf . admin . application . service . migratable . JsonBundle . SimpleState state = org . codice . ddf . admin . application . service . migratable . JsonBundle . getSimpleState ( bundle ) ; if ( state != ( JsonBundle . SimpleState . UNINSTALLED ) ) { final java . lang . String name = org . codice . ddf . admin . application . service . migratable . JsonBundle . getFullName ( bundle ) ; tasks . add ( Operation . UNINSTALL , name , ( r ) -> uninstallBundle ( r , bundle ) ) ; return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( bundleProcessor . processUninstalledBundleAndPopulateTaskList ( bundle , tasks ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "window ( ) { return window ; }", "testMethod": "windowOnlyContextWindowReturnsWindow ( ) { org . apache . beam . sdk . transforms . windowing . BoundedWindow window = new org . apache . beam . sdk . transforms . windowing . IntervalWindow ( new org . joda . time . Instant ( ( - 137 ) ) , org . joda . time . Duration . millis ( 21L ) ) ; org . apache . beam . sdk . state . StateContext < org . apache . beam . sdk . transforms . windowing . BoundedWindow > context = org . apache . beam . sdk . state . StateContexts . windowOnlyContext ( window ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( context . window ( ) , org . hamcrest . Matchers . equalTo ( window ) )", "total": "windowOnlyContextWindowReturnsWindow ( ) { org . apache . beam . sdk . transforms . windowing . BoundedWindow window = new org . apache . beam . sdk . transforms . windowing . IntervalWindow ( new org . joda . time . Instant ( ( - 137 ) ) , org . joda . time . Duration . millis ( 21L ) ) ; org . apache . beam . sdk . state . StateContext < org . apache . beam . sdk . transforms . windowing . BoundedWindow > context = org . apache . beam . sdk . state . StateContexts . windowOnlyContext ( window ) ; \"<AssertPlaceHolder>\" ; } window ( ) { return window ; }", "answer": "org . junit . Assert . assertThat ( context . window ( ) , org . hamcrest . Matchers . equalTo ( window ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "yield_A$Function1_emptyGenerator ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs1 = com . m3 . scalaflavor4j . Seq . apply ( \"a\" , \"b\" ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Integer > xs2 = com . m3 . scalaflavor4j . Seq . apply ( ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Long > xs3 = com . m3 . scalaflavor4j . Seq . apply ( 10L , 20L ) ; com . m3 . scalaflavor4j . Seq < java . lang . String > rs = com . m3 . scalaflavor4j . For . apply ( xs1 , xs2 , xs3 ) . yield ( new com . m3 . scalaflavor4j . F1 < com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > , java . lang . String > ( ) { public java . lang . String apply ( com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > t ) { return ( ( t . _1 ( ) ) + ( t . _2 ( ) ) ) + ( t . _3 ( ) ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rs . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "yield_A$Function1_emptyGenerator ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs1 = com . m3 . scalaflavor4j . Seq . apply ( \"a\" , \"b\" ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Integer > xs2 = com . m3 . scalaflavor4j . Seq . apply ( ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Long > xs3 = com . m3 . scalaflavor4j . Seq . apply ( 10L , 20L ) ; com . m3 . scalaflavor4j . Seq < java . lang . String > rs = com . m3 . scalaflavor4j . For . apply ( xs1 , xs2 , xs3 ) . yield ( new com . m3 . scalaflavor4j . F1 < com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > , java . lang . String > ( ) { public java . lang . String apply ( com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > t ) { return ( ( t . _1 ( ) ) + ( t . _2 ( ) ) ) + ( t . _3 ( ) ) ; } } ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( rs . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "split ( java . lang . String ) { java . util . List < java . lang . String > result = new java . util . ArrayList ( ) ; return com . openshift . internal . util . StringSplitter . split ( str , result ) ; }", "testMethod": "testSimpleManyParameters ( ) { java . util . List < java . lang . String > result = com . openshift . internal . util . StringSplitter . split ( \"parm1<sp>parm2<sp>parm3\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"parm1\" , \"parm2\" , \"parm3\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testSimpleManyParameters ( ) { java . util . List < java . lang . String > result = com . openshift . internal . util . StringSplitter . split ( \"parm1<sp>parm2<sp>parm3\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"parm1\" , \"parm2\" , \"parm3\" ) ; \"<AssertPlaceHolder>\" ; } split ( java . lang . String ) { java . util . List < java . lang . String > result = new java . util . ArrayList ( ) ; return com . openshift . internal . util . StringSplitter . split ( str , result ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getQuery ( ) { java . lang . StringBuilder query = new java . lang . StringBuilder ( ) ; query . append ( getEdmEntityName ( ) ) ; if ( ! ( isSingletonEntity ( ) ) ) { query . append ( generateParameters ( ) ) ; } return query . toString ( ) ; }", "testMethod": "createBoundFunctionQueryWithoutParams ( ) { com . sdl . odata . client . api . ODataClientQuery query = new com . sdl . odata . client . BoundFunctionClientQuery . Builder ( ) . withBoundEntityName ( \"SampleEntitySet\" ) . withNameSpace ( \"Web.Sdl\" ) . withEntityType ( com . sdl . odata . client . DefaultODataClientQueryTest . EmptyEntity . class ) . withFunctionName ( \"SampleFunction\" ) . build ( ) ; java . lang . String expectedToString = \"SampleEntitySet/Web.Sdl.SampleFunction\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . getQuery ( ) , org . hamcrest . core . Is . is ( expectedToString ) )", "total": "createBoundFunctionQueryWithoutParams ( ) { com . sdl . odata . client . api . ODataClientQuery query = new com . sdl . odata . client . BoundFunctionClientQuery . Builder ( ) . withBoundEntityName ( \"SampleEntitySet\" ) . withNameSpace ( \"Web.Sdl\" ) . withEntityType ( com . sdl . odata . client . DefaultODataClientQueryTest . EmptyEntity . class ) . withFunctionName ( \"SampleFunction\" ) . build ( ) ; java . lang . String expectedToString = \"SampleEntitySet/Web.Sdl.SampleFunction\" ; \"<AssertPlaceHolder>\" ; } getQuery ( ) { java . lang . StringBuilder query = new java . lang . StringBuilder ( ) ; query . append ( getEdmEntityName ( ) ) ; if ( ! ( isSingletonEntity ( ) ) ) { query . append ( generateParameters ( ) ) ; } return query . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( query . getQuery ( ) , org . hamcrest . core . Is . is ( expectedToString ) )"}
{"focal": "bepaalDatumTijdEindeFormelePeriodeResultaat ( nl . bzk . brp . service . bevraging . geefmedebewoners . GeefMedebewonersVerzoek , java . time . ZonedDateTime ) { return datumTijdKlaarzettenBericht ; }", "testMethod": "bepaalDatumTijdEindeFormelePeriodeResultaat ( ) { final java . time . ZonedDateTime datumTijdKlaarzettenBericht = nl . bzk . algemeenbrp . util . common . DatumUtil . nuAlsZonedDateTime ( ) ; final java . time . ZonedDateTime datumTijdEindeFormelePeriodeResultaat = zoekPersoonProtocolleerBerichtService . bepaalDatumTijdEindeFormelePeriodeResultaat ( bevragingVerzoek , datumTijdKlaarzettenBericht ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( datumTijdEindeFormelePeriodeResultaat , org . hamcrest . core . Is . is ( datumTijdKlaarzettenBericht ) )", "total": "bepaalDatumTijdEindeFormelePeriodeResultaat ( ) { final java . time . ZonedDateTime datumTijdKlaarzettenBericht = nl . bzk . algemeenbrp . util . common . DatumUtil . nuAlsZonedDateTime ( ) ; final java . time . ZonedDateTime datumTijdEindeFormelePeriodeResultaat = zoekPersoonProtocolleerBerichtService . bepaalDatumTijdEindeFormelePeriodeResultaat ( bevragingVerzoek , datumTijdKlaarzettenBericht ) ; \"<AssertPlaceHolder>\" ; } bepaalDatumTijdEindeFormelePeriodeResultaat ( nl . bzk . brp . service . bevraging . geefmedebewoners . GeefMedebewonersVerzoek , java . time . ZonedDateTime ) { return datumTijdKlaarzettenBericht ; }", "answer": "org . junit . Assert . assertThat ( datumTijdEindeFormelePeriodeResultaat , org . hamcrest . core . Is . is ( datumTijdKlaarzettenBericht ) )"}
{"focal": "toString ( ) { return ( ( ( \"spacemanager={\" + ( destination ) ) + \",<sp>\" ) + ( inner ) ) + \"}\" ; }", "testMethod": "testParsingToStringOutputWithEqualsOptionKey ( ) { org . dcache . util . Args original = new org . dcache . util . Args ( \"-foo\\\\=bar=baz\" ) ; org . dcache . util . Args parsed = new org . dcache . util . Args ( original . toString ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( parsed , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( original ) ) )", "total": "testParsingToStringOutputWithEqualsOptionKey ( ) { org . dcache . util . Args original = new org . dcache . util . Args ( \"-foo\\\\=bar=baz\" ) ; org . dcache . util . Args parsed = new org . dcache . util . Args ( original . toString ( ) ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return ( ( ( \"spacemanager={\" + ( destination ) ) + \",<sp>\" ) + ( inner ) ) + \"}\" ; }", "answer": "org . junit . Assert . assertThat ( parsed , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( original ) ) )"}
{"focal": "get_partitions_pspec ( java . lang . String , java . lang . String , int ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = databaseMappingService . databaseMapping ( db_name ) ; java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > partitionSpecs = mapping . getClient ( ) . get_partitions_pspec ( mapping . transformInboundDatabaseName ( db_name ) , tbl_name , max_parts ) ; return mapping . transformOutboundPartitionSpecs ( partitionSpecs ) ; }", "testMethod": "get_partitions_pspec ( ) { java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > partitionSpecs = com . google . common . collect . Lists . newArrayList ( ) ; java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > outbound = com . google . common . collect . Lists . newArrayList ( ) ; when ( primaryMapping . transformInboundDatabaseName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ) . thenReturn ( \"inbound\" ) ; when ( primaryClient . get_partitions_pspec ( \"inbound\" , \"table\" , ( ( short ) ( 10 ) ) ) ) . thenReturn ( partitionSpecs ) ; when ( primaryMapping . transformOutboundPartitionSpecs ( partitionSpecs ) ) . thenReturn ( outbound ) ; java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > result = handler . get_partitions_pspec ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P , \"table\" , ( ( short ) ( 10 ) ) ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping , never ( ) ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )", "total": "get_partitions_pspec ( ) { java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > partitionSpecs = com . google . common . collect . Lists . newArrayList ( ) ; java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > outbound = com . google . common . collect . Lists . newArrayList ( ) ; when ( primaryMapping . transformInboundDatabaseName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ) . thenReturn ( \"inbound\" ) ; when ( primaryClient . get_partitions_pspec ( \"inbound\" , \"table\" , ( ( short ) ( 10 ) ) ) ) . thenReturn ( partitionSpecs ) ; when ( primaryMapping . transformOutboundPartitionSpecs ( partitionSpecs ) ) . thenReturn ( outbound ) ; java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > result = handler . get_partitions_pspec ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P , \"table\" , ( ( short ) ( 10 ) ) ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping , never ( ) ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; } get_partitions_pspec ( java . lang . String , java . lang . String , int ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = databaseMappingService . databaseMapping ( db_name ) ; java . util . List < org . apache . hadoop . hive . metastore . api . PartitionSpec > partitionSpecs = mapping . getClient ( ) . get_partitions_pspec ( mapping . transformInboundDatabaseName ( db_name ) , tbl_name , max_parts ) ; return mapping . transformOutboundPartitionSpecs ( partitionSpecs ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )"}
{"focal": "of ( java . lang . String , java . util . SortedSet ) { return new org . batfish . common . Container ( name , testrigs ) ; }", "testMethod": "testComputeRoutesWithNextHop ( ) { java . lang . String c1 = \"c1\" ; java . lang . String v1 = \"v1\" ; java . lang . String v2 = \"v2\" ; java . lang . String i1 = \"i1\" ; org . batfish . datamodel . ConnectedRoute r1 = new org . batfish . datamodel . ConnectedRoute ( org . batfish . datamodel . ForwardingAnalysisImplTest . P1 , i1 ) ; final org . batfish . datamodel . MockFib mockFib = org . batfish . datamodel . MockFib . builder ( ) . setFibEntries ( com . google . common . collect . ImmutableMap . of ( Ip . AUTO , com . google . common . collect . ImmutableSet . of ( new org . batfish . datamodel . FibEntry ( Ip . AUTO , i1 , com . google . common . collect . ImmutableList . of ( r1 ) ) ) ) ) . build ( ) ; java . util . Map < java . lang . String , java . util . Map < java . lang . String , org . batfish . datamodel . Fib > > fibs = com . google . common . collect . ImmutableMap . of ( c1 , com . google . common . collect . ImmutableMap . of ( v1 , mockFib , v2 , mockFib ) ) ; org . batfish . datamodel . Configuration config = _cb . setHostname ( c1 ) . build ( ) ; org . batfish . datamodel . Vrf vrf1 = _vb . setName ( v1 ) . setOwner ( config ) . build ( ) ; _vb . setName ( v2 ) . setOwner ( config ) . build ( ) ; _ib . setName ( i1 ) . setVrf ( vrf1 ) . setOwner ( config ) . build ( ) ; java . util . Map < java . lang . String , java . util . Map < java . lang . String , java . util . Map < java . lang . String , java . util . Set < org . batfish . datamodel . AbstractRoute > > > > result = org . batfish . datamodel . ForwardingAnalysisImpl . computeRoutesWithNextHop ( fibs ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( com . google . common . collect . ImmutableMap . of ( c1 , com . google . common . collect . ImmutableMap . of ( v1 , com . google . common . collect . ImmutableMap . of ( i1 , com . google . common . collect . ImmutableSet . of ( r1 ) ) , v2 , com . google . common . collect . ImmutableMap . of ( i1 , com . google . common . collect . ImmutableSet . of ( r1 ) ) ) ) ) )", "total": "testComputeRoutesWithNextHop ( ) { java . lang . String c1 = \"c1\" ; java . lang . String v1 = \"v1\" ; java . lang . String v2 = \"v2\" ; java . lang . String i1 = \"i1\" ; org . batfish . datamodel . ConnectedRoute r1 = new org . batfish . datamodel . ConnectedRoute ( org . batfish . datamodel . ForwardingAnalysisImplTest . P1 , i1 ) ; final org . batfish . datamodel . MockFib mockFib = org . batfish . datamodel . MockFib . builder ( ) . setFibEntries ( com . google . common . collect . ImmutableMap . of ( Ip . AUTO , com . google . common . collect . ImmutableSet . of ( new org . batfish . datamodel . FibEntry ( Ip . AUTO , i1 , com . google . common . collect . ImmutableList . of ( r1 ) ) ) ) ) . build ( ) ; java . util . Map < java . lang . String , java . util . Map < java . lang . String , org . batfish . datamodel . Fib > > fibs = com . google . common . collect . ImmutableMap . of ( c1 , com . google . common . collect . ImmutableMap . of ( v1 , mockFib , v2 , mockFib ) ) ; org . batfish . datamodel . Configuration config = _cb . setHostname ( c1 ) . build ( ) ; org . batfish . datamodel . Vrf vrf1 = _vb . setName ( v1 ) . setOwner ( config ) . build ( ) ; _vb . setName ( v2 ) . setOwner ( config ) . build ( ) ; _ib . setName ( i1 ) . setVrf ( vrf1 ) . setOwner ( config ) . build ( ) ; java . util . Map < java . lang . String , java . util . Map < java . lang . String , java . util . Map < java . lang . String , java . util . Set < org . batfish . datamodel . AbstractRoute > > > > result = org . batfish . datamodel . ForwardingAnalysisImpl . computeRoutesWithNextHop ( fibs ) ; \"<AssertPlaceHolder>\" ; } of ( java . lang . String , java . util . SortedSet ) { return new org . batfish . common . Container ( name , testrigs ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( com . google . common . collect . ImmutableMap . of ( c1 , com . google . common . collect . ImmutableMap . of ( v1 , com . google . common . collect . ImmutableMap . of ( i1 , com . google . common . collect . ImmutableSet . of ( r1 ) ) , v2 , com . google . common . collect . ImmutableMap . of ( i1 , com . google . common . collect . ImmutableSet . of ( r1 ) ) ) ) ) )"}
{"focal": "parseIsoDate ( java . lang . String ) { return com . metservice . kanban . utils . DateUtils . ISO_FORMAT . parseDateTime ( dateString ) . toLocalDate ( ) ; }", "testMethod": "canCalculateTheFirstDateForACollectionOfWorkItems ( ) { com . metservice . kanban . model . WorkItem workItem1 = new com . metservice . kanban . model . WorkItem ( 1 , TWO_PHASES ) ; workItem1 . setDateAsString ( \"phase<sp>1\" , \"2011-06-02\" ) ; workItem1 . setDateAsString ( \"phase<sp>2\" , \"2011-06-03\" ) ; com . metservice . kanban . model . WorkItem workItem2 = new com . metservice . kanban . model . WorkItem ( 2 , TWO_PHASES ) ; workItem2 . setDateAsString ( \"phase<sp>1\" , \"2011-06-01\" ) ; workItem2 . setDateAsString ( \"phase<sp>2\" , \"2011-06-03\" ) ; org . joda . time . LocalDate date = com . metservice . kanban . charts . ChartUtils . getFirstDate ( asList ( workItem1 , workItem2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( date , org . hamcrest . core . Is . is ( parseIsoDate ( \"2011-06-01\" ) ) )", "total": "canCalculateTheFirstDateForACollectionOfWorkItems ( ) { com . metservice . kanban . model . WorkItem workItem1 = new com . metservice . kanban . model . WorkItem ( 1 , TWO_PHASES ) ; workItem1 . setDateAsString ( \"phase<sp>1\" , \"2011-06-02\" ) ; workItem1 . setDateAsString ( \"phase<sp>2\" , \"2011-06-03\" ) ; com . metservice . kanban . model . WorkItem workItem2 = new com . metservice . kanban . model . WorkItem ( 2 , TWO_PHASES ) ; workItem2 . setDateAsString ( \"phase<sp>1\" , \"2011-06-01\" ) ; workItem2 . setDateAsString ( \"phase<sp>2\" , \"2011-06-03\" ) ; org . joda . time . LocalDate date = com . metservice . kanban . charts . ChartUtils . getFirstDate ( asList ( workItem1 , workItem2 ) ) ; \"<AssertPlaceHolder>\" ; } parseIsoDate ( java . lang . String ) { return com . metservice . kanban . utils . DateUtils . ISO_FORMAT . parseDateTime ( dateString ) . toLocalDate ( ) ; }", "answer": "org . junit . Assert . assertThat ( date , org . hamcrest . core . Is . is ( parseIsoDate ( \"2011-06-01\" ) ) )"}
{"focal": "getType ( ) { return \"number\" ; }", "testMethod": "doStartSkipsInvalidCsel ( ) { org . sonatype . nexus . selector . SelectorConfiguration jexlSelector = createSelector ( \"invalid\" , JexlSelector . TYPE ) ; when ( selectorManager . browseJexl ( ) ) . thenReturn ( asList ( jexlSelector ) ) ; java . lang . String expression = jexlSelector . getAttributes ( ) . get ( \"expression\" ) ; doThrow ( org . sonatype . nexus . selector . SelectorEvaluationException . class ) . when ( selectorFactory ) . validateSelector ( CselSelector . TYPE , expression ) ; manager . doStart ( ) ; verify ( selectorManager ) . browseJexl ( ) ; \"<AssertPlaceHolder>\" ; verifyNoMoreInteractions ( selectorManager ) ; }", "assertLine": "org . junit . Assert . assertThat ( jexlSelector . getType ( ) , org . hamcrest . CoreMatchers . is ( JexlSelector . TYPE ) )", "total": "doStartSkipsInvalidCsel ( ) { org . sonatype . nexus . selector . SelectorConfiguration jexlSelector = createSelector ( \"invalid\" , JexlSelector . TYPE ) ; when ( selectorManager . browseJexl ( ) ) . thenReturn ( asList ( jexlSelector ) ) ; java . lang . String expression = jexlSelector . getAttributes ( ) . get ( \"expression\" ) ; doThrow ( org . sonatype . nexus . selector . SelectorEvaluationException . class ) . when ( selectorFactory ) . validateSelector ( CselSelector . TYPE , expression ) ; manager . doStart ( ) ; verify ( selectorManager ) . browseJexl ( ) ; \"<AssertPlaceHolder>\" ; verifyNoMoreInteractions ( selectorManager ) ; } getType ( ) { return \"number\" ; }", "answer": "org . junit . Assert . assertThat ( jexlSelector . getType ( ) , org . hamcrest . CoreMatchers . is ( JexlSelector . TYPE ) )"}
{"focal": "getValue ( ) { final int state = com . allanbank . mongodb . client . FutureCallback . Sync . getState ( ) ; switch ( state ) { case com . allanbank . mongodb . client . FutureCallback . Sync . COMPLETED : if ( ( myException ) != null ) { throw new java . util . concurrent . ExecutionException ( myException ) ; } return myValue ; case com . allanbank . mongodb . client . FutureCallback . Sync . CANCELED : case com . allanbank . mongodb . client . FutureCallback . Sync . INTERRUPTED : final java . util . concurrent . CancellationException cancellation = new java . util . concurrent . CancellationException ( \"Future<sp>was<sp>canceled.\" ) ; cancellation . initCause ( myException ) ; throw cancellation ; default : throw new java . lang . IllegalStateException ( ( \"Sync<sp>in<sp>invalid<sp>state:<sp>\" + state ) ) ; } }", "testMethod": "testParallelScanAsync ( ) { final com . allanbank . mongodb . Callback < java . util . Collection < com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > > > mockCallback = createMock ( com . allanbank . mongodb . Callback . class ) ; final com . allanbank . mongodb . client . ClusterStats mockStats = createMock ( com . allanbank . mongodb . client . ClusterStats . class ) ; final com . allanbank . mongodb . bson . builder . DocumentBuilder commandDoc = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; commandDoc . add ( \"parallelCollectionScan\" , \"test\" ) ; commandDoc . add ( \"numCursors\" , 2 ) ; final com . allanbank . mongodb . bson . builder . DocumentBuilder replyDoc = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; replyDoc . add ( \"ok\" , 1 ) ; replyDoc . pushArray ( \"cursors\" ) . push ( ) . push ( \"cursor\" ) . add ( \"id\" , 1234 ) . pushArray ( \"firstBatch\" ) ; final com . allanbank . mongodb . builder . ParallelScan . Builder scan = com . allanbank . mongodb . builder . ParallelScan . builder ( ) . requestedIteratorCount ( 2 ) . readPreference ( ReadPreference . PREFER_SECONDARY ) ; final com . allanbank . mongodb . client . message . ParallelScanCommand commandMsg = new com . allanbank . mongodb . client . message . ParallelScanCommand ( scan . build ( ) , \"test\" , \"test\" , commandDoc . build ( ) , com . allanbank . mongodb . ReadPreference . PREFER_SECONDARY ) ; expect ( myMockClient . getClusterType ( ) ) . andReturn ( ClusterType . REPLICA_SET ) ; expect ( myMockDatabase . getName ( ) ) . andReturn ( \"test\" ) ; myMockClient . send ( eq ( commandMsg ) , com . allanbank . mongodb . AnswerCallback . callback ( reply ( replyDoc . build ( ) ) ) ) ; expectLastCall ( ) ; org . easymock . Capture < java . util . Collection < com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > > > capture ; capture = new org . easymock . Capture < java . util . Collection < com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > > > ( ) ; mockCallback . callback ( capture ( capture ) ) ; expectLastCall ( ) ; replay ( mockCallback , mockStats ) ; myTestInstance . parallelScanAsync ( mockCallback , scan ) ; verify ( mockCallback , mockStats ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( capture . getValue ( ) . size ( ) , org . hamcrest . Matchers . is ( 1 ) )", "total": "testParallelScanAsync ( ) { final com . allanbank . mongodb . Callback < java . util . Collection < com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > > > mockCallback = createMock ( com . allanbank . mongodb . Callback . class ) ; final com . allanbank . mongodb . client . ClusterStats mockStats = createMock ( com . allanbank . mongodb . client . ClusterStats . class ) ; final com . allanbank . mongodb . bson . builder . DocumentBuilder commandDoc = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; commandDoc . add ( \"parallelCollectionScan\" , \"test\" ) ; commandDoc . add ( \"numCursors\" , 2 ) ; final com . allanbank . mongodb . bson . builder . DocumentBuilder replyDoc = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; replyDoc . add ( \"ok\" , 1 ) ; replyDoc . pushArray ( \"cursors\" ) . push ( ) . push ( \"cursor\" ) . add ( \"id\" , 1234 ) . pushArray ( \"firstBatch\" ) ; final com . allanbank . mongodb . builder . ParallelScan . Builder scan = com . allanbank . mongodb . builder . ParallelScan . builder ( ) . requestedIteratorCount ( 2 ) . readPreference ( ReadPreference . PREFER_SECONDARY ) ; final com . allanbank . mongodb . client . message . ParallelScanCommand commandMsg = new com . allanbank . mongodb . client . message . ParallelScanCommand ( scan . build ( ) , \"test\" , \"test\" , commandDoc . build ( ) , com . allanbank . mongodb . ReadPreference . PREFER_SECONDARY ) ; expect ( myMockClient . getClusterType ( ) ) . andReturn ( ClusterType . REPLICA_SET ) ; expect ( myMockDatabase . getName ( ) ) . andReturn ( \"test\" ) ; myMockClient . send ( eq ( commandMsg ) , com . allanbank . mongodb . AnswerCallback . callback ( reply ( replyDoc . build ( ) ) ) ) ; expectLastCall ( ) ; org . easymock . Capture < java . util . Collection < com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > > > capture ; capture = new org . easymock . Capture < java . util . Collection < com . allanbank . mongodb . MongoIterator < com . allanbank . mongodb . bson . Document > > > ( ) ; mockCallback . callback ( capture ( capture ) ) ; expectLastCall ( ) ; replay ( mockCallback , mockStats ) ; myTestInstance . parallelScanAsync ( mockCallback , scan ) ; verify ( mockCallback , mockStats ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { final int state = com . allanbank . mongodb . client . FutureCallback . Sync . getState ( ) ; switch ( state ) { case com . allanbank . mongodb . client . FutureCallback . Sync . COMPLETED : if ( ( myException ) != null ) { throw new java . util . concurrent . ExecutionException ( myException ) ; } return myValue ; case com . allanbank . mongodb . client . FutureCallback . Sync . CANCELED : case com . allanbank . mongodb . client . FutureCallback . Sync . INTERRUPTED : final java . util . concurrent . CancellationException cancellation = new java . util . concurrent . CancellationException ( \"Future<sp>was<sp>canceled.\" ) ; cancellation . initCause ( myException ) ; throw cancellation ; default : throw new java . lang . IllegalStateException ( ( \"Sync<sp>in<sp>invalid<sp>state:<sp>\" + state ) ) ; } }", "answer": "org . junit . Assert . assertThat ( capture . getValue ( ) . size ( ) , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "deletionOfAResourceByANonAuthenticatedUser ( ) { try { resource ( ) . path ( aResourceURI ( ) ) . request ( MediaType . APPLICATION_JSON ) . delete ( ) ; org . junit . Assert . fail ( \"A<sp>non<sp>authenticated<sp>user<sp>shouldn't<sp>delete<sp>a<sp>resource\" ) ; } catch ( javax . ws . rs . WebApplicationException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int unauthorized = Status . UNAUTHORIZED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( unauthorized ) )", "total": "deletionOfAResourceByANonAuthenticatedUser ( ) { try { resource ( ) . path ( aResourceURI ( ) ) . request ( MediaType . APPLICATION_JSON ) . delete ( ) ; org . junit . Assert . fail ( \"A<sp>non<sp>authenticated<sp>user<sp>shouldn't<sp>delete<sp>a<sp>resource\" ) ; } catch ( javax . ws . rs . WebApplicationException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int unauthorized = Status . UNAUTHORIZED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( unauthorized ) )"}
{"focal": "position ( ) { return position ; }", "testMethod": "marksPosition ( ) { int [ ] array = new int [ ] { 2 , 3 , 5 , 7 } ; java . nio . IntBuffer buffer = java . nio . IntBuffer . wrap ( array ) ; buffer . position ( 1 ) ; buffer . mark ( ) ; buffer . position ( 2 ) ; buffer . reset ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( buffer . position ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "marksPosition ( ) { int [ ] array = new int [ ] { 2 , 3 , 5 , 7 } ; java . nio . IntBuffer buffer = java . nio . IntBuffer . wrap ( array ) ; buffer . position ( 1 ) ; buffer . mark ( ) ; buffer . position ( 2 ) ; buffer . reset ( ) ; \"<AssertPlaceHolder>\" ; } position ( ) { return position ; }", "answer": "org . junit . Assert . assertThat ( buffer . position ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "metadata ( ) { return new uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher ( ) ; }", "testMethod": "shouldMatchWithNoSettings ( ) { final uk . gov . justice . services . messaging . Metadata metadata = metadataWithRandomUUID ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . EVENT_NAME ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( metadata , uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher . metadata ( ) )", "total": "shouldMatchWithNoSettings ( ) { final uk . gov . justice . services . messaging . Metadata metadata = metadataWithRandomUUID ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . EVENT_NAME ) . build ( ) ; \"<AssertPlaceHolder>\" ; } metadata ( ) { return new uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher ( ) ; }", "answer": "org . junit . Assert . assertThat ( metadata , uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher . metadata ( ) )"}
{"focal": "toServiceObject ( ) { return new org . batfish . referencelibrary . ServiceObject ( ipProtocol , name , ports ) ; }", "testMethod": "conversionToAndFrom ( ) { org . batfish . referencelibrary . ServiceObject serviceObject = new org . batfish . referencelibrary . ServiceObject ( org . batfish . datamodel . IpProtocol . TCP , \"so\" , new org . batfish . datamodel . SubRange ( 1 , 2 ) ) ; org . batfish . coordinator . resources . ServiceObjectBean bean = new org . batfish . coordinator . resources . ServiceObjectBean ( serviceObject ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( new org . batfish . coordinator . resources . ServiceObjectBean ( bean . toServiceObject ( ) ) , org . hamcrest . Matchers . equalTo ( bean ) )", "total": "conversionToAndFrom ( ) { org . batfish . referencelibrary . ServiceObject serviceObject = new org . batfish . referencelibrary . ServiceObject ( org . batfish . datamodel . IpProtocol . TCP , \"so\" , new org . batfish . datamodel . SubRange ( 1 , 2 ) ) ; org . batfish . coordinator . resources . ServiceObjectBean bean = new org . batfish . coordinator . resources . ServiceObjectBean ( serviceObject ) ; \"<AssertPlaceHolder>\" ; } toServiceObject ( ) { return new org . batfish . referencelibrary . ServiceObject ( ipProtocol , name , ports ) ; }", "answer": "org . junit . Assert . assertThat ( new org . batfish . coordinator . resources . ServiceObjectBean ( bean . toServiceObject ( ) ) , org . hamcrest . Matchers . equalTo ( bean ) )"}
{"focal": "getContent ( ) { return content ; }", "testMethod": "getContent ( ) { expect ( backend . getContent ( endpointNode ) ) . andReturn ( org . talend . esb . servicelocator . TestContent . CONTENT_ANY_1 ) ; replay ( backend ) ; byte [ ] content = endpointNode . getContent ( ) ; \"<AssertPlaceHolder>\" ; verify ( backend ) ; }", "assertLine": "org . junit . Assert . assertThat ( content , org . hamcrest . Matchers . equalTo ( org . talend . esb . servicelocator . TestContent . CONTENT_ANY_1 ) )", "total": "getContent ( ) { expect ( backend . getContent ( endpointNode ) ) . andReturn ( org . talend . esb . servicelocator . TestContent . CONTENT_ANY_1 ) ; replay ( backend ) ; byte [ ] content = endpointNode . getContent ( ) ; \"<AssertPlaceHolder>\" ; verify ( backend ) ; } getContent ( ) { return content ; }", "answer": "org . junit . Assert . assertThat ( content , org . hamcrest . Matchers . equalTo ( org . talend . esb . servicelocator . TestContent . CONTENT_ANY_1 ) )"}
{"focal": "getTenantId ( ) { return tenantId ; }", "testMethod": "getCaseDefinitionWithAuthenticatedTenant ( ) { identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyCaseDefinitionCmdsTenantCheckTest . TENANT_ONE ) ) ; org . camunda . bpm . engine . repository . CaseDefinition definition = repositoryService . getCaseDefinition ( caseDefinitionId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( definition . getTenantId ( ) , org . hamcrest . CoreMatchers . is ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyCaseDefinitionCmdsTenantCheckTest . TENANT_ONE ) )", "total": "getCaseDefinitionWithAuthenticatedTenant ( ) { identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyCaseDefinitionCmdsTenantCheckTest . TENANT_ONE ) ) ; org . camunda . bpm . engine . repository . CaseDefinition definition = repositoryService . getCaseDefinition ( caseDefinitionId ) ; \"<AssertPlaceHolder>\" ; } getTenantId ( ) { return tenantId ; }", "answer": "org . junit . Assert . assertThat ( definition . getTenantId ( ) , org . hamcrest . CoreMatchers . is ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyCaseDefinitionCmdsTenantCheckTest . TENANT_ONE ) )"}
{"focal": "read ( java . io . File ) { try { return java . nio . file . Files . readAllLines ( file . toPath ( ) ) . stream ( ) . findFirst ( ) . orElseThrow ( ( ) -> new java . lang . AssertionError ( file ) ) ; } catch ( java . io . IOException e ) { throw new java . lang . AssertionError ( e ) ; } }", "testMethod": "begin_field_field_separator ( ) { java . lang . String [ ] [ ] result = read ( \",\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"\" } } ) )", "total": "begin_field_field_separator ( ) { java . lang . String [ ] [ ] result = read ( \",\" ) ; \"<AssertPlaceHolder>\" ; } read ( java . io . File ) { try { return java . nio . file . Files . readAllLines ( file . toPath ( ) ) . stream ( ) . findFirst ( ) . orElseThrow ( ( ) -> new java . lang . AssertionError ( file ) ) ; } catch ( java . io . IOException e ) { throw new java . lang . AssertionError ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"\" } } ) )"}
{"focal": "tenant ( ) { if ( ( authenticatedDevice ) != null ) { return authenticatedDevice . getTenantId ( ) ; } else if ( ( topic ) != null ) { return topic . getTenantId ( ) ; } else { return null ; } }", "testMethod": "testTenantIsRetrievedFromAuthenticatedDevice ( ) { final io . vertx . mqtt . messages . MqttPublishMessage msg = mock ( io . vertx . mqtt . messages . MqttPublishMessage . class ) ; when ( msg . topicName ( ) ) . thenReturn ( \"t\" ) ; final org . eclipse . hono . auth . Device device = new org . eclipse . hono . auth . Device ( \"tenant\" , \"device\" ) ; final org . eclipse . hono . adapter . mqtt . MqttContext context = org . eclipse . hono . adapter . mqtt . MqttContext . fromPublishPacket ( msg , mock ( io . vertx . mqtt . MqttEndpoint . class ) , device ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( context . tenant ( ) , org . hamcrest . CoreMatchers . is ( \"tenant\" ) )", "total": "testTenantIsRetrievedFromAuthenticatedDevice ( ) { final io . vertx . mqtt . messages . MqttPublishMessage msg = mock ( io . vertx . mqtt . messages . MqttPublishMessage . class ) ; when ( msg . topicName ( ) ) . thenReturn ( \"t\" ) ; final org . eclipse . hono . auth . Device device = new org . eclipse . hono . auth . Device ( \"tenant\" , \"device\" ) ; final org . eclipse . hono . adapter . mqtt . MqttContext context = org . eclipse . hono . adapter . mqtt . MqttContext . fromPublishPacket ( msg , mock ( io . vertx . mqtt . MqttEndpoint . class ) , device ) ; \"<AssertPlaceHolder>\" ; } tenant ( ) { if ( ( authenticatedDevice ) != null ) { return authenticatedDevice . getTenantId ( ) ; } else if ( ( topic ) != null ) { return topic . getTenantId ( ) ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( context . tenant ( ) , org . hamcrest . CoreMatchers . is ( \"tenant\" ) )"}
{"focal": "getFieldValueByName ( T , java . lang . String ) { java . lang . reflect . Field field ; try { field = object . getClass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; } catch ( java . lang . NoSuchFieldException e ) { field = object . getClass ( ) . getSuperclass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; } return field . get ( object ) ; }", "testMethod": "unmarshallerShouldBeCreatedWhenItIsNull ( ) { when ( dtoUnmarshallerFactory . newUnmarshaller ( java . lang . Object . class ) ) . thenReturn ( unmarshaller ) ; org . eclipse . che . ide . rest . AsyncRequestCallback < java . lang . Object > asyncCallback = callbackBuilder . unmarshaller ( java . lang . Object . class ) . success ( successCallback ) . failure ( failureCallback ) . build ( ) ; org . eclipse . che . ide . rest . Unmarshallable < java . lang . Object > unmarshallerValue = ( ( org . eclipse . che . ide . rest . Unmarshallable ) ( org . eclipse . che . ide . ext . runner . client . TestUtil . getFieldValueByName ( asyncCallback , org . eclipse . che . ide . ext . runner . client . callbacks . AsyncCallbackBuilderTest . UNMARSHALLER_FIELD_NAME ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( unmarshallerValue , org . hamcrest . CoreMatchers . equalTo ( unmarshaller ) )", "total": "unmarshallerShouldBeCreatedWhenItIsNull ( ) { when ( dtoUnmarshallerFactory . newUnmarshaller ( java . lang . Object . class ) ) . thenReturn ( unmarshaller ) ; org . eclipse . che . ide . rest . AsyncRequestCallback < java . lang . Object > asyncCallback = callbackBuilder . unmarshaller ( java . lang . Object . class ) . success ( successCallback ) . failure ( failureCallback ) . build ( ) ; org . eclipse . che . ide . rest . Unmarshallable < java . lang . Object > unmarshallerValue = ( ( org . eclipse . che . ide . rest . Unmarshallable ) ( org . eclipse . che . ide . ext . runner . client . TestUtil . getFieldValueByName ( asyncCallback , org . eclipse . che . ide . ext . runner . client . callbacks . AsyncCallbackBuilderTest . UNMARSHALLER_FIELD_NAME ) ) ) ; \"<AssertPlaceHolder>\" ; } getFieldValueByName ( T , java . lang . String ) { java . lang . reflect . Field field ; try { field = object . getClass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; } catch ( java . lang . NoSuchFieldException e ) { field = object . getClass ( ) . getSuperclass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; } return field . get ( object ) ; }", "answer": "org . junit . Assert . assertThat ( unmarshallerValue , org . hamcrest . CoreMatchers . equalTo ( unmarshaller ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "loadFlow ( ) { java . util . Map < com . asakusafw . yaess . core . ExecutionPhase , java . util . List < ? extends com . asakusafw . yaess . core . ExecutionScript > > exec = new java . util . HashMap ( ) ; exec . put ( ExecutionPhase . IMPORT , java . util . Arrays . asList ( command ( 0 ) ) ) ; exec . put ( ExecutionPhase . MAIN , java . util . Arrays . asList ( hadoop ( 1 ) , command ( 2 , 1 ) ) ) ; exec . put ( ExecutionPhase . EXPORT , java . util . Arrays . asList ( command ( 100 ) ) ) ; java . util . Set < com . asakusafw . yaess . core . ExecutionScript . Kind > kinds = java . util . EnumSet . allOf ( ExecutionScript . Kind . class ) ; com . asakusafw . yaess . core . FlowScript script = new com . asakusafw . yaess . core . FlowScript ( \"testing\" , set ( \"b1\" , \"b2\" ) , exec , kinds ) ; exec . put ( ExecutionPhase . INITIALIZE , java . util . Arrays . asList ( command ( 100 ) ) ) ; com . asakusafw . yaess . core . FlowScript dummy = new com . asakusafw . yaess . core . FlowScript ( \"dummy\" , set ( ) , exec , kinds ) ; java . util . Properties p = new java . util . Properties ( ) ; script . storeTo ( p ) ; dummy . storeTo ( p ) ; com . asakusafw . yaess . core . FlowScript loaded = com . asakusafw . yaess . core . FlowScript . load ( p , \"testing\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( loaded , is ( script ) )", "total": "loadFlow ( ) { java . util . Map < com . asakusafw . yaess . core . ExecutionPhase , java . util . List < ? extends com . asakusafw . yaess . core . ExecutionScript > > exec = new java . util . HashMap ( ) ; exec . put ( ExecutionPhase . IMPORT , java . util . Arrays . asList ( command ( 0 ) ) ) ; exec . put ( ExecutionPhase . MAIN , java . util . Arrays . asList ( hadoop ( 1 ) , command ( 2 , 1 ) ) ) ; exec . put ( ExecutionPhase . EXPORT , java . util . Arrays . asList ( command ( 100 ) ) ) ; java . util . Set < com . asakusafw . yaess . core . ExecutionScript . Kind > kinds = java . util . EnumSet . allOf ( ExecutionScript . Kind . class ) ; com . asakusafw . yaess . core . FlowScript script = new com . asakusafw . yaess . core . FlowScript ( \"testing\" , set ( \"b1\" , \"b2\" ) , exec , kinds ) ; exec . put ( ExecutionPhase . INITIALIZE , java . util . Arrays . asList ( command ( 100 ) ) ) ; com . asakusafw . yaess . core . FlowScript dummy = new com . asakusafw . yaess . core . FlowScript ( \"dummy\" , set ( ) , exec , kinds ) ; java . util . Properties p = new java . util . Properties ( ) ; script . storeTo ( p ) ; dummy . storeTo ( p ) ; com . asakusafw . yaess . core . FlowScript loaded = com . asakusafw . yaess . core . FlowScript . load ( p , \"testing\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( loaded , is ( script ) )"}
{"focal": "getQuery ( ) { java . lang . StringBuilder query = new java . lang . StringBuilder ( ) ; query . append ( getEdmEntityName ( ) ) ; if ( ! ( isSingletonEntity ( ) ) ) { query . append ( generateParameters ( ) ) ; } return query . toString ( ) ; }", "testMethod": "createUnboundFunctionQueryWithoutParams ( ) { com . sdl . odata . client . api . ODataClientQuery query = new com . sdl . odata . client . FunctionImportClientQuery . Builder ( ) . withEntityType ( com . sdl . odata . client . DefaultODataClientQueryTest . EmptyEntity . class ) . withFunctionName ( \"SampleFunction\" ) . build ( ) ; java . lang . String expectedToString = \"SampleFunction\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . getQuery ( ) , org . hamcrest . core . Is . is ( expectedToString ) )", "total": "createUnboundFunctionQueryWithoutParams ( ) { com . sdl . odata . client . api . ODataClientQuery query = new com . sdl . odata . client . FunctionImportClientQuery . Builder ( ) . withEntityType ( com . sdl . odata . client . DefaultODataClientQueryTest . EmptyEntity . class ) . withFunctionName ( \"SampleFunction\" ) . build ( ) ; java . lang . String expectedToString = \"SampleFunction\" ; \"<AssertPlaceHolder>\" ; } getQuery ( ) { java . lang . StringBuilder query = new java . lang . StringBuilder ( ) ; query . append ( getEdmEntityName ( ) ) ; if ( ! ( isSingletonEntity ( ) ) ) { query . append ( generateParameters ( ) ) ; } return query . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( query . getQuery ( ) , org . hamcrest . core . Is . is ( expectedToString ) )"}
{"focal": "indexOf ( T ) { return - 1 ; }", "testMethod": "indexOf_A$Object ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . String elem = \"foo\" ; int actual = nil . indexOf ( elem ) ; int expected = - 1 ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "indexOf_A$Object ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . String elem = \"foo\" ; int actual = nil . indexOf ( elem ) ; int expected = - 1 ; \"<AssertPlaceHolder>\" ; } indexOf ( T ) { return - 1 ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "size ( ) { return this . cells . size ( ) ; }", "testMethod": "size_napthalene ( ) { int [ ] [ ] napthalene = org . openscience . cdk . graph . InitialCyclesTest . naphthalene ( ) ; org . openscience . cdk . graph . MinimumCycleBasis mcb = new org . openscience . cdk . graph . MinimumCycleBasis ( napthalene ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mcb . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "size_napthalene ( ) { int [ ] [ ] napthalene = org . openscience . cdk . graph . InitialCyclesTest . naphthalene ( ) ; org . openscience . cdk . graph . MinimumCycleBasis mcb = new org . openscience . cdk . graph . MinimumCycleBasis ( napthalene ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . cells . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( mcb . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "getCacheExpiresHours ( ) { return cacheExpiresHours ; }", "testMethod": "givenZeroValue_whenSetCacheExpiresHours_thenValueIsStored ( ) { final long validCacheExpiresHours = 0 ; config . setCacheExpiresHours ( validCacheExpiresHours ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( config . getCacheExpiresHours ( ) , org . hamcrest . CoreMatchers . equalTo ( validCacheExpiresHours ) )", "total": "givenZeroValue_whenSetCacheExpiresHours_thenValueIsStored ( ) { final long validCacheExpiresHours = 0 ; config . setCacheExpiresHours ( validCacheExpiresHours ) ; \"<AssertPlaceHolder>\" ; } getCacheExpiresHours ( ) { return cacheExpiresHours ; }", "answer": "org . junit . Assert . assertThat ( config . getCacheExpiresHours ( ) , org . hamcrest . CoreMatchers . equalTo ( validCacheExpiresHours ) )"}
{"focal": "getMaxWorkers ( ) { return workerTool . getMaxWorkers ( ) ; }", "testMethod": "testDefaultGetMaxWorkers ( ) { com . facebook . buck . shell . WorkerTool workerTool = com . facebook . buck . shell . WorkerToolDescriptionTest . createWorkerToolWithDefaultSettings ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( workerTool . getMaxWorkers ( ) , org . hamcrest . Matchers . equalTo ( 1 ) )", "total": "testDefaultGetMaxWorkers ( ) { com . facebook . buck . shell . WorkerTool workerTool = com . facebook . buck . shell . WorkerToolDescriptionTest . createWorkerToolWithDefaultSettings ( ) ; \"<AssertPlaceHolder>\" ; } getMaxWorkers ( ) { return workerTool . getMaxWorkers ( ) ; }", "answer": "org . junit . Assert . assertThat ( workerTool . getMaxWorkers ( ) , org . hamcrest . Matchers . equalTo ( 1 ) )"}
{"focal": "get ( br . com . caelum . vraptor . validator . Severity ) { if ( ! ( messages . containsKey ( severity ) ) ) { messages . put ( severity , createMessageList ( ) ) ; } return messages . get ( severity ) ; }", "testMethod": "shouldReturnEmptyList ( ) { when ( dao . searchSimilarTitle ( music . getTitle ( ) ) ) . thenReturn ( new java . util . ArrayList < br . com . caelum . vraptor . musicjungle . model . Music > ( ) ) ; controller . search ( music ) ; java . util . List < br . com . caelum . vraptor . musicjungle . model . Music > musics = ( ( java . util . List < br . com . caelum . vraptor . musicjungle . model . Music > ) ( result . included ( ) . get ( \"musics\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( musics , org . hamcrest . Matchers . empty ( ) )", "total": "shouldReturnEmptyList ( ) { when ( dao . searchSimilarTitle ( music . getTitle ( ) ) ) . thenReturn ( new java . util . ArrayList < br . com . caelum . vraptor . musicjungle . model . Music > ( ) ) ; controller . search ( music ) ; java . util . List < br . com . caelum . vraptor . musicjungle . model . Music > musics = ( ( java . util . List < br . com . caelum . vraptor . musicjungle . model . Music > ) ( result . included ( ) . get ( \"musics\" ) ) ) ; \"<AssertPlaceHolder>\" ; } get ( br . com . caelum . vraptor . validator . Severity ) { if ( ! ( messages . containsKey ( severity ) ) ) { messages . put ( severity , createMessageList ( ) ) ; } return messages . get ( severity ) ; }", "answer": "org . junit . Assert . assertThat ( musics , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getTokens ( ) { java . util . List < annis . model . AnnisNode > tokens = new java . util . ArrayList < annis . model . AnnisNode > ( ) ; for ( annis . model . AnnisNode node : nodes ) { if ( node . isToken ( ) ) tokens . add ( node ) ; } java . util . Collections . sort ( tokens , new annis . model . AnnotationGraph . NodeComparator ( ) ) ; return tokens ; }", "testMethod": "addNodeToken ( ) { annis . model . AnnisNode token1 = newMockedToken ( 1 ) ; annis . model . AnnisNode token2 = newMockedToken ( 2 ) ; annis . model . AnnisNode token3 = newMockedToken ( 3 ) ; annis . model . AnnisNode node1 = new annis . model . AnnisNode ( 1 ) ; annis . model . AnnisNode node2 = new annis . model . AnnisNode ( 2 ) ; graph . addNode ( token2 ) ; graph . addNode ( token1 ) ; graph . addNode ( node2 ) ; graph . addNode ( node1 ) ; graph . addNode ( token3 ) ; java . util . List < annis . model . AnnisNode > expected = java . util . Arrays . asList ( token1 , token2 , token3 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( graph . getTokens ( ) , org . hamcrest . Matchers . is ( expected ) )", "total": "addNodeToken ( ) { annis . model . AnnisNode token1 = newMockedToken ( 1 ) ; annis . model . AnnisNode token2 = newMockedToken ( 2 ) ; annis . model . AnnisNode token3 = newMockedToken ( 3 ) ; annis . model . AnnisNode node1 = new annis . model . AnnisNode ( 1 ) ; annis . model . AnnisNode node2 = new annis . model . AnnisNode ( 2 ) ; graph . addNode ( token2 ) ; graph . addNode ( token1 ) ; graph . addNode ( node2 ) ; graph . addNode ( node1 ) ; graph . addNode ( token3 ) ; java . util . List < annis . model . AnnisNode > expected = java . util . Arrays . asList ( token1 , token2 , token3 ) ; \"<AssertPlaceHolder>\" ; } getTokens ( ) { java . util . List < annis . model . AnnisNode > tokens = new java . util . ArrayList < annis . model . AnnisNode > ( ) ; for ( annis . model . AnnisNode node : nodes ) { if ( node . isToken ( ) ) tokens . add ( node ) ; } java . util . Collections . sort ( tokens , new annis . model . AnnotationGraph . NodeComparator ( ) ) ; return tokens ; }", "answer": "org . junit . Assert . assertThat ( graph . getTokens ( ) , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "storeTo ( ) { java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( CoreProfile . KEY_PREFIX ) + ( CoreProfile . KEY_MAX_PROCESSES ) ) , \"10\" ) ; com . asakusafw . windgate . core . CoreProfile profile = com . asakusafw . windgate . core . CoreProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; java . util . Properties restored = new java . util . Properties ( ) ; profile . storeTo ( restored ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored , is ( p ) )", "total": "storeTo ( ) { java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( CoreProfile . KEY_PREFIX ) + ( CoreProfile . KEY_MAX_PROCESSES ) ) , \"10\" ) ; com . asakusafw . windgate . core . CoreProfile profile = com . asakusafw . windgate . core . CoreProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; java . util . Properties restored = new java . util . Properties ( ) ; profile . storeTo ( restored ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( restored , is ( p ) )"}
{"focal": "getInLink ( ) { return inLink ; }", "testMethod": "testSetInLink ( ) { target . setInLink ( \"jkl\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getInLink ( ) , org . hamcrest . CoreMatchers . is ( \"jkl\" ) )", "total": "testSetInLink ( ) { target . setInLink ( \"jkl\" ) ; \"<AssertPlaceHolder>\" ; } getInLink ( ) { return inLink ; }", "answer": "org . junit . Assert . assertThat ( target . getInLink ( ) , org . hamcrest . CoreMatchers . is ( \"jkl\" ) )"}
{"focal": "getChildren ( ) { java . util . List < org . eclipse . egit . ui . internal . synchronize . model . GitModelObjectContainer > result = new java . util . ArrayList ( ) ; org . eclipse . jgit . lib . Repository repo = gsd . getRepository ( ) ; org . eclipse . jgit . revwalk . RevCommit srcRevCommit = gsd . getSrcRevCommit ( ) ; org . eclipse . jgit . revwalk . RevCommit dstRevCommit = gsd . getDstRevCommit ( ) ; org . eclipse . jgit . treewalk . filter . TreeFilter pathFilter = gsd . getPathFilter ( ) ; java . util . List < org . eclipse . egit . core . synchronize . GitCommitsModelCache . Commit > commitCache ; if ( ( srcRevCommit != null ) && ( dstRevCommit != null ) ) try { commitCache = org . eclipse . egit . core . synchronize . GitCommitsModelCache . build ( repo , srcRevCommit , dstRevCommit , pathFilter ) ; } catch ( java . io . IOException e ) { org . eclipse . egit . ui . Activator . logError ( e . getMessage ( ) , e ) ; commitCache = null ; } else commitCache = null ; if ( ( commitCache != null ) && ( ! ( commitCache . isEmpty ( ) ) ) ) result . addAll ( getListOfCommit ( commitCache ) ) ; result . addAll ( getWorkingChanges ( ) ) ; disposeOldChildren ( ) ; children = result . toArray ( new org . eclipse . egit . ui . internal . synchronize . model . GitModelObjectContainer [ 0 ] ) ; return children ; }", "testMethod": "shouldIgnoreEmptyRepositories ( ) { touchAndSubmit ( \"second<sp>commit\" ) ; org . eclipse . egit . core . synchronize . dto . GitSynchronizeDataSet gsds = new org . eclipse . egit . core . synchronize . dto . GitSynchronizeDataSet ( ) ; gsds . add ( new org . eclipse . egit . core . synchronize . dto . GitSynchronizeData ( org . eclipse . egit . ui . internal . synchronize . model . GitModelRootTest . repo1 , HEAD , ( ( HEAD ) + \"^1\" ) , false ) ) ; gsds . add ( new org . eclipse . egit . core . synchronize . dto . GitSynchronizeData ( org . eclipse . egit . ui . internal . synchronize . model . GitModelRootTest . repo2 , HEAD , HEAD , false ) ) ; org . eclipse . egit . ui . internal . synchronize . model . GitModelRoot root = new org . eclipse . egit . ui . internal . synchronize . model . GitModelRoot ( gsds ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( java . lang . Integer . valueOf ( root . getChildren ( ) . length ) , org . hamcrest . CoreMatchers . is ( java . lang . Integer . valueOf ( 1 ) ) )", "total": "shouldIgnoreEmptyRepositories ( ) { touchAndSubmit ( \"second<sp>commit\" ) ; org . eclipse . egit . core . synchronize . dto . GitSynchronizeDataSet gsds = new org . eclipse . egit . core . synchronize . dto . GitSynchronizeDataSet ( ) ; gsds . add ( new org . eclipse . egit . core . synchronize . dto . GitSynchronizeData ( org . eclipse . egit . ui . internal . synchronize . model . GitModelRootTest . repo1 , HEAD , ( ( HEAD ) + \"^1\" ) , false ) ) ; gsds . add ( new org . eclipse . egit . core . synchronize . dto . GitSynchronizeData ( org . eclipse . egit . ui . internal . synchronize . model . GitModelRootTest . repo2 , HEAD , HEAD , false ) ) ; org . eclipse . egit . ui . internal . synchronize . model . GitModelRoot root = new org . eclipse . egit . ui . internal . synchronize . model . GitModelRoot ( gsds ) ; \"<AssertPlaceHolder>\" ; } getChildren ( ) { java . util . List < org . eclipse . egit . ui . internal . synchronize . model . GitModelObjectContainer > result = new java . util . ArrayList ( ) ; org . eclipse . jgit . lib . Repository repo = gsd . getRepository ( ) ; org . eclipse . jgit . revwalk . RevCommit srcRevCommit = gsd . getSrcRevCommit ( ) ; org . eclipse . jgit . revwalk . RevCommit dstRevCommit = gsd . getDstRevCommit ( ) ; org . eclipse . jgit . treewalk . filter . TreeFilter pathFilter = gsd . getPathFilter ( ) ; java . util . List < org . eclipse . egit . core . synchronize . GitCommitsModelCache . Commit > commitCache ; if ( ( srcRevCommit != null ) && ( dstRevCommit != null ) ) try { commitCache = org . eclipse . egit . core . synchronize . GitCommitsModelCache . build ( repo , srcRevCommit , dstRevCommit , pathFilter ) ; } catch ( java . io . IOException e ) { org . eclipse . egit . ui . Activator . logError ( e . getMessage ( ) , e ) ; commitCache = null ; } else commitCache = null ; if ( ( commitCache != null ) && ( ! ( commitCache . isEmpty ( ) ) ) ) result . addAll ( getListOfCommit ( commitCache ) ) ; result . addAll ( getWorkingChanges ( ) ) ; disposeOldChildren ( ) ; children = result . toArray ( new org . eclipse . egit . ui . internal . synchronize . model . GitModelObjectContainer [ 0 ] ) ; return children ; }", "answer": "org . junit . Assert . assertThat ( java . lang . Integer . valueOf ( root . getChildren ( ) . length ) , org . hamcrest . CoreMatchers . is ( java . lang . Integer . valueOf ( 1 ) ) )"}
{"focal": "getTenantId ( ) { return tenantId ; }", "testMethod": "getProcessDefinitionWithAuthenticatedTenant ( ) { identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyProcessDefinitionCmdsTenantCheckTest . TENANT_ONE ) ) ; org . camunda . bpm . engine . repository . ProcessDefinition definition = repositoryService . getProcessDefinition ( processDefinitionId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( definition . getTenantId ( ) , org . hamcrest . CoreMatchers . is ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyProcessDefinitionCmdsTenantCheckTest . TENANT_ONE ) )", "total": "getProcessDefinitionWithAuthenticatedTenant ( ) { identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyProcessDefinitionCmdsTenantCheckTest . TENANT_ONE ) ) ; org . camunda . bpm . engine . repository . ProcessDefinition definition = repositoryService . getProcessDefinition ( processDefinitionId ) ; \"<AssertPlaceHolder>\" ; } getTenantId ( ) { return tenantId ; }", "answer": "org . junit . Assert . assertThat ( definition . getTenantId ( ) , org . hamcrest . CoreMatchers . is ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyProcessDefinitionCmdsTenantCheckTest . TENANT_ONE ) )"}
{"focal": "equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "testMethod": "getMainInputSingleOutputSideInputs ( ) { org . apache . beam . sdk . runners . AppliedPTransform < org . apache . beam . sdk . values . PCollection < java . lang . Long > , ? , ? > application = org . apache . beam . sdk . runners . AppliedPTransform . of ( \"application\" , org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableMap . < org . apache . beam . sdk . values . TupleTag < ? > , org . apache . beam . sdk . values . PValue > builder ( ) . put ( new org . apache . beam . sdk . values . TupleTag < java . lang . Long > ( ) , mainInput ) . put ( sideInput . getTagInternal ( ) , sideInput . getPCollection ( ) ) . build ( ) , java . util . Collections . singletonMap ( new org . apache . beam . sdk . values . TupleTag < java . lang . Long > ( ) , output ) , org . apache . beam . sdk . transforms . ParDo . of ( new org . apache . beam . runners . core . construction . PTransformReplacementsTest . TestDoFn ( ) ) . withSideInputs ( sideInput ) , pipeline ) ; org . apache . beam . sdk . values . PCollection < java . lang . Long > input = org . apache . beam . runners . core . construction . PTransformReplacements . getSingletonMainInput ( application ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( input , org . hamcrest . Matchers . equalTo ( mainInput ) )", "total": "getMainInputSingleOutputSideInputs ( ) { org . apache . beam . sdk . runners . AppliedPTransform < org . apache . beam . sdk . values . PCollection < java . lang . Long > , ? , ? > application = org . apache . beam . sdk . runners . AppliedPTransform . of ( \"application\" , org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableMap . < org . apache . beam . sdk . values . TupleTag < ? > , org . apache . beam . sdk . values . PValue > builder ( ) . put ( new org . apache . beam . sdk . values . TupleTag < java . lang . Long > ( ) , mainInput ) . put ( sideInput . getTagInternal ( ) , sideInput . getPCollection ( ) ) . build ( ) , java . util . Collections . singletonMap ( new org . apache . beam . sdk . values . TupleTag < java . lang . Long > ( ) , output ) , org . apache . beam . sdk . transforms . ParDo . of ( new org . apache . beam . runners . core . construction . PTransformReplacementsTest . TestDoFn ( ) ) . withSideInputs ( sideInput ) , pipeline ) ; org . apache . beam . sdk . values . PCollection < java . lang . Long > input = org . apache . beam . runners . core . construction . PTransformReplacements . getSingletonMainInput ( application ) ; \"<AssertPlaceHolder>\" ; } equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( input , org . hamcrest . Matchers . equalTo ( mainInput ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testRetrieveClaimValuesNoCertValues ( ) { org . codice . ddf . security . claims . certificate . CertificateClaimsHandler certificateClaimsHandler = new org . codice . ddf . security . claims . certificate . CertificateClaimsHandler ( ) ; org . apache . cxf . rt . security . claims . ClaimCollection claims = getClaims ( ) ; org . apache . cxf . sts . claims . ClaimsParameters parameters = new org . apache . cxf . sts . claims . ClaimsParameters ( ) ; parameters . setPrincipal ( mock ( java . security . Principal . class ) ) ; org . apache . cxf . sts . claims . ProcessedClaimCollection processedClaims = certificateClaimsHandler . retrieveClaimValues ( claims , parameters ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( processedClaims . size ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "testRetrieveClaimValuesNoCertValues ( ) { org . codice . ddf . security . claims . certificate . CertificateClaimsHandler certificateClaimsHandler = new org . codice . ddf . security . claims . certificate . CertificateClaimsHandler ( ) ; org . apache . cxf . rt . security . claims . ClaimCollection claims = getClaims ( ) ; org . apache . cxf . sts . claims . ClaimsParameters parameters = new org . apache . cxf . sts . claims . ClaimsParameters ( ) ; parameters . setPrincipal ( mock ( java . security . Principal . class ) ) ; org . apache . cxf . sts . claims . ProcessedClaimCollection processedClaims = certificateClaimsHandler . retrieveClaimValues ( claims , parameters ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( processedClaims . size ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "isFailedCommand ( ) { return new fr . treeptik . cloudunit . cli . integration . ShellMatchers . CommandStatusMatcher ( false ) ; }", "testMethod": "test_shouldNotUpdateEnvironmentVariableEmptyOldKey ( ) { connect ( ) ; createApplication ( ) ; try { createEnvironmentVariable ( \"key\" , \"value\" ) ; org . springframework . shell . core . CommandResult result = updateEnvironmentVariable ( \"\" , \"key\" , \"value\" ) ; \"<AssertPlaceHolder>\" ; } finally { removeApplication ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( result , isFailedCommand ( ) )", "total": "test_shouldNotUpdateEnvironmentVariableEmptyOldKey ( ) { connect ( ) ; createApplication ( ) ; try { createEnvironmentVariable ( \"key\" , \"value\" ) ; org . springframework . shell . core . CommandResult result = updateEnvironmentVariable ( \"\" , \"key\" , \"value\" ) ; \"<AssertPlaceHolder>\" ; } finally { removeApplication ( ) ; } } isFailedCommand ( ) { return new fr . treeptik . cloudunit . cli . integration . ShellMatchers . CommandStatusMatcher ( false ) ; }", "answer": "org . junit . Assert . assertThat ( result , isFailedCommand ( ) )"}
{"focal": "isStatic ( ) { return ( ( this . access ) & ( org . objectweb . asm . Opcodes . ACC_STATIC ) ) != 0 ; }", "testMethod": "isStaticShouldReturnTrueWhenMethodIsStatic ( ) { final org . pitest . mutationtest . engine . gregor . MethodInfo testee = this . methodInfo . withAccess ( org . pitest . mutationtest . engine . gregor . MethodInfoTest . STATIC_MODIFIER ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testee . isStatic ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "isStaticShouldReturnTrueWhenMethodIsStatic ( ) { final org . pitest . mutationtest . engine . gregor . MethodInfo testee = this . methodInfo . withAccess ( org . pitest . mutationtest . engine . gregor . MethodInfoTest . STATIC_MODIFIER ) ; \"<AssertPlaceHolder>\" ; } isStatic ( ) { return ( ( this . access ) & ( org . objectweb . asm . Opcodes . ACC_STATIC ) ) != 0 ; }", "answer": "org . junit . Assert . assertThat ( testee . isStatic ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "isSameCause ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause , hudson . model . Cause ) { if ( ! ( oldMavenCause instanceof org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ) { return java . util . Collections . emptyList ( ) ; } java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > newCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( newMavenCause . getMavenArtifacts ( ) , \"newMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > oldCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( ( ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ( oldMavenCause ) ) . getMavenArtifacts ( ) , \"oldMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = new java . util . ArrayList ( ) ; for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact newCauseArtifact : newCauseArtifacts ) { if ( ( newCauseArtifact . isSnapshot ( ) ) && ( newCauseArtifact . getVersion ( ) . contains ( \"SNAPSHOT\" ) ) ) { } else { for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact oldCauseArtifact : oldCauseArtifacts ) { if ( ( ( ( ( ( java . util . Objects . equals ( newCauseArtifact . getGroupId ( ) , oldCauseArtifact . getGroupId ( ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getArtifactId ( ) , oldCauseArtifact . getArtifactId ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getVersion ( ) , oldCauseArtifact . getVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getBaseVersion ( ) , oldCauseArtifact . getBaseVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getClassifier ( ) , oldCauseArtifact . getClassifier ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getType ( ) , oldCauseArtifact . getType ( ) ) ) ) { matchingArtifacts . add ( newCauseArtifact ) ; } } } } return matchingArtifacts ; }", "testMethod": "isSameCause_singleArtifact_noBaseVersion_sameSnapshot_false ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-SNAPSHOT\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( secondArtifact ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( matchingArtifacts . isEmpty ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "isSameCause_singleArtifact_noBaseVersion_sameSnapshot_false ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-SNAPSHOT\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( secondArtifact ) ) ; \"<AssertPlaceHolder>\" ; } isSameCause ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause , hudson . model . Cause ) { if ( ! ( oldMavenCause instanceof org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ) { return java . util . Collections . emptyList ( ) ; } java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > newCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( newMavenCause . getMavenArtifacts ( ) , \"newMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > oldCauseArtifacts = com . google . common . base . Preconditions . checkNotNull ( ( ( org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCause ) ( oldMavenCause ) ) . getMavenArtifacts ( ) , \"oldMavenCause.mavenArtifacts<sp>should<sp>not<sp>be<sp>null\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = new java . util . ArrayList ( ) ; for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact newCauseArtifact : newCauseArtifacts ) { if ( ( newCauseArtifact . isSnapshot ( ) ) && ( newCauseArtifact . getVersion ( ) . contains ( \"SNAPSHOT\" ) ) ) { } else { for ( org . jenkinsci . plugins . pipeline . maven . MavenArtifact oldCauseArtifact : oldCauseArtifacts ) { if ( ( ( ( ( ( java . util . Objects . equals ( newCauseArtifact . getGroupId ( ) , oldCauseArtifact . getGroupId ( ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getArtifactId ( ) , oldCauseArtifact . getArtifactId ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getVersion ( ) , oldCauseArtifact . getVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getBaseVersion ( ) , oldCauseArtifact . getBaseVersion ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getClassifier ( ) , oldCauseArtifact . getClassifier ( ) ) ) ) && ( java . util . Objects . equals ( newCauseArtifact . getType ( ) , oldCauseArtifact . getType ( ) ) ) ) { matchingArtifacts . add ( newCauseArtifact ) ; } } } } return matchingArtifacts ; }", "answer": "org . junit . Assert . assertThat ( matchingArtifacts . isEmpty ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getVersionDescription ( ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"CDK-\" ) . append ( getClass ( ) . getSimpleName ( ) ) . append ( \"/\" ) . append ( org . openscience . cdk . CDK . getVersion ( ) ) ; for ( Map . Entry < java . lang . String , java . lang . String > param : getParameters ( ) ) { sb . append ( '<sp>' ) . append ( param . getKey ( ) ) . append ( '=' ) . append ( param . getValue ( ) ) ; } return sb . toString ( ) ; }", "testMethod": "testVersion ( ) { org . openscience . cdk . fingerprint . Fingerprinter fpr = new org . openscience . cdk . fingerprint . Fingerprinter ( 1024 , 7 ) ; fpr . setPathLimit ( 2000 ) ; fpr . setHashPseudoAtoms ( true ) ; java . lang . String expected = ( \"CDK-Fingerprinter/\" + ( org . openscience . cdk . CDK . getVersion ( ) ) ) + \"<sp>searchDepth=7<sp>pathLimit=2000<sp>hashPseudoAtoms=true\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fpr . getVersionDescription ( ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testVersion ( ) { org . openscience . cdk . fingerprint . Fingerprinter fpr = new org . openscience . cdk . fingerprint . Fingerprinter ( 1024 , 7 ) ; fpr . setPathLimit ( 2000 ) ; fpr . setHashPseudoAtoms ( true ) ; java . lang . String expected = ( \"CDK-Fingerprinter/\" + ( org . openscience . cdk . CDK . getVersion ( ) ) ) + \"<sp>searchDepth=7<sp>pathLimit=2000<sp>hashPseudoAtoms=true\" ; \"<AssertPlaceHolder>\" ; } getVersionDescription ( ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"CDK-\" ) . append ( getClass ( ) . getSimpleName ( ) ) . append ( \"/\" ) . append ( org . openscience . cdk . CDK . getVersion ( ) ) ; for ( Map . Entry < java . lang . String , java . lang . String > param : getParameters ( ) ) { sb . append ( '<sp>' ) . append ( param . getKey ( ) ) . append ( '=' ) . append ( param . getValue ( ) ) ; } return sb . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( fpr . getVersionDescription ( ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "map ( K , V , K , V ) { java . util . Map < K , V > map = com . google . common . collect . Maps . newLinkedHashMap ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }", "testMethod": "All_Different_1 ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . map ( 1 , 1 , 2 , 2 , 3 , 3 ) , org . javersion . core . DiffTest . map ( 4 , 4 , 5 , 5 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . map ( 1 , null , 2 , null , 3 , null , 4 , 4 , 5 , 5 ) ) )", "total": "All_Different_1 ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . map ( 1 , 1 , 2 , 2 , 3 , 3 ) , org . javersion . core . DiffTest . map ( 4 , 4 , 5 , 5 ) ) ; \"<AssertPlaceHolder>\" ; } map ( K , V , K , V ) { java . util . Map < K , V > map = com . google . common . collect . Maps . newLinkedHashMap ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }", "answer": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . map ( 1 , null , 2 , null , 3 , null , 4 , 4 , 5 , 5 ) ) )"}
{"focal": "equalTo ( com . facebook . buck . query . QueryEnvironment$Argument ) { return ( ( ( type . equals ( other . type ) ) && ( ( integer ) == ( other . integer ) ) ) && ( java . util . Objects . equals ( expression , other . expression ) ) ) && ( java . util . Objects . equals ( word , other . word ) ) ; }", "testMethod": "targetGraphOnlyDepsDoNotAffectRuleKey ( ) { com . facebook . buck . io . filesystem . ProjectFilesystem filesystem = new com . facebook . buck . io . filesystem . impl . FakeProjectFilesystem ( ) ; for ( com . facebook . buck . features . python . PythonBuckConfig . PackageStyle packageStyle : PythonBuckConfig . PackageStyle . values ( ) ) { com . facebook . buck . features . python . PythonBinaryBuilder pythonBinaryBuilder = com . facebook . buck . features . python . PythonBinaryBuilder . create ( com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//:bin\" ) ) . setMainModule ( \"main\" ) . setPackageStyle ( packageStyle ) ; com . facebook . buck . core . model . targetgraph . TargetGraph targetGraph = com . facebook . buck . core . model . targetgraph . TargetGraphFactory . newInstance ( pythonBinaryBuilder . build ( ) ) ; com . facebook . buck . core . rules . ActionGraphBuilder graphBuilder = new com . facebook . buck . core . rules . resolver . impl . TestActionGraphBuilder ( targetGraph ) ; com . facebook . buck . features . python . PythonBinary pythonBinaryWithoutDep = pythonBinaryBuilder . build ( graphBuilder , filesystem , targetGraph ) ; com . facebook . buck . core . rulekey . RuleKey ruleKeyWithoutDep = calculateRuleKey ( graphBuilder , pythonBinaryWithoutDep ) ; com . facebook . buck . cxx . CxxBinaryBuilder cxxBinaryBuilder = new com . facebook . buck . cxx . CxxBinaryBuilder ( com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//:dep\" ) ) ; pythonBinaryBuilder . setDeps ( com . google . common . collect . ImmutableSortedSet . of ( cxxBinaryBuilder . getTarget ( ) ) ) ; targetGraph = com . facebook . buck . core . model . targetgraph . TargetGraphFactory . newInstance ( cxxBinaryBuilder . build ( ) , pythonBinaryBuilder . build ( ) ) ; graphBuilder = new com . facebook . buck . core . rules . resolver . impl . TestActionGraphBuilder ( targetGraph ) ; cxxBinaryBuilder . build ( graphBuilder , filesystem , targetGraph ) ; com . facebook . buck . features . python . PythonBinary pythonBinaryWithDep = pythonBinaryBuilder . build ( graphBuilder , filesystem , targetGraph ) ; com . facebook . buck . core . rulekey . RuleKey ruleKeyWithDep = calculateRuleKey ( graphBuilder , pythonBinaryWithDep ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( ruleKeyWithoutDep , org . hamcrest . Matchers . equalTo ( ruleKeyWithDep ) )", "total": "targetGraphOnlyDepsDoNotAffectRuleKey ( ) { com . facebook . buck . io . filesystem . ProjectFilesystem filesystem = new com . facebook . buck . io . filesystem . impl . FakeProjectFilesystem ( ) ; for ( com . facebook . buck . features . python . PythonBuckConfig . PackageStyle packageStyle : PythonBuckConfig . PackageStyle . values ( ) ) { com . facebook . buck . features . python . PythonBinaryBuilder pythonBinaryBuilder = com . facebook . buck . features . python . PythonBinaryBuilder . create ( com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//:bin\" ) ) . setMainModule ( \"main\" ) . setPackageStyle ( packageStyle ) ; com . facebook . buck . core . model . targetgraph . TargetGraph targetGraph = com . facebook . buck . core . model . targetgraph . TargetGraphFactory . newInstance ( pythonBinaryBuilder . build ( ) ) ; com . facebook . buck . core . rules . ActionGraphBuilder graphBuilder = new com . facebook . buck . core . rules . resolver . impl . TestActionGraphBuilder ( targetGraph ) ; com . facebook . buck . features . python . PythonBinary pythonBinaryWithoutDep = pythonBinaryBuilder . build ( graphBuilder , filesystem , targetGraph ) ; com . facebook . buck . core . rulekey . RuleKey ruleKeyWithoutDep = calculateRuleKey ( graphBuilder , pythonBinaryWithoutDep ) ; com . facebook . buck . cxx . CxxBinaryBuilder cxxBinaryBuilder = new com . facebook . buck . cxx . CxxBinaryBuilder ( com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//:dep\" ) ) ; pythonBinaryBuilder . setDeps ( com . google . common . collect . ImmutableSortedSet . of ( cxxBinaryBuilder . getTarget ( ) ) ) ; targetGraph = com . facebook . buck . core . model . targetgraph . TargetGraphFactory . newInstance ( cxxBinaryBuilder . build ( ) , pythonBinaryBuilder . build ( ) ) ; graphBuilder = new com . facebook . buck . core . rules . resolver . impl . TestActionGraphBuilder ( targetGraph ) ; cxxBinaryBuilder . build ( graphBuilder , filesystem , targetGraph ) ; com . facebook . buck . features . python . PythonBinary pythonBinaryWithDep = pythonBinaryBuilder . build ( graphBuilder , filesystem , targetGraph ) ; com . facebook . buck . core . rulekey . RuleKey ruleKeyWithDep = calculateRuleKey ( graphBuilder , pythonBinaryWithDep ) ; \"<AssertPlaceHolder>\" ; } } equalTo ( com . facebook . buck . query . QueryEnvironment$Argument ) { return ( ( ( type . equals ( other . type ) ) && ( ( integer ) == ( other . integer ) ) ) && ( java . util . Objects . equals ( expression , other . expression ) ) ) && ( java . util . Objects . equals ( word , other . word ) ) ; }", "answer": "org . junit . Assert . assertThat ( ruleKeyWithoutDep , org . hamcrest . Matchers . equalTo ( ruleKeyWithDep ) )"}
{"focal": "elementsAreAllUnique ( ) { return new cucumber . runtime . java . guice . matcher . ElementsAreAllUniqueMatcher < E > ( ) ; }", "testMethod": "shouldGiveNewInstanceOfBoundScenarioScopedClassForEachScenario ( ) { factory = new cucumber . runtime . java . guice . impl . GuiceFactory ( injector ( CucumberModules . SCENARIO , boundScenarioScopedClassModule ) ) ; instancesFromDifferentScenarios = getInstancesFromDifferentScenarios ( factory , cucumber . runtime . java . guice . impl . GuiceFactoryTest . BoundScenarioScopedClass . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( instancesFromDifferentScenarios , elementsAreAllUnique ( ) )", "total": "shouldGiveNewInstanceOfBoundScenarioScopedClassForEachScenario ( ) { factory = new cucumber . runtime . java . guice . impl . GuiceFactory ( injector ( CucumberModules . SCENARIO , boundScenarioScopedClassModule ) ) ; instancesFromDifferentScenarios = getInstancesFromDifferentScenarios ( factory , cucumber . runtime . java . guice . impl . GuiceFactoryTest . BoundScenarioScopedClass . class ) ; \"<AssertPlaceHolder>\" ; } elementsAreAllUnique ( ) { return new cucumber . runtime . java . guice . matcher . ElementsAreAllUniqueMatcher < E > ( ) ; }", "answer": "org . junit . Assert . assertThat ( instancesFromDifferentScenarios , elementsAreAllUnique ( ) )"}
{"focal": "id ( ) { return id ; }", "testMethod": "testBuildName ( ) { final java . lang . String imageName = \"test-build-name\" ; final java . nio . file . Path dockerDirectory = com . spotify . docker . client . DefaultDockerClientTest . getResource ( \"dockerDirectory\" ) ; final java . lang . String imageId = sut . build ( dockerDirectory , imageName ) ; final com . spotify . docker . client . messages . ImageInfo info = sut . inspectImage ( imageName ) ; final java . lang . String expectedId = ( dockerApiVersionLessThan ( \"1.22\" ) ) ? imageId : \"sha256:\" + imageId ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( info . id ( ) , org . hamcrest . Matchers . startsWith ( expectedId ) )", "total": "testBuildName ( ) { final java . lang . String imageName = \"test-build-name\" ; final java . nio . file . Path dockerDirectory = com . spotify . docker . client . DefaultDockerClientTest . getResource ( \"dockerDirectory\" ) ; final java . lang . String imageId = sut . build ( dockerDirectory , imageName ) ; final com . spotify . docker . client . messages . ImageInfo info = sut . inspectImage ( imageName ) ; final java . lang . String expectedId = ( dockerApiVersionLessThan ( \"1.22\" ) ) ? imageId : \"sha256:\" + imageId ; \"<AssertPlaceHolder>\" ; } id ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( info . id ( ) , org . hamcrest . Matchers . startsWith ( expectedId ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "isEmpty_A$ ( ) { java . util . Map < java . lang . String , java . lang . Integer > map = new java . util . HashMap < java . lang . String , java . lang . Integer > ( ) ; map . put ( \"foo\" , 123 ) ; map . put ( \"bar\" , 456 ) ; com . m3 . scalaflavor4j . SMap < java . lang . String , java . lang . Integer > smap = com . m3 . scalaflavor4j . SMap . apply ( map ) ; boolean actual = smap . isEmpty ( ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isEmpty_A$ ( ) { java . util . Map < java . lang . String , java . lang . Integer > map = new java . util . HashMap < java . lang . String , java . lang . Integer > ( ) ; map . put ( \"foo\" , 123 ) ; map . put ( \"bar\" , 456 ) ; com . m3 . scalaflavor4j . SMap < java . lang . String , java . lang . Integer > smap = com . m3 . scalaflavor4j . SMap . apply ( map ) ; boolean actual = smap . isEmpty ( ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "hasFurtherParams ( ) { return externalEntitiesIterator . hasNext ( ) ; }", "testMethod": "notAllowedPayloadPosition ( ) { wsattacker . library . intelligentdos . helper . IterateModel iterateModel = wsattacker . library . intelligentdos . helper . IterateModel . custom ( ) . startAt ( 2 ) . stopAt ( 2 ) . build ( ) ; coerciveParsing . setNumberOfTagsIterator ( iterateModel ) ; \"<AssertPlaceHolder>\" ; coerciveParsing . nextParam ( ) ; coerciveParsing . getTamperedRequest ( \"\" , PayloadPosition . ATTRIBUTE ) ; }", "assertLine": "org . junit . Assert . assertThat ( coerciveParsing . hasFurtherParams ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "notAllowedPayloadPosition ( ) { wsattacker . library . intelligentdos . helper . IterateModel iterateModel = wsattacker . library . intelligentdos . helper . IterateModel . custom ( ) . startAt ( 2 ) . stopAt ( 2 ) . build ( ) ; coerciveParsing . setNumberOfTagsIterator ( iterateModel ) ; \"<AssertPlaceHolder>\" ; coerciveParsing . nextParam ( ) ; coerciveParsing . getTamperedRequest ( \"\" , PayloadPosition . ATTRIBUTE ) ; } hasFurtherParams ( ) { return externalEntitiesIterator . hasNext ( ) ; }", "answer": "org . junit . Assert . assertThat ( coerciveParsing . hasFurtherParams ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "delete ( ) { ensureOnlyOneNotNull ( org . camunda . bpm . engine . exception . NullValueException . class , \"'processDefinitionKey'<sp>or<sp>'processDefinitionIds'<sp>cannot<sp>be<sp>null\" , processDefinitionKey , processDefinitionIds ) ; org . camunda . bpm . engine . impl . interceptor . Command < java . lang . Void > command ; if ( ( processDefinitionKey ) != null ) { command = new org . camunda . bpm . engine . impl . cmd . DeleteProcessDefinitionsByKeyCmd ( processDefinitionKey , cascade , skipCustomListeners , skipIoMappings , tenantId , isTenantIdSet ) ; } else if ( ( ( processDefinitionIds ) != null ) && ( ! ( processDefinitionIds . isEmpty ( ) ) ) ) { command = new org . camunda . bpm . engine . impl . cmd . DeleteProcessDefinitionsByIdsCmd ( processDefinitionIds , cascade , skipCustomListeners , skipIoMappings ) ; } else { return ; } commandExecutor . execute ( command ) ; }", "testMethod": "testDeleteProcessDefinitionsByIdsWithCustomListenersSkipped ( ) { org . camunda . bpm . engine . test . api . runtime . util . IncrementCounterListener . counter = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { deployTwoProcessDefinitions ( ) ; } java . lang . String [ ] processDefinitionIds = findProcessDefinitionIdsByKey ( \"processOne\" ) ; runtimeService . startProcessInstanceByKey ( \"processOne\" ) ; repositoryService . deleteProcessDefinitions ( ) . byIds ( processDefinitionIds ) . cascade ( ) . skipCustomListeners ( ) . delete ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( IncrementCounterListener . counter , org . hamcrest . Matchers . is ( 0 ) )", "total": "testDeleteProcessDefinitionsByIdsWithCustomListenersSkipped ( ) { org . camunda . bpm . engine . test . api . runtime . util . IncrementCounterListener . counter = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { deployTwoProcessDefinitions ( ) ; } java . lang . String [ ] processDefinitionIds = findProcessDefinitionIdsByKey ( \"processOne\" ) ; runtimeService . startProcessInstanceByKey ( \"processOne\" ) ; repositoryService . deleteProcessDefinitions ( ) . byIds ( processDefinitionIds ) . cascade ( ) . skipCustomListeners ( ) . delete ( ) ; \"<AssertPlaceHolder>\" ; } delete ( ) { ensureOnlyOneNotNull ( org . camunda . bpm . engine . exception . NullValueException . class , \"'processDefinitionKey'<sp>or<sp>'processDefinitionIds'<sp>cannot<sp>be<sp>null\" , processDefinitionKey , processDefinitionIds ) ; org . camunda . bpm . engine . impl . interceptor . Command < java . lang . Void > command ; if ( ( processDefinitionKey ) != null ) { command = new org . camunda . bpm . engine . impl . cmd . DeleteProcessDefinitionsByKeyCmd ( processDefinitionKey , cascade , skipCustomListeners , skipIoMappings , tenantId , isTenantIdSet ) ; } else if ( ( ( processDefinitionIds ) != null ) && ( ! ( processDefinitionIds . isEmpty ( ) ) ) ) { command = new org . camunda . bpm . engine . impl . cmd . DeleteProcessDefinitionsByIdsCmd ( processDefinitionIds , cascade , skipCustomListeners , skipIoMappings ) ; } else { return ; } commandExecutor . execute ( command ) ; }", "answer": "org . junit . Assert . assertThat ( IncrementCounterListener . counter , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "validate ( com . hotels . bdp . circustrain . metrics . conf . Graphite ) { if ( graphite == null ) { graphite = new com . hotels . bdp . circustrain . metrics . conf . Graphite ( ) ; } com . hotels . bdp . circustrain . metrics . conf . Graphite validated = loader . load ( graphite . getConfig ( ) ) ; if ( ( graphite . getHost ( ) ) != null ) { validated . setHost ( graphite . getHost ( ) ) ; } if ( ( graphite . getPrefix ( ) ) != null ) { validated . setPrefix ( graphite . getPrefix ( ) ) ; } if ( ( graphite . getNamespace ( ) ) != null ) { validated . setNamespace ( graphite . getNamespace ( ) ) ; } validated . init ( ) ; if ( validated . isEnabled ( ) ) { if ( ( ( ( validated . getHost ( ) ) == null ) || ( ( validated . getPrefix ( ) ) == null ) ) || ( ( validated . getNamespace ( ) ) == null ) ) { throw new com . hotels . bdp . circustrain . api . CircusTrainException ( java . lang . String . format ( \"Missing<sp>graphite<sp>configuration<sp>property:<sp>host[%s],<sp>prefix[%s],<sp>namespace[%s]\" , validated . getHost ( ) , validated . getPrefix ( ) , validated . getNamespace ( ) ) ) ; } } return new com . hotels . bdp . circustrain . metrics . conf . ValidatedGraphite ( validated ) ; }", "testMethod": "blankHiveMetastoreUris ( ) { replicaCatalog . setHiveMetastoreUris ( \"<sp>\" ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . circustrain . api . conf . ReplicaCatalog > > violations = validator . validate ( replicaCatalog ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "blankHiveMetastoreUris ( ) { replicaCatalog . setHiveMetastoreUris ( \"<sp>\" ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . circustrain . api . conf . ReplicaCatalog > > violations = validator . validate ( replicaCatalog ) ; \"<AssertPlaceHolder>\" ; } validate ( com . hotels . bdp . circustrain . metrics . conf . Graphite ) { if ( graphite == null ) { graphite = new com . hotels . bdp . circustrain . metrics . conf . Graphite ( ) ; } com . hotels . bdp . circustrain . metrics . conf . Graphite validated = loader . load ( graphite . getConfig ( ) ) ; if ( ( graphite . getHost ( ) ) != null ) { validated . setHost ( graphite . getHost ( ) ) ; } if ( ( graphite . getPrefix ( ) ) != null ) { validated . setPrefix ( graphite . getPrefix ( ) ) ; } if ( ( graphite . getNamespace ( ) ) != null ) { validated . setNamespace ( graphite . getNamespace ( ) ) ; } validated . init ( ) ; if ( validated . isEnabled ( ) ) { if ( ( ( ( validated . getHost ( ) ) == null ) || ( ( validated . getPrefix ( ) ) == null ) ) || ( ( validated . getNamespace ( ) ) == null ) ) { throw new com . hotels . bdp . circustrain . api . CircusTrainException ( java . lang . String . format ( \"Missing<sp>graphite<sp>configuration<sp>property:<sp>host[%s],<sp>prefix[%s],<sp>namespace[%s]\" , validated . getHost ( ) , validated . getPrefix ( ) , validated . getNamespace ( ) ) ) ; } } return new com . hotels . bdp . circustrain . metrics . conf . ValidatedGraphite ( validated ) ; }", "answer": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "list ( java . lang . String , java . lang . String ) { final java . util . Map < com . spotify . helios . common . descriptors . JobId , com . spotify . helios . common . descriptors . Job > allJobs ; if ( ! ( hostPattern . isEmpty ( ) ) ) { allJobs = model . listHosts ( hostPattern ) . stream ( ) . map ( model :: getHostStatus ) . flatMap ( ( hostStatus ) -> hostStatus . getJobs ( ) . keySet ( ) . stream ( ) ) . distinct ( ) . collect ( java . util . stream . Collectors . toMap ( java . util . function . Function . identity ( ) , model :: getJob ) ) ; } else { allJobs = model . getJobs ( ) ; } if ( query . isEmpty ( ) ) { metrics . jobsInJobList ( allJobs . size ( ) ) ; return allJobs ; } final java . util . Map < com . spotify . helios . common . descriptors . JobId , com . spotify . helios . common . descriptors . Job > filteredJobs = com . google . common . collect . Maps . newHashMap ( ) ; for ( final Map . Entry < com . spotify . helios . common . descriptors . JobId , com . spotify . helios . common . descriptors . Job > entry : allJobs . entrySet ( ) ) { if ( entry . getKey ( ) . toString ( ) . contains ( query ) ) { filteredJobs . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } metrics . jobsInJobList ( filteredJobs . size ( ) ) ; return filteredJobs ; }", "testMethod": "testListJobsWithMultipleDeployments ( ) { final java . lang . String namePattern = \"foo\" ; when ( model . listHosts ( namePattern ) ) . thenReturn ( com . google . common . collect . ImmutableList . of ( \"foobar.example.net\" , \"barfoo.example.net\" ) ) ; final com . spotify . helios . common . descriptors . JobId jobId1 = com . spotify . helios . common . descriptors . JobId . parse ( \"foobar:1\" ) ; final com . spotify . helios . common . descriptors . JobId jobId2 = com . spotify . helios . common . descriptors . JobId . parse ( \"foobat:2\" ) ; final com . spotify . helios . common . descriptors . Job job1 = com . spotify . helios . common . descriptors . Job . newBuilder ( ) . build ( ) ; final com . spotify . helios . common . descriptors . Job job2 = com . spotify . helios . common . descriptors . Job . newBuilder ( ) . build ( ) ; final com . spotify . helios . common . descriptors . HostStatus hostStatus = com . spotify . helios . master . resources . JobsResourceTest . mockHostStatus ( com . google . common . collect . ImmutableMap . of ( jobId1 , com . spotify . helios . common . descriptors . Deployment . of ( jobId1 , Goal . START ) , jobId2 , com . spotify . helios . common . descriptors . Deployment . of ( jobId2 , Goal . START ) ) ) ; when ( model . getHostStatus ( \"foobar.example.net\" ) ) . thenReturn ( hostStatus ) ; when ( model . getHostStatus ( \"barfoo.example.net\" ) ) . thenReturn ( hostStatus ) ; when ( model . getJob ( jobId1 ) ) . thenReturn ( job1 ) ; when ( model . getJob ( jobId2 ) ) . thenReturn ( job2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resource . list ( \"\" , namePattern ) , org . hamcrest . Matchers . is ( com . google . common . collect . ImmutableMap . of ( jobId1 , job1 , jobId2 , job2 ) ) )", "total": "testListJobsWithMultipleDeployments ( ) { final java . lang . String namePattern = \"foo\" ; when ( model . listHosts ( namePattern ) ) . thenReturn ( com . google . common . collect . ImmutableList . of ( \"foobar.example.net\" , \"barfoo.example.net\" ) ) ; final com . spotify . helios . common . descriptors . JobId jobId1 = com . spotify . helios . common . descriptors . JobId . parse ( \"foobar:1\" ) ; final com . spotify . helios . common . descriptors . JobId jobId2 = com . spotify . helios . common . descriptors . JobId . parse ( \"foobat:2\" ) ; final com . spotify . helios . common . descriptors . Job job1 = com . spotify . helios . common . descriptors . Job . newBuilder ( ) . build ( ) ; final com . spotify . helios . common . descriptors . Job job2 = com . spotify . helios . common . descriptors . Job . newBuilder ( ) . build ( ) ; final com . spotify . helios . common . descriptors . HostStatus hostStatus = com . spotify . helios . master . resources . JobsResourceTest . mockHostStatus ( com . google . common . collect . ImmutableMap . of ( jobId1 , com . spotify . helios . common . descriptors . Deployment . of ( jobId1 , Goal . START ) , jobId2 , com . spotify . helios . common . descriptors . Deployment . of ( jobId2 , Goal . START ) ) ) ; when ( model . getHostStatus ( \"foobar.example.net\" ) ) . thenReturn ( hostStatus ) ; when ( model . getHostStatus ( \"barfoo.example.net\" ) ) . thenReturn ( hostStatus ) ; when ( model . getJob ( jobId1 ) ) . thenReturn ( job1 ) ; when ( model . getJob ( jobId2 ) ) . thenReturn ( job2 ) ; \"<AssertPlaceHolder>\" ; } list ( java . lang . String , java . lang . String ) { final java . util . Map < com . spotify . helios . common . descriptors . JobId , com . spotify . helios . common . descriptors . Job > allJobs ; if ( ! ( hostPattern . isEmpty ( ) ) ) { allJobs = model . listHosts ( hostPattern ) . stream ( ) . map ( model :: getHostStatus ) . flatMap ( ( hostStatus ) -> hostStatus . getJobs ( ) . keySet ( ) . stream ( ) ) . distinct ( ) . collect ( java . util . stream . Collectors . toMap ( java . util . function . Function . identity ( ) , model :: getJob ) ) ; } else { allJobs = model . getJobs ( ) ; } if ( query . isEmpty ( ) ) { metrics . jobsInJobList ( allJobs . size ( ) ) ; return allJobs ; } final java . util . Map < com . spotify . helios . common . descriptors . JobId , com . spotify . helios . common . descriptors . Job > filteredJobs = com . google . common . collect . Maps . newHashMap ( ) ; for ( final Map . Entry < com . spotify . helios . common . descriptors . JobId , com . spotify . helios . common . descriptors . Job > entry : allJobs . entrySet ( ) ) { if ( entry . getKey ( ) . toString ( ) . contains ( query ) ) { filteredJobs . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } metrics . jobsInJobList ( filteredJobs . size ( ) ) ; return filteredJobs ; }", "answer": "org . junit . Assert . assertThat ( resource . list ( \"\" , namePattern ) , org . hamcrest . Matchers . is ( com . google . common . collect . ImmutableMap . of ( jobId1 , job1 , jobId2 , job2 ) ) )"}
{"focal": "getFields ( ) { return fields ; }", "testMethod": "testPickList ( ) { com . sforce . soap . partner . DescribeSObjectResult describeSObjectResult = new com . sforce . soap . partner . DescribeSObjectResult ( ) ; com . sforce . soap . partner . Field pickList = new com . sforce . soap . partner . Field ( ) ; pickList . setName ( \"pickList\" ) ; pickList . setType ( FieldType . picklist ) ; describeSObjectResult . setFields ( new com . sforce . soap . partner . Field [ ] { pickList } ) ; org . apache . avro . Schema schema = org . talend . components . salesforce . runtime . dataprep . SalesforceAvroRegistryString . get ( ) . inferSchema ( describeSObjectResult ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( 1 , org . hamcrest . Matchers . is ( schema . getFields ( ) . size ( ) ) )", "total": "testPickList ( ) { com . sforce . soap . partner . DescribeSObjectResult describeSObjectResult = new com . sforce . soap . partner . DescribeSObjectResult ( ) ; com . sforce . soap . partner . Field pickList = new com . sforce . soap . partner . Field ( ) ; pickList . setName ( \"pickList\" ) ; pickList . setType ( FieldType . picklist ) ; describeSObjectResult . setFields ( new com . sforce . soap . partner . Field [ ] { pickList } ) ; org . apache . avro . Schema schema = org . talend . components . salesforce . runtime . dataprep . SalesforceAvroRegistryString . get ( ) . inferSchema ( describeSObjectResult ) ; \"<AssertPlaceHolder>\" ; } getFields ( ) { return fields ; }", "answer": "org . junit . Assert . assertThat ( 1 , org . hamcrest . Matchers . is ( schema . getFields ( ) . size ( ) ) )"}
{"focal": "getFeatures ( ) { return features ; }", "testMethod": "shouldRetrieveAnnotatedField ( ) { final org . objectweb . asm . ClassWriter cw = initClassWriterFor ( \"test.utils.FieldAnnotatedTest\" ) ; uut = new com . github . bmsantos . core . cola . injector . InfoClassVisitor ( cw , getClass ( ) . getClassLoader ( ) ) ; cr . accept ( uut , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uut . getFeatures ( ) . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "shouldRetrieveAnnotatedField ( ) { final org . objectweb . asm . ClassWriter cw = initClassWriterFor ( \"test.utils.FieldAnnotatedTest\" ) ; uut = new com . github . bmsantos . core . cola . injector . InfoClassVisitor ( cw , getClass ( ) . getClassLoader ( ) ) ; cr . accept ( uut , 0 ) ; \"<AssertPlaceHolder>\" ; } getFeatures ( ) { return features ; }", "answer": "org . junit . Assert . assertThat ( uut . getFeatures ( ) . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getPattern ( ) { return pattern ; }", "testMethod": "pluralFormTwo ( ) { final org . apache . isis . applib . services . i18n . TranslatableString ts = org . apache . isis . applib . services . i18n . TranslatableString . trn ( \"You<sp>can't<sp>do<sp>that<sp>because<sp>there<sp>is<sp>a<sp>dependent<sp>object\" , \"You<sp>can't<sp>do<sp>that<sp>because<sp>there<sp>are<sp>dependent<sp>objects\" , 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ts . getPattern ( ) , org . hamcrest . CoreMatchers . is ( \"You<sp>can't<sp>do<sp>that<sp>because<sp>there<sp>are<sp>dependent<sp>objects\" ) )", "total": "pluralFormTwo ( ) { final org . apache . isis . applib . services . i18n . TranslatableString ts = org . apache . isis . applib . services . i18n . TranslatableString . trn ( \"You<sp>can't<sp>do<sp>that<sp>because<sp>there<sp>is<sp>a<sp>dependent<sp>object\" , \"You<sp>can't<sp>do<sp>that<sp>because<sp>there<sp>are<sp>dependent<sp>objects\" , 2 ) ; \"<AssertPlaceHolder>\" ; } getPattern ( ) { return pattern ; }", "answer": "org . junit . Assert . assertThat ( ts . getPattern ( ) , org . hamcrest . CoreMatchers . is ( \"You<sp>can't<sp>do<sp>that<sp>because<sp>there<sp>are<sp>dependent<sp>objects\" ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "read_null ( ) { com . asakusafw . runtime . io . json . value . IntOptionPropertyAdapter adapter = builder . build ( ) ; com . asakusafw . runtime . value . IntOption option = new com . asakusafw . runtime . value . IntOption ( 1234 ) ; adapter . read ( new com . asakusafw . runtime . io . json . value . MockValue ( null ) , option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( option , is ( new com . asakusafw . runtime . value . IntOption ( ) ) )", "total": "read_null ( ) { com . asakusafw . runtime . io . json . value . IntOptionPropertyAdapter adapter = builder . build ( ) ; com . asakusafw . runtime . value . IntOption option = new com . asakusafw . runtime . value . IntOption ( 1234 ) ; adapter . read ( new com . asakusafw . runtime . io . json . value . MockValue ( null ) , option ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( option , is ( new com . asakusafw . runtime . value . IntOption ( ) ) )"}
{"focal": "getOptions ( ) { return this . options ; }", "testMethod": "legacy_testOptionsWhenTwoDescriptionProvidersHigherRankingDoesntProvideOptions ( ) { org . eclipse . smarthome . core . types . StateDescription stateDescription1 = new org . eclipse . smarthome . core . types . StateDescription ( null , null , null , null , false , java . util . Collections . emptyList ( ) ) ; org . eclipse . smarthome . core . types . StateDescription stateDescription2 = new org . eclipse . smarthome . core . types . StateDescription ( null , null , null , null , false , java . util . Arrays . asList ( new org . eclipse . smarthome . core . types . StateOption ( \"value\" , \"label\" ) ) ) ; registerStateDescriptionProvider ( stateDescription1 , ( - 1 ) ) ; registerStateDescriptionProvider ( stateDescription2 , ( - 2 ) ) ; org . eclipse . smarthome . core . types . StateDescription finalStateDescription = item . getStateDescription ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( finalStateDescription . getOptions ( ) , org . hamcrest . CoreMatchers . is ( stateDescription2 . getOptions ( ) ) )", "total": "legacy_testOptionsWhenTwoDescriptionProvidersHigherRankingDoesntProvideOptions ( ) { org . eclipse . smarthome . core . types . StateDescription stateDescription1 = new org . eclipse . smarthome . core . types . StateDescription ( null , null , null , null , false , java . util . Collections . emptyList ( ) ) ; org . eclipse . smarthome . core . types . StateDescription stateDescription2 = new org . eclipse . smarthome . core . types . StateDescription ( null , null , null , null , false , java . util . Arrays . asList ( new org . eclipse . smarthome . core . types . StateOption ( \"value\" , \"label\" ) ) ) ; registerStateDescriptionProvider ( stateDescription1 , ( - 1 ) ) ; registerStateDescriptionProvider ( stateDescription2 , ( - 2 ) ) ; org . eclipse . smarthome . core . types . StateDescription finalStateDescription = item . getStateDescription ( ) ; \"<AssertPlaceHolder>\" ; } getOptions ( ) { return this . options ; }", "answer": "org . junit . Assert . assertThat ( finalStateDescription . getOptions ( ) , org . hamcrest . CoreMatchers . is ( stateDescription2 . getOptions ( ) ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsOtherInstance ( ) { org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( match ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsOtherInstance ( ) { org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( match ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "toString ( ) { org . apache . commons . lang3 . builder . ToStringBuilder b = new org . apache . commons . lang3 . builder . ToStringBuilder ( this , org . apache . commons . lang3 . builder . ToStringStyle . SHORT_PREFIX_STYLE ) ; if ( ( ( myLocationCol ) != null ) || ( ( myLocationLine ) != null ) ) { b . append ( \"col\" , myLocationCol ) ; b . append ( \"row\" , myLocationLine ) ; } if ( ( myLocationString ) != null ) { b . append ( \"locationString\" , myLocationString ) ; } b . append ( \"message\" , myMessage ) ; if ( ( mySeverity ) != null ) { b . append ( \"severity\" , mySeverity . getCode ( ) ) ; } return b . toString ( ) ; }", "testMethod": "testNewHeaderBuilder_urlHasNoTrailingSlash_shouldNotTrimLastCharacter ( ) { java . lang . StringBuilder headerBuilder = ca . uhn . fhir . okhttp . client . OkHttpRestfulClient . newHeaderBuilder ( new java . lang . StringBuilder ( \"http://example.com\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( headerBuilder . toString ( ) , org . hamcrest . Matchers . equalTo ( \"http://example.com\" ) )", "total": "testNewHeaderBuilder_urlHasNoTrailingSlash_shouldNotTrimLastCharacter ( ) { java . lang . StringBuilder headerBuilder = ca . uhn . fhir . okhttp . client . OkHttpRestfulClient . newHeaderBuilder ( new java . lang . StringBuilder ( \"http://example.com\" ) ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { org . apache . commons . lang3 . builder . ToStringBuilder b = new org . apache . commons . lang3 . builder . ToStringBuilder ( this , org . apache . commons . lang3 . builder . ToStringStyle . SHORT_PREFIX_STYLE ) ; if ( ( ( myLocationCol ) != null ) || ( ( myLocationLine ) != null ) ) { b . append ( \"col\" , myLocationCol ) ; b . append ( \"row\" , myLocationLine ) ; } if ( ( myLocationString ) != null ) { b . append ( \"locationString\" , myLocationString ) ; } b . append ( \"message\" , myMessage ) ; if ( ( mySeverity ) != null ) { b . append ( \"severity\" , mySeverity . getCode ( ) ) ; } return b . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( headerBuilder . toString ( ) , org . hamcrest . Matchers . equalTo ( \"http://example.com\" ) )"}
{"focal": "stream ( net . time4j . Duration ) { if ( ( this . isEmpty ( ) ) && ( duration . isPositive ( ) ) ) { return java . util . stream . Stream . empty ( ) ; } net . time4j . range . DateInterval interval = this . toCanonical ( ) ; net . time4j . PlainDate start = interval . getStartAsCalendarDate ( ) ; net . time4j . PlainDate end = interval . getEndAsCalendarDate ( ) ; if ( ( start == null ) || ( end == null ) ) { throw new java . lang . IllegalStateException ( \"Streaming<sp>is<sp>not<sp>supported<sp>for<sp>infinite<sp>intervals.\" ) ; } return net . time4j . range . DateInterval . stream ( duration , start , end ) ; }", "testMethod": "stream ( ) { net . time4j . Moment start = net . time4j . PlainTimestamp . of ( 2014 , 5 , 1 , 23 , 0 ) . atUTC ( ) ; net . time4j . Moment end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 2 , 1 , 30 ) . atUTC ( ) ; net . time4j . range . MomentInterval interval = net . time4j . range . MomentInterval . between ( start , end ) ; net . time4j . MachineTime < ? > duration = net . time4j . MachineTime . ofPosixUnits ( 3601 , 0 ) ; java . util . List < net . time4j . Moment > expected = new java . util . ArrayList ( ) ; expected . add ( start ) ; expected . add ( net . time4j . PlainTimestamp . of ( 2014 , 5 , 2 , 0 , 0 , 1 ) . atUTC ( ) ) ; expected . add ( net . time4j . PlainTimestamp . of ( 2014 , 5 , 2 , 1 , 0 , 2 ) . atUTC ( ) ) ; java . util . List < net . time4j . Moment > result = interval . stream ( duration ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "stream ( ) { net . time4j . Moment start = net . time4j . PlainTimestamp . of ( 2014 , 5 , 1 , 23 , 0 ) . atUTC ( ) ; net . time4j . Moment end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 2 , 1 , 30 ) . atUTC ( ) ; net . time4j . range . MomentInterval interval = net . time4j . range . MomentInterval . between ( start , end ) ; net . time4j . MachineTime < ? > duration = net . time4j . MachineTime . ofPosixUnits ( 3601 , 0 ) ; java . util . List < net . time4j . Moment > expected = new java . util . ArrayList ( ) ; expected . add ( start ) ; expected . add ( net . time4j . PlainTimestamp . of ( 2014 , 5 , 2 , 0 , 0 , 1 ) . atUTC ( ) ) ; expected . add ( net . time4j . PlainTimestamp . of ( 2014 , 5 , 2 , 1 , 0 , 2 ) . atUTC ( ) ) ; java . util . List < net . time4j . Moment > result = interval . stream ( duration ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; } stream ( net . time4j . Duration ) { if ( ( this . isEmpty ( ) ) && ( duration . isPositive ( ) ) ) { return java . util . stream . Stream . empty ( ) ; } net . time4j . range . DateInterval interval = this . toCanonical ( ) ; net . time4j . PlainDate start = interval . getStartAsCalendarDate ( ) ; net . time4j . PlainDate end = interval . getEndAsCalendarDate ( ) ; if ( ( start == null ) || ( end == null ) ) { throw new java . lang . IllegalStateException ( \"Streaming<sp>is<sp>not<sp>supported<sp>for<sp>infinite<sp>intervals.\" ) ; } return net . time4j . range . DateInterval . stream ( duration , start , end ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getPath ( ) { return this . path ; }", "testMethod": "getPathIsCorrect ( ) { final java . lang . String iotHubHostname = \"test.iothub\" ; final java . lang . String deviceId = \"test-deviceid\" ; final java . lang . String eTag = \"test-etag\" ; final java . lang . String path = \"test-path\" ; new mockit . NonStrictExpectations ( ) { { mockIotHubUri . getPath ( ) ; result = path ; } } ; com . microsoft . azure . sdk . iot . device . net . IotHubAbandonUri abandonUri = new com . microsoft . azure . sdk . iot . device . net . IotHubAbandonUri ( iotHubHostname , deviceId , eTag , null ) ; java . lang . String testPath = abandonUri . getPath ( ) ; final java . lang . String expectedPath = path ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testPath , org . hamcrest . CoreMatchers . is ( expectedPath ) )", "total": "getPathIsCorrect ( ) { final java . lang . String iotHubHostname = \"test.iothub\" ; final java . lang . String deviceId = \"test-deviceid\" ; final java . lang . String eTag = \"test-etag\" ; final java . lang . String path = \"test-path\" ; new mockit . NonStrictExpectations ( ) { { mockIotHubUri . getPath ( ) ; result = path ; } } ; com . microsoft . azure . sdk . iot . device . net . IotHubAbandonUri abandonUri = new com . microsoft . azure . sdk . iot . device . net . IotHubAbandonUri ( iotHubHostname , deviceId , eTag , null ) ; java . lang . String testPath = abandonUri . getPath ( ) ; final java . lang . String expectedPath = path ; \"<AssertPlaceHolder>\" ; } getPath ( ) { return this . path ; }", "answer": "org . junit . Assert . assertThat ( testPath , org . hamcrest . CoreMatchers . is ( expectedPath ) )"}
{"focal": "toMap ( com . facebook . buck . core . build . engine . manifest . Manifest ) { com . google . common . collect . ImmutableMap . Builder < com . facebook . buck . core . rulekey . RuleKey , com . google . common . collect . ImmutableMap < java . lang . String , com . google . common . hash . HashCode > > builder = com . google . common . collect . ImmutableMap . builder ( ) ; for ( com . facebook . buck . util . types . Pair < com . facebook . buck . core . rulekey . RuleKey , int [ ] > entry : manifest . entries ) { com . google . common . collect . ImmutableMap . Builder < java . lang . String , com . google . common . hash . HashCode > entryBuilder = com . google . common . collect . ImmutableMap . builder ( ) ; for ( int hashIndex : entry . getSecond ( ) ) { com . facebook . buck . util . types . Pair < java . lang . Integer , com . google . common . hash . HashCode > hashEntry = manifest . hashes . get ( hashIndex ) ; java . lang . String input = manifest . inputs . get ( hashEntry . getFirst ( ) ) ; com . google . common . hash . HashCode inputHash = hashEntry . getSecond ( ) ; entryBuilder . put ( input , inputHash ) ; } builder . put ( entry . getFirst ( ) , entryBuilder . build ( ) ) ; } return builder . build ( ) ; }", "testMethod": "serialize ( ) { com . google . common . collect . ImmutableMap < com . facebook . buck . core . rulekey . RuleKey , com . google . common . collect . ImmutableMap < java . lang . String , com . google . common . hash . HashCode > > entries = com . google . common . collect . ImmutableMap . of ( new com . facebook . buck . core . rulekey . RuleKey ( \"aa\" ) , com . google . common . collect . ImmutableMap . of ( \"foo/bar.h\" , com . google . common . hash . HashCode . fromInt ( 20 ) ) ) ; java . io . ByteArrayOutputStream byteArrayOutputStream = new java . io . ByteArrayOutputStream ( ) ; com . facebook . buck . core . build . engine . manifest . ManifestUtil . fromMap ( new com . facebook . buck . core . rulekey . RuleKey ( \"cc\" ) , entries ) . serialize ( byteArrayOutputStream ) ; com . facebook . buck . core . build . engine . manifest . Manifest deserialized = new com . facebook . buck . core . build . engine . manifest . Manifest ( new java . io . ByteArrayInputStream ( byteArrayOutputStream . toByteArray ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . facebook . buck . core . build . engine . manifest . ManifestUtil . toMap ( deserialized ) , org . hamcrest . Matchers . equalTo ( entries ) )", "total": "serialize ( ) { com . google . common . collect . ImmutableMap < com . facebook . buck . core . rulekey . RuleKey , com . google . common . collect . ImmutableMap < java . lang . String , com . google . common . hash . HashCode > > entries = com . google . common . collect . ImmutableMap . of ( new com . facebook . buck . core . rulekey . RuleKey ( \"aa\" ) , com . google . common . collect . ImmutableMap . of ( \"foo/bar.h\" , com . google . common . hash . HashCode . fromInt ( 20 ) ) ) ; java . io . ByteArrayOutputStream byteArrayOutputStream = new java . io . ByteArrayOutputStream ( ) ; com . facebook . buck . core . build . engine . manifest . ManifestUtil . fromMap ( new com . facebook . buck . core . rulekey . RuleKey ( \"cc\" ) , entries ) . serialize ( byteArrayOutputStream ) ; com . facebook . buck . core . build . engine . manifest . Manifest deserialized = new com . facebook . buck . core . build . engine . manifest . Manifest ( new java . io . ByteArrayInputStream ( byteArrayOutputStream . toByteArray ( ) ) ) ; \"<AssertPlaceHolder>\" ; } toMap ( com . facebook . buck . core . build . engine . manifest . Manifest ) { com . google . common . collect . ImmutableMap . Builder < com . facebook . buck . core . rulekey . RuleKey , com . google . common . collect . ImmutableMap < java . lang . String , com . google . common . hash . HashCode > > builder = com . google . common . collect . ImmutableMap . builder ( ) ; for ( com . facebook . buck . util . types . Pair < com . facebook . buck . core . rulekey . RuleKey , int [ ] > entry : manifest . entries ) { com . google . common . collect . ImmutableMap . Builder < java . lang . String , com . google . common . hash . HashCode > entryBuilder = com . google . common . collect . ImmutableMap . builder ( ) ; for ( int hashIndex : entry . getSecond ( ) ) { com . facebook . buck . util . types . Pair < java . lang . Integer , com . google . common . hash . HashCode > hashEntry = manifest . hashes . get ( hashIndex ) ; java . lang . String input = manifest . inputs . get ( hashEntry . getFirst ( ) ) ; com . google . common . hash . HashCode inputHash = hashEntry . getSecond ( ) ; entryBuilder . put ( input , inputHash ) ; } builder . put ( entry . getFirst ( ) , entryBuilder . build ( ) ) ; } return builder . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( com . facebook . buck . core . build . engine . manifest . ManifestUtil . toMap ( deserialized ) , org . hamcrest . Matchers . equalTo ( entries ) )"}
{"focal": "getProductName ( ) { return productName ; }", "testMethod": "testProductNameDoesNotExist ( ) { org . codice . ddf . configuration . DictionaryMap < java . lang . String , java . lang . Object > configProps = new org . codice . ddf . configuration . DictionaryMap ( ) ; org . osgi . service . cm . Configuration configuration = mock ( org . osgi . service . cm . Configuration . class ) ; org . osgi . service . cm . Configuration [ ] configurations = new org . osgi . service . cm . Configuration [ ] { configuration } ; when ( configurationAdmin . listConfigurations ( \"(service.pid=ddf.platform.ui.config)\" ) ) . thenReturn ( configurations ) ; when ( configurationAdmin . getConfiguration ( \"ddf.platform.ui.config\" , null ) ) . thenReturn ( configuration ) ; when ( configuration . getProperties ( ) ) . thenReturn ( configProps ) ; org . codice . ddf . ui . searchui . simple . properties . UiConfigurationPropertiesFactory . getInstance ( ) . setConfigurationAdmin ( configurationAdmin ) ; org . codice . ddf . ui . searchui . simple . properties . UiConfigurationProperties props = org . codice . ddf . ui . searchui . simple . properties . UiConfigurationPropertiesFactory . getInstance ( ) . getProperties ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( props . getProductName ( ) , org . hamcrest . core . Is . is ( \"\" ) )", "total": "testProductNameDoesNotExist ( ) { org . codice . ddf . configuration . DictionaryMap < java . lang . String , java . lang . Object > configProps = new org . codice . ddf . configuration . DictionaryMap ( ) ; org . osgi . service . cm . Configuration configuration = mock ( org . osgi . service . cm . Configuration . class ) ; org . osgi . service . cm . Configuration [ ] configurations = new org . osgi . service . cm . Configuration [ ] { configuration } ; when ( configurationAdmin . listConfigurations ( \"(service.pid=ddf.platform.ui.config)\" ) ) . thenReturn ( configurations ) ; when ( configurationAdmin . getConfiguration ( \"ddf.platform.ui.config\" , null ) ) . thenReturn ( configuration ) ; when ( configuration . getProperties ( ) ) . thenReturn ( configProps ) ; org . codice . ddf . ui . searchui . simple . properties . UiConfigurationPropertiesFactory . getInstance ( ) . setConfigurationAdmin ( configurationAdmin ) ; org . codice . ddf . ui . searchui . simple . properties . UiConfigurationProperties props = org . codice . ddf . ui . searchui . simple . properties . UiConfigurationPropertiesFactory . getInstance ( ) . getProperties ( ) ; \"<AssertPlaceHolder>\" ; } getProductName ( ) { return productName ; }", "answer": "org . junit . Assert . assertThat ( props . getProductName ( ) , org . hamcrest . core . Is . is ( \"\" ) )"}
{"focal": "hasPermission ( org . dayatang . security . domain . Permission ) { return getPermissions ( ) . contains ( permission ) ; }", "testMethod": "testHasPermission ( ) { org . dayatang . security . domain . Role role = org . dayatang . security . domain . Role . getByName ( \"role1\" ) ; org . dayatang . security . domain . FunctionalPermission permission = org . dayatang . security . domain . FunctionalPermission . getByFunction ( \"addUser\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( role . hasPermission ( permission ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testHasPermission ( ) { org . dayatang . security . domain . Role role = org . dayatang . security . domain . Role . getByName ( \"role1\" ) ; org . dayatang . security . domain . FunctionalPermission permission = org . dayatang . security . domain . FunctionalPermission . getByFunction ( \"addUser\" ) ; \"<AssertPlaceHolder>\" ; } hasPermission ( org . dayatang . security . domain . Permission ) { return getPermissions ( ) . contains ( permission ) ; }", "answer": "org . junit . Assert . assertThat ( role . hasPermission ( permission ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getText ( ) { if ( ( editArea ) == null ) { return null ; } return editArea . getText ( ) ; }", "testMethod": "populatesTimeTextFieldFromProfile ( ) { com . eviware . soapui . impl . rest . OAuth2Profile profile = com . eviware . soapui . impl . rest . actions . oauth . OAuth2TestUtils . getOAuthProfileWithDefaultValues ( ) ; profile . setManualAccessTokenExpirationTime ( \"90\" ) ; initializeChooserFromProfile ( profile ) ; javax . swing . JTextField timeField = walker . findComponent ( ExpirationTimeChooser . TIME_FIELD_NAME , javax . swing . JTextField . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( timeField . getText ( ) , org . hamcrest . CoreMatchers . is ( \"90\" ) )", "total": "populatesTimeTextFieldFromProfile ( ) { com . eviware . soapui . impl . rest . OAuth2Profile profile = com . eviware . soapui . impl . rest . actions . oauth . OAuth2TestUtils . getOAuthProfileWithDefaultValues ( ) ; profile . setManualAccessTokenExpirationTime ( \"90\" ) ; initializeChooserFromProfile ( profile ) ; javax . swing . JTextField timeField = walker . findComponent ( ExpirationTimeChooser . TIME_FIELD_NAME , javax . swing . JTextField . class ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { if ( ( editArea ) == null ) { return null ; } return editArea . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( timeField . getText ( ) , org . hamcrest . CoreMatchers . is ( \"90\" ) )"}
{"focal": "expr ( org . openscience . cdk . isomorphism . matchers . Expr$Type , int ) { return new org . openscience . cdk . isomorphism . matchers . Expr ( type , val ) ; }", "testMethod": "periodicTableGroupCDKLegacy ( ) { org . openscience . cdk . isomorphism . matchers . Expr actual = org . openscience . cdk . smarts . SmartsExprReadTest . getAtomExpr ( \"[G16]\" , Smarts . FLAVOR_CDK_LEGACY ) ; org . openscience . cdk . isomorphism . matchers . Expr expected = org . openscience . cdk . smarts . SmartsExprReadTest . expr ( org . openscience . cdk . smarts . PERIODIC_GROUP , 16 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "periodicTableGroupCDKLegacy ( ) { org . openscience . cdk . isomorphism . matchers . Expr actual = org . openscience . cdk . smarts . SmartsExprReadTest . getAtomExpr ( \"[G16]\" , Smarts . FLAVOR_CDK_LEGACY ) ; org . openscience . cdk . isomorphism . matchers . Expr expected = org . openscience . cdk . smarts . SmartsExprReadTest . expr ( org . openscience . cdk . smarts . PERIODIC_GROUP , 16 ) ; \"<AssertPlaceHolder>\" ; } expr ( org . openscience . cdk . isomorphism . matchers . Expr$Type , int ) { return new org . openscience . cdk . isomorphism . matchers . Expr ( type , val ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "toString ( ) { return \"<function5>\" ; }", "testMethod": "toString_A$ ( ) { com . m3 . scalaflavor4j . RichVoidFunction5 < java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String > vf = new com . m3 . scalaflavor4j . RichVoidFunction5 ( new com . m3 . scalaflavor4j . VoidF5 < java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String > ( ) { public void apply ( java . lang . String v1 , java . lang . String v2 , java . lang . String v3 , java . lang . String v4 , java . lang . String v5 ) { System . out . println ( ( ( ( ( v1 + v2 ) + v3 ) + v4 ) + v5 ) ) ; } } ) ; java . lang . String actual = vf . toString ( ) ; java . lang . String expected = \"<void-function5>\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "toString_A$ ( ) { com . m3 . scalaflavor4j . RichVoidFunction5 < java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String > vf = new com . m3 . scalaflavor4j . RichVoidFunction5 ( new com . m3 . scalaflavor4j . VoidF5 < java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String > ( ) { public void apply ( java . lang . String v1 , java . lang . String v2 , java . lang . String v3 , java . lang . String v4 , java . lang . String v5 ) { System . out . println ( ( ( ( ( v1 + v2 ) + v3 ) + v4 ) + v5 ) ) ; } } ) ; java . lang . String actual = vf . toString ( ) ; java . lang . String expected = \"<void-function5>\" ; \"<AssertPlaceHolder>\" ; } toString ( ) { return \"<function5>\" ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "magPersoonGeleverdWorden ( nl . bzk . brp . model . hisvolledig . predikaatview . kern . PersoonHisVolledigView ) { boolean magPersoonGeleverdWorden = false ; if ( ( persoonView != null ) && ( persoonView . isMagGeleverdWorden ( ) ) ) { if ( heeftWijzigingenInIdentificerendeGroep ( persoonView ) ) { magPersoonGeleverdWorden = true ; } else if ( isAfgeleidAdministratiefInhoudelijkGewijzigd ( persoonView ) ) { magPersoonGeleverdWorden = true ; } else if ( heeftWijzigingenBuitenIdentificerendeGroep ( persoonView ) ) { magPersoonGeleverdWorden = true ; } else if ( persoonView . heeftBetrokkenhedenVoorLeveren ( ) ) { magPersoonGeleverdWorden = true ; } else if ( heeftWijzigingenDoorOnderzoek ( persoonView ) ) { magPersoonGeleverdWorden = true ; } } return magPersoonGeleverdWorden ; }", "testMethod": "testMagWelGeleverdWordenHeeftWijzigingenInIdentificerendeGroep ( ) { final nl . bzk . brp . model . hisvolledig . impl . kern . PersoonHisVolledigImpl persoonHisVolledig = nl . bzk . brp . util . testpersoonbouwers . TestPersoonJohnnyJordaan . maak ( ) ; final nl . bzk . brp . model . hisvolledig . predikaatview . kern . PersoonHisVolledigView persoon = new nl . bzk . brp . model . hisvolledig . predikaatview . kern . PersoonHisVolledigView ( persoonHisVolledig , new nl . bzk . brp . model . hisvolledig . predikaat . AdministratieveHandelingDeltaPredikaat ( 3L ) ) ; final boolean resultaat = bepaler . magPersoonGeleverdWorden ( persoon ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultaat , org . hamcrest . Matchers . is ( true ) )", "total": "testMagWelGeleverdWordenHeeftWijzigingenInIdentificerendeGroep ( ) { final nl . bzk . brp . model . hisvolledig . impl . kern . PersoonHisVolledigImpl persoonHisVolledig = nl . bzk . brp . util . testpersoonbouwers . TestPersoonJohnnyJordaan . maak ( ) ; final nl . bzk . brp . model . hisvolledig . predikaatview . kern . PersoonHisVolledigView persoon = new nl . bzk . brp . model . hisvolledig . predikaatview . kern . PersoonHisVolledigView ( persoonHisVolledig , new nl . bzk . brp . model . hisvolledig . predikaat . AdministratieveHandelingDeltaPredikaat ( 3L ) ) ; final boolean resultaat = bepaler . magPersoonGeleverdWorden ( persoon ) ; \"<AssertPlaceHolder>\" ; } magPersoonGeleverdWorden ( nl . bzk . brp . model . hisvolledig . predikaatview . kern . PersoonHisVolledigView ) { boolean magPersoonGeleverdWorden = false ; if ( ( persoonView != null ) && ( persoonView . isMagGeleverdWorden ( ) ) ) { if ( heeftWijzigingenInIdentificerendeGroep ( persoonView ) ) { magPersoonGeleverdWorden = true ; } else if ( isAfgeleidAdministratiefInhoudelijkGewijzigd ( persoonView ) ) { magPersoonGeleverdWorden = true ; } else if ( heeftWijzigingenBuitenIdentificerendeGroep ( persoonView ) ) { magPersoonGeleverdWorden = true ; } else if ( persoonView . heeftBetrokkenhedenVoorLeveren ( ) ) { magPersoonGeleverdWorden = true ; } else if ( heeftWijzigingenDoorOnderzoek ( persoonView ) ) { magPersoonGeleverdWorden = true ; } } return magPersoonGeleverdWorden ; }", "answer": "org . junit . Assert . assertThat ( resultaat , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "get ( java . lang . Object ) { return this . metaDataMap . get ( o ) ; }", "testMethod": "shouldFindRelativePositionOfSecond ( ) { java . util . List < com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step > steps = newArrayList ( com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . step ( \"1\" ) , com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . step ( \"2\" ) , com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . step ( \"3\" ) ) ; com . adobe . acs . commons . wcm . comparisons . impl . lines . Stepper < com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step > underTest = new com . adobe . acs . commons . wcm . comparisons . impl . lines . Stepper < com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step > ( steps , com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . toId ) ; underTest . next ( ) ; final int position = underTest . positionOfIdAfterCurrent ( steps . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( position , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "shouldFindRelativePositionOfSecond ( ) { java . util . List < com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step > steps = newArrayList ( com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . step ( \"1\" ) , com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . step ( \"2\" ) , com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . step ( \"3\" ) ) ; com . adobe . acs . commons . wcm . comparisons . impl . lines . Stepper < com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step > underTest = new com . adobe . acs . commons . wcm . comparisons . impl . lines . Stepper < com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step > ( steps , com . adobe . acs . commons . wcm . comparisons . impl . lines . StepperTest . Step . toId ) ; underTest . next ( ) ; final int position = underTest . positionOfIdAfterCurrent ( steps . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . Object ) { return this . metaDataMap . get ( o ) ; }", "answer": "org . junit . Assert . assertThat ( position , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "handleResponse ( org . apache . http . HttpResponse ) { return response . getStatusLine ( ) . getStatusCode ( ) ; }", "testMethod": "test201 ( ) { net . jadler . Jadler . onRequest ( ) . respond ( ) . withStatus ( 201 ) ; final int status = org . apache . http . client . fluent . Executor . newInstance ( ) . execute ( org . apache . http . client . fluent . Request . Get ( jadlerUri ( ) ) ) . handleResponse ( net . jadler . STATUS_RETRIEVER ) ; \"<AssertPlaceHolder>\" ; net . jadler . Jadler . verifyThatRequest ( ) . receivedOnce ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( 201 ) )", "total": "test201 ( ) { net . jadler . Jadler . onRequest ( ) . respond ( ) . withStatus ( 201 ) ; final int status = org . apache . http . client . fluent . Executor . newInstance ( ) . execute ( org . apache . http . client . fluent . Request . Get ( jadlerUri ( ) ) ) . handleResponse ( net . jadler . STATUS_RETRIEVER ) ; \"<AssertPlaceHolder>\" ; net . jadler . Jadler . verifyThatRequest ( ) . receivedOnce ( ) ; } handleResponse ( org . apache . http . HttpResponse ) { return response . getStatusLine ( ) . getStatusCode ( ) ; }", "answer": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( 201 ) )"}
{"focal": "mkString ( java . lang . String ) { return mkString ( \"\" , sep , \"\" ) ; }", "testMethod": "mkString_A$String_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . String > seq = com . m3 . scalaflavor4j . Seq . apply ( emptyList ) ; java . lang . String sep = \"-\" ; java . lang . String actual = seq . mkString ( sep ) ; java . lang . String expected = \"\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "mkString_A$String_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . String > seq = com . m3 . scalaflavor4j . Seq . apply ( emptyList ) ; java . lang . String sep = \"-\" ; java . lang . String actual = seq . mkString ( sep ) ; java . lang . String expected = \"\" ; \"<AssertPlaceHolder>\" ; } mkString ( java . lang . String ) { return mkString ( \"\" , sep , \"\" ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "isNull ( ) { mark ( 1024 ) ; char ch = readAndSkipBlank ( ) ; if ( ( ( pos ) + 3 ) > ( limit ) ) { reset ( ) ; return false ; } if ( ( ( ( ch == 'n' ) && ( 'u' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) { if ( ( pos ) >= ( limit ) ) return true ; ch = readAndSkipBlank ( ) ; if ( isEndFlag ( ch ) ) { ( pos ) -- ; return true ; } else { reset ( ) ; return false ; } } else { reset ( ) ; return false ; } }", "testMethod": "testIsNull3 ( ) { com . firefly . utils . json . JsonReader reader = new com . firefly . utils . json . io . JsonStringReader ( \"<sp>nul\" ) ; \"<AssertPlaceHolder>\" ; reader . close ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( reader . isNull ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "testIsNull3 ( ) { com . firefly . utils . json . JsonReader reader = new com . firefly . utils . json . io . JsonStringReader ( \"<sp>nul\" ) ; \"<AssertPlaceHolder>\" ; reader . close ( ) ; } isNull ( ) { mark ( 1024 ) ; char ch = readAndSkipBlank ( ) ; if ( ( ( pos ) + 3 ) > ( limit ) ) { reset ( ) ; return false ; } if ( ( ( ( ch == 'n' ) && ( 'u' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) { if ( ( pos ) >= ( limit ) ) return true ; ch = readAndSkipBlank ( ) ; if ( isEndFlag ( ch ) ) { ( pos ) -- ; return true ; } else { reset ( ) ; return false ; } } else { reset ( ) ; return false ; } }", "answer": "org . junit . Assert . assertThat ( reader . isNull ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "is ( java . lang . Class ) { br . com . caelum . vraptor . proxy . MethodInvocation < T > handler = new br . com . caelum . vraptor . proxy . MethodInvocation < T > ( ) { public java . lang . Object intercept ( java . lang . Object proxy , java . lang . reflect . Method method , java . lang . Object [ ] args , br . com . caelum . vraptor . proxy . SuperMethod superMethod ) { boolean alreadySetTheStrategy = ! ( strategy . getClass ( ) . equals ( br . com . caelum . vraptor . http . route . NoStrategy . class ) ) ; if ( alreadySetTheStrategy ) { return null ; } is ( type , method ) ; return null ; } } ; return proxifier . proxify ( type , handler ) ; }", "testMethod": "if_formatIsSpecifiedReturnIt ( ) { when ( request . getParameter ( \"_format\" ) ) . thenReturn ( \"xml\" ) ; java . lang . String format = resolver . getAcceptFormat ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( format , org . hamcrest . Matchers . is ( \"xml\" ) )", "total": "if_formatIsSpecifiedReturnIt ( ) { when ( request . getParameter ( \"_format\" ) ) . thenReturn ( \"xml\" ) ; java . lang . String format = resolver . getAcceptFormat ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { br . com . caelum . vraptor . proxy . MethodInvocation < T > handler = new br . com . caelum . vraptor . proxy . MethodInvocation < T > ( ) { public java . lang . Object intercept ( java . lang . Object proxy , java . lang . reflect . Method method , java . lang . Object [ ] args , br . com . caelum . vraptor . proxy . SuperMethod superMethod ) { boolean alreadySetTheStrategy = ! ( strategy . getClass ( ) . equals ( br . com . caelum . vraptor . http . route . NoStrategy . class ) ) ; if ( alreadySetTheStrategy ) { return null ; } is ( type , method ) ; return null ; } } ; return proxifier . proxify ( type , handler ) ; }", "answer": "org . junit . Assert . assertThat ( format , org . hamcrest . Matchers . is ( \"xml\" ) )"}
{"focal": "toString ( ) { return \"<function5>\" ; }", "testMethod": "dropNull_A$ ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Nil . apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > actual = seq . dropNull ( ) ; java . lang . String expected = \"Seq()\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . toString ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "dropNull_A$ ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Nil . apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > actual = seq . dropNull ( ) ; java . lang . String expected = \"Seq()\" ; \"<AssertPlaceHolder>\" ; } toString ( ) { return \"<function5>\" ; }", "answer": "org . junit . Assert . assertThat ( actual . toString ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "getText ( ) { return stb . getText ( ) ; }", "testMethod": "testLowerCaseAlphaKeys ( ) { org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"enabeledTextElement\" ) ) ; element . clear ( ) ; java . lang . String lowerAlphas = \"abcdefghijklmnopqrstuvwxyz\" ; element . sendKeys ( lowerAlphas ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( element . getText ( ) , org . hamcrest . Matchers . is ( lowerAlphas ) )", "total": "testLowerCaseAlphaKeys ( ) { org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"enabeledTextElement\" ) ) ; element . clear ( ) ; java . lang . String lowerAlphas = \"abcdefghijklmnopqrstuvwxyz\" ; element . sendKeys ( lowerAlphas ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { return stb . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( element . getText ( ) , org . hamcrest . Matchers . is ( lowerAlphas ) )"}
{"focal": "getLength ( ) { return data . capacity ( ) ; }", "testMethod": "launchActionShouldNotContainRemoteRunnableWhenNotProvided ( ) { ImmutableMap . Builder < com . facebook . buck . apple . xcode . xcodeproj . PBXTarget , java . nio . file . Path > targetToProjectPathMapBuilder = com . google . common . collect . ImmutableMap . builder ( ) ; com . facebook . buck . apple . xcode . xcodeproj . PBXTarget rootTarget = new com . facebook . buck . apple . xcode . xcodeproj . PBXNativeTarget ( \"rootRule\" ) ; rootTarget . setGlobalID ( \"rootGID\" ) ; rootTarget . setProductReference ( new com . facebook . buck . apple . xcode . xcodeproj . PBXFileReference ( \"root.a\" , \"root.a\" , PBXReference . SourceTree . BUILT_PRODUCTS_DIR , java . util . Optional . empty ( ) ) ) ; rootTarget . setProductType ( ProductTypes . STATIC_LIBRARY ) ; java . nio . file . Path pbxprojectPath = java . nio . file . Paths . get ( \"foo/Foo.xcodeproj/project.pbxproj\" ) ; targetToProjectPathMapBuilder . put ( rootTarget , pbxprojectPath ) ; com . facebook . buck . features . apple . project . SchemeGenerator schemeGenerator = new com . facebook . buck . features . apple . project . SchemeGenerator ( projectFilesystem , java . util . Optional . of ( rootTarget ) , com . google . common . collect . ImmutableSet . of ( rootTarget ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , \"TestScheme\" , java . nio . file . Paths . get ( \"_gen/Foo.xcworkspace/scshareddata/xcshemes\" ) , false , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) , SchemeActionType . DEFAULT_CONFIG_NAMES , targetToProjectPathMapBuilder . build ( ) , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) , XCScheme . LaunchAction . LaunchStyle . AUTO , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) ) ; java . nio . file . Path schemePath = schemeGenerator . writeScheme ( ) ; javax . xml . parsers . DocumentBuilderFactory dbFactory = javax . xml . parsers . DocumentBuilderFactory . newInstance ( ) ; javax . xml . parsers . DocumentBuilder dBuilder = dbFactory . newDocumentBuilder ( ) ; org . w3c . dom . Document scheme = dBuilder . parse ( projectFilesystem . newFileInputStream ( schemePath ) ) ; javax . xml . xpath . XPathFactory xpathFactory = javax . xml . xpath . XPathFactory . newInstance ( ) ; javax . xml . xpath . XPath remoteRunnableLaunchActionXPath = xpathFactory . newXPath ( ) ; javax . xml . xpath . XPathExpression remoteRunnableLaunchActionExpr = remoteRunnableLaunchActionXPath . compile ( \"//LaunchAction/RemoteRunnable\" ) ; org . w3c . dom . NodeList remoteRunnables = ( ( org . w3c . dom . NodeList ) ( remoteRunnableLaunchActionExpr . evaluate ( scheme , XPathConstants . NODESET ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( remoteRunnables . getLength ( ) , org . hamcrest . Matchers . equalTo ( 0 ) )", "total": "launchActionShouldNotContainRemoteRunnableWhenNotProvided ( ) { ImmutableMap . Builder < com . facebook . buck . apple . xcode . xcodeproj . PBXTarget , java . nio . file . Path > targetToProjectPathMapBuilder = com . google . common . collect . ImmutableMap . builder ( ) ; com . facebook . buck . apple . xcode . xcodeproj . PBXTarget rootTarget = new com . facebook . buck . apple . xcode . xcodeproj . PBXNativeTarget ( \"rootRule\" ) ; rootTarget . setGlobalID ( \"rootGID\" ) ; rootTarget . setProductReference ( new com . facebook . buck . apple . xcode . xcodeproj . PBXFileReference ( \"root.a\" , \"root.a\" , PBXReference . SourceTree . BUILT_PRODUCTS_DIR , java . util . Optional . empty ( ) ) ) ; rootTarget . setProductType ( ProductTypes . STATIC_LIBRARY ) ; java . nio . file . Path pbxprojectPath = java . nio . file . Paths . get ( \"foo/Foo.xcodeproj/project.pbxproj\" ) ; targetToProjectPathMapBuilder . put ( rootTarget , pbxprojectPath ) ; com . facebook . buck . features . apple . project . SchemeGenerator schemeGenerator = new com . facebook . buck . features . apple . project . SchemeGenerator ( projectFilesystem , java . util . Optional . of ( rootTarget ) , com . google . common . collect . ImmutableSet . of ( rootTarget ) , com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( ) , \"TestScheme\" , java . nio . file . Paths . get ( \"_gen/Foo.xcworkspace/scshareddata/xcshemes\" ) , false , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) , SchemeActionType . DEFAULT_CONFIG_NAMES , targetToProjectPathMapBuilder . build ( ) , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) , XCScheme . LaunchAction . LaunchStyle . AUTO , java . util . Optional . empty ( ) , java . util . Optional . empty ( ) ) ; java . nio . file . Path schemePath = schemeGenerator . writeScheme ( ) ; javax . xml . parsers . DocumentBuilderFactory dbFactory = javax . xml . parsers . DocumentBuilderFactory . newInstance ( ) ; javax . xml . parsers . DocumentBuilder dBuilder = dbFactory . newDocumentBuilder ( ) ; org . w3c . dom . Document scheme = dBuilder . parse ( projectFilesystem . newFileInputStream ( schemePath ) ) ; javax . xml . xpath . XPathFactory xpathFactory = javax . xml . xpath . XPathFactory . newInstance ( ) ; javax . xml . xpath . XPath remoteRunnableLaunchActionXPath = xpathFactory . newXPath ( ) ; javax . xml . xpath . XPathExpression remoteRunnableLaunchActionExpr = remoteRunnableLaunchActionXPath . compile ( \"//LaunchAction/RemoteRunnable\" ) ; org . w3c . dom . NodeList remoteRunnables = ( ( org . w3c . dom . NodeList ) ( remoteRunnableLaunchActionExpr . evaluate ( scheme , XPathConstants . NODESET ) ) ) ; \"<AssertPlaceHolder>\" ; } getLength ( ) { return data . capacity ( ) ; }", "answer": "org . junit . Assert . assertThat ( remoteRunnables . getLength ( ) , org . hamcrest . Matchers . equalTo ( 0 ) )"}
{"focal": "isValidSchemaEvolution ( io . confluent . ksql . util . PersistentQueryMetadata , io . confluent . kafka . schemaregistry . client . SchemaRegistryClient ) { if ( ( persistentQueryMetadata . getResultTopicSerde ( ) ) != ( DataSource . DataSourceSerDe . AVRO ) ) { return true ; } final org . apache . avro . Schema avroSchema = io . confluent . ksql . util . SchemaUtil . buildAvroSchema ( persistentQueryMetadata . getResultSchema ( ) , persistentQueryMetadata . getResultTopic ( ) . getName ( ) ) ; final java . lang . String topicName = persistentQueryMetadata . getResultTopic ( ) . getKafkaTopicName ( ) ; return io . confluent . ksql . util . AvroUtil . isValidAvroSchemaForTopic ( topicName , avroSchema , schemaRegistryClient ) ; }", "testMethod": "shouldReturnValidEvolutionIfSubjectNotRegistered ( ) { when ( srClient . testCompatibility ( any ( ) , any ( ) ) ) . thenThrow ( new io . confluent . kafka . schemaregistry . client . rest . exceptions . RestClientException ( \"Unknown<sp>subject\" , 404 , 40401 ) ) ; final boolean result = io . confluent . ksql . util . AvroUtil . isValidSchemaEvolution ( persistentQuery , srClient ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )", "total": "shouldReturnValidEvolutionIfSubjectNotRegistered ( ) { when ( srClient . testCompatibility ( any ( ) , any ( ) ) ) . thenThrow ( new io . confluent . kafka . schemaregistry . client . rest . exceptions . RestClientException ( \"Unknown<sp>subject\" , 404 , 40401 ) ) ; final boolean result = io . confluent . ksql . util . AvroUtil . isValidSchemaEvolution ( persistentQuery , srClient ) ; \"<AssertPlaceHolder>\" ; } isValidSchemaEvolution ( io . confluent . ksql . util . PersistentQueryMetadata , io . confluent . kafka . schemaregistry . client . SchemaRegistryClient ) { if ( ( persistentQueryMetadata . getResultTopicSerde ( ) ) != ( DataSource . DataSourceSerDe . AVRO ) ) { return true ; } final org . apache . avro . Schema avroSchema = io . confluent . ksql . util . SchemaUtil . buildAvroSchema ( persistentQueryMetadata . getResultSchema ( ) , persistentQueryMetadata . getResultTopic ( ) . getName ( ) ) ; final java . lang . String topicName = persistentQueryMetadata . getResultTopic ( ) . getKafkaTopicName ( ) ; return io . confluent . ksql . util . AvroUtil . isValidAvroSchemaForTopic ( topicName , avroSchema , schemaRegistryClient ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "get ( ) { return value ; }", "testMethod": "testDelegateCalledBeforeRuleCreation ( ) { com . facebook . buck . core . model . BuildTarget target = com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//:rule\" ) ; com . facebook . buck . core . rules . BuildRule rule = new com . facebook . buck . core . build . engine . impl . CachingBuildEngineTest . EmptyBuildRule ( target , filesystem ) ; java . util . concurrent . atomic . AtomicReference < com . facebook . buck . core . rules . BuildRule > lastRuleToBeBuilt = new java . util . concurrent . atomic . AtomicReference ( ) ; com . facebook . buck . core . build . engine . delegate . CachingBuildEngineDelegate testDelegate = new com . facebook . buck . core . build . engine . delegate . LocalCachingBuildEngineDelegate ( fileHashCache ) { @ com . facebook . buck . core . build . engine . impl . Override public void onRuleAboutToBeBuilt ( com . facebook . buck . core . rules . BuildRule buildRule ) { super . onRuleAboutToBeBuilt ( buildRule ) ; lastRuleToBeBuilt . set ( buildRule ) ; } } ; try ( com . facebook . buck . core . build . engine . impl . CachingBuildEngine cachingBuildEngine = cachingBuildEngineFactory ( ) . setCachingBuildEngineDelegate ( testDelegate ) . build ( ) ) { cachingBuildEngine . build ( buildContext , com . facebook . buck . step . TestExecutionContext . newInstance ( ) , rule ) . getResult ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( lastRuleToBeBuilt . get ( ) , org . hamcrest . Matchers . is ( rule ) )", "total": "testDelegateCalledBeforeRuleCreation ( ) { com . facebook . buck . core . model . BuildTarget target = com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//:rule\" ) ; com . facebook . buck . core . rules . BuildRule rule = new com . facebook . buck . core . build . engine . impl . CachingBuildEngineTest . EmptyBuildRule ( target , filesystem ) ; java . util . concurrent . atomic . AtomicReference < com . facebook . buck . core . rules . BuildRule > lastRuleToBeBuilt = new java . util . concurrent . atomic . AtomicReference ( ) ; com . facebook . buck . core . build . engine . delegate . CachingBuildEngineDelegate testDelegate = new com . facebook . buck . core . build . engine . delegate . LocalCachingBuildEngineDelegate ( fileHashCache ) { @ com . facebook . buck . core . build . engine . impl . Override public void onRuleAboutToBeBuilt ( com . facebook . buck . core . rules . BuildRule buildRule ) { super . onRuleAboutToBeBuilt ( buildRule ) ; lastRuleToBeBuilt . set ( buildRule ) ; } } ; try ( com . facebook . buck . core . build . engine . impl . CachingBuildEngine cachingBuildEngine = cachingBuildEngineFactory ( ) . setCachingBuildEngineDelegate ( testDelegate ) . build ( ) ) { cachingBuildEngine . build ( buildContext , com . facebook . buck . step . TestExecutionContext . newInstance ( ) , rule ) . getResult ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; } } get ( ) { return value ; }", "answer": "org . junit . Assert . assertThat ( lastRuleToBeBuilt . get ( ) , org . hamcrest . Matchers . is ( rule ) )"}
{"focal": "isEmpty ( ) { return map . isEmpty ( ) ; }", "testMethod": "testGetL2Db ( ) { resultMap = defaultIsisLsdb . getL2Db ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultMap . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testGetL2Db ( ) { resultMap = defaultIsisLsdb . getL2Db ( ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return map . isEmpty ( ) ; }", "answer": "org . junit . Assert . assertThat ( resultMap . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "hasReportedProperty ( int , java . lang . String ) { return org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter . hasReports ( org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter . whatever ( ) , hasEntry ( ( ( long ) ( count ) ) , path ) ) ; }", "testMethod": "getPropertiesReportsProperty ( ) { final org . apache . jackrabbit . oak . spi . state . NodeBuilder builder = EmptyNodeState . EMPTY_NODE . builder ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { builder . setProperty ( ( \"a\" + i ) , \"foo\" ) ; } final org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter reporter = new org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter ( 10 , 10 ) ; final org . apache . jackrabbit . oak . spi . state . NodeState nodeState = org . apache . jackrabbit . oak . plugins . migration . report . ReportingNodeState . wrap ( builder . getNodeState ( ) , reporter ) ; reporter . reset ( ) ; int counter = 0 ; for ( final org . apache . jackrabbit . oak . api . PropertyState property : nodeState . getProperties ( ) ) { if ( ( ++ counter ) == 10 ) { break ; } } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( reporter , org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter . hasReportedProperty ( 10 , org . hamcrest . CoreMatchers . any ( java . lang . String . class ) ) )", "total": "getPropertiesReportsProperty ( ) { final org . apache . jackrabbit . oak . spi . state . NodeBuilder builder = EmptyNodeState . EMPTY_NODE . builder ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { builder . setProperty ( ( \"a\" + i ) , \"foo\" ) ; } final org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter reporter = new org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter ( 10 , 10 ) ; final org . apache . jackrabbit . oak . spi . state . NodeState nodeState = org . apache . jackrabbit . oak . plugins . migration . report . ReportingNodeState . wrap ( builder . getNodeState ( ) , reporter ) ; reporter . reset ( ) ; int counter = 0 ; for ( final org . apache . jackrabbit . oak . api . PropertyState property : nodeState . getProperties ( ) ) { if ( ( ++ counter ) == 10 ) { break ; } } \"<AssertPlaceHolder>\" ; } hasReportedProperty ( int , java . lang . String ) { return org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter . hasReports ( org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter . whatever ( ) , hasEntry ( ( ( long ) ( count ) ) , path ) ) ; }", "answer": "org . junit . Assert . assertThat ( reporter , org . apache . jackrabbit . oak . plugins . migration . report . AssertingPeriodicReporter . hasReportedProperty ( 10 , org . hamcrest . CoreMatchers . any ( java . lang . String . class ) ) )"}
{"focal": "getProperties ( java . lang . String ) { io . ebean . text . PathProperties . Props props = pathMap . get ( path ) ; return props == null ? null : props . getProperties ( ) ; }", "testMethod": "test_all_properties ( ) { io . ebean . FetchPath root = io . ebean . text . PathProperties . parse ( \"*\" ) ; \"<AssertPlaceHolder>\" . containsExactly ( \"*\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( root . getProperties ( null ) )", "total": "test_all_properties ( ) { io . ebean . FetchPath root = io . ebean . text . PathProperties . parse ( \"*\" ) ; \"<AssertPlaceHolder>\" . containsExactly ( \"*\" ) ; } getProperties ( java . lang . String ) { io . ebean . text . PathProperties . Props props = pathMap . get ( path ) ; return props == null ? null : props . getProperties ( ) ; }", "answer": "org . junit . Assert . assertThat ( root . getProperties ( null ) )"}
{"focal": "findByParty ( org . estatio . module . party . dom . Party ) { return allMatches ( \"findByParty\" , \"party\" , party ) ; }", "testMethod": "happyCase ( ) { org . estatio . module . agreement . dom . AgreementRole existingRole = agreementRoleRepository . findByParty ( party ) . get ( 0 ) ; existingRole . setEndDate ( new org . joda . time . LocalDate ( 2013 , 12 , 31 ) ) ; wrap ( agreement ) . newRole ( agreementRoleTypeRepository . findByTitle ( LeaseAgreementRoleTypeEnum . MANAGER . getTitle ( ) ) , party , new org . joda . time . LocalDate ( 2014 , 1 , 1 ) , new org . joda . time . LocalDate ( 2014 , 12 , 31 ) ) ; wrap ( agreement ) . newRole ( agreementRoleTypeRepository . findByTitle ( LeaseAgreementRoleTypeEnum . MANAGER . getTitle ( ) ) , party , new org . joda . time . LocalDate ( 2015 , 1 , 1 ) , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( agreementRoleRepository . findByParty ( party ) . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "happyCase ( ) { org . estatio . module . agreement . dom . AgreementRole existingRole = agreementRoleRepository . findByParty ( party ) . get ( 0 ) ; existingRole . setEndDate ( new org . joda . time . LocalDate ( 2013 , 12 , 31 ) ) ; wrap ( agreement ) . newRole ( agreementRoleTypeRepository . findByTitle ( LeaseAgreementRoleTypeEnum . MANAGER . getTitle ( ) ) , party , new org . joda . time . LocalDate ( 2014 , 1 , 1 ) , new org . joda . time . LocalDate ( 2014 , 12 , 31 ) ) ; wrap ( agreement ) . newRole ( agreementRoleTypeRepository . findByTitle ( LeaseAgreementRoleTypeEnum . MANAGER . getTitle ( ) ) , party , new org . joda . time . LocalDate ( 2015 , 1 , 1 ) , null ) ; \"<AssertPlaceHolder>\" ; } findByParty ( org . estatio . module . party . dom . Party ) { return allMatches ( \"findByParty\" , \"party\" , party ) ; }", "answer": "org . junit . Assert . assertThat ( agreementRoleRepository . findByParty ( party ) . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "getSortColumn ( ) { return this . sortColumn ; }", "testMethod": "shouldDelegateGetSortColumn ( ) { java . lang . String sortColumn = \"column\" ; given ( this . delegate . getSortColumn ( ) ) . willReturn ( sortColumn ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . request . getSortColumn ( ) , org . hamcrest . CoreMatchers . is ( sortColumn ) )", "total": "shouldDelegateGetSortColumn ( ) { java . lang . String sortColumn = \"column\" ; given ( this . delegate . getSortColumn ( ) ) . willReturn ( sortColumn ) ; \"<AssertPlaceHolder>\" ; } getSortColumn ( ) { return this . sortColumn ; }", "answer": "org . junit . Assert . assertThat ( this . request . getSortColumn ( ) , org . hamcrest . CoreMatchers . is ( sortColumn ) )"}
{"focal": "getNoOfParties ( ) { return delegate . getNoOfParties ( ) ; }", "testMethod": "getNoOfParties ( ) { dk . alexandra . fresco . logging . NetworkLoggingDecorator networkLoggingDecorator = new dk . alexandra . fresco . logging . NetworkLoggingDecorator ( new dk . alexandra . fresco . framework . network . Network ( ) { @ dk . alexandra . fresco . logging . Override public void send ( int partyId , byte [ ] data ) { } @ dk . alexandra . fresco . logging . Override public byte [ ] receive ( int partyId ) { return new byte [ 0 ] ; } @ dk . alexandra . fresco . logging . Override public int getNoOfParties ( ) { return 22 ; } } ) ; \"<AssertPlaceHolder>\" ; networkLoggingDecorator . close ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( networkLoggingDecorator . getNoOfParties ( ) , org . hamcrest . core . Is . is ( 22 ) )", "total": "getNoOfParties ( ) { dk . alexandra . fresco . logging . NetworkLoggingDecorator networkLoggingDecorator = new dk . alexandra . fresco . logging . NetworkLoggingDecorator ( new dk . alexandra . fresco . framework . network . Network ( ) { @ dk . alexandra . fresco . logging . Override public void send ( int partyId , byte [ ] data ) { } @ dk . alexandra . fresco . logging . Override public byte [ ] receive ( int partyId ) { return new byte [ 0 ] ; } @ dk . alexandra . fresco . logging . Override public int getNoOfParties ( ) { return 22 ; } } ) ; \"<AssertPlaceHolder>\" ; networkLoggingDecorator . close ( ) ; } getNoOfParties ( ) { return delegate . getNoOfParties ( ) ; }", "answer": "org . junit . Assert . assertThat ( networkLoggingDecorator . getNoOfParties ( ) , org . hamcrest . core . Is . is ( 22 ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldExcludeAllPrimitiveFieldsInACollection ( ) { java . lang . String expectedResult = \"{\\\"list\\\":<sp>[{},{}]}\" ; java . util . List < br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order > orders = new java . util . ArrayList < br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order > ( ) ; orders . add ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"nykolas<sp>lima\" ) , 15.0 , \"gift<sp>bags,<sp>please\" ) ) ; orders . add ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"Rafael<sp>Dipold\" ) , 15.0 , \"gift<sp>bags,<sp>please\" ) ) ; serialization . from ( orders ) . excludeAll ( ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldExcludeAllPrimitiveFieldsInACollection ( ) { java . lang . String expectedResult = \"{\\\"list\\\":<sp>[{},{}]}\" ; java . util . List < br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order > orders = new java . util . ArrayList < br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order > ( ) ; orders . add ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"nykolas<sp>lima\" ) , 15.0 , \"gift<sp>bags,<sp>please\" ) ) ; orders . add ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"Rafael<sp>Dipold\" ) , 15.0 , \"gift<sp>bags,<sp>please\" ) ) ; serialization . from ( orders ) . excludeAll ( ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "newTable ( ) { org . apache . hadoop . hive . metastore . api . Table table = new org . apache . hadoop . hive . metastore . api . Table ( ) ; org . apache . hadoop . hive . metastore . api . StorageDescriptor sd = new org . apache . hadoop . hive . metastore . api . StorageDescriptor ( ) ; org . apache . hadoop . hive . metastore . api . SerDeInfo info = new org . apache . hadoop . hive . metastore . api . SerDeInfo ( ) ; info . setParameters ( new java . util . HashMap < java . lang . String , java . lang . String > ( ) ) ; sd . setSerdeInfo ( info ) ; table . setSd ( sd ) ; table . setParameters ( new java . util . HashMap < java . lang . String , java . lang . String > ( ) ) ; return table ; }", "testMethod": "missingAvroDestinationFolder ( ) { com . hotels . bdp . circustrain . api . event . EventReplicaTable eventReplicaTable = new com . hotels . bdp . circustrain . api . event . EventReplicaTable ( \"db\" , \"table\" , \"location\" ) ; when ( tableReplicationEvent . getReplicaTable ( ) ) . thenReturn ( eventReplicaTable ) ; transformation . tableReplicationStart ( tableReplicationEvent , \"eventId\" ) ; transformation . transform ( table ) ; verifyZeroInteractions ( schemaCopier ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( table , org . hamcrest . CoreMatchers . is ( com . hotels . bdp . circustrain . avro . TestUtils . newTable ( ) ) )", "total": "missingAvroDestinationFolder ( ) { com . hotels . bdp . circustrain . api . event . EventReplicaTable eventReplicaTable = new com . hotels . bdp . circustrain . api . event . EventReplicaTable ( \"db\" , \"table\" , \"location\" ) ; when ( tableReplicationEvent . getReplicaTable ( ) ) . thenReturn ( eventReplicaTable ) ; transformation . tableReplicationStart ( tableReplicationEvent , \"eventId\" ) ; transformation . transform ( table ) ; verifyZeroInteractions ( schemaCopier ) ; \"<AssertPlaceHolder>\" ; } newTable ( ) { org . apache . hadoop . hive . metastore . api . Table table = new org . apache . hadoop . hive . metastore . api . Table ( ) ; org . apache . hadoop . hive . metastore . api . StorageDescriptor sd = new org . apache . hadoop . hive . metastore . api . StorageDescriptor ( ) ; org . apache . hadoop . hive . metastore . api . SerDeInfo info = new org . apache . hadoop . hive . metastore . api . SerDeInfo ( ) ; info . setParameters ( new java . util . HashMap < java . lang . String , java . lang . String > ( ) ) ; sd . setSerdeInfo ( info ) ; table . setSd ( sd ) ; table . setParameters ( new java . util . HashMap < java . lang . String , java . lang . String > ( ) ) ; return table ; }", "answer": "org . junit . Assert . assertThat ( table , org . hamcrest . CoreMatchers . is ( com . hotels . bdp . circustrain . avro . TestUtils . newTable ( ) ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "load ( ) { org . apache . hadoop . conf . Configuration conf = new org . apache . hadoop . conf . Configuration ( ) ; com . asakusafw . runtime . flow . RuntimeResourceManager manager = new com . asakusafw . runtime . flow . RuntimeResourceManager ( conf ) ; java . util . List < com . asakusafw . runtime . core . legacy . RuntimeResource > loaded = manager . load ( ) ; boolean found = false ; for ( com . asakusafw . runtime . core . legacy . RuntimeResource resource : loaded ) { if ( resource instanceof com . asakusafw . runtime . core . legacy . LegacyReport . Initializer ) { found = true ; break ; } } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( found , is ( true ) )", "total": "load ( ) { org . apache . hadoop . conf . Configuration conf = new org . apache . hadoop . conf . Configuration ( ) ; com . asakusafw . runtime . flow . RuntimeResourceManager manager = new com . asakusafw . runtime . flow . RuntimeResourceManager ( conf ) ; java . util . List < com . asakusafw . runtime . core . legacy . RuntimeResource > loaded = manager . load ( ) ; boolean found = false ; for ( com . asakusafw . runtime . core . legacy . RuntimeResource resource : loaded ) { if ( resource instanceof com . asakusafw . runtime . core . legacy . LegacyReport . Initializer ) { found = true ; break ; } } \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( found , is ( true ) )"}
{"focal": "estimatedDuration ( ) { return formatted ( lastBuild ( ) . estimatedDuration ( ) ) ; }", "testMethod": "should_not_say_anything_if_it_doesnt_know_how_long_the_next_build_is_supposed_to_take ( ) { view = a ( jobView ( ) . of ( a ( job ( ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( view . estimatedDuration ( ) , org . hamcrest . core . Is . is ( \"\" ) )", "total": "should_not_say_anything_if_it_doesnt_know_how_long_the_next_build_is_supposed_to_take ( ) { view = a ( jobView ( ) . of ( a ( job ( ) ) ) ) ; \"<AssertPlaceHolder>\" ; } estimatedDuration ( ) { return formatted ( lastBuild ( ) . estimatedDuration ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( view . estimatedDuration ( ) , org . hamcrest . core . Is . is ( \"\" ) )"}
{"focal": "toList ( java . lang . Object ) { java . util . Objects . requireNonNull ( array ) ; if ( array . getClass ( ) . isArray ( ) ) { int len = java . lang . reflect . Array . getLength ( array ) ; java . util . List < java . lang . Object > objs = new java . util . ArrayList ( ) ; for ( int i = 0 ; i < len ; i ++ ) { objs . add ( java . lang . reflect . Array . get ( array , i ) ) ; } return objs ; } else { throw new java . lang . ClassCastException ( \"\" ) ; } }", "testMethod": "toList4 ( ) { java . lang . Integer [ ] ids = new org . fastquery . util . Integer [ ] { 1 , 2 , 3 } ; java . util . List < java . lang . Object > objects = org . fastquery . util . TypeUtil . toList ( ids ) ; for ( int i = 0 ; i < ( ids . length ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( ids [ i ] , equalTo ( objects . get ( i ) ) )", "total": "toList4 ( ) { java . lang . Integer [ ] ids = new org . fastquery . util . Integer [ ] { 1 , 2 , 3 } ; java . util . List < java . lang . Object > objects = org . fastquery . util . TypeUtil . toList ( ids ) ; for ( int i = 0 ; i < ( ids . length ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } } toList ( java . lang . Object ) { java . util . Objects . requireNonNull ( array ) ; if ( array . getClass ( ) . isArray ( ) ) { int len = java . lang . reflect . Array . getLength ( array ) ; java . util . List < java . lang . Object > objs = new java . util . ArrayList ( ) ; for ( int i = 0 ; i < len ; i ++ ) { objs . add ( java . lang . reflect . Array . get ( array , i ) ) ; } return objs ; } else { throw new java . lang . ClassCastException ( \"\" ) ; } }", "answer": "org . junit . Assert . assertThat ( ids [ i ] , equalTo ( objects . get ( i ) ) )"}
{"focal": "create ( java . lang . String , java . lang . String , java . lang . String [ ] ) { return nl . knaw . huygens . timbuctoo . security . dto . ImmutableVreAuthorization . builder ( ) . vreId ( vreId ) . userId ( userId ) . addRoles ( roles ) . build ( ) ; }", "testMethod": "isAllowedToWriteReturnsTrueIfTheRolesContainUser ( ) { nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization instance = nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization . create ( \"\" , \"\" , nl . knaw . huygens . timbuctoo . security . USER_ROLE ) ; boolean allowedToWrite = instance . isAllowedToWrite ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allowedToWrite , org . hamcrest . core . Is . is ( true ) )", "total": "isAllowedToWriteReturnsTrueIfTheRolesContainUser ( ) { nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization instance = nl . knaw . huygens . timbuctoo . security . dto . VreAuthorization . create ( \"\" , \"\" , nl . knaw . huygens . timbuctoo . security . USER_ROLE ) ; boolean allowedToWrite = instance . isAllowedToWrite ( ) ; \"<AssertPlaceHolder>\" ; } create ( java . lang . String , java . lang . String , java . lang . String [ ] ) { return nl . knaw . huygens . timbuctoo . security . dto . ImmutableVreAuthorization . builder ( ) . vreId ( vreId ) . userId ( userId ) . addRoles ( roles ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( allowedToWrite , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "mainFlow ( java . io . Reader ) { java . io . BufferedReader br = new java . io . BufferedReader ( in ) ; int num = 0 ; try { num = java . lang . Integer . parseInt ( br . readLine ( ) ) ; } catch ( java . lang . NumberFormatException iexc ) { System . out . println ( \"Wrong<sp>numeric\" ) ; } return num ; }", "testMethod": "WhenPutInFlowIntThanGetItFromFlow ( ) { ru . szhernovoy . AddTwoNum obj = new ru . szhernovoy . AddTwoNum ( ) ; java . lang . System . setIn ( new java . io . StringBufferInputStream ( \"1\" ) ) ; int result = obj . mainFlow ( new java . io . InputStreamReader ( System . in ) ) ; int message = 1 ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( message ) )", "total": "WhenPutInFlowIntThanGetItFromFlow ( ) { ru . szhernovoy . AddTwoNum obj = new ru . szhernovoy . AddTwoNum ( ) ; java . lang . System . setIn ( new java . io . StringBufferInputStream ( \"1\" ) ) ; int result = obj . mainFlow ( new java . io . InputStreamReader ( System . in ) ) ; int message = 1 ; \"<AssertPlaceHolder>\" ; } mainFlow ( java . io . Reader ) { java . io . BufferedReader br = new java . io . BufferedReader ( in ) ; int num = 0 ; try { num = java . lang . Integer . parseInt ( br . readLine ( ) ) ; } catch ( java . lang . NumberFormatException iexc ) { System . out . println ( \"Wrong<sp>numeric\" ) ; } return num ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( message ) )"}
{"focal": "swapSourceAndDestinationFields ( net . sf . javabdd . BDD ) { return bdd . replace ( _swapSourceAndDestinationPairing ) ; }", "testMethod": "testSwapSourceAndDestinationFields ( ) { org . batfish . common . bdd . BDDPacket pkt = new org . batfish . common . bdd . BDDPacket ( ) ; org . batfish . common . bdd . BDDInteger dstIp = pkt . getDstIp ( ) ; org . batfish . common . bdd . BDDInteger srcIp = pkt . getSrcIp ( ) ; org . batfish . common . bdd . BDDInteger dstPort = pkt . getDstPort ( ) ; org . batfish . common . bdd . BDDInteger srcPort = pkt . getSrcPort ( ) ; org . batfish . datamodel . Ip ip1 = org . batfish . datamodel . Ip . parse ( \"1.1.1.1\" ) ; org . batfish . datamodel . Ip ip2 = org . batfish . datamodel . Ip . parse ( \"2.2.2.2\" ) ; org . batfish . datamodel . Ip ip3 = org . batfish . datamodel . Ip . parse ( \"3.3.3.3\" ) ; org . batfish . datamodel . Ip ip4 = org . batfish . datamodel . Ip . parse ( \"4.4.4.4\" ) ; java . util . function . BiFunction < org . batfish . common . bdd . BDDInteger , org . batfish . common . bdd . BDDInteger , java . util . function . Function < org . batfish . common . bdd . BDDInteger , net . sf . javabdd . BDD > > mkBdd = ( ipVar1 , ipVar2 ) -> ( portVar ) -> ipVar1 . value ( ip1 . asLong ( ) ) . and ( ipVar2 . value ( ip2 . asLong ( ) ) ) . and ( portVar . value ( 0 ) ) . or ( ipVar1 . value ( ip3 . asLong ( ) ) . and ( ipVar2 . value ( ip4 . asLong ( ) ) ) . and ( ipVar1 . value ( 1 ) ) ) ; net . sf . javabdd . BDD orig = mkBdd . apply ( dstIp , srcIp ) . apply ( dstPort ) ; net . sf . javabdd . BDD swapped = mkBdd . apply ( srcIp , dstIp ) . apply ( srcPort ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pkt . swapSourceAndDestinationFields ( orig ) , org . hamcrest . Matchers . equalTo ( swapped ) )", "total": "testSwapSourceAndDestinationFields ( ) { org . batfish . common . bdd . BDDPacket pkt = new org . batfish . common . bdd . BDDPacket ( ) ; org . batfish . common . bdd . BDDInteger dstIp = pkt . getDstIp ( ) ; org . batfish . common . bdd . BDDInteger srcIp = pkt . getSrcIp ( ) ; org . batfish . common . bdd . BDDInteger dstPort = pkt . getDstPort ( ) ; org . batfish . common . bdd . BDDInteger srcPort = pkt . getSrcPort ( ) ; org . batfish . datamodel . Ip ip1 = org . batfish . datamodel . Ip . parse ( \"1.1.1.1\" ) ; org . batfish . datamodel . Ip ip2 = org . batfish . datamodel . Ip . parse ( \"2.2.2.2\" ) ; org . batfish . datamodel . Ip ip3 = org . batfish . datamodel . Ip . parse ( \"3.3.3.3\" ) ; org . batfish . datamodel . Ip ip4 = org . batfish . datamodel . Ip . parse ( \"4.4.4.4\" ) ; java . util . function . BiFunction < org . batfish . common . bdd . BDDInteger , org . batfish . common . bdd . BDDInteger , java . util . function . Function < org . batfish . common . bdd . BDDInteger , net . sf . javabdd . BDD > > mkBdd = ( ipVar1 , ipVar2 ) -> ( portVar ) -> ipVar1 . value ( ip1 . asLong ( ) ) . and ( ipVar2 . value ( ip2 . asLong ( ) ) ) . and ( portVar . value ( 0 ) ) . or ( ipVar1 . value ( ip3 . asLong ( ) ) . and ( ipVar2 . value ( ip4 . asLong ( ) ) ) . and ( ipVar1 . value ( 1 ) ) ) ; net . sf . javabdd . BDD orig = mkBdd . apply ( dstIp , srcIp ) . apply ( dstPort ) ; net . sf . javabdd . BDD swapped = mkBdd . apply ( srcIp , dstIp ) . apply ( srcPort ) ; \"<AssertPlaceHolder>\" ; } swapSourceAndDestinationFields ( net . sf . javabdd . BDD ) { return bdd . replace ( _swapSourceAndDestinationPairing ) ; }", "answer": "org . junit . Assert . assertThat ( pkt . swapSourceAndDestinationFields ( orig ) , org . hamcrest . Matchers . equalTo ( swapped ) )"}
{"focal": "isDefinedAt ( java . lang . Object ) { return getCaseClauses ( ) . foldLeft ( false , new com . m3 . scalaflavor4j . F2 < java . lang . Boolean , com . m3 . scalaflavor4j . CaseClause < ? , R > , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . Boolean isDefinedAt , com . m3 . scalaflavor4j . CaseClause < ? , R > caseClause ) throws com . m3 . scalaflavor4j . Exception { if ( isDefinedAt ) { return true ; } return caseClause . isDefinedAt ( v ) ; } } ) ; }", "testMethod": "isDefinedAt_A$int ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; for ( int i = - 3 ; i < 3 ; i ++ ) { boolean actual = nil . isDefinedAt ( i ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isDefinedAt_A$int ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; for ( int i = - 3 ; i < 3 ; i ++ ) { boolean actual = nil . isDefinedAt ( i ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } } isDefinedAt ( java . lang . Object ) { return getCaseClauses ( ) . foldLeft ( false , new com . m3 . scalaflavor4j . F2 < java . lang . Boolean , com . m3 . scalaflavor4j . CaseClause < ? , R > , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . Boolean isDefinedAt , com . m3 . scalaflavor4j . CaseClause < ? , R > caseClause ) throws com . m3 . scalaflavor4j . Exception { if ( isDefinedAt ) { return true ; } return caseClause . isDefinedAt ( v ) ; } } ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "roundtrip ( java . lang . Object ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutputStream oos = new java . io . ObjectOutputStream ( baos ) ; oos . writeObject ( obj ) ; byte [ ] data = baos . toByteArray ( ) ; oos . close ( ) ; java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( data ) ; java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( bais ) ; java . lang . Object ser = ois . readObject ( ) ; ois . close ( ) ; return ser ; }", "testMethod": "roundTripOfMomentInterval ( ) { net . time4j . Moment start = net . time4j . PlainTimestamp . of ( 2014 , 2 , 27 , 0 , 0 ) . atUTC ( ) ; net . time4j . Moment end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 ) . atUTC ( ) ; java . lang . Object interval = net . time4j . range . MomentInterval . between ( start , end ) ; java . lang . Object ser = net . time4j . range . SerializationTest . roundtrip ( interval ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interval , org . hamcrest . CoreMatchers . is ( ser ) )", "total": "roundTripOfMomentInterval ( ) { net . time4j . Moment start = net . time4j . PlainTimestamp . of ( 2014 , 2 , 27 , 0 , 0 ) . atUTC ( ) ; net . time4j . Moment end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 ) . atUTC ( ) ; java . lang . Object interval = net . time4j . range . MomentInterval . between ( start , end ) ; java . lang . Object ser = net . time4j . range . SerializationTest . roundtrip ( interval ) ; \"<AssertPlaceHolder>\" ; } roundtrip ( java . lang . Object ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutputStream oos = new java . io . ObjectOutputStream ( baos ) ; oos . writeObject ( obj ) ; byte [ ] data = baos . toByteArray ( ) ; oos . close ( ) ; java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( data ) ; java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( bais ) ; java . lang . Object ser = ois . readObject ( ) ; ois . close ( ) ; return ser ; }", "answer": "org . junit . Assert . assertThat ( interval , org . hamcrest . CoreMatchers . is ( ser ) )"}
{"focal": "getDuedate ( ) { return duedate ; }", "testMethod": "shouldScheduleToNow ( ) { testRule . deploy ( PROCESS ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE ) ; runtimeService . startProcessInstanceByKey ( PROCESS_KEY ) ; java . lang . String taskId = taskService . createTaskQuery ( ) . singleResult ( ) . getId ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { taskService . addCandidateUser ( taskId , ( \"aUserId\" + i ) ) ; } taskService . complete ( taskId ) ; engineConfiguration . setHistoryCleanupBatchSize ( 5 ) ; engineConfiguration . initHistoryCleanup ( ) ; java . util . Date removalTime = org . apache . commons . lang3 . time . DateUtils . addDays ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE , 5 ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( removalTime ) ; runHistoryCleanup ( ) ; org . camunda . bpm . engine . runtime . Job job = historyService . findHistoryCleanupJobs ( ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( job . getDuedate ( ) , org . hamcrest . core . Is . is ( removalTime ) )", "total": "shouldScheduleToNow ( ) { testRule . deploy ( PROCESS ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE ) ; runtimeService . startProcessInstanceByKey ( PROCESS_KEY ) ; java . lang . String taskId = taskService . createTaskQuery ( ) . singleResult ( ) . getId ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { taskService . addCandidateUser ( taskId , ( \"aUserId\" + i ) ) ; } taskService . complete ( taskId ) ; engineConfiguration . setHistoryCleanupBatchSize ( 5 ) ; engineConfiguration . initHistoryCleanup ( ) ; java . util . Date removalTime = org . apache . commons . lang3 . time . DateUtils . addDays ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE , 5 ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( removalTime ) ; runHistoryCleanup ( ) ; org . camunda . bpm . engine . runtime . Job job = historyService . findHistoryCleanupJobs ( ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; } getDuedate ( ) { return duedate ; }", "answer": "org . junit . Assert . assertThat ( job . getDuedate ( ) , org . hamcrest . core . Is . is ( removalTime ) )"}
{"focal": "hashCode ( ) { return edgeSet ( ) . hashCode ( ) ; }", "testMethod": "testHashCode ( ) { org . openscience . cdk . io . formats . IResourceFormat a = resourceFormat . getClass ( ) . newInstance ( ) ; org . openscience . cdk . io . formats . IResourceFormat b = resourceFormat . getClass ( ) . newInstance ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( a . hashCode ( ) , org . hamcrest . CoreMatchers . is ( b . hashCode ( ) ) )", "total": "testHashCode ( ) { org . openscience . cdk . io . formats . IResourceFormat a = resourceFormat . getClass ( ) . newInstance ( ) ; org . openscience . cdk . io . formats . IResourceFormat b = resourceFormat . getClass ( ) . newInstance ( ) ; \"<AssertPlaceHolder>\" ; } hashCode ( ) { return edgeSet ( ) . hashCode ( ) ; }", "answer": "org . junit . Assert . assertThat ( a . hashCode ( ) , org . hamcrest . CoreMatchers . is ( b . hashCode ( ) ) )"}
{"focal": "save ( java . lang . String ) { return persist ( entity ) ; }", "testMethod": "itPersistsEntities ( ) { \"<AssertPlaceHolder>\" ; verify ( session ) . saveOrUpdate ( \"woo\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( dao . save ( \"woo\" ) , org . hamcrest . CoreMatchers . is ( \"woo\" ) )", "total": "itPersistsEntities ( ) { \"<AssertPlaceHolder>\" ; verify ( session ) . saveOrUpdate ( \"woo\" ) ; } save ( java . lang . String ) { return persist ( entity ) ; }", "answer": "org . junit . Assert . assertThat ( dao . save ( \"woo\" ) , org . hamcrest . CoreMatchers . is ( \"woo\" ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "scanLeft_A$Object$Function2 ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Nil . apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > actual = seq . scanLeft ( 0 , new com . m3 . scalaflavor4j . F2 < java . lang . Integer , java . lang . Integer , java . lang . Integer > ( ) { @ com . m3 . scalaflavor4j . Override public com . m3 . scalaflavor4j . Integer apply ( java . lang . Integer acm , java . lang . Integer i ) { return acm + i ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "scanLeft_A$Object$Function2 ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Nil . apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > actual = seq . scanLeft ( 0 , new com . m3 . scalaflavor4j . F2 < java . lang . Integer , java . lang . Integer , java . lang . Integer > ( ) { @ com . m3 . scalaflavor4j . Override public com . m3 . scalaflavor4j . Integer apply ( java . lang . Integer acm , java . lang . Integer i ) { return acm + i ; } } ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "makeResults ( java . lang . String , boolean ) { java . lang . String lombokResult = de . plushnikov . intellij . plugin . thirdparty . LombokHandlerUtil . toGetterName ( de . plushnikov . intellij . plugin . thirdparty . LombokUtilsGetterTest . DEFAULT_ACCESSORS , fieldName , isBoolean ) ; java . lang . String result = de . plushnikov . intellij . plugin . thirdparty . LombokUtils . toGetterName ( de . plushnikov . intellij . plugin . thirdparty . LombokUtilsGetterTest . DEFAULT_ACCESSORS , fieldName , isBoolean ) ; org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( lombokResult ) ) ; return result ; }", "testMethod": "testToGetterNames_Boolean_is_Uppercase ( ) { java . lang . String result = makeResults ( \"isMyField\" , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( \"isMyField\" ) )", "total": "testToGetterNames_Boolean_is_Uppercase ( ) { java . lang . String result = makeResults ( \"isMyField\" , true ) ; \"<AssertPlaceHolder>\" ; } makeResults ( java . lang . String , boolean ) { java . lang . String lombokResult = de . plushnikov . intellij . plugin . thirdparty . LombokHandlerUtil . toGetterName ( de . plushnikov . intellij . plugin . thirdparty . LombokUtilsGetterTest . DEFAULT_ACCESSORS , fieldName , isBoolean ) ; java . lang . String result = de . plushnikov . intellij . plugin . thirdparty . LombokUtils . toGetterName ( de . plushnikov . intellij . plugin . thirdparty . LombokUtilsGetterTest . DEFAULT_ACCESSORS , fieldName , isBoolean ) ; org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( lombokResult ) ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( \"isMyField\" ) )"}
{"focal": "wrappedArray ( ) { return array ; }", "testMethod": "wrap1 ( ) { org . diirt . util . array . ArrayBoolean array = new org . diirt . util . array . ArrayBoolean ( new boolean [ ] { true , false , true , true } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( array . wrappedArray ( ) , equalTo ( new boolean [ ] { true , false , true , true } ) )", "total": "wrap1 ( ) { org . diirt . util . array . ArrayBoolean array = new org . diirt . util . array . ArrayBoolean ( new boolean [ ] { true , false , true , true } ) ; \"<AssertPlaceHolder>\" ; } wrappedArray ( ) { return array ; }", "answer": "org . junit . Assert . assertThat ( array . wrappedArray ( ) , equalTo ( new boolean [ ] { true , false , true , true } ) )"}
{"focal": "getTotalBeansDestroyed ( ) { return this . totalBeansCreatedProperty ( ) . get ( ) ; }", "testMethod": "totalBeansDestroyedForSingleton ( ) { org . lightview . business . pool . entity . PoolStatistics poolStats = this . cut . getPoolStats ( \"lightfish\" , \"Configurator\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( poolStats . getTotalBeansDestroyed ( ) , org . hamcrest . CoreMatchers . is ( ( - 1 ) ) )", "total": "totalBeansDestroyedForSingleton ( ) { org . lightview . business . pool . entity . PoolStatistics poolStats = this . cut . getPoolStats ( \"lightfish\" , \"Configurator\" ) ; \"<AssertPlaceHolder>\" ; } getTotalBeansDestroyed ( ) { return this . totalBeansCreatedProperty ( ) . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( poolStats . getTotalBeansDestroyed ( ) , org . hamcrest . CoreMatchers . is ( ( - 1 ) ) )"}
{"focal": "count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "testMethod": "deleteHistoricCaseInstanceWithAuthenticatedTenant ( ) { testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . CMMN_PROCESS_WITH_MANUAL_ACTIVATION ) ; java . lang . String caseInstanceId = createAndCloseCaseInstance ( null ) ; identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE ) ) ; historyService . deleteHistoricCaseInstance ( caseInstanceId ) ; identityService . clearAuthentication ( ) ; org . camunda . bpm . engine . history . HistoricCaseInstanceQuery query = historyService . createHistoricCaseInstanceQuery ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "deleteHistoricCaseInstanceWithAuthenticatedTenant ( ) { testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . CMMN_PROCESS_WITH_MANUAL_ACTIVATION ) ; java . lang . String caseInstanceId = createAndCloseCaseInstance ( null ) ; identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE ) ) ; historyService . deleteHistoricCaseInstance ( caseInstanceId ) ; identityService . clearAuthentication ( ) ; org . camunda . bpm . engine . history . HistoricCaseInstanceQuery query = historyService . createHistoricCaseInstanceQuery ( ) ; \"<AssertPlaceHolder>\" ; } count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "leestAfnemerindicatiesVoorAlleenLezenNietBestaandPersoon ( ) { final java . lang . Integer persoonId = 123 ; final java . util . Set < ? > indicaties = repository . leesGenormaliseerdModelVoorInMemoryBlob ( persoonId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( indicaties . size ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "leestAfnemerindicatiesVoorAlleenLezenNietBestaandPersoon ( ) { final java . lang . Integer persoonId = 123 ; final java . util . Set < ? > indicaties = repository . leesGenormaliseerdModelVoorInMemoryBlob ( persoonId ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( indicaties . size ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "getSubscriptionsByANonAuthenticatedUser ( ) { com . sun . jersey . api . client . WebResource resource = resource ( ) ; try { resource . path ( org . silverpeas . core . subscription . web . SubscriptionTestResources . SUBSCRIPTION_RESOURCE_PATH ) . accept ( MediaType . APPLICATION_JSON ) . get ( java . lang . String . class ) ; org . junit . Assert . fail ( \"A<sp>non<sp>authenticated<sp>user<sp>shouldn't<sp>access<sp>the<sp>comment\" ) ; } catch ( com . sun . jersey . api . client . UniformInterfaceException ex ) { int recievedStatus = ex . getResponse ( ) . getStatus ( ) ; int unauthorized = Status . UNAUTHORIZED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( recievedStatus , org . hamcrest . Matchers . is ( unauthorized ) )", "total": "getSubscriptionsByANonAuthenticatedUser ( ) { com . sun . jersey . api . client . WebResource resource = resource ( ) ; try { resource . path ( org . silverpeas . core . subscription . web . SubscriptionTestResources . SUBSCRIPTION_RESOURCE_PATH ) . accept ( MediaType . APPLICATION_JSON ) . get ( java . lang . String . class ) ; org . junit . Assert . fail ( \"A<sp>non<sp>authenticated<sp>user<sp>shouldn't<sp>access<sp>the<sp>comment\" ) ; } catch ( com . sun . jersey . api . client . UniformInterfaceException ex ) { int recievedStatus = ex . getResponse ( ) . getStatus ( ) ; int unauthorized = Status . UNAUTHORIZED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( recievedStatus , org . hamcrest . Matchers . is ( unauthorized ) )"}
{"focal": "getPackets ( ) { java . lang . String path = org . o3project . odenos . core . component . NetworkInterface . PACKETS_PATH ; org . o3project . odenos . core . component . NetworkInterface . log . debug ( \">><sp>[networkId<sp>:<sp>'{}']\" , this . networkId ) ; org . o3project . odenos . remoteobject . message . Response resp = getObjectToNetwork ( this . networkId , path ) ; if ( resp == null ) { return null ; } try { return resp . getBody ( org . o3project . odenos . core . component . network . packet . PacketStatus . class ) ; } catch ( java . lang . Exception e ) { org . o3project . odenos . core . component . NetworkInterface . log . error ( \"Recieved<sp>Message<sp>Exception.\" , e ) ; return null ; } }", "testMethod": "testGetPackets ( ) { target . packets = packets ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getPackets ( ) , org . hamcrest . CoreMatchers . is ( packets ) )", "total": "testGetPackets ( ) { target . packets = packets ; \"<AssertPlaceHolder>\" ; } getPackets ( ) { java . lang . String path = org . o3project . odenos . core . component . NetworkInterface . PACKETS_PATH ; org . o3project . odenos . core . component . NetworkInterface . log . debug ( \">><sp>[networkId<sp>:<sp>'{}']\" , this . networkId ) ; org . o3project . odenos . remoteobject . message . Response resp = getObjectToNetwork ( this . networkId , path ) ; if ( resp == null ) { return null ; } try { return resp . getBody ( org . o3project . odenos . core . component . network . packet . PacketStatus . class ) ; } catch ( java . lang . Exception e ) { org . o3project . odenos . core . component . NetworkInterface . log . error ( \"Recieved<sp>Message<sp>Exception.\" , e ) ; return null ; } }", "answer": "org . junit . Assert . assertThat ( target . getPackets ( ) , org . hamcrest . CoreMatchers . is ( packets ) )"}
{"focal": "rsSizeOf ( java . sql . ResultSet ) { int tableCount = 0 ; while ( rs . next ( ) ) { tableCount ++ ; } return tableCount ; }", "testMethod": "getSingleTable ( ) { java . sql . ResultSet rs = this . metaData . getTables ( null , null , \"ouser\" , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rsSizeOf ( rs ) , org . hamcrest . Matchers . is ( 1 ) )", "total": "getSingleTable ( ) { java . sql . ResultSet rs = this . metaData . getTables ( null , null , \"ouser\" , null ) ; \"<AssertPlaceHolder>\" ; } rsSizeOf ( java . sql . ResultSet ) { int tableCount = 0 ; while ( rs . next ( ) ) { tableCount ++ ; } return tableCount ; }", "answer": "org . junit . Assert . assertThat ( rsSizeOf ( rs ) , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "testMethod": "testMatchExactlyStatusErr ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; long idleTimeout = 0 ; long hardTimeout = 0 ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow flow = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , idleTimeout , hardTimeout , path , edgeAction , flowAttributes ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match3 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match4 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; flow . addMatch ( match1 ) ; flow . addMatch ( match2 ) ; flow . addMatch ( match3 ) ; flow . addMatch ( match4 ) ; queriesString = \"type=node&enabled=true&status=established&path=node_id=node01,port_id=port01\" ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowQuery ( queriesString ) ; target . parse ( ) ; flow . setEnabled ( false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testMatchExactlyStatusErr ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; long idleTimeout = 0 ; long hardTimeout = 0 ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow flow = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , idleTimeout , hardTimeout , path , edgeAction , flowAttributes ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match3 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch match4 = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowMatch ( ) ; flow . addMatch ( match1 ) ; flow . addMatch ( match2 ) ; flow . addMatch ( match3 ) ; flow . addMatch ( match4 ) ; queriesString = \"type=node&enabled=true&status=established&path=node_id=node01,port_id=port01\" ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowQuery ( queriesString ) ; target . parse ( ) ; flow . setEnabled ( false ) ; \"<AssertPlaceHolder>\" ; } matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "post ( java . lang . String , byte [ ] , java . lang . String , java . lang . String ) { return post ( url , content , username , password , com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . String > of ( ) ) ; }", "testMethod": "xmlShouldBePosted ( ) { final java . lang . String requestBody = \"<xml><test>data</test></xml>\" ; final java . lang . String responseBody = java . lang . String . format ( \"<xml><test>%s</test></xml>\" , com . freedomotic . helpers . HttpHelperTest . OK_RESPONSE ) ; final byte [ ] request = requestBody . getBytes ( \"UTF-8\" ) ; mockServerClient . when ( request ( ) . withBody ( requestBody ) ) . respond ( response ( ) . withBody ( responseBody ) . withStatusCode ( 200 ) ) ; byte [ ] response = httpHelper . post ( baseUrl , request , com . freedomotic . helpers . HttpHelperTest . A_USERNAME , com . freedomotic . helpers . HttpHelperTest . A_PASSWORD ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( responseBody , org . hamcrest . CoreMatchers . equalTo ( new java . lang . String ( response , \"UTF-8\" ) ) )", "total": "xmlShouldBePosted ( ) { final java . lang . String requestBody = \"<xml><test>data</test></xml>\" ; final java . lang . String responseBody = java . lang . String . format ( \"<xml><test>%s</test></xml>\" , com . freedomotic . helpers . HttpHelperTest . OK_RESPONSE ) ; final byte [ ] request = requestBody . getBytes ( \"UTF-8\" ) ; mockServerClient . when ( request ( ) . withBody ( requestBody ) ) . respond ( response ( ) . withBody ( responseBody ) . withStatusCode ( 200 ) ) ; byte [ ] response = httpHelper . post ( baseUrl , request , com . freedomotic . helpers . HttpHelperTest . A_USERNAME , com . freedomotic . helpers . HttpHelperTest . A_PASSWORD ) ; \"<AssertPlaceHolder>\" ; } post ( java . lang . String , byte [ ] , java . lang . String , java . lang . String ) { return post ( url , content , username , password , com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . String > of ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( responseBody , org . hamcrest . CoreMatchers . equalTo ( new java . lang . String ( response , \"UTF-8\" ) ) )"}
{"focal": "getSourceDir ( ) { return getDir ( mavenProject . getBuild ( ) . getSourceDirectory ( ) ) ; }", "testMethod": "should_get_sourceDir ( ) { org . apache . maven . model . Build build = mock ( org . apache . maven . model . Build . class ) ; when ( build . getSourceDirectory ( ) ) . thenReturn ( \"/dev/sonar/plugins/sonar-scm-stats/src/main/java\" ) ; org . apache . maven . project . MavenProject mavenProject = mock ( org . apache . maven . project . MavenProject . class ) ; when ( mavenProject . getBuild ( ) ) . thenReturn ( build ) ; java . io . File baseDir = mock ( java . io . File . class ) ; when ( baseDir . getAbsolutePath ( ) ) . thenReturn ( \"/dev/sonar/plugins/sonar-scm-stats\" ) ; when ( mavenProject . getBasedir ( ) ) . thenReturn ( baseDir ) ; org . sonar . plugins . scmstats . MavenScmConfiguration mavenConfig = new org . sonar . plugins . scmstats . MavenScmConfiguration ( mavenProject ) ; java . lang . String expectedDir = \"src/main/java\" ; java . lang . String sourceDir = mavenConfig . getSourceDir ( ) ; \"<AssertPlaceHolder>\" . isEqualTo ( expectedDir ) ; }", "assertLine": "org . junit . Assert . assertThat ( sourceDir )", "total": "should_get_sourceDir ( ) { org . apache . maven . model . Build build = mock ( org . apache . maven . model . Build . class ) ; when ( build . getSourceDirectory ( ) ) . thenReturn ( \"/dev/sonar/plugins/sonar-scm-stats/src/main/java\" ) ; org . apache . maven . project . MavenProject mavenProject = mock ( org . apache . maven . project . MavenProject . class ) ; when ( mavenProject . getBuild ( ) ) . thenReturn ( build ) ; java . io . File baseDir = mock ( java . io . File . class ) ; when ( baseDir . getAbsolutePath ( ) ) . thenReturn ( \"/dev/sonar/plugins/sonar-scm-stats\" ) ; when ( mavenProject . getBasedir ( ) ) . thenReturn ( baseDir ) ; org . sonar . plugins . scmstats . MavenScmConfiguration mavenConfig = new org . sonar . plugins . scmstats . MavenScmConfiguration ( mavenProject ) ; java . lang . String expectedDir = \"src/main/java\" ; java . lang . String sourceDir = mavenConfig . getSourceDir ( ) ; \"<AssertPlaceHolder>\" . isEqualTo ( expectedDir ) ; } getSourceDir ( ) { return getDir ( mavenProject . getBuild ( ) . getSourceDirectory ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( sourceDir )"}
{"focal": "process ( name . abuchen . portfolio . model . BuySellEntry , name . abuchen . portfolio . model . Account , name . abuchen . portfolio . model . Portfolio ) { name . abuchen . portfolio . datatransfer . actions . Status status = check ( entry . getAccountTransaction ( ) , account . getTransactions ( ) ) ; if ( ( status . getCode ( ) ) != ( Status . Code . OK ) ) return status ; return check ( entry . getPortfolioTransaction ( ) , portfolio . getTransactions ( ) ) ; }", "testMethod": "testBuySellEntry ( ) { name . abuchen . portfolio . model . Account account = new name . abuchen . portfolio . model . Account ( ) ; account . setCurrencyCode ( \"EUR\" ) ; name . abuchen . portfolio . model . Security security = new name . abuchen . portfolio . model . Security ( ) ; security . setCurrencyCode ( \"USD\" ) ; name . abuchen . portfolio . model . Portfolio portfolio = new name . abuchen . portfolio . model . Portfolio ( ) ; name . abuchen . portfolio . model . BuySellEntry entry = new name . abuchen . portfolio . model . BuySellEntry ( ) ; entry . setType ( PortfolioTransaction . Type . BUY ) ; entry . setSecurity ( security ) ; entry . setMonetaryAmount ( name . abuchen . portfolio . money . Money . of ( \"EUR\" , 10000 ) ) ; entry . getPortfolioTransaction ( ) . addUnit ( new name . abuchen . portfolio . model . Transaction . Unit ( Unit . Type . GROSS_VALUE , name . abuchen . portfolio . money . Money . of ( \"EUR\" , 8000 ) , name . abuchen . portfolio . money . Money . of ( \"USD\" , 10000 ) , java . math . BigDecimal . valueOf ( 0.8 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( action . process ( entry , account , portfolio ) . getCode ( ) , org . hamcrest . CoreMatchers . is ( Status . Code . OK ) )", "total": "testBuySellEntry ( ) { name . abuchen . portfolio . model . Account account = new name . abuchen . portfolio . model . Account ( ) ; account . setCurrencyCode ( \"EUR\" ) ; name . abuchen . portfolio . model . Security security = new name . abuchen . portfolio . model . Security ( ) ; security . setCurrencyCode ( \"USD\" ) ; name . abuchen . portfolio . model . Portfolio portfolio = new name . abuchen . portfolio . model . Portfolio ( ) ; name . abuchen . portfolio . model . BuySellEntry entry = new name . abuchen . portfolio . model . BuySellEntry ( ) ; entry . setType ( PortfolioTransaction . Type . BUY ) ; entry . setSecurity ( security ) ; entry . setMonetaryAmount ( name . abuchen . portfolio . money . Money . of ( \"EUR\" , 10000 ) ) ; entry . getPortfolioTransaction ( ) . addUnit ( new name . abuchen . portfolio . model . Transaction . Unit ( Unit . Type . GROSS_VALUE , name . abuchen . portfolio . money . Money . of ( \"EUR\" , 8000 ) , name . abuchen . portfolio . money . Money . of ( \"USD\" , 10000 ) , java . math . BigDecimal . valueOf ( 0.8 ) ) ) ; \"<AssertPlaceHolder>\" ; } process ( name . abuchen . portfolio . model . BuySellEntry , name . abuchen . portfolio . model . Account , name . abuchen . portfolio . model . Portfolio ) { name . abuchen . portfolio . datatransfer . actions . Status status = check ( entry . getAccountTransaction ( ) , account . getTransactions ( ) ) ; if ( ( status . getCode ( ) ) != ( Status . Code . OK ) ) return status ; return check ( entry . getPortfolioTransaction ( ) , portfolio . getTransactions ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( action . process ( entry , account , portfolio ) . getCode ( ) , org . hamcrest . CoreMatchers . is ( Status . Code . OK ) )"}
{"focal": "next ( ) { java . math . BigInteger oldValue ; java . math . BigInteger newValue ; do { oldValue = ( ( java . math . BigInteger ) ( refCounter . get ( ) ) ) ; newValue = ( oldValue == null ) ? java . math . BigInteger . valueOf ( 1 ) : oldValue . shiftLeft ( 1 ) ; } while ( ! ( refCounter . compareAndSet ( oldValue , newValue ) ) ) ; return newValue ; }", "testMethod": "whenLinkedListHaveAnyMoreValueWeGetAllAcrossIterator ( ) { ru . szhernovoy . linkedlist . DynamicLinkedList < java . lang . String > container = new ru . szhernovoy . linkedlist . DynamicLinkedList ( ) ; container . add ( \"First<sp>message\" ) ; container . add ( \"Second<sp>message\" ) ; container . add ( \"Third<sp>message\" ) ; java . util . Iterator < java . lang . String > iter = container . iterator ( ) ; int index = 0 ; java . lang . String message = \"\" ; while ( ( iter . hasNext ( ) ) && ( index < 2 ) ) { message = iter . next ( ) ; index ++ ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( \"Second<sp>message\" , org . hamcrest . core . Is . is ( message ) )", "total": "whenLinkedListHaveAnyMoreValueWeGetAllAcrossIterator ( ) { ru . szhernovoy . linkedlist . DynamicLinkedList < java . lang . String > container = new ru . szhernovoy . linkedlist . DynamicLinkedList ( ) ; container . add ( \"First<sp>message\" ) ; container . add ( \"Second<sp>message\" ) ; container . add ( \"Third<sp>message\" ) ; java . util . Iterator < java . lang . String > iter = container . iterator ( ) ; int index = 0 ; java . lang . String message = \"\" ; while ( ( iter . hasNext ( ) ) && ( index < 2 ) ) { message = iter . next ( ) ; index ++ ; } \"<AssertPlaceHolder>\" ; } next ( ) { java . math . BigInteger oldValue ; java . math . BigInteger newValue ; do { oldValue = ( ( java . math . BigInteger ) ( refCounter . get ( ) ) ) ; newValue = ( oldValue == null ) ? java . math . BigInteger . valueOf ( 1 ) : oldValue . shiftLeft ( 1 ) ; } while ( ! ( refCounter . compareAndSet ( oldValue , newValue ) ) ) ; return newValue ; }", "answer": "org . junit . Assert . assertThat ( \"Second<sp>message\" , org . hamcrest . core . Is . is ( message ) )"}
{"focal": "transpose ( com . asakusafw . utils . graph . Graph ) { if ( graph == null ) { throw new java . lang . IllegalArgumentException ( \"graph<sp>must<sp>not<sp>be<sp>null\" ) ; } com . asakusafw . utils . graph . Graph < V > results = new com . asakusafw . utils . graph . HashGraph ( ) ; for ( com . asakusafw . utils . graph . Graph . Vertex < V > vertex : graph ) { V from = vertex . getNode ( ) ; results . addNode ( from ) ; for ( V to : vertex . getConnected ( ) ) { results . addEdge ( to , from ) ; } } return results ; }", "testMethod": "testTransposeGraph_noEdges ( ) { com . asakusafw . utils . graph . Graph < java . lang . Integer > graph = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . prepare ( graph , 1 ) ; com . asakusafw . utils . graph . Graph < java . lang . Integer > expect = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . prepare ( expect , 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . asakusafw . utils . graph . Graphs . transpose ( graph ) , is ( expect ) )", "total": "testTransposeGraph_noEdges ( ) { com . asakusafw . utils . graph . Graph < java . lang . Integer > graph = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . prepare ( graph , 1 ) ; com . asakusafw . utils . graph . Graph < java . lang . Integer > expect = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . prepare ( expect , 1 ) ; \"<AssertPlaceHolder>\" ; } transpose ( com . asakusafw . utils . graph . Graph ) { if ( graph == null ) { throw new java . lang . IllegalArgumentException ( \"graph<sp>must<sp>not<sp>be<sp>null\" ) ; } com . asakusafw . utils . graph . Graph < V > results = new com . asakusafw . utils . graph . HashGraph ( ) ; for ( com . asakusafw . utils . graph . Graph . Vertex < V > vertex : graph ) { V from = vertex . getNode ( ) ; results . addNode ( from ) ; for ( V to : vertex . getConnected ( ) ) { results . addEdge ( to , from ) ; } } return results ; }", "answer": "org . junit . Assert . assertThat ( com . asakusafw . utils . graph . Graphs . transpose ( graph ) , is ( expect ) )"}
{"focal": "resolveMessage ( org . terasoluna . gfw . common . message . ResultMessage , org . springframework . context . MessageSource , java . util . Locale ) { org . springframework . util . Assert . notNull ( messageSource , \"messageSource<sp>must<sp>not<sp>be<sp>null!\" ) ; org . springframework . util . Assert . notNull ( message , \"message<sp>must<sp>not<sp>be<sp>null!\" ) ; org . springframework . util . Assert . notNull ( locale , \"locale<sp>must<sp>not<sp>be<sp>null!\" ) ; java . lang . String msg ; java . lang . String code = message . getCode ( ) ; if ( code != null ) { try { msg = messageSource . getMessage ( code , message . getArgs ( ) , locale ) ; } catch ( org . springframework . context . NoSuchMessageException e ) { java . lang . String text = message . getText ( ) ; if ( text != null ) { if ( org . terasoluna . gfw . common . message . ResultMessageUtils . logger . isDebugEnabled ( ) ) { org . terasoluna . gfw . common . message . ResultMessageUtils . logger . debug ( ( ( ( ( ( ( \"messege<sp>is<sp>not<sp>found<sp>under<sp>code<sp>'\" + code ) + \"'<sp>for<sp>'\" ) + locale ) + \"'.<sp>use<sp>'\" ) + text ) + \"'<sp>instead\" ) , e ) ; } msg = text ; } else { throw e ; } } } else { msg = message . getText ( ) ; } return msg ; }", "testMethod": "testResolveMessageWithLocale ( ) { org . terasoluna . gfw . common . message . ResultMessage message = mock ( org . terasoluna . gfw . common . message . ResultMessage . class ) ; org . springframework . context . MessageSource messageSource = mock ( org . springframework . context . MessageSource . class ) ; java . util . Locale locale = java . util . Locale . getDefault ( ) ; when ( message . getCode ( ) ) . thenReturn ( \"MSG001\" ) ; when ( message . getArgs ( ) ) . thenReturn ( null ) ; when ( messageSource . getMessage ( \"MSG001\" , null , locale ) ) . thenReturn ( \"MESSAGE_TEXT\" ) ; java . lang . String msg = org . terasoluna . gfw . common . message . ResultMessageUtils . resolveMessage ( message , messageSource , locale ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( msg , org . hamcrest . CoreMatchers . is ( \"MESSAGE_TEXT\" ) )", "total": "testResolveMessageWithLocale ( ) { org . terasoluna . gfw . common . message . ResultMessage message = mock ( org . terasoluna . gfw . common . message . ResultMessage . class ) ; org . springframework . context . MessageSource messageSource = mock ( org . springframework . context . MessageSource . class ) ; java . util . Locale locale = java . util . Locale . getDefault ( ) ; when ( message . getCode ( ) ) . thenReturn ( \"MSG001\" ) ; when ( message . getArgs ( ) ) . thenReturn ( null ) ; when ( messageSource . getMessage ( \"MSG001\" , null , locale ) ) . thenReturn ( \"MESSAGE_TEXT\" ) ; java . lang . String msg = org . terasoluna . gfw . common . message . ResultMessageUtils . resolveMessage ( message , messageSource , locale ) ; \"<AssertPlaceHolder>\" ; } resolveMessage ( org . terasoluna . gfw . common . message . ResultMessage , org . springframework . context . MessageSource , java . util . Locale ) { org . springframework . util . Assert . notNull ( messageSource , \"messageSource<sp>must<sp>not<sp>be<sp>null!\" ) ; org . springframework . util . Assert . notNull ( message , \"message<sp>must<sp>not<sp>be<sp>null!\" ) ; org . springframework . util . Assert . notNull ( locale , \"locale<sp>must<sp>not<sp>be<sp>null!\" ) ; java . lang . String msg ; java . lang . String code = message . getCode ( ) ; if ( code != null ) { try { msg = messageSource . getMessage ( code , message . getArgs ( ) , locale ) ; } catch ( org . springframework . context . NoSuchMessageException e ) { java . lang . String text = message . getText ( ) ; if ( text != null ) { if ( org . terasoluna . gfw . common . message . ResultMessageUtils . logger . isDebugEnabled ( ) ) { org . terasoluna . gfw . common . message . ResultMessageUtils . logger . debug ( ( ( ( ( ( ( \"messege<sp>is<sp>not<sp>found<sp>under<sp>code<sp>'\" + code ) + \"'<sp>for<sp>'\" ) + locale ) + \"'.<sp>use<sp>'\" ) + text ) + \"'<sp>instead\" ) , e ) ; } msg = text ; } else { throw e ; } } } else { msg = message . getText ( ) ; } return msg ; }", "answer": "org . junit . Assert . assertThat ( msg , org . hamcrest . CoreMatchers . is ( \"MESSAGE_TEXT\" ) )"}
{"focal": "createODataRequest ( com . sdl . odata . api . service . ODataRequest$Method , java . util . Map ) { if ( headers == null ) { headers = new java . util . HashMap ( ) ; } return new com . sdl . odata . api . service . ODataRequest . Builder ( ) . setBodyText ( \"test\" , \"UTF-8\" ) . setUri ( com . sdl . odata . test . util . TestUtils . SERVICE_ROOT ) . setHeaders ( headers ) . setMethod ( method ) . build ( ) ; }", "testMethod": "testEntityPostRequestScore ( ) { java . lang . String uri = \"http://some.com/xyz.svc/Customers(111)\" ; odataUri = uriParser . parseUri ( uri , entityDataModel ) ; int score = unmarshaller . score ( createODataRequestContext ( createODataRequest ( com . sdl . odata . unmarshaller . atom . POST , com . sdl . odata . unmarshaller . atom . AtomActionUnmarshallerTest . CONTENT_TYPE ) , odataUri , entityDataModel ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( score , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "testEntityPostRequestScore ( ) { java . lang . String uri = \"http://some.com/xyz.svc/Customers(111)\" ; odataUri = uriParser . parseUri ( uri , entityDataModel ) ; int score = unmarshaller . score ( createODataRequestContext ( createODataRequest ( com . sdl . odata . unmarshaller . atom . POST , com . sdl . odata . unmarshaller . atom . AtomActionUnmarshallerTest . CONTENT_TYPE ) , odataUri , entityDataModel ) ) ; \"<AssertPlaceHolder>\" ; } createODataRequest ( com . sdl . odata . api . service . ODataRequest$Method , java . util . Map ) { if ( headers == null ) { headers = new java . util . HashMap ( ) ; } return new com . sdl . odata . api . service . ODataRequest . Builder ( ) . setBodyText ( \"test\" , \"UTF-8\" ) . setUri ( com . sdl . odata . test . util . TestUtils . SERVICE_ROOT ) . setHeaders ( headers ) . setMethod ( method ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( score , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "empty ( ) { org . apache . beam . sdk . util . ApiSurface . LOG . debug ( \"Returning<sp>an<sp>empty<sp>ApiSurface\" ) ; return new org . apache . beam . sdk . util . ApiSurface ( java . util . Collections . emptySet ( ) , java . util . Collections . emptySet ( ) ) ; }", "testMethod": "testRunReadLoopWithEmptySource ( ) { java . util . List < org . apache . beam . sdk . util . WindowedValue < java . lang . Long > > outValues = new java . util . ArrayList ( ) ; java . util . Collection < org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . Long > > > consumers = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . of ( outValues :: add ) ; org . apache . beam . fn . harness . BoundedSourceRunner < org . apache . beam . sdk . io . BoundedSource < java . lang . Long > , java . lang . Long > runner = new org . apache . beam . fn . harness . BoundedSourceRunner ( org . apache . beam . sdk . options . PipelineOptionsFactory . create ( ) , RunnerApi . FunctionSpec . getDefaultInstance ( ) , consumers ) ; runner . runReadLoop ( valueInGlobalWindow ( org . apache . beam . sdk . io . CountingSource . upTo ( 0 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( outValues , empty ( ) )", "total": "testRunReadLoopWithEmptySource ( ) { java . util . List < org . apache . beam . sdk . util . WindowedValue < java . lang . Long > > outValues = new java . util . ArrayList ( ) ; java . util . Collection < org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . Long > > > consumers = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . of ( outValues :: add ) ; org . apache . beam . fn . harness . BoundedSourceRunner < org . apache . beam . sdk . io . BoundedSource < java . lang . Long > , java . lang . Long > runner = new org . apache . beam . fn . harness . BoundedSourceRunner ( org . apache . beam . sdk . options . PipelineOptionsFactory . create ( ) , RunnerApi . FunctionSpec . getDefaultInstance ( ) , consumers ) ; runner . runReadLoop ( valueInGlobalWindow ( org . apache . beam . sdk . io . CountingSource . upTo ( 0 ) ) ) ; \"<AssertPlaceHolder>\" ; } empty ( ) { org . apache . beam . sdk . util . ApiSurface . LOG . debug ( \"Returning<sp>an<sp>empty<sp>ApiSurface\" ) ; return new org . apache . beam . sdk . util . ApiSurface ( java . util . Collections . emptySet ( ) , java . util . Collections . emptySet ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( outValues , empty ( ) )"}
{"focal": "equivalentTo ( software . amazon . kinesis . retrieval . KinesisClientRecord ) { return new software . amazon . kinesis . multilang . messages . JsonFriendlyRecordTest . RecordMatcher ( expected ) ; }", "testMethod": "testRecordHandlesArrayByteBuffer ( ) { java . nio . ByteBuffer expected = java . nio . ByteBuffer . wrap ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; kinesisClientRecord = defaultRecord ( ) . data ( expected ) . build ( ) ; software . amazon . kinesis . multilang . messages . JsonFriendlyRecord jsonFriendlyRecord = software . amazon . kinesis . multilang . messages . JsonFriendlyRecord . fromKinesisClientRecord ( kinesisClientRecord ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( jsonFriendlyRecord , software . amazon . kinesis . multilang . messages . JsonFriendlyRecordTest . equivalentTo ( kinesisClientRecord ) )", "total": "testRecordHandlesArrayByteBuffer ( ) { java . nio . ByteBuffer expected = java . nio . ByteBuffer . wrap ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; kinesisClientRecord = defaultRecord ( ) . data ( expected ) . build ( ) ; software . amazon . kinesis . multilang . messages . JsonFriendlyRecord jsonFriendlyRecord = software . amazon . kinesis . multilang . messages . JsonFriendlyRecord . fromKinesisClientRecord ( kinesisClientRecord ) ; \"<AssertPlaceHolder>\" ; } equivalentTo ( software . amazon . kinesis . retrieval . KinesisClientRecord ) { return new software . amazon . kinesis . multilang . messages . JsonFriendlyRecordTest . RecordMatcher ( expected ) ; }", "answer": "org . junit . Assert . assertThat ( jsonFriendlyRecord , software . amazon . kinesis . multilang . messages . JsonFriendlyRecordTest . equivalentTo ( kinesisClientRecord ) )"}
{"focal": "getMonth ( java . time . LocalDate ) { return localDate . getMonthValue ( ) ; }", "testMethod": "whenGetMonth_thenCorrectMonth ( ) { int actualMonth = localDateTimeExtractYearMonthDayIntegerValues . getMonth ( localDateTime ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualMonth , org . hamcrest . CoreMatchers . is ( 12 ) )", "total": "whenGetMonth_thenCorrectMonth ( ) { int actualMonth = localDateTimeExtractYearMonthDayIntegerValues . getMonth ( localDateTime ) ; \"<AssertPlaceHolder>\" ; } getMonth ( java . time . LocalDate ) { return localDate . getMonthValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( actualMonth , org . hamcrest . CoreMatchers . is ( 12 ) )"}
{"focal": "shouldIgnore ( com . threewks . thundr . request . Request ) { return userAgentIsBlocked ( req . getHeader ( Header . UserAgent ) ) ; }", "testMethod": "shouldPermitEverythingByDefault ( ) { req . withHeader ( Header . UserAgent , \"Googlebot/2.1<sp>(+http://www.google.com/bot.html)\" ) ; com . threewks . thundr . route . controller . FilterRules filterRules = new com . threewks . thundr . route . controller . FilterRules ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filterRules . shouldIgnore ( req ) , is ( false ) )", "total": "shouldPermitEverythingByDefault ( ) { req . withHeader ( Header . UserAgent , \"Googlebot/2.1<sp>(+http://www.google.com/bot.html)\" ) ; com . threewks . thundr . route . controller . FilterRules filterRules = new com . threewks . thundr . route . controller . FilterRules ( ) ; \"<AssertPlaceHolder>\" ; } shouldIgnore ( com . threewks . thundr . request . Request ) { return userAgentIsBlocked ( req . getHeader ( Header . UserAgent ) ) ; }", "answer": "org . junit . Assert . assertThat ( filterRules . shouldIgnore ( req ) , is ( false ) )"}
{"focal": "getOptions ( ) { return runOptions ; }", "testMethod": "setRunOptionsShouldBeReturned ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( runner . getOptions ( ) , org . hamcrest . core . Is . is ( runOptions ) )", "total": "setRunOptionsShouldBeReturned ( ) { \"<AssertPlaceHolder>\" ; } getOptions ( ) { return runOptions ; }", "answer": "org . junit . Assert . assertThat ( runner . getOptions ( ) , org . hamcrest . core . Is . is ( runOptions ) )"}
{"focal": "getLengthOfYear ( net . time4j . history . HistoricEra , int ) { try { net . time4j . history . HistoricDate min ; net . time4j . history . HistoricDate max ; int extra ; if ( ( this . nys ) == null ) { min = net . time4j . history . HistoricDate . of ( era , yearOfEra , 1 , 1 ) ; max = net . time4j . history . HistoricDate . of ( era , yearOfEra , 12 , 31 ) ; extra = 1 ; } else { min = this . nys . newYear ( era , yearOfEra ) ; if ( era == ( HistoricEra . BC ) ) { if ( yearOfEra == 1 ) { max = this . nys . newYear ( HistoricEra . AD , 1 ) ; } else { max = this . nys . newYear ( era , ( yearOfEra - 1 ) ) ; } } else { max = this . nys . newYear ( era , ( yearOfEra + 1 ) ) ; if ( era == ( HistoricEra . BYZANTINE ) ) { net . time4j . history . HistoricDate hd = this . nys . newYear ( HistoricEra . AD , era . annoDomini ( yearOfEra ) ) ; if ( ( hd . compareTo ( min ) ) > 0 ) { max = hd ; } } } extra = 0 ; } return ( ( int ) ( ( CalendarUnit . DAYS . between ( this . convert ( min ) , this . convert ( max ) ) ) + extra ) ) ; } catch ( java . lang . RuntimeException re ) { return - 1 ; } }", "testMethod": "lengthOfYearOutOfRangeMAX ( ) { net . time4j . history . ChronoHistory history = net . time4j . history . ChronoHistory . of ( Locale . UK ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( history . getLengthOfYear ( HistoricEra . AD , Integer . MAX_VALUE ) , org . hamcrest . CoreMatchers . is ( ( - 1 ) ) )", "total": "lengthOfYearOutOfRangeMAX ( ) { net . time4j . history . ChronoHistory history = net . time4j . history . ChronoHistory . of ( Locale . UK ) ; \"<AssertPlaceHolder>\" ; } getLengthOfYear ( net . time4j . history . HistoricEra , int ) { try { net . time4j . history . HistoricDate min ; net . time4j . history . HistoricDate max ; int extra ; if ( ( this . nys ) == null ) { min = net . time4j . history . HistoricDate . of ( era , yearOfEra , 1 , 1 ) ; max = net . time4j . history . HistoricDate . of ( era , yearOfEra , 12 , 31 ) ; extra = 1 ; } else { min = this . nys . newYear ( era , yearOfEra ) ; if ( era == ( HistoricEra . BC ) ) { if ( yearOfEra == 1 ) { max = this . nys . newYear ( HistoricEra . AD , 1 ) ; } else { max = this . nys . newYear ( era , ( yearOfEra - 1 ) ) ; } } else { max = this . nys . newYear ( era , ( yearOfEra + 1 ) ) ; if ( era == ( HistoricEra . BYZANTINE ) ) { net . time4j . history . HistoricDate hd = this . nys . newYear ( HistoricEra . AD , era . annoDomini ( yearOfEra ) ) ; if ( ( hd . compareTo ( min ) ) > 0 ) { max = hd ; } } } extra = 0 ; } return ( ( int ) ( ( CalendarUnit . DAYS . between ( this . convert ( min ) , this . convert ( max ) ) ) + extra ) ) ; } catch ( java . lang . RuntimeException re ) { return - 1 ; } }", "answer": "org . junit . Assert . assertThat ( history . getLengthOfYear ( HistoricEra . AD , Integer . MAX_VALUE ) , org . hamcrest . CoreMatchers . is ( ( - 1 ) ) )"}
{"focal": "size ( ) { return this . elements . size ( ) ; }", "testMethod": "whenAddThreeElementsThenSizeThree ( ) { final int expectedListLength = 3 ; list . add ( \"0\" ) ; list . add ( \"1\" ) ; list . add ( \"2\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . core . Is . is ( expectedListLength ) )", "total": "whenAddThreeElementsThenSizeThree ( ) { final int expectedListLength = 3 ; list . add ( \"0\" ) ; list . add ( \"1\" ) ; list . add ( \"2\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . elements . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . core . Is . is ( expectedListLength ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsNotEqualsGroupId ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionGroupAction obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionGroupAction ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsNotEqualsGroupId ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionGroupAction obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionGroupAction ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "statement ( java . lang . String ) { return statement ; }", "testMethod": "generalStatement ( ) { java . util . List < java . lang . String > expected = asList ( \"SELECT<sp>*<sp>FROM<sp>x\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( processor . statement ( \"SELECT<sp>*<sp>FROM<sp>x\" ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "generalStatement ( ) { java . util . List < java . lang . String > expected = asList ( \"SELECT<sp>*<sp>FROM<sp>x\" ) ; \"<AssertPlaceHolder>\" ; } statement ( java . lang . String ) { return statement ; }", "answer": "org . junit . Assert . assertThat ( processor . statement ( \"SELECT<sp>*<sp>FROM<sp>x\" ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "fileRead ( java . lang . String ) { return org . apache . maven . shared . utils . io . FileUtils . fileRead ( file , null ) ; }", "testMethod": "writeWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines ( ) { java . io . File file = org . apache . maven . shared . utils . testhelpers . FileTestHelper . newFile ( tempFolder , \"lines.txt\" ) ; org . apache . maven . shared . utils . io . FileUtils . fileWrite ( file , \"UTF-8\" , \"This<sp>line<sp>was<sp>there<sp>before<sp>you...\" ) ; org . apache . maven . shared . utils . io . FileUtils . fileAppend ( file . getAbsolutePath ( ) , \"UTF-8\" , \"this<sp>is<sp>brand<sp>new<sp>data\" ) ; java . lang . String expected = \"This<sp>line<sp>was<sp>there<sp>before<sp>you...\" + \"this<sp>is<sp>brand<sp>new<sp>data\" ; java . lang . String actual = org . apache . maven . shared . utils . io . FileUtils . fileRead ( file ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "writeWithEncoding_WithAppendOptionTrue_ShouldNotDeletePreviousFileLines ( ) { java . io . File file = org . apache . maven . shared . utils . testhelpers . FileTestHelper . newFile ( tempFolder , \"lines.txt\" ) ; org . apache . maven . shared . utils . io . FileUtils . fileWrite ( file , \"UTF-8\" , \"This<sp>line<sp>was<sp>there<sp>before<sp>you...\" ) ; org . apache . maven . shared . utils . io . FileUtils . fileAppend ( file . getAbsolutePath ( ) , \"UTF-8\" , \"this<sp>is<sp>brand<sp>new<sp>data\" ) ; java . lang . String expected = \"This<sp>line<sp>was<sp>there<sp>before<sp>you...\" + \"this<sp>is<sp>brand<sp>new<sp>data\" ; java . lang . String actual = org . apache . maven . shared . utils . io . FileUtils . fileRead ( file ) ; \"<AssertPlaceHolder>\" ; } fileRead ( java . lang . String ) { return org . apache . maven . shared . utils . io . FileUtils . fileRead ( file , null ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "difference ( org . onosproject . store . resource . impl . DiscreteResources ) { if ( other instanceof org . onosproject . store . resource . impl . GenericDiscreteResources ) { return org . onosproject . store . resource . impl . GenericDiscreteResources . of ( new java . util . LinkedHashSet ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ) ; } else if ( other instanceof org . onosproject . store . resource . impl . EmptyDiscreteResources ) { return this ; } return org . onosproject . store . resource . impl . DiscreteResources . of ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ; }", "testMethod": "testDifferenceFromEmpty ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; org . onosproject . store . resource . impl . DiscreteResources other = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( ) ) ; org . onosproject . store . resource . impl . DiscreteResources expected = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sut . difference ( other ) , org . hamcrest . Matchers . is ( expected ) )", "total": "testDifferenceFromEmpty ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; org . onosproject . store . resource . impl . DiscreteResources other = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( ) ) ; org . onosproject . store . resource . impl . DiscreteResources expected = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; \"<AssertPlaceHolder>\" ; } difference ( org . onosproject . store . resource . impl . DiscreteResources ) { if ( other instanceof org . onosproject . store . resource . impl . GenericDiscreteResources ) { return org . onosproject . store . resource . impl . GenericDiscreteResources . of ( new java . util . LinkedHashSet ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ) ; } else if ( other instanceof org . onosproject . store . resource . impl . EmptyDiscreteResources ) { return this ; } return org . onosproject . store . resource . impl . DiscreteResources . of ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( sut . difference ( other ) , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "parseExpr ( java . lang . Class , java . lang . String ) { org . teavm . flavour . expr . EvaluatorBuilder builder = new org . teavm . flavour . expr . InterpretingEvaluatorBuilder ( ) . importPackage ( \"java.lang\" ) . importPackage ( \"java.util\" ) . importClass ( org . teavm . flavour . expr . test . EvaluatorTest . class . getName ( ) ) . importClass ( java . util . stream . Collectors . class . getName ( ) ) ; org . teavm . flavour . expr . Evaluator < T , org . teavm . flavour . expr . test . TestVars > e ; try { e = builder . build ( cls , org . teavm . flavour . expr . test . TestVars . class , str ) ; } catch ( org . teavm . flavour . expr . InvalidExpressionException ex ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"Errors<sp>occurred<sp>compiling<sp>expression:\\n\" ) ; sb . append ( str ) . append ( \"\\n\" ) ; java . util . List < org . teavm . flavour . expr . Diagnostic > diagnostics = ex . getDiagnostics ( ) . stream ( ) . sorted ( java . util . Comparator . comparingInt ( ( d ) -> d . getStart ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( org . teavm . flavour . expr . Diagnostic diagnostic : diagnostics ) { for ( int i = 0 ; i < ( diagnostic . getStart ( ) ) ; ++ i ) { sb . append ( '<sp>' ) ; } sb . append ( \"^\\n\" ) ; sb . append ( diagnostic . getMessage ( ) ) . append ( \"\\n\\n\" ) ; } throw new java . lang . AssertionError ( sb . toString ( ) ) ; } vars = e . getVariables ( ) ; return e . getFunction ( ) ; }", "testMethod": "castsObjectToPrimitiveArray ( ) { org . teavm . flavour . expr . test . IntComputation c = parseExpr ( org . teavm . flavour . expr . test . IntComputation . class , \"((int[])<sp>object)[0]\" ) ; vars . object ( new int [ ] { 23 } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( c . compute ( ) , org . hamcrest . Matchers . is ( 23 ) )", "total": "castsObjectToPrimitiveArray ( ) { org . teavm . flavour . expr . test . IntComputation c = parseExpr ( org . teavm . flavour . expr . test . IntComputation . class , \"((int[])<sp>object)[0]\" ) ; vars . object ( new int [ ] { 23 } ) ; \"<AssertPlaceHolder>\" ; } parseExpr ( java . lang . Class , java . lang . String ) { org . teavm . flavour . expr . EvaluatorBuilder builder = new org . teavm . flavour . expr . InterpretingEvaluatorBuilder ( ) . importPackage ( \"java.lang\" ) . importPackage ( \"java.util\" ) . importClass ( org . teavm . flavour . expr . test . EvaluatorTest . class . getName ( ) ) . importClass ( java . util . stream . Collectors . class . getName ( ) ) ; org . teavm . flavour . expr . Evaluator < T , org . teavm . flavour . expr . test . TestVars > e ; try { e = builder . build ( cls , org . teavm . flavour . expr . test . TestVars . class , str ) ; } catch ( org . teavm . flavour . expr . InvalidExpressionException ex ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"Errors<sp>occurred<sp>compiling<sp>expression:\\n\" ) ; sb . append ( str ) . append ( \"\\n\" ) ; java . util . List < org . teavm . flavour . expr . Diagnostic > diagnostics = ex . getDiagnostics ( ) . stream ( ) . sorted ( java . util . Comparator . comparingInt ( ( d ) -> d . getStart ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( org . teavm . flavour . expr . Diagnostic diagnostic : diagnostics ) { for ( int i = 0 ; i < ( diagnostic . getStart ( ) ) ; ++ i ) { sb . append ( '<sp>' ) ; } sb . append ( \"^\\n\" ) ; sb . append ( diagnostic . getMessage ( ) ) . append ( \"\\n\\n\" ) ; } throw new java . lang . AssertionError ( sb . toString ( ) ) ; } vars = e . getVariables ( ) ; return e . getFunction ( ) ; }", "answer": "org . junit . Assert . assertThat ( c . compute ( ) , org . hamcrest . Matchers . is ( 23 ) )"}
{"focal": "isInitialized ( ) { return initialized ; }", "testMethod": "initializeNoStateReceived ( ) { doReturn ( future ) . when ( thingHandler . device . attributes ) . subscribeAndReceive ( any ( ) , any ( ) , anyString ( ) , any ( ) , anyInt ( ) ) ; doReturn ( future ) . when ( thingHandler . device . attributes ) . unsubscribe ( ) ; doNothing ( ) . when ( thingHandler ) . accept ( any ( ) ) ; thingHandler . initialize ( ) ; \"<AssertPlaceHolder>\" ; verify ( callback ) . statusUpdated ( eq ( thing ) , argThat ( ( arg ) -> ( arg . getStatus ( ) . equals ( ThingStatus . OFFLINE ) ) && ( arg . getStatusDetail ( ) . equals ( ThingStatusDetail . GONE ) ) ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( thingHandler . device . isInitialized ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "initializeNoStateReceived ( ) { doReturn ( future ) . when ( thingHandler . device . attributes ) . subscribeAndReceive ( any ( ) , any ( ) , anyString ( ) , any ( ) , anyInt ( ) ) ; doReturn ( future ) . when ( thingHandler . device . attributes ) . unsubscribe ( ) ; doNothing ( ) . when ( thingHandler ) . accept ( any ( ) ) ; thingHandler . initialize ( ) ; \"<AssertPlaceHolder>\" ; verify ( callback ) . statusUpdated ( eq ( thing ) , argThat ( ( arg ) -> ( arg . getStatus ( ) . equals ( ThingStatus . OFFLINE ) ) && ( arg . getStatusDetail ( ) . equals ( ThingStatusDetail . GONE ) ) ) ) ; } isInitialized ( ) { return initialized ; }", "answer": "org . junit . Assert . assertThat ( thingHandler . device . isInitialized ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getLoggers ( ) { return innerFactory . getLoggers ( ) ; }", "testMethod": "shouldGetLoggers ( ) { final java . util . Collection < java . lang . String > loggers = factory . getLoggers ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( loggers , org . hamcrest . Matchers . equalTo ( this . loggers ) )", "total": "shouldGetLoggers ( ) { final java . util . Collection < java . lang . String > loggers = factory . getLoggers ( ) ; \"<AssertPlaceHolder>\" ; } getLoggers ( ) { return innerFactory . getLoggers ( ) ; }", "answer": "org . junit . Assert . assertThat ( loggers , org . hamcrest . Matchers . equalTo ( this . loggers ) )"}
{"focal": "fromJsonBytes ( byte [ ] ) { return com . distelli . europa . notifiers . WebhookRecord . OBJECT_MAPPER . readValue ( recordBytes , com . distelli . europa . notifiers . WebhookRecord . class ) ; }", "testMethod": "testWebhookRecord ( ) { com . distelli . europa . notifiers . WebhookRequest request = com . distelli . europa . notifiers . WebhookRequest . builder ( ) . body ( \"{\\\"hello\\\":\\\"world\\\"}\" ) . header ( \"a\" , \"b\" ) . header ( \"b\" , \"c\" ) . build ( ) ; com . distelli . europa . notifiers . WebhookResponse response = com . distelli . europa . notifiers . WebhookResponse . builder ( ) . httpStatusCode ( 200 ) . body ( \"{\\\"some\\\":\\\"response\\\"}\" ) . header ( \"1\" , \"2\" ) . header ( \"3\" , \"4\" ) . build ( ) ; com . distelli . europa . notifiers . WebhookRecord record = new com . distelli . europa . notifiers . WebhookRecord ( ) ; record . setRequest ( request ) ; record . setResponse ( response ) ; byte [ ] bytes = record . toJsonBytes ( ) ; com . distelli . europa . notifiers . WebhookRecord record2 = com . distelli . europa . notifiers . WebhookRecord . fromJsonBytes ( bytes ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( record2 , org . hamcrest . CoreMatchers . equalTo ( record ) )", "total": "testWebhookRecord ( ) { com . distelli . europa . notifiers . WebhookRequest request = com . distelli . europa . notifiers . WebhookRequest . builder ( ) . body ( \"{\\\"hello\\\":\\\"world\\\"}\" ) . header ( \"a\" , \"b\" ) . header ( \"b\" , \"c\" ) . build ( ) ; com . distelli . europa . notifiers . WebhookResponse response = com . distelli . europa . notifiers . WebhookResponse . builder ( ) . httpStatusCode ( 200 ) . body ( \"{\\\"some\\\":\\\"response\\\"}\" ) . header ( \"1\" , \"2\" ) . header ( \"3\" , \"4\" ) . build ( ) ; com . distelli . europa . notifiers . WebhookRecord record = new com . distelli . europa . notifiers . WebhookRecord ( ) ; record . setRequest ( request ) ; record . setResponse ( response ) ; byte [ ] bytes = record . toJsonBytes ( ) ; com . distelli . europa . notifiers . WebhookRecord record2 = com . distelli . europa . notifiers . WebhookRecord . fromJsonBytes ( bytes ) ; \"<AssertPlaceHolder>\" ; } fromJsonBytes ( byte [ ] ) { return com . distelli . europa . notifiers . WebhookRecord . OBJECT_MAPPER . readValue ( recordBytes , com . distelli . europa . notifiers . WebhookRecord . class ) ; }", "answer": "org . junit . Assert . assertThat ( record2 , org . hamcrest . CoreMatchers . equalTo ( record ) )"}
{"focal": "contains ( java . lang . Object ) { return data . contains ( o ) ; }", "testMethod": "testSearchForExtensionToken ( ) { ca . uhn . fhir . jpa . dao . r4 . SearchParameter eyeColourSp = new ca . uhn . fhir . jpa . dao . r4 . SearchParameter ( ) ; eyeColourSp . addBase ( \"Patient\" ) ; eyeColourSp . setCode ( \"eyecolour\" ) ; eyeColourSp . setType ( org . hl7 . fhir . r4 . model . Enumerations . SearchParamType . TOKEN ) ; eyeColourSp . setTitle ( \"Eye<sp>Colour\" ) ; eyeColourSp . setExpression ( \"Patient.extension('http://acme.org/eyecolour')\" ) ; eyeColourSp . setXpathUsage ( org . hl7 . fhir . r4 . model . SearchParameter . XPathUsageType . NORMAL ) ; eyeColourSp . setStatus ( org . hl7 . fhir . r4 . model . Enumerations . PublicationStatus . ACTIVE ) ; mySearchParameterDao . create ( eyeColourSp , mySrd ) ; mySearchParamRegistry . forceRefresh ( ) ; ca . uhn . fhir . jpa . dao . r4 . Patient p1 = new ca . uhn . fhir . jpa . dao . r4 . Patient ( ) ; p1 . setActive ( true ) ; p1 . addExtension ( ) . setUrl ( \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . r4 . CodeType ( \"blue\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p1id = myPatientDao . create ( p1 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . dao . r4 . Patient p2 = new ca . uhn . fhir . jpa . dao . r4 . Patient ( ) ; p2 . setActive ( true ) ; p2 . addExtension ( ) . setUrl ( \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . r4 . CodeType ( \"green\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p2id = myPatientDao . create ( p2 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . searchparam . SearchParameterMap map = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; map . add ( \"eyecolour\" , new ca . uhn . fhir . jpa . dao . r4 . TokenParam ( null , \"blue\" ) ) ; ca . uhn . fhir . rest . api . server . IBundleProvider results = myPatientDao . search ( map ) ; java . util . List < java . lang . String > foundResources = toUnqualifiedVersionlessIdValues ( results ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( foundResources , contains ( p1id . getValue ( ) ) )", "total": "testSearchForExtensionToken ( ) { ca . uhn . fhir . jpa . dao . r4 . SearchParameter eyeColourSp = new ca . uhn . fhir . jpa . dao . r4 . SearchParameter ( ) ; eyeColourSp . addBase ( \"Patient\" ) ; eyeColourSp . setCode ( \"eyecolour\" ) ; eyeColourSp . setType ( org . hl7 . fhir . r4 . model . Enumerations . SearchParamType . TOKEN ) ; eyeColourSp . setTitle ( \"Eye<sp>Colour\" ) ; eyeColourSp . setExpression ( \"Patient.extension('http://acme.org/eyecolour')\" ) ; eyeColourSp . setXpathUsage ( org . hl7 . fhir . r4 . model . SearchParameter . XPathUsageType . NORMAL ) ; eyeColourSp . setStatus ( org . hl7 . fhir . r4 . model . Enumerations . PublicationStatus . ACTIVE ) ; mySearchParameterDao . create ( eyeColourSp , mySrd ) ; mySearchParamRegistry . forceRefresh ( ) ; ca . uhn . fhir . jpa . dao . r4 . Patient p1 = new ca . uhn . fhir . jpa . dao . r4 . Patient ( ) ; p1 . setActive ( true ) ; p1 . addExtension ( ) . setUrl ( \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . r4 . CodeType ( \"blue\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p1id = myPatientDao . create ( p1 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . dao . r4 . Patient p2 = new ca . uhn . fhir . jpa . dao . r4 . Patient ( ) ; p2 . setActive ( true ) ; p2 . addExtension ( ) . setUrl ( \"http://acme.org/eyecolour\" ) . setValue ( new ca . uhn . fhir . jpa . dao . r4 . CodeType ( \"green\" ) ) ; org . hl7 . fhir . instance . model . api . IIdType p2id = myPatientDao . create ( p2 ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . searchparam . SearchParameterMap map = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; map . add ( \"eyecolour\" , new ca . uhn . fhir . jpa . dao . r4 . TokenParam ( null , \"blue\" ) ) ; ca . uhn . fhir . rest . api . server . IBundleProvider results = myPatientDao . search ( map ) ; java . util . List < java . lang . String > foundResources = toUnqualifiedVersionlessIdValues ( results ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . Object ) { return data . contains ( o ) ; }", "answer": "org . junit . Assert . assertThat ( foundResources , contains ( p1id . getValue ( ) ) )"}
{"focal": "fromConfiguration ( org . apache . hadoop . conf . Configuration ) { org . apache . crunch . types . avro . AvroMode mode = org . apache . crunch . types . avro . AvroMode . getMode ( conf . getEnum ( org . apache . crunch . types . avro . AvroMode . AVRO_MODE_PROPERTY , org . apache . crunch . types . avro . AvroMode . ModeType . REFLECT ) ) ; return mode . withFactoryFromConfiguration ( conf ) ; }", "testMethod": "configureAndRetrieveSpecific ( ) { org . apache . hadoop . conf . Configuration conf = new org . apache . hadoop . conf . Configuration ( ) ; AvroMode . SPECIFIC . configure ( conf ) ; org . apache . crunch . types . avro . AvroMode returnedMode = org . apache . crunch . types . avro . AvroMode . fromConfiguration ( conf ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( returnedMode , org . hamcrest . CoreMatchers . is ( AvroMode . SPECIFIC ) )", "total": "configureAndRetrieveSpecific ( ) { org . apache . hadoop . conf . Configuration conf = new org . apache . hadoop . conf . Configuration ( ) ; AvroMode . SPECIFIC . configure ( conf ) ; org . apache . crunch . types . avro . AvroMode returnedMode = org . apache . crunch . types . avro . AvroMode . fromConfiguration ( conf ) ; \"<AssertPlaceHolder>\" ; } fromConfiguration ( org . apache . hadoop . conf . Configuration ) { org . apache . crunch . types . avro . AvroMode mode = org . apache . crunch . types . avro . AvroMode . getMode ( conf . getEnum ( org . apache . crunch . types . avro . AvroMode . AVRO_MODE_PROPERTY , org . apache . crunch . types . avro . AvroMode . ModeType . REFLECT ) ) ; return mode . withFactoryFromConfiguration ( conf ) ; }", "answer": "org . junit . Assert . assertThat ( returnedMode , org . hamcrest . CoreMatchers . is ( AvroMode . SPECIFIC ) )"}
{"focal": "read ( java . io . InputStream ) { java . util . Map < java . lang . String , javax . naming . directory . Attributes > result = new java . util . LinkedHashMap ( ) ; try ( java . io . BufferedReader reader = new java . io . BufferedReader ( new java . io . InputStreamReader ( in ) ) ) { java . lang . String line ; javax . naming . directory . Attributes currentEntity = null ; java . lang . String currentLine = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . startsWith ( \"#\" ) ) { continue ; } if ( line . isEmpty ( ) ) { if ( currentLine != null ) { lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . storeAttribute ( result , currentEntity , currentLine ) ; } currentEntity = null ; currentLine = null ; continue ; } if ( currentEntity == null ) { currentEntity = new javax . naming . directory . BasicAttributes ( ) ; } if ( ! ( line . startsWith ( \"<sp>\" ) ) ) { if ( currentLine != null ) { lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . storeAttribute ( result , currentEntity , currentLine ) ; } currentLine = line ; } else { currentLine = currentLine + line ; } } if ( currentLine != null ) { lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . storeAttribute ( result , currentEntity , currentLine ) ; } } return result ; }", "testMethod": "read ( ) { java . util . Map < java . lang . String , javax . naming . directory . Attributes > entities = lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . read ( getClass ( ) . getResourceAsStream ( \"/example.ldif\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( entities . size ( ) , org . hamcrest . CoreMatchers . is ( 4 ) )", "total": "read ( ) { java . util . Map < java . lang . String , javax . naming . directory . Attributes > entities = lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . read ( getClass ( ) . getResourceAsStream ( \"/example.ldif\" ) ) ; \"<AssertPlaceHolder>\" ; } read ( java . io . InputStream ) { java . util . Map < java . lang . String , javax . naming . directory . Attributes > result = new java . util . LinkedHashMap ( ) ; try ( java . io . BufferedReader reader = new java . io . BufferedReader ( new java . io . InputStreamReader ( in ) ) ) { java . lang . String line ; javax . naming . directory . Attributes currentEntity = null ; java . lang . String currentLine = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . startsWith ( \"#\" ) ) { continue ; } if ( line . isEmpty ( ) ) { if ( currentLine != null ) { lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . storeAttribute ( result , currentEntity , currentLine ) ; } currentEntity = null ; currentLine = null ; continue ; } if ( currentEntity == null ) { currentEntity = new javax . naming . directory . BasicAttributes ( ) ; } if ( ! ( line . startsWith ( \"<sp>\" ) ) ) { if ( currentLine != null ) { lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . storeAttribute ( result , currentEntity , currentLine ) ; } currentLine = line ; } else { currentLine = currentLine + line ; } } if ( currentLine != null ) { lv . ctco . cukes . ldap . internal . ldif . LDIFUtils . storeAttribute ( result , currentEntity , currentLine ) ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( entities . size ( ) , org . hamcrest . CoreMatchers . is ( 4 ) )"}
{"focal": "getSessionResource ( ) { __assertAuthenticated ( ) ; if ( ( ( defensiveCopyOfSessionResource ) == null ) || ( ! ( com . acciente . oacc . sql . internal . SQLAccessControlContext . __isEqual ( defensiveCopyOfSessionResource , sessionResource ) ) ) ) { defensiveCopyOfSessionResource = com . acciente . oacc . Resources . getInstance ( sessionResource . getId ( ) , sessionResource . getExternalId ( ) ) ; } return defensiveCopyOfSessionResource ; }", "testMethod": "getSessionResource_impersonated ( ) { authenticateSystemResource ( ) ; final char [ ] password = generateUniquePassword ( ) ; final com . acciente . oacc . Resource accessorResource = generateAuthenticatableResource ( password ) ; final com . acciente . oacc . Resource impersonatedResource = generateAuthenticatableResource ( generateUniquePassword ( ) ) ; accessControlContext . setResourcePermissions ( accessorResource , impersonatedResource , setOf ( com . acciente . oacc . ResourcePermissions . getInstance ( ResourcePermissions . IMPERSONATE ) ) ) ; accessControlContext . authenticate ( accessorResource , com . acciente . oacc . PasswordCredentials . newInstance ( password ) ) ; accessControlContext . impersonate ( impersonatedResource ) ; final com . acciente . oacc . Resource authenticatedResource = accessControlContext . getSessionResource ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( authenticatedResource , org . hamcrest . CoreMatchers . is ( impersonatedResource ) )", "total": "getSessionResource_impersonated ( ) { authenticateSystemResource ( ) ; final char [ ] password = generateUniquePassword ( ) ; final com . acciente . oacc . Resource accessorResource = generateAuthenticatableResource ( password ) ; final com . acciente . oacc . Resource impersonatedResource = generateAuthenticatableResource ( generateUniquePassword ( ) ) ; accessControlContext . setResourcePermissions ( accessorResource , impersonatedResource , setOf ( com . acciente . oacc . ResourcePermissions . getInstance ( ResourcePermissions . IMPERSONATE ) ) ) ; accessControlContext . authenticate ( accessorResource , com . acciente . oacc . PasswordCredentials . newInstance ( password ) ) ; accessControlContext . impersonate ( impersonatedResource ) ; final com . acciente . oacc . Resource authenticatedResource = accessControlContext . getSessionResource ( ) ; \"<AssertPlaceHolder>\" ; } getSessionResource ( ) { __assertAuthenticated ( ) ; if ( ( ( defensiveCopyOfSessionResource ) == null ) || ( ! ( com . acciente . oacc . sql . internal . SQLAccessControlContext . __isEqual ( defensiveCopyOfSessionResource , sessionResource ) ) ) ) { defensiveCopyOfSessionResource = com . acciente . oacc . Resources . getInstance ( sessionResource . getId ( ) , sessionResource . getExternalId ( ) ) ; } return defensiveCopyOfSessionResource ; }", "answer": "org . junit . Assert . assertThat ( authenticatedResource , org . hamcrest . CoreMatchers . is ( impersonatedResource ) )"}
{"focal": "filter ( java . lang . String ) { this . filter = filter ; return this ; }", "testMethod": "test_TDP_690 ( ) { java . lang . String id = java . util . UUID . randomUUID ( ) . toString ( ) ; final org . talend . dataprep . api . dataset . DataSetMetadata metadata = metadataBuilder . metadata ( ) . id ( id ) . build ( ) ; dataSetMetadataRepository . save ( metadata ) ; contentStore . storeAsRaw ( metadata , org . talend . dataprep . dataset . service . DataSetServiceTest . class . getResourceAsStream ( \"../wave_lab_utf16_LE.txt\" ) ) ; formatAnalysis . analyze ( id ) ; final org . talend . dataprep . api . dataset . DataSetMetadata actual = dataSetMetadataRepository . get ( id ) ; java . util . stream . Stream < org . talend . dataprep . api . dataset . row . DataSetRow > content = contentStore . stream ( actual ) ; final long emptyRows = content . filter ( DataSetRow :: isEmpty ) . count ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( emptyRows , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "test_TDP_690 ( ) { java . lang . String id = java . util . UUID . randomUUID ( ) . toString ( ) ; final org . talend . dataprep . api . dataset . DataSetMetadata metadata = metadataBuilder . metadata ( ) . id ( id ) . build ( ) ; dataSetMetadataRepository . save ( metadata ) ; contentStore . storeAsRaw ( metadata , org . talend . dataprep . dataset . service . DataSetServiceTest . class . getResourceAsStream ( \"../wave_lab_utf16_LE.txt\" ) ) ; formatAnalysis . analyze ( id ) ; final org . talend . dataprep . api . dataset . DataSetMetadata actual = dataSetMetadataRepository . get ( id ) ; java . util . stream . Stream < org . talend . dataprep . api . dataset . row . DataSetRow > content = contentStore . stream ( actual ) ; final long emptyRows = content . filter ( DataSetRow :: isEmpty ) . count ( ) ; \"<AssertPlaceHolder>\" ; } filter ( java . lang . String ) { this . filter = filter ; return this ; }", "answer": "org . junit . Assert . assertThat ( emptyRows , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "getLocalizedThingStatusInfo ( org . eclipse . smarthome . core . thing . Thing , java . util . Locale ) { if ( thing == null ) { throw new java . lang . IllegalArgumentException ( \"Thing<sp>must<sp>not<sp>be<sp>null.\" ) ; } org . eclipse . smarthome . core . thing . binding . ThingHandler thingHandler = thing . getHandler ( ) ; if ( thingHandler == null ) { return thing . getStatusInfo ( ) ; } java . lang . String description = thing . getStatusInfo ( ) . getDescription ( ) ; if ( ( description == null ) || ( ! ( org . eclipse . smarthome . core . i18n . I18nUtil . isConstant ( description ) ) ) ) { return thing . getStatusInfo ( ) ; } java . lang . String translatedDescription = translateDescription ( description , locale , thingHandler ) ; return new org . eclipse . smarthome . core . thing . ThingStatusInfo ( thing . getStatus ( ) , thing . getStatusInfo ( ) . getStatusDetail ( ) , translatedDescription ) ; }", "testMethod": "thingStatusInfoNotChangedForNonI18nConstantDescription ( ) { org . eclipse . smarthome . core . thing . ThingStatusInfo expected = new org . eclipse . smarthome . core . thing . ThingStatusInfo ( org . eclipse . smarthome . core . thing . ThingStatus . ONLINE , org . eclipse . smarthome . core . thing . ThingStatusDetail . NONE , \"The<sp>description.\" ) ; setThingStatusInfo ( thing , expected ) ; org . eclipse . smarthome . core . thing . ThingStatusInfo thingStatusInfo = thingStatusInfoI18nLocalizationService . getLocalizedThingStatusInfo ( thing , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( thingStatusInfo , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "thingStatusInfoNotChangedForNonI18nConstantDescription ( ) { org . eclipse . smarthome . core . thing . ThingStatusInfo expected = new org . eclipse . smarthome . core . thing . ThingStatusInfo ( org . eclipse . smarthome . core . thing . ThingStatus . ONLINE , org . eclipse . smarthome . core . thing . ThingStatusDetail . NONE , \"The<sp>description.\" ) ; setThingStatusInfo ( thing , expected ) ; org . eclipse . smarthome . core . thing . ThingStatusInfo thingStatusInfo = thingStatusInfoI18nLocalizationService . getLocalizedThingStatusInfo ( thing , null ) ; \"<AssertPlaceHolder>\" ; } getLocalizedThingStatusInfo ( org . eclipse . smarthome . core . thing . Thing , java . util . Locale ) { if ( thing == null ) { throw new java . lang . IllegalArgumentException ( \"Thing<sp>must<sp>not<sp>be<sp>null.\" ) ; } org . eclipse . smarthome . core . thing . binding . ThingHandler thingHandler = thing . getHandler ( ) ; if ( thingHandler == null ) { return thing . getStatusInfo ( ) ; } java . lang . String description = thing . getStatusInfo ( ) . getDescription ( ) ; if ( ( description == null ) || ( ! ( org . eclipse . smarthome . core . i18n . I18nUtil . isConstant ( description ) ) ) ) { return thing . getStatusInfo ( ) ; } java . lang . String translatedDescription = translateDescription ( description , locale , thingHandler ) ; return new org . eclipse . smarthome . core . thing . ThingStatusInfo ( thing . getStatus ( ) , thing . getStatusInfo ( ) . getStatusDetail ( ) , translatedDescription ) ; }", "answer": "org . junit . Assert . assertThat ( thingStatusInfo , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "get ( java . lang . Object ) { if ( ( gov . nysenate . openleg . service . shiro . shiroCacheManager . cache . get ( key ) ) == null ) return null ; else return gov . nysenate . openleg . service . shiro . shiroCacheManager . cache . get ( key ) . getObjectValue ( ) ; }", "testMethod": "stateAbbreviationParses ( ) { java . util . List < java . util . List < java . lang . String > > pages = gov . nysenate . openleg . processor . hearing . PublicHearingTestHelper . getPagesFromFileName ( \"10-10-13<sp>NYsenate_Fuschillo_MTA_FINAL.txt\" ) ; java . lang . String expected = \"Senate<sp>Majority<sp>Office\\n250<sp>Broadway,<sp>Suite<sp>2034\\nNew<sp>York,<sp>NY<sp>10007-2375\" ; java . lang . String actual = addressParser . parse ( pages . get ( 0 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "stateAbbreviationParses ( ) { java . util . List < java . util . List < java . lang . String > > pages = gov . nysenate . openleg . processor . hearing . PublicHearingTestHelper . getPagesFromFileName ( \"10-10-13<sp>NYsenate_Fuschillo_MTA_FINAL.txt\" ) ; java . lang . String expected = \"Senate<sp>Majority<sp>Office\\n250<sp>Broadway,<sp>Suite<sp>2034\\nNew<sp>York,<sp>NY<sp>10007-2375\" ; java . lang . String actual = addressParser . parse ( pages . get ( 0 ) ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . Object ) { if ( ( gov . nysenate . openleg . service . shiro . shiroCacheManager . cache . get ( key ) ) == null ) return null ; else return gov . nysenate . openleg . service . shiro . shiroCacheManager . cache . get ( key ) . getObjectValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "putAllContextMap ( java . util . Map ) { return new java . lang . Runnable ( ) { @ com . sap . hcp . cf . logging . servlet . filter . Override public void run ( ) { contextMap . putAll ( org . slf4j . MDC . getCopyOfContextMap ( ) ) ; } } ; }", "testMethod": "hasEmptyMDCWhenNoMapInRequest ( ) { java . util . Map < java . lang . String , java . lang . String > contextMap = new java . util . HashMap ( ) ; testedContext . start ( putAllContextMap ( contextMap ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( contextMap . entrySet ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . empty ( ) ) )", "total": "hasEmptyMDCWhenNoMapInRequest ( ) { java . util . Map < java . lang . String , java . lang . String > contextMap = new java . util . HashMap ( ) ; testedContext . start ( putAllContextMap ( contextMap ) ) ; \"<AssertPlaceHolder>\" ; } putAllContextMap ( java . util . Map ) { return new java . lang . Runnable ( ) { @ com . sap . hcp . cf . logging . servlet . filter . Override public void run ( ) { contextMap . putAll ( org . slf4j . MDC . getCopyOfContextMap ( ) ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( contextMap . entrySet ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . empty ( ) ) )"}
{"focal": "getValue ( ) { return java . util . Arrays . copyOf ( this . value , this . value . length ) ; }", "testMethod": "testUpdatePasswordWithPassword ( ) { org . codice . ddf . admin . core . impl . AdminConsoleService configAdmin = getConfigAdmin ( ) ; java . util . Dictionary < java . lang . String , java . lang . Object > currentProps = new java . util . Hashtable ( ) ; currentProps . put ( \"TestKey_0_12\" , \"secret\" ) ; when ( org . codice . ddf . admin . core . impl . AdminConsoleServiceTest . testConfig . getProperties ( ) ) . thenReturn ( currentProps ) ; java . util . Hashtable < java . lang . String , java . lang . Object > values = new java . util . Hashtable ( ) ; values . put ( \"TestKey_0_12\" , \"password\" ) ; org . mockito . ArgumentCaptor < java . util . Dictionary > captor = org . mockito . ArgumentCaptor . forClass ( java . util . Dictionary . class ) ; configAdmin . update ( org . codice . ddf . admin . core . impl . AdminConsoleServiceTest . TEST_PID , values ) ; verify ( org . codice . ddf . admin . core . impl . AdminConsoleServiceTest . testConfig , times ( 1 ) ) . update ( captor . capture ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( captor . getValue ( ) . get ( \"TestKey_0_12\" ) , org . hamcrest . Matchers . equalTo ( \"secret\" ) )", "total": "testUpdatePasswordWithPassword ( ) { org . codice . ddf . admin . core . impl . AdminConsoleService configAdmin = getConfigAdmin ( ) ; java . util . Dictionary < java . lang . String , java . lang . Object > currentProps = new java . util . Hashtable ( ) ; currentProps . put ( \"TestKey_0_12\" , \"secret\" ) ; when ( org . codice . ddf . admin . core . impl . AdminConsoleServiceTest . testConfig . getProperties ( ) ) . thenReturn ( currentProps ) ; java . util . Hashtable < java . lang . String , java . lang . Object > values = new java . util . Hashtable ( ) ; values . put ( \"TestKey_0_12\" , \"password\" ) ; org . mockito . ArgumentCaptor < java . util . Dictionary > captor = org . mockito . ArgumentCaptor . forClass ( java . util . Dictionary . class ) ; configAdmin . update ( org . codice . ddf . admin . core . impl . AdminConsoleServiceTest . TEST_PID , values ) ; verify ( org . codice . ddf . admin . core . impl . AdminConsoleServiceTest . testConfig , times ( 1 ) ) . update ( captor . capture ( ) ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return java . util . Arrays . copyOf ( this . value , this . value . length ) ; }", "answer": "org . junit . Assert . assertThat ( captor . getValue ( ) . get ( \"TestKey_0_12\" ) , org . hamcrest . Matchers . equalTo ( \"secret\" ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectNotFlowAction ( ) { org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch obj = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsObjectNotFlowAction ( ) { org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch obj = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getUnit ( ) { return unit ; }", "testMethod": "setUnit_k_unitIsSet ( ) { java . lang . String unitOfMeasure = \"K\" ; sampledValue . setUnit ( unitOfMeasure ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sampledValue . getUnit ( ) , org . hamcrest . CoreMatchers . equalTo ( unitOfMeasure ) )", "total": "setUnit_k_unitIsSet ( ) { java . lang . String unitOfMeasure = \"K\" ; sampledValue . setUnit ( unitOfMeasure ) ; \"<AssertPlaceHolder>\" ; } getUnit ( ) { return unit ; }", "answer": "org . junit . Assert . assertThat ( sampledValue . getUnit ( ) , org . hamcrest . CoreMatchers . equalTo ( unitOfMeasure ) )"}
{"focal": "createJenaModel ( java . lang . Object [ ] ) { return org . eclipse . lyo . oslc4j . provider . jena . JenaModelHelper . createJenaModel ( null , null , null , objects , null ) ; }", "testMethod": "testSeqMarshalling ( ) { final org . apache . jena . rdf . model . Model expectedModel = org . eclipse . lyo . oslc4j . provider . jena . helpers . RDFHelper . loadResourceModel ( \"container-element.ttl\" ) ; final org . eclipse . lyo . oslc4j . provider . jena . resources . Container container = new org . eclipse . lyo . oslc4j . provider . jena . resources . Container ( ) ; container . setAbout ( java . net . URI . create ( \"urn:containerA\" ) ) ; final org . apache . jena . ext . com . google . common . collect . ImmutableList < org . eclipse . lyo . oslc4j . provider . jena . resources . Element > children = org . apache . jena . ext . com . google . common . collect . ImmutableList . of ( element ( \"A\" ) , element ( \"B\" ) ) ; container . setChildrenL ( children ) ; container . setChildrenB ( children ) ; final org . apache . jena . rdf . model . Model actualModel = org . eclipse . lyo . oslc4j . provider . jena . JenaModelHelper . createJenaModel ( new java . lang . Object [ ] { container } ) ; \"<AssertPlaceHolder>\" . isomorphicWith ( expectedModel ) ; }", "assertLine": "org . junit . Assert . assertThat ( actualModel )", "total": "testSeqMarshalling ( ) { final org . apache . jena . rdf . model . Model expectedModel = org . eclipse . lyo . oslc4j . provider . jena . helpers . RDFHelper . loadResourceModel ( \"container-element.ttl\" ) ; final org . eclipse . lyo . oslc4j . provider . jena . resources . Container container = new org . eclipse . lyo . oslc4j . provider . jena . resources . Container ( ) ; container . setAbout ( java . net . URI . create ( \"urn:containerA\" ) ) ; final org . apache . jena . ext . com . google . common . collect . ImmutableList < org . eclipse . lyo . oslc4j . provider . jena . resources . Element > children = org . apache . jena . ext . com . google . common . collect . ImmutableList . of ( element ( \"A\" ) , element ( \"B\" ) ) ; container . setChildrenL ( children ) ; container . setChildrenB ( children ) ; final org . apache . jena . rdf . model . Model actualModel = org . eclipse . lyo . oslc4j . provider . jena . JenaModelHelper . createJenaModel ( new java . lang . Object [ ] { container } ) ; \"<AssertPlaceHolder>\" . isomorphicWith ( expectedModel ) ; } createJenaModel ( java . lang . Object [ ] ) { return org . eclipse . lyo . oslc4j . provider . jena . JenaModelHelper . createJenaModel ( null , null , null , objects , null ) ; }", "answer": "org . junit . Assert . assertThat ( actualModel )"}
{"focal": "compare ( com . mongodb . DBObject , com . mongodb . DBObject ) { final int obj1Count = getCount ( obj1 ) ; final int obj2Count = getCount ( obj2 ) ; return obj2Count - obj1Count ; }", "testMethod": "countRegexMatchesAll ( ) { final com . mongodb . BasicDBObject dbObj = new com . mongodb . BasicDBObject ( \"Attr1\" , \"these<sp>are<sp>some<sp>random<sp>words<sp>to<sp>test\" ) . append ( \"Attr2\" , \"these<sp>are<sp>some<sp>more<sp>search<sp>words\" ) . append ( \"Attr3\" , \"and<sp>some<sp>more<sp>words\" ) ; final com . mongodb . BasicDBObject otherDBObj = new com . mongodb . BasicDBObject ( \"Attr1\" , \"these<sp>are<sp>some<sp>other<sp>words<sp>to<sp>test\" ) ; this . dbObjectComparator = new xbdd . webapp . resource . feature . DBObjectComparator ( java . util . Arrays . asList ( \"random\" , \".*\" , \"\\\\d+\" ) ) ; final int comparison1 = this . dbObjectComparator . compare ( dbObj , otherDBObj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( comparison1 , org . hamcrest . Matchers . is ( 0 ) )", "total": "countRegexMatchesAll ( ) { final com . mongodb . BasicDBObject dbObj = new com . mongodb . BasicDBObject ( \"Attr1\" , \"these<sp>are<sp>some<sp>random<sp>words<sp>to<sp>test\" ) . append ( \"Attr2\" , \"these<sp>are<sp>some<sp>more<sp>search<sp>words\" ) . append ( \"Attr3\" , \"and<sp>some<sp>more<sp>words\" ) ; final com . mongodb . BasicDBObject otherDBObj = new com . mongodb . BasicDBObject ( \"Attr1\" , \"these<sp>are<sp>some<sp>other<sp>words<sp>to<sp>test\" ) ; this . dbObjectComparator = new xbdd . webapp . resource . feature . DBObjectComparator ( java . util . Arrays . asList ( \"random\" , \".*\" , \"\\\\d+\" ) ) ; final int comparison1 = this . dbObjectComparator . compare ( dbObj , otherDBObj ) ; \"<AssertPlaceHolder>\" ; } compare ( com . mongodb . DBObject , com . mongodb . DBObject ) { final int obj1Count = getCount ( obj1 ) ; final int obj2Count = getCount ( obj2 ) ; return obj2Count - obj1Count ; }", "answer": "org . junit . Assert . assertThat ( comparison1 , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "copyNoClose ( jscover . util . InputStream , jscover . util . OutputStream , int ) { int bufSize = java . lang . Math . min ( 1024 , length ) ; byte [ ] buf = new byte [ bufSize ] ; try { for ( int total = 0 , read ; ( total < length ) && ( ( read = is . read ( buf , 0 , java . lang . Math . min ( bufSize , ( length - total ) ) ) ) != ( - 1 ) ) ; total += read ) { os . write ( buf , 0 , read ) ; os . flush ( ) ; } } catch ( jscover . util . IOException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "testMethod": "shouldCopyISToOSNoCloseLength ( ) { java . lang . String data = \"data\" ; byte [ ] bytes = data . getBytes ( ) ; jscover . util . ByteArrayOutputStream baos = new jscover . util . ByteArrayOutputStream ( ) ; ioUtils . copyNoClose ( new jscover . util . ByteArrayInputStream ( bytes ) , baos , bytes . length ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( new java . lang . String ( baos . toByteArray ( ) ) , org . hamcrest . CoreMatchers . equalTo ( data ) )", "total": "shouldCopyISToOSNoCloseLength ( ) { java . lang . String data = \"data\" ; byte [ ] bytes = data . getBytes ( ) ; jscover . util . ByteArrayOutputStream baos = new jscover . util . ByteArrayOutputStream ( ) ; ioUtils . copyNoClose ( new jscover . util . ByteArrayInputStream ( bytes ) , baos , bytes . length ) ; \"<AssertPlaceHolder>\" ; } copyNoClose ( jscover . util . InputStream , jscover . util . OutputStream , int ) { int bufSize = java . lang . Math . min ( 1024 , length ) ; byte [ ] buf = new byte [ bufSize ] ; try { for ( int total = 0 , read ; ( total < length ) && ( ( read = is . read ( buf , 0 , java . lang . Math . min ( bufSize , ( length - total ) ) ) ) != ( - 1 ) ) ; total += read ) { os . write ( buf , 0 , read ) ; os . flush ( ) ; } } catch ( jscover . util . IOException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( new java . lang . String ( baos . toByteArray ( ) ) , org . hamcrest . CoreMatchers . equalTo ( data ) )"}
{"focal": "size ( ) { return list . size ( ) ; }", "testMethod": "dataPointsArrayMethodMayContainNullValue ( ) { java . util . List < org . junit . experimental . theories . PotentialAssignment > valueSources = allMemberValuesFor ( org . junit . tests . experimental . theories . internal . AllMembersSupplierTest . HasDataPointsMethodWithNullValue . class , org . junit . tests . experimental . theories . internal . Integer . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( valueSources . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "dataPointsArrayMethodMayContainNullValue ( ) { java . util . List < org . junit . experimental . theories . PotentialAssignment > valueSources = allMemberValuesFor ( org . junit . tests . experimental . theories . internal . AllMembersSupplierTest . HasDataPointsMethodWithNullValue . class , org . junit . tests . experimental . theories . internal . Integer . class ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return list . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( valueSources . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "reverseGet ( V ) { return reverseMap . get ( value ) ; }", "testMethod": "reverseGetAdded ( ) { subject . set ( key , value ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( subject . reverseGet ( value ) , org . hamcrest . CoreMatchers . is ( key ) )", "total": "reverseGetAdded ( ) { subject . set ( key , value ) ; \"<AssertPlaceHolder>\" ; } reverseGet ( V ) { return reverseMap . get ( value ) ; }", "answer": "org . junit . Assert . assertThat ( subject . reverseGet ( value ) , org . hamcrest . CoreMatchers . is ( key ) )"}
{"focal": "copy ( java . io . InputStream , java . io . OutputStream ) { org . apache . maven . shared . utils . io . IOUtil . copy ( input , output , org . apache . maven . shared . utils . io . IOUtil . DEFAULT_BUFFER_SIZE ) ; }", "testMethod": "copyByteArrayValidOutputStream ( ) { java . io . ByteArrayOutputStream outputStream = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseByteArrayOutputStream ( ) ; byte [ ] input = new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ; org . apache . maven . shared . utils . io . IOUtil . copy ( input , outputStream ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( outputStream . toByteArray ( ) , org . hamcrest . CoreMatchers . is ( input ) )", "total": "copyByteArrayValidOutputStream ( ) { java . io . ByteArrayOutputStream outputStream = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseByteArrayOutputStream ( ) ; byte [ ] input = new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ; org . apache . maven . shared . utils . io . IOUtil . copy ( input , outputStream ) ; \"<AssertPlaceHolder>\" ; } copy ( java . io . InputStream , java . io . OutputStream ) { org . apache . maven . shared . utils . io . IOUtil . copy ( input , output , org . apache . maven . shared . utils . io . IOUtil . DEFAULT_BUFFER_SIZE ) ; }", "answer": "org . junit . Assert . assertThat ( outputStream . toByteArray ( ) , org . hamcrest . CoreMatchers . is ( input ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testRemainingLifetime ( ) { defaultLspWrapper . setLsdbAge ( defaultIsisLsdbAge ) ; defaultLspWrapper . setAgeCounterWhenReceived ( 1 ) ; defaultLspWrapper . currentAge ( ) ; defaultLspWrapper . setRemainingLifetime ( 1 ) ; result1 = defaultLspWrapper . remainingLifetime ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testRemainingLifetime ( ) { defaultLspWrapper . setLsdbAge ( defaultIsisLsdbAge ) ; defaultLspWrapper . setAgeCounterWhenReceived ( 1 ) ; defaultLspWrapper . currentAge ( ) ; defaultLspWrapper . setRemainingLifetime ( 1 ) ; result1 = defaultLspWrapper . remainingLifetime ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "published ( ) { java . util . List < com . github . pfichtner . ardulink . util . Message > result = new java . util . ArrayList < com . github . pfichtner . ardulink . util . Message > ( published ) ; published . clear ( ) ; return result ; }", "testMethod": "compactLatestWins ( ) { int pin = 11 ; mqttClient . configureAnalogReadChangeListener ( pin ) . compact ( CompactStrategy . LAST_WINS , dummyTimeSlicer ) . add ( ) ; fire ( pin ) ; dummyTimeSlicer . simulateTick ( ) ; com . github . pfichtner . ardulink . util . Message first = mqttMessage . analogPin ( pin ) . hasValue ( 0 ) ; com . github . pfichtner . ardulink . util . Message last = mqttMessage . analogPin ( pin ) . hasValue ( 99 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( published ( ) , org . hamcrest . core . Is . is ( java . util . Arrays . asList ( first , last ) ) )", "total": "compactLatestWins ( ) { int pin = 11 ; mqttClient . configureAnalogReadChangeListener ( pin ) . compact ( CompactStrategy . LAST_WINS , dummyTimeSlicer ) . add ( ) ; fire ( pin ) ; dummyTimeSlicer . simulateTick ( ) ; com . github . pfichtner . ardulink . util . Message first = mqttMessage . analogPin ( pin ) . hasValue ( 0 ) ; com . github . pfichtner . ardulink . util . Message last = mqttMessage . analogPin ( pin ) . hasValue ( 99 ) ; \"<AssertPlaceHolder>\" ; } published ( ) { java . util . List < com . github . pfichtner . ardulink . util . Message > result = new java . util . ArrayList < com . github . pfichtner . ardulink . util . Message > ( published ) ; published . clear ( ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( published ( ) , org . hamcrest . core . Is . is ( java . util . Arrays . asList ( first , last ) ) )"}
{"focal": "store ( ) { if ( ! ( stored ) ) { org . codice . ddf . configuration . admin . ExportMigrationConfigurationAdminEntry . LOGGER . debug ( \"Exporting<sp>configuration<sp>[{}]<sp>to<sp>[{}]...\" , configuration . getPid ( ) , entry . getPath ( ) ) ; final java . util . Dictionary < java . lang . String , java . lang . Object > props = configuration . getProperties ( ) ; final java . lang . String factoryPid = configuration . getFactoryPid ( ) ; if ( factoryPid != null ) { props . put ( ConfigurationAdmin . SERVICE_FACTORYPID , factoryPid ) ; } else { props . remove ( ConfigurationAdmin . SERVICE_FACTORYPID ) ; } props . put ( org . osgi . framework . Constants . SERVICE_PID , configuration . getPid ( ) ) ; final java . lang . String location = configuration . getBundleLocation ( ) ; if ( location != null ) { props . put ( ConfigurationAdmin . SERVICE_BUNDLELOCATION , location ) ; } else { props . remove ( ConfigurationAdmin . SERVICE_BUNDLELOCATION ) ; } this . stored = entry . store ( ( r , out ) -> persister . write ( out , props ) ) ; } return stored ; }", "testMethod": "testStoreWithConsumerThrowingExportIOException ( ) { final org . codice . ddf . util . function . BiThrowingConsumer < org . codice . ddf . migration . MigrationReport , java . io . OutputStream , java . io . IOException > consumer = org . mockito . Mockito . mock ( org . codice . ddf . util . function . BiThrowingConsumer . class ) ; final org . codice . ddf . util . function . BiThrowingConsumer < org . codice . ddf . migration . MigrationReport , java . io . OutputStream , java . io . IOException > consumer2 = org . mockito . Mockito . mock ( org . codice . ddf . util . function . BiThrowingConsumer . class ) ; final java . io . OutputStream mockOutputStream = org . mockito . Mockito . mock ( java . io . OutputStream . class ) ; final java . io . IOException ioe = org . mockito . Mockito . mock ( java . io . IOException . class ) ; final org . codice . ddf . configuration . migration . ExportIOException eioe = new org . codice . ddf . configuration . migration . ExportIOException ( ioe ) ; org . mockito . Mockito . when ( context . getOutputStreamFor ( org . mockito . Mockito . any ( ) ) ) . thenReturn ( mockOutputStream ) ; org . mockito . Mockito . doThrow ( eioe ) . when ( consumer ) . accept ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ; thrown . expect ( org . hamcrest . Matchers . instanceOf ( org . codice . ddf . migration . MigrationException . class ) ) ; thrown . expectCause ( org . hamcrest . Matchers . sameInstance ( ioe ) ) ; try { entry . store ( consumer ) ; } finally { org . mockito . Mockito . verify ( consumer ) . accept ( org . mockito . Mockito . same ( report ) , org . mockito . Mockito . same ( mockOutputStream ) ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( consumer2 , org . mockito . Mockito . never ( ) ) . accept ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ; } }", "assertLine": "org . junit . Assert . assertThat ( entry . store ( ) , org . hamcrest . Matchers . equalTo ( false ) )", "total": "testStoreWithConsumerThrowingExportIOException ( ) { final org . codice . ddf . util . function . BiThrowingConsumer < org . codice . ddf . migration . MigrationReport , java . io . OutputStream , java . io . IOException > consumer = org . mockito . Mockito . mock ( org . codice . ddf . util . function . BiThrowingConsumer . class ) ; final org . codice . ddf . util . function . BiThrowingConsumer < org . codice . ddf . migration . MigrationReport , java . io . OutputStream , java . io . IOException > consumer2 = org . mockito . Mockito . mock ( org . codice . ddf . util . function . BiThrowingConsumer . class ) ; final java . io . OutputStream mockOutputStream = org . mockito . Mockito . mock ( java . io . OutputStream . class ) ; final java . io . IOException ioe = org . mockito . Mockito . mock ( java . io . IOException . class ) ; final org . codice . ddf . configuration . migration . ExportIOException eioe = new org . codice . ddf . configuration . migration . ExportIOException ( ioe ) ; org . mockito . Mockito . when ( context . getOutputStreamFor ( org . mockito . Mockito . any ( ) ) ) . thenReturn ( mockOutputStream ) ; org . mockito . Mockito . doThrow ( eioe ) . when ( consumer ) . accept ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ; thrown . expect ( org . hamcrest . Matchers . instanceOf ( org . codice . ddf . migration . MigrationException . class ) ) ; thrown . expectCause ( org . hamcrest . Matchers . sameInstance ( ioe ) ) ; try { entry . store ( consumer ) ; } finally { org . mockito . Mockito . verify ( consumer ) . accept ( org . mockito . Mockito . same ( report ) , org . mockito . Mockito . same ( mockOutputStream ) ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( consumer2 , org . mockito . Mockito . never ( ) ) . accept ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ; } } store ( ) { if ( ! ( stored ) ) { org . codice . ddf . configuration . admin . ExportMigrationConfigurationAdminEntry . LOGGER . debug ( \"Exporting<sp>configuration<sp>[{}]<sp>to<sp>[{}]...\" , configuration . getPid ( ) , entry . getPath ( ) ) ; final java . util . Dictionary < java . lang . String , java . lang . Object > props = configuration . getProperties ( ) ; final java . lang . String factoryPid = configuration . getFactoryPid ( ) ; if ( factoryPid != null ) { props . put ( ConfigurationAdmin . SERVICE_FACTORYPID , factoryPid ) ; } else { props . remove ( ConfigurationAdmin . SERVICE_FACTORYPID ) ; } props . put ( org . osgi . framework . Constants . SERVICE_PID , configuration . getPid ( ) ) ; final java . lang . String location = configuration . getBundleLocation ( ) ; if ( location != null ) { props . put ( ConfigurationAdmin . SERVICE_BUNDLELOCATION , location ) ; } else { props . remove ( ConfigurationAdmin . SERVICE_BUNDLELOCATION ) ; } this . stored = entry . store ( ( r , out ) -> persister . write ( out , props ) ) ; } return stored ; }", "answer": "org . junit . Assert . assertThat ( entry . store ( ) , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "addDouble ( double ) { data [ endOffset ] = value ; ( endOffset ) ++ ; if ( ( ( endOffset ) == ( data . length ) ) && ( ! ( reachedMax ) ) ) resize ( ) ; if ( ( endOffset ) == ( data . length ) ) { endOffset = 0 ; } if ( ( endOffset ) == ( startOffset ) ) ( startOffset ) ++ ; if ( ( startOffset ) == ( data . length ) ) startOffset = 0 ; }", "testMethod": "add4 ( ) { org . diirt . util . array . CircularBufferDouble coll = new org . diirt . util . array . CircularBufferDouble ( 3 ) ; for ( int i = 0 ; i < 5 ; i ++ ) { coll . addDouble ( i ) ; } org . diirt . util . array . ListDouble reference = new org . diirt . util . array . ArrayDouble ( new double [ ] { 2 , 3 , 4 } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( coll , equalTo ( reference ) )", "total": "add4 ( ) { org . diirt . util . array . CircularBufferDouble coll = new org . diirt . util . array . CircularBufferDouble ( 3 ) ; for ( int i = 0 ; i < 5 ; i ++ ) { coll . addDouble ( i ) ; } org . diirt . util . array . ListDouble reference = new org . diirt . util . array . ArrayDouble ( new double [ ] { 2 , 3 , 4 } ) ; \"<AssertPlaceHolder>\" ; } addDouble ( double ) { data [ endOffset ] = value ; ( endOffset ) ++ ; if ( ( ( endOffset ) == ( data . length ) ) && ( ! ( reachedMax ) ) ) resize ( ) ; if ( ( endOffset ) == ( data . length ) ) { endOffset = 0 ; } if ( ( endOffset ) == ( startOffset ) ) ( startOffset ) ++ ; if ( ( startOffset ) == ( data . length ) ) startOffset = 0 ; }", "answer": "org . junit . Assert . assertThat ( coll , equalTo ( reference ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "parseFileList_empty ( ) { java . util . List < java . io . File > result = canonicalize ( com . asakusafw . windgate . cli . CommandLineUtil . parseFileList ( \"\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , is ( canonicalize ( ) ) )", "total": "parseFileList_empty ( ) { java . util . List < java . io . File > result = canonicalize ( com . asakusafw . windgate . cli . CommandLineUtil . parseFileList ( \"\" ) ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , is ( canonicalize ( ) ) )"}
{"focal": "decrypt ( java . lang . String , byte [ ] ) { if ( value == null ) { return null ; } byte [ ] bytes = cipher ( org . jivesoftware . util . Base64 . decode ( value ) , getKey ( ) , ( iv == null ? org . jivesoftware . util . AesEncryptor . INIT_PARM : iv ) , Cipher . DECRYPT_MODE ) ; if ( bytes == null ) { return null ; } return new java . lang . String ( bytes , java . nio . charset . StandardCharsets . UTF_8 ) ; }", "testMethod": "testEncryptionWithKeyAndIV ( ) { final java . lang . String plainText = java . util . UUID . randomUUID ( ) . toString ( ) ; final byte [ ] iv = \"0123456789abcdef\" . getBytes ( ) ; final org . jivesoftware . util . Encryptor encryptor = new org . jivesoftware . util . AesEncryptor ( java . util . UUID . randomUUID ( ) . toString ( ) ) ; final java . lang . String encryptedText = encryptor . encrypt ( plainText , iv ) ; final java . lang . String decryptedText = encryptor . decrypt ( encryptedText , iv ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( decryptedText , org . hamcrest . Matchers . is ( plainText ) )", "total": "testEncryptionWithKeyAndIV ( ) { final java . lang . String plainText = java . util . UUID . randomUUID ( ) . toString ( ) ; final byte [ ] iv = \"0123456789abcdef\" . getBytes ( ) ; final org . jivesoftware . util . Encryptor encryptor = new org . jivesoftware . util . AesEncryptor ( java . util . UUID . randomUUID ( ) . toString ( ) ) ; final java . lang . String encryptedText = encryptor . encrypt ( plainText , iv ) ; final java . lang . String decryptedText = encryptor . decrypt ( encryptedText , iv ) ; \"<AssertPlaceHolder>\" ; } decrypt ( java . lang . String , byte [ ] ) { if ( value == null ) { return null ; } byte [ ] bytes = cipher ( org . jivesoftware . util . Base64 . decode ( value ) , getKey ( ) , ( iv == null ? org . jivesoftware . util . AesEncryptor . INIT_PARM : iv ) , Cipher . DECRYPT_MODE ) ; if ( bytes == null ) { return null ; } return new java . lang . String ( bytes , java . nio . charset . StandardCharsets . UTF_8 ) ; }", "answer": "org . junit . Assert . assertThat ( decryptedText , org . hamcrest . Matchers . is ( plainText ) )"}
{"focal": "hasPermission ( fr . xephi . authme . listener . JoiningPlayer , fr . xephi . authme . permission . PermissionNode ) { return joiningPlayer . getPermissionLookupFunction ( ) . apply ( this , permissionNode ) ; }", "testMethod": "shouldDenyEvenForOpPlayer ( ) { fr . xephi . authme . permission . PermissionNode node = TestPermissions . WORLD_DOMINATION ; org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; boolean result = permissionsManager . hasPermission ( player , node ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )", "total": "shouldDenyEvenForOpPlayer ( ) { fr . xephi . authme . permission . PermissionNode node = TestPermissions . WORLD_DOMINATION ; org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; boolean result = permissionsManager . hasPermission ( player , node ) ; \"<AssertPlaceHolder>\" ; } hasPermission ( fr . xephi . authme . listener . JoiningPlayer , fr . xephi . authme . permission . PermissionNode ) { return joiningPlayer . getPermissionLookupFunction ( ) . apply ( this , permissionNode ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "getMaxProcesses ( ) { return maxProcesses ; }", "testMethod": "loadFrom_configured ( ) { java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( CoreProfile . KEY_PREFIX ) + ( CoreProfile . KEY_MAX_PROCESSES ) ) , \"10\" ) ; com . asakusafw . windgate . core . CoreProfile profile = com . asakusafw . windgate . core . CoreProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( profile . getMaxProcesses ( ) , is ( 10 ) )", "total": "loadFrom_configured ( ) { java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( CoreProfile . KEY_PREFIX ) + ( CoreProfile . KEY_MAX_PROCESSES ) ) , \"10\" ) ; com . asakusafw . windgate . core . CoreProfile profile = com . asakusafw . windgate . core . CoreProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; \"<AssertPlaceHolder>\" ; } getMaxProcesses ( ) { return maxProcesses ; }", "answer": "org . junit . Assert . assertThat ( profile . getMaxProcesses ( ) , is ( 10 ) )"}
{"focal": "performFragmentation ( byte [ ] , long , int ) { byte [ ] [ ] byteFragments = paxos . fragmentation . FragmentationUtils . performFragmentation ( message , size ) ; paxos . fragmentation . MessageFragment [ ] fragments = new paxos . fragmentation . MessageFragment [ byteFragments . length ] ; for ( int i = 0 ; i < ( fragments . length ) ; i ++ ) { fragments [ i ] = new paxos . fragmentation . MessageFragment ( msgId , byteFragments [ i ] , i , fragments . length ) ; } return fragments ; }", "testMethod": "testFragmentationWithOneFragment ( ) { paxos . fragmentation . MessageFragment [ ] messageFragments = paxos . fragmentation . FragmentationUtils . performFragmentation ( paxos . fragmentation . FragmentationUtilsTest . BYTES , 1 , 100 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( messageFragments . length , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testFragmentationWithOneFragment ( ) { paxos . fragmentation . MessageFragment [ ] messageFragments = paxos . fragmentation . FragmentationUtils . performFragmentation ( paxos . fragmentation . FragmentationUtilsTest . BYTES , 1 , 100 ) ; \"<AssertPlaceHolder>\" ; } performFragmentation ( byte [ ] , long , int ) { byte [ ] [ ] byteFragments = paxos . fragmentation . FragmentationUtils . performFragmentation ( message , size ) ; paxos . fragmentation . MessageFragment [ ] fragments = new paxos . fragmentation . MessageFragment [ byteFragments . length ] ; for ( int i = 0 ; i < ( fragments . length ) ; i ++ ) { fragments [ i ] = new paxos . fragmentation . MessageFragment ( msgId , byteFragments [ i ] , i , fragments . length ) ; } return fragments ; }", "answer": "org . junit . Assert . assertThat ( messageFragments . length , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "setObjectState ( java . lang . String ) { return setProperty ( org . o3project . odenos . remoteobject . ObjectProperty . PropertyNames . OBJECT_STATE , objectState ) ; }", "testMethod": "testIsFinalizeStateFinalizing ( ) { org . o3project . odenos . remoteobject . ObjectProperty prop = ( ( org . o3project . odenos . remoteobject . ObjectProperty ) ( target . getProperty ( ) . clone ( ) ) ) ; prop . setObjectState ( ObjectProperty . State . FINALIZING ) ; boolean result = org . powermock . reflect . Whitebox . invokeMethod ( target , \"isFinalize\" , prop ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testIsFinalizeStateFinalizing ( ) { org . o3project . odenos . remoteobject . ObjectProperty prop = ( ( org . o3project . odenos . remoteobject . ObjectProperty ) ( target . getProperty ( ) . clone ( ) ) ) ; prop . setObjectState ( ObjectProperty . State . FINALIZING ) ; boolean result = org . powermock . reflect . Whitebox . invokeMethod ( target , \"isFinalize\" , prop ) ; \"<AssertPlaceHolder>\" ; } setObjectState ( java . lang . String ) { return setProperty ( org . o3project . odenos . remoteobject . ObjectProperty . PropertyNames . OBJECT_STATE , objectState ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "isPackageLocal ( java . lang . String ) { return ( ( ( methodSignature != null ) && ( ! ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"public\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ) ) && ( ! ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"protected\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ) ) && ( ! ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"private\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ) ; }", "testMethod": "isPackageLocal_A$String_StringIsNull ( ) { java . lang . String methodSignature = null ; boolean actual = org . junithelper . core . util . AccessModifierDetector . isPackageLocal ( methodSignature ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isPackageLocal_A$String_StringIsNull ( ) { java . lang . String methodSignature = null ; boolean actual = org . junithelper . core . util . AccessModifierDetector . isPackageLocal ( methodSignature ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } isPackageLocal ( java . lang . String ) { return ( ( ( methodSignature != null ) && ( ! ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"public\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ) ) && ( ! ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"protected\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ) ) && ( ! ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"private\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "toCollectionLike_A$List_Seq ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs = com . m3 . scalaflavor4j . Seq . apply ( \"foo\" , \"bar\" ) ; com . m3 . scalaflavor4j . Generator < java . lang . String > gen = com . m3 . scalaflavor4j . Generator . apply ( xs ) ; java . util . List < java . lang . String > xs_ = new java . util . ArrayList < java . lang . String > ( ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . String > cl = gen . toCollectionLike ( xs_ ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cl . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "toCollectionLike_A$List_Seq ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs = com . m3 . scalaflavor4j . Seq . apply ( \"foo\" , \"bar\" ) ; com . m3 . scalaflavor4j . Generator < java . lang . String > gen = com . m3 . scalaflavor4j . Generator . apply ( xs ) ; java . util . List < java . lang . String > xs_ = new java . util . ArrayList < java . lang . String > ( ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . String > cl = gen . toCollectionLike ( xs_ ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( cl . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testProcessExportedBundlesAndPopulateTaskListWhenNotFoundInMemory ( ) { final org . codice . ddf . admin . application . service . migratable . JsonBundle jbundle = new org . codice . ddf . admin . application . service . migratable . JsonBundle ( org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . NAME , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . VERSION , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . ID , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . STATE , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . LOCATION ) ; final java . util . Map < java . lang . String , org . osgi . framework . Bundle > bundles = new java . util . HashMap ( ) ; bundles . put ( org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . NAME_VERSION2 , bundle2 ) ; org . mockito . Mockito . doReturn ( java . util . stream . Stream . of ( jbundle ) ) . when ( jprofile ) . bundles ( ) ; org . mockito . Mockito . doNothing ( ) . when ( bundleProcessor ) . processBundleAndPopulateTaskList ( context , jbundle , null , tasks ) ; bundleProcessor . processExportedBundlesAndPopulateTaskList ( context , jprofile , bundles , tasks ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( bundleProcessor ) . processBundleAndPopulateTaskList ( context , jbundle , null , tasks ) ; }", "assertLine": "org . junit . Assert . assertThat ( bundles . size ( ) , org . hamcrest . Matchers . equalTo ( 1 ) )", "total": "testProcessExportedBundlesAndPopulateTaskListWhenNotFoundInMemory ( ) { final org . codice . ddf . admin . application . service . migratable . JsonBundle jbundle = new org . codice . ddf . admin . application . service . migratable . JsonBundle ( org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . NAME , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . VERSION , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . ID , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . STATE , org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . LOCATION ) ; final java . util . Map < java . lang . String , org . osgi . framework . Bundle > bundles = new java . util . HashMap ( ) ; bundles . put ( org . codice . ddf . admin . application . service . migratable . BundleProcessorTest . NAME_VERSION2 , bundle2 ) ; org . mockito . Mockito . doReturn ( java . util . stream . Stream . of ( jbundle ) ) . when ( jprofile ) . bundles ( ) ; org . mockito . Mockito . doNothing ( ) . when ( bundleProcessor ) . processBundleAndPopulateTaskList ( context , jbundle , null , tasks ) ; bundleProcessor . processExportedBundlesAndPopulateTaskList ( context , jprofile , bundles , tasks ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( bundleProcessor ) . processBundleAndPopulateTaskList ( context , jbundle , null , tasks ) ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( bundles . size ( ) , org . hamcrest . Matchers . equalTo ( 1 ) )"}
{"focal": "getValue ( ) { return value ; }", "testMethod": "xpathWithDefaults ( ) { java . lang . Object value = flowRunner ( \"xpathWithDefaults\" ) . withPayload ( getDocumentStream ( ) ) . run ( ) . getMessage ( ) . getPayload ( ) . getValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( \"xpathWithDefaults\" ) )", "total": "xpathWithDefaults ( ) { java . lang . Object value = flowRunner ( \"xpathWithDefaults\" ) . withPayload ( getDocumentStream ( ) ) . run ( ) . getMessage ( ) . getPayload ( ) . getValue ( ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return value ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( \"xpathWithDefaults\" ) )"}
{"focal": "getTaxonCacheService ( ) { final org . eol . globi . taxon . TaxonCacheService cacheService = new org . eol . globi . taxon . TaxonCacheService ( org . eol . globi . taxon . TaxonCacheServiceTest . TAXON_CACHE_TEST_RESOURCE , org . eol . globi . taxon . TaxonCacheServiceTest . TAXON_MAP_TEST_RESOURCE ) ; cacheService . setCacheDir ( mapdbDir ) ; return cacheService ; }", "testMethod": "resolveWithoutDuplicates ( ) { final org . eol . globi . taxon . TaxonCacheService taxonCacheService = getTaxonCacheService ( ) ; java . util . List < org . eol . globi . domain . Taxon > taxa = new java . util . ArrayList ( ) ; taxonCacheService . findTerms ( java . util . Arrays . asList ( new org . eol . globi . domain . TermImpl ( null , \"Felis<sp>catus\" ) ) , new org . eol . globi . taxon . TermMatchListener ( ) { @ org . eol . globi . taxon . Override public void foundTaxonForName ( java . lang . Long nodeId , java . lang . String name , org . eol . globi . domain . Taxon taxon , org . eol . globi . domain . NameType nameType ) { taxa . add ( taxon ) ; } } ) ; \"<AssertPlaceHolder>\" ; taxonCacheService . shutdown ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( taxa . size ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "resolveWithoutDuplicates ( ) { final org . eol . globi . taxon . TaxonCacheService taxonCacheService = getTaxonCacheService ( ) ; java . util . List < org . eol . globi . domain . Taxon > taxa = new java . util . ArrayList ( ) ; taxonCacheService . findTerms ( java . util . Arrays . asList ( new org . eol . globi . domain . TermImpl ( null , \"Felis<sp>catus\" ) ) , new org . eol . globi . taxon . TermMatchListener ( ) { @ org . eol . globi . taxon . Override public void foundTaxonForName ( java . lang . Long nodeId , java . lang . String name , org . eol . globi . domain . Taxon taxon , org . eol . globi . domain . NameType nameType ) { taxa . add ( taxon ) ; } } ) ; \"<AssertPlaceHolder>\" ; taxonCacheService . shutdown ( ) ; } getTaxonCacheService ( ) { final org . eol . globi . taxon . TaxonCacheService cacheService = new org . eol . globi . taxon . TaxonCacheService ( org . eol . globi . taxon . TaxonCacheServiceTest . TAXON_CACHE_TEST_RESOURCE , org . eol . globi . taxon . TaxonCacheServiceTest . TAXON_MAP_TEST_RESOURCE ) ; cacheService . setCacheDir ( mapdbDir ) ; return cacheService ; }", "answer": "org . junit . Assert . assertThat ( taxa . size ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "getPartitionSpecFilter ( ) { com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListener . LOG . info ( \"Creating<sp>partition<sp>spec<sp>from<sp>'{}'<sp>detected<sp>partitions.\" , partitionValues . size ( ) ) ; java . util . List < java . lang . String > filterPartitions = new java . util . ArrayList ( ) ; for ( java . util . List < java . lang . String > values : partitionValues ) { if ( ! ( values . contains ( hiveDefaultPartitionName ) ) ) { filterPartitions . add ( ( ( \"(\" + ( com . google . common . base . Joiner . on ( \"<sp>AND<sp>\" ) . withKeyValueSeparator ( \"=\" ) . join ( quoteValues ( values ) ) ) ) + \")\" ) ) ; } else { com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListener . LOG . warn ( \"Can't<sp>replicate<sp>partition<sp>with<sp>these<sp>values<sp>{},<sp>will<sp>skip<sp>them.\" , values ) ; } } return com . google . common . base . Joiner . on ( \"<sp>OR<sp>\" ) . join ( filterPartitions ) ; }", "testMethod": "ignoreDefaultPartitionValues ( ) { org . apache . hadoop . hive . metastore . api . Partition partition1 = new org . apache . hadoop . hive . metastore . api . Partition ( com . google . common . collect . Lists . newArrayList ( \"__HIVE_DEFAULT_PARTITION__\" , \"val2\" ) , com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListenerTest . DB , com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListenerTest . TABLE , 1 , 1 , null , null ) ; listener . onDiffStart ( source , replica ) ; listener . onNewPartition ( \"p1\" , partition1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( listener . getPartitionSpecFilter ( ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "ignoreDefaultPartitionValues ( ) { org . apache . hadoop . hive . metastore . api . Partition partition1 = new org . apache . hadoop . hive . metastore . api . Partition ( com . google . common . collect . Lists . newArrayList ( \"__HIVE_DEFAULT_PARTITION__\" , \"val2\" ) , com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListenerTest . DB , com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListenerTest . TABLE , 1 , 1 , null , null ) ; listener . onDiffStart ( source , replica ) ; listener . onNewPartition ( \"p1\" , partition1 ) ; \"<AssertPlaceHolder>\" ; } getPartitionSpecFilter ( ) { com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListener . LOG . info ( \"Creating<sp>partition<sp>spec<sp>from<sp>'{}'<sp>detected<sp>partitions.\" , partitionValues . size ( ) ) ; java . util . List < java . lang . String > filterPartitions = new java . util . ArrayList ( ) ; for ( java . util . List < java . lang . String > values : partitionValues ) { if ( ! ( values . contains ( hiveDefaultPartitionName ) ) ) { filterPartitions . add ( ( ( \"(\" + ( com . google . common . base . Joiner . on ( \"<sp>AND<sp>\" ) . withKeyValueSeparator ( \"=\" ) . join ( quoteValues ( values ) ) ) ) + \")\" ) ) ; } else { com . hotels . bdp . circustrain . comparator . listener . PartitionSpecCreatingDiffListener . LOG . warn ( \"Can't<sp>replicate<sp>partition<sp>with<sp>these<sp>values<sp>{},<sp>will<sp>skip<sp>them.\" , values ) ; } } return com . google . common . base . Joiner . on ( \"<sp>OR<sp>\" ) . join ( filterPartitions ) ; }", "answer": "org . junit . Assert . assertThat ( listener . getPartitionSpecFilter ( ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "close ( ) { delegate . close ( ) ; }", "testMethod": "bucketing ( ) { java . io . File in = tmp . newFolder ( \"in\" ) ; org . apache . hadoop . mapred . Counters expectedCounters = new org . apache . hadoop . mapred . Counters ( ) ; java . util . List < java . lang . String > expectedBucketFiles = new java . util . ArrayList < java . lang . String > ( ) ; org . apache . hadoop . mapred . Counters actualCounters = new org . apache . hadoop . mapred . Counters ( ) ; java . io . DataInputStream countersStream = org . apache . hadoop . fs . FileSystem . get ( job ) . open ( crush . getCounters ( ) ) ; actualCounters . readFields ( countersStream ) ; countersStream . close ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualCounters , org . hamcrest . Matchers . equalTo ( expectedCounters ) )", "total": "bucketing ( ) { java . io . File in = tmp . newFolder ( \"in\" ) ; org . apache . hadoop . mapred . Counters expectedCounters = new org . apache . hadoop . mapred . Counters ( ) ; java . util . List < java . lang . String > expectedBucketFiles = new java . util . ArrayList < java . lang . String > ( ) ; org . apache . hadoop . mapred . Counters actualCounters = new org . apache . hadoop . mapred . Counters ( ) ; java . io . DataInputStream countersStream = org . apache . hadoop . fs . FileSystem . get ( job ) . open ( crush . getCounters ( ) ) ; actualCounters . readFields ( countersStream ) ; countersStream . close ( ) ; \"<AssertPlaceHolder>\" ; } close ( ) { delegate . close ( ) ; }", "answer": "org . junit . Assert . assertThat ( actualCounters , org . hamcrest . Matchers . equalTo ( expectedCounters ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . GridMigrationFinishedEvent event = new com . github . seratch . jslack . api . model . event . GridMigrationFinishedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"grid_migration_finished\\\"}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . GridMigrationFinishedEvent event = new com . github . seratch . jslack . api . model . event . GridMigrationFinishedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"grid_migration_finished\\\"}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "size ( ) { return this . cells . size ( ) ; }", "testMethod": "generatesCarbon13 ( ) { org . openscience . cdk . interfaces . IAtomContainer container = mock ( org . openscience . cdk . interfaces . IAtomContainer . class ) ; org . openscience . cdk . interfaces . IAtom atom = mock ( org . openscience . cdk . interfaces . IAtom . class ) ; when ( atom . getAtomicNumber ( ) ) . thenReturn ( 6 ) ; when ( atom . getMassNumber ( ) ) . thenReturn ( 13 ) ; when ( atom . getImplicitHydrogenCount ( ) ) . thenReturn ( 0 ) ; when ( atom . getFormalCharge ( ) ) . thenReturn ( 0 ) ; org . openscience . cdk . renderer . RendererModel model = new org . openscience . cdk . renderer . RendererModel ( ) ; model . registerParameters ( new org . openscience . cdk . renderer . generators . standard . StandardGenerator ( new java . awt . Font ( java . awt . Font . SANS_SERIF , java . awt . Font . PLAIN , 12 ) ) ) ; org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generateSymbol ( container , atom , HydrogenPosition . Left , model ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "generatesCarbon13 ( ) { org . openscience . cdk . interfaces . IAtomContainer container = mock ( org . openscience . cdk . interfaces . IAtomContainer . class ) ; org . openscience . cdk . interfaces . IAtom atom = mock ( org . openscience . cdk . interfaces . IAtom . class ) ; when ( atom . getAtomicNumber ( ) ) . thenReturn ( 6 ) ; when ( atom . getMassNumber ( ) ) . thenReturn ( 13 ) ; when ( atom . getImplicitHydrogenCount ( ) ) . thenReturn ( 0 ) ; when ( atom . getFormalCharge ( ) ) . thenReturn ( 0 ) ; org . openscience . cdk . renderer . RendererModel model = new org . openscience . cdk . renderer . RendererModel ( ) ; model . registerParameters ( new org . openscience . cdk . renderer . generators . standard . StandardGenerator ( new java . awt . Font ( java . awt . Font . SANS_SERIF , java . awt . Font . PLAIN , 12 ) ) ) ; org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generateSymbol ( container , atom , HydrogenPosition . Left , model ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . cells . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "canWrite ( org . springframework . expression . EvaluationContext , java . lang . Object , java . lang . String ) { return false ; }", "testMethod": "doesNotSupportWrites ( ) { \"<AssertPlaceHolder>\" ; PdxReaderPropertyAccessor . INSTANCE . write ( null , null , null , reader ) ; }", "assertLine": "org . junit . Assert . assertThat ( PdxReaderPropertyAccessor . INSTANCE . canWrite ( null , null , null ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "doesNotSupportWrites ( ) { \"<AssertPlaceHolder>\" ; PdxReaderPropertyAccessor . INSTANCE . write ( null , null , null , reader ) ; } canWrite ( org . springframework . expression . EvaluationContext , java . lang . Object , java . lang . String ) { return false ; }", "answer": "org . junit . Assert . assertThat ( PdxReaderPropertyAccessor . INSTANCE . canWrite ( null , null , null ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "clone ( ) { return this ; }", "testMethod": "testClone ( ) { org . slim3 . util . ArraySet < java . lang . String > newSet = ( ( org . slim3 . util . ArraySet < java . lang . String > ) ( set . clone ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( newSet , org . hamcrest . CoreMatchers . is ( set ) )", "total": "testClone ( ) { org . slim3 . util . ArraySet < java . lang . String > newSet = ( ( org . slim3 . util . ArraySet < java . lang . String > ) ( set . clone ( ) ) ) ; \"<AssertPlaceHolder>\" ; } clone ( ) { return this ; }", "answer": "org . junit . Assert . assertThat ( newSet , org . hamcrest . CoreMatchers . is ( set ) )"}
{"focal": "count ( ) { throw new java . lang . UnsupportedOperationException ( ) ; }", "testMethod": "testInsertMap ( ) { int before = count ( ) ; egov . data . ibatis . sample . annotation . Map < java . lang . String , java . lang . String > map = new egov . data . ibatis . sample . annotation . HashMap < java . lang . String , java . lang . String > ( ) ; map . put ( \"name\" , \"test\" ) ; repository . saveMap ( map ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count ( ) , org . hamcrest . CoreMatchers . is ( ( before + 1 ) ) )", "total": "testInsertMap ( ) { int before = count ( ) ; egov . data . ibatis . sample . annotation . Map < java . lang . String , java . lang . String > map = new egov . data . ibatis . sample . annotation . HashMap < java . lang . String , java . lang . String > ( ) ; map . put ( \"name\" , \"test\" ) ; repository . saveMap ( map ) ; \"<AssertPlaceHolder>\" ; } count ( ) { throw new java . lang . UnsupportedOperationException ( ) ; }", "answer": "org . junit . Assert . assertThat ( count ( ) , org . hamcrest . CoreMatchers . is ( ( before + 1 ) ) )"}
{"focal": "systemCodecID ( ) { return - 1 ; }", "testMethod": "id ( ) { byte b = uut . systemCodecID ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( b , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( ( ( byte ) ( - 1 ) ) ) ) )", "total": "id ( ) { byte b = uut . systemCodecID ( ) ; \"<AssertPlaceHolder>\" ; } systemCodecID ( ) { return - 1 ; }", "answer": "org . junit . Assert . assertThat ( b , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( ( ( byte ) ( - 1 ) ) ) ) )"}
{"focal": "count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "testMethod": "deleteHistoricDecisionInstanceWithDisabledTenantCheck ( ) { testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . DMN ) ; testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_TWO , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . DMN ) ; java . lang . String decisionDefinitionIdOne = evaluateDecisionTable ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE ) ; java . lang . String decisionDefinitionIdTwo = evaluateDecisionTable ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_TWO ) ; identityService . setAuthentication ( \"user\" , null , null ) ; processEngineConfiguration . setTenantCheckEnabled ( false ) ; historyService . deleteHistoricDecisionInstanceByDefinitionId ( decisionDefinitionIdOne ) ; historyService . deleteHistoricDecisionInstanceByDefinitionId ( decisionDefinitionIdTwo ) ; org . camunda . bpm . engine . history . HistoricDecisionInstanceQuery query = historyService . createHistoricDecisionInstanceQuery ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "deleteHistoricDecisionInstanceWithDisabledTenantCheck ( ) { testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . DMN ) ; testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_TWO , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . DMN ) ; java . lang . String decisionDefinitionIdOne = evaluateDecisionTable ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_ONE ) ; java . lang . String decisionDefinitionIdTwo = evaluateDecisionTable ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricDataCmdsTenantCheckTest . TENANT_TWO ) ; identityService . setAuthentication ( \"user\" , null , null ) ; processEngineConfiguration . setTenantCheckEnabled ( false ) ; historyService . deleteHistoricDecisionInstanceByDefinitionId ( decisionDefinitionIdOne ) ; historyService . deleteHistoricDecisionInstanceByDefinitionId ( decisionDefinitionIdTwo ) ; org . camunda . bpm . engine . history . HistoricDecisionInstanceQuery query = historyService . createHistoricDecisionInstanceQuery ( ) ; \"<AssertPlaceHolder>\" ; } count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "getTokenString ( ) { return ( ( ( ( tokenName ) + ( org . terasoluna . gfw . web . token . transaction . TransactionToken . TOKEN_STRING_SEPARATOR ) ) + ( tokenKey ) ) + ( org . terasoluna . gfw . web . token . transaction . TransactionToken . TOKEN_STRING_SEPARATOR ) ) + ( tokenValue ) ; }", "testMethod": "testGetExtraHiddenFields02 ( ) { org . terasoluna . gfw . web . token . transaction . TransactionTokenRequestDataValueProcessor processor = new org . terasoluna . gfw . web . token . transaction . TransactionTokenRequestDataValueProcessor ( ) ; javax . servlet . http . HttpServletRequest request = mock ( javax . servlet . http . HttpServletRequest . class ) ; org . terasoluna . gfw . web . token . transaction . TransactionToken token = new org . terasoluna . gfw . web . token . transaction . TransactionToken ( \"tokenName\" , \"tokenkey\" , \"tokenValue\" ) ; when ( ( ( org . terasoluna . gfw . web . token . transaction . TransactionToken ) ( request . getAttribute ( TransactionTokenInterceptor . NEXT_TOKEN_REQUEST_ATTRIBUTE_NAME ) ) ) ) . thenReturn ( token ) ; java . util . Map < java . lang . String , java . lang . String > result = processor . getExtraHiddenFields ( request ) ; java . util . Map < java . lang . String , java . lang . String > expected = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; expected . put ( \"_TRANSACTION_TOKEN\" , token . getTokenString ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testGetExtraHiddenFields02 ( ) { org . terasoluna . gfw . web . token . transaction . TransactionTokenRequestDataValueProcessor processor = new org . terasoluna . gfw . web . token . transaction . TransactionTokenRequestDataValueProcessor ( ) ; javax . servlet . http . HttpServletRequest request = mock ( javax . servlet . http . HttpServletRequest . class ) ; org . terasoluna . gfw . web . token . transaction . TransactionToken token = new org . terasoluna . gfw . web . token . transaction . TransactionToken ( \"tokenName\" , \"tokenkey\" , \"tokenValue\" ) ; when ( ( ( org . terasoluna . gfw . web . token . transaction . TransactionToken ) ( request . getAttribute ( TransactionTokenInterceptor . NEXT_TOKEN_REQUEST_ATTRIBUTE_NAME ) ) ) ) . thenReturn ( token ) ; java . util . Map < java . lang . String , java . lang . String > result = processor . getExtraHiddenFields ( request ) ; java . util . Map < java . lang . String , java . lang . String > expected = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; expected . put ( \"_TRANSACTION_TOKEN\" , token . getTokenString ( ) ) ; \"<AssertPlaceHolder>\" ; } getTokenString ( ) { return ( ( ( ( tokenName ) + ( org . terasoluna . gfw . web . token . transaction . TransactionToken . TOKEN_STRING_SEPARATOR ) ) + ( tokenKey ) ) + ( org . terasoluna . gfw . web . token . transaction . TransactionToken . TOKEN_STRING_SEPARATOR ) ) + ( tokenValue ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "itUsesTheSpecifiedName ( ) { final com . wesabe . xmlson . XmlsonObject representation = presenter . present ( \"amount\" , amount , Locale . GERMANY ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( representation . getName ( ) , org . hamcrest . CoreMatchers . is ( \"amount\" ) )", "total": "itUsesTheSpecifiedName ( ) { final com . wesabe . xmlson . XmlsonObject representation = presenter . present ( \"amount\" , amount , Locale . GERMANY ) ; \"<AssertPlaceHolder>\" ; } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( representation . getName ( ) , org . hamcrest . CoreMatchers . is ( \"amount\" ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "setup_help ( ) { java . nio . file . Path java = com . asakusafw . integration . core . SetupToolsTest . java ( ) ; com . asakusafw . integration . AsakusaProject project = provider . newInstance ( \"tls\" ) ; project . gradle ( \"installAsakusafw\" ) ; int exit = project . getCommandLauncher ( ) . launch ( java , \"-jar\" , project . getFramework ( ) . get ( com . asakusafw . integration . core . SetupToolsTest . SETUP_JAR ) . toAbsolutePath ( ) . toString ( ) , \"--help\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( exit , is ( 0 ) )", "total": "setup_help ( ) { java . nio . file . Path java = com . asakusafw . integration . core . SetupToolsTest . java ( ) ; com . asakusafw . integration . AsakusaProject project = provider . newInstance ( \"tls\" ) ; project . gradle ( \"installAsakusafw\" ) ; int exit = project . getCommandLauncher ( ) . launch ( java , \"-jar\" , project . getFramework ( ) . get ( com . asakusafw . integration . core . SetupToolsTest . SETUP_JAR ) . toAbsolutePath ( ) . toString ( ) , \"--help\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( exit , is ( 0 ) )"}
{"focal": "isOpen ( ) { return ( ( transport ) != null ) && ( transport . isOpen ( ) ) ; }", "testMethod": "isOpenWithReconnection ( ) { when ( base . isOpen ( ) ) . thenReturn ( false ) . thenReturn ( true ) ; com . hotels . bdp . waggledance . client . CloseableThriftHiveMetastoreIface iface = factory . newInstance ( \"name\" , com . hotels . bdp . waggledance . client . DefaultMetaStoreClientFactoryTest . RECONNECTION_RETRIES , base ) ; boolean result = iface . isOpen ( ) ; \"<AssertPlaceHolder>\" ; verify ( base ) . reconnect ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )", "total": "isOpenWithReconnection ( ) { when ( base . isOpen ( ) ) . thenReturn ( false ) . thenReturn ( true ) ; com . hotels . bdp . waggledance . client . CloseableThriftHiveMetastoreIface iface = factory . newInstance ( \"name\" , com . hotels . bdp . waggledance . client . DefaultMetaStoreClientFactoryTest . RECONNECTION_RETRIES , base ) ; boolean result = iface . isOpen ( ) ; \"<AssertPlaceHolder>\" ; verify ( base ) . reconnect ( ) ; } isOpen ( ) { return ( ( transport ) != null ) && ( transport . isOpen ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getStartSchedule ( ) { return startSchedule ; }", "testMethod": "setStartSchedule_calendarNow_startScheduleIsSet ( ) { java . util . Calendar now = java . util . Calendar . getInstance ( ) ; chargingSchedule . setStartSchedule ( now ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chargingSchedule . getStartSchedule ( ) , org . hamcrest . CoreMatchers . equalTo ( now ) )", "total": "setStartSchedule_calendarNow_startScheduleIsSet ( ) { java . util . Calendar now = java . util . Calendar . getInstance ( ) ; chargingSchedule . setStartSchedule ( now ) ; \"<AssertPlaceHolder>\" ; } getStartSchedule ( ) { return startSchedule ; }", "answer": "org . junit . Assert . assertThat ( chargingSchedule . getStartSchedule ( ) , org . hamcrest . CoreMatchers . equalTo ( now ) )"}
{"focal": "restore ( org . codice . ddf . util . function . BiThrowingConsumer ) { org . apache . commons . lang . Validate . notNull ( consumer , \"invalid<sp>null<sp>consumer\" ) ; if ( ( restored ) == null ) { this . restored = false ; java . util . Optional < java . io . InputStream > is = java . util . Optional . empty ( ) ; try { is = getInputStream ( true ) ; final java . util . Optional < java . io . InputStream > fis = is ; this . restored = getReport ( ) . wasIOSuccessful ( ( ) -> consumer . accept ( getReport ( ) , fis ) ) ; } catch ( java . io . IOException e ) { getReport ( ) . record ( new org . codice . ddf . migration . MigrationException ( Messages . IMPORT_PATH_COPY_ERROR , path , context . getPathUtils ( ) . getDDFHome ( ) , e ) ) ; } finally { is . ifPresent ( org . apache . commons . io . IOUtils :: closeQuietly ) ; } } return restored ; }", "testMethod": "restoreFailsWhenFileIsNotSoftLink ( ) { entry = new org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImpl ( mockContext , com . google . common . collect . ImmutableMap . of ( MigrationEntryImpl . METADATA_NAME , org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImplTest . ENTRY_NAME , MigrationEntryImpl . METADATA_SOFTLINK , true ) ) ; \"<AssertPlaceHolder>\" ; verify ( mockPathUtils , never ( ) ) . getChecksumFor ( any ( java . nio . file . Path . class ) ) ; verifyReportHasMatchingWarning ( report , \"not<sp>a<sp>symbolic<sp>link\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( entry . restore ( true ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "restoreFailsWhenFileIsNotSoftLink ( ) { entry = new org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImpl ( mockContext , com . google . common . collect . ImmutableMap . of ( MigrationEntryImpl . METADATA_NAME , org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImplTest . ENTRY_NAME , MigrationEntryImpl . METADATA_SOFTLINK , true ) ) ; \"<AssertPlaceHolder>\" ; verify ( mockPathUtils , never ( ) ) . getChecksumFor ( any ( java . nio . file . Path . class ) ) ; verifyReportHasMatchingWarning ( report , \"not<sp>a<sp>symbolic<sp>link\" ) ; } restore ( org . codice . ddf . util . function . BiThrowingConsumer ) { org . apache . commons . lang . Validate . notNull ( consumer , \"invalid<sp>null<sp>consumer\" ) ; if ( ( restored ) == null ) { this . restored = false ; java . util . Optional < java . io . InputStream > is = java . util . Optional . empty ( ) ; try { is = getInputStream ( true ) ; final java . util . Optional < java . io . InputStream > fis = is ; this . restored = getReport ( ) . wasIOSuccessful ( ( ) -> consumer . accept ( getReport ( ) , fis ) ) ; } catch ( java . io . IOException e ) { getReport ( ) . record ( new org . codice . ddf . migration . MigrationException ( Messages . IMPORT_PATH_COPY_ERROR , path , context . getPathUtils ( ) . getDDFHome ( ) , e ) ) ; } finally { is . ifPresent ( org . apache . commons . io . IOUtils :: closeQuietly ) ; } } return restored ; }", "answer": "org . junit . Assert . assertThat ( entry . restore ( true ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "getChild ( int ) { return children [ index ] ; }", "testMethod": "cannotModifyChildrenThroughArrayArgumentToConstructor ( ) { com . metservice . kanban . model . TreeNode < java . lang . String > originalChild = com . metservice . kanban . model . TreeNode . create ( java . lang . String . class , \"child<sp>0\" ) ; @ com . metservice . kanban . model . SuppressWarnings ( \"unchecked\" ) com . metservice . kanban . model . TreeNode < java . lang . String > [ ] children = new com . metservice . kanban . model . TreeNode [ ] { originalChild } ; com . metservice . kanban . model . TreeNode < java . lang . String > parent = com . metservice . kanban . model . TreeNode . create ( java . lang . String . class , \"parent\" , children ) ; children [ 0 ] = com . metservice . kanban . model . TreeNode . create ( java . lang . String . class , \"new<sp>child\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( parent . getChild ( 0 ) , org . hamcrest . core . Is . is ( originalChild ) )", "total": "cannotModifyChildrenThroughArrayArgumentToConstructor ( ) { com . metservice . kanban . model . TreeNode < java . lang . String > originalChild = com . metservice . kanban . model . TreeNode . create ( java . lang . String . class , \"child<sp>0\" ) ; @ com . metservice . kanban . model . SuppressWarnings ( \"unchecked\" ) com . metservice . kanban . model . TreeNode < java . lang . String > [ ] children = new com . metservice . kanban . model . TreeNode [ ] { originalChild } ; com . metservice . kanban . model . TreeNode < java . lang . String > parent = com . metservice . kanban . model . TreeNode . create ( java . lang . String . class , \"parent\" , children ) ; children [ 0 ] = com . metservice . kanban . model . TreeNode . create ( java . lang . String . class , \"new<sp>child\" ) ; \"<AssertPlaceHolder>\" ; } getChild ( int ) { return children [ index ] ; }", "answer": "org . junit . Assert . assertThat ( parent . getChild ( 0 ) , org . hamcrest . core . Is . is ( originalChild ) )"}
{"focal": "getId ( ) { return this . id ; }", "testMethod": "whenAddItemInBDThatWeMayGetFrom ( ) { ru . szhernovoy . model . Tracker myTrack = new ru . szhernovoy . model . Tracker ( ) ; myTrack . connect ( ) ; ru . szhernovoy . model . Item item = new ru . szhernovoy . model . Item ( \"first\" , \"opis\" , java . lang . System . currentTimeMillis ( ) ) ; java . lang . String beforeId = item . getId ( ) ; myTrack . addItem ( item ) ; java . lang . String Resultid = item . getId ( ) ; \"<AssertPlaceHolder>\" ; if ( ! ( myTrack . close ( ) ) ) { throw new java . lang . UnknownError ( \"connector<sp>in<sp>SQL<sp>base<sp>not<sp>close\" ) ; } }", "assertLine": "org . junit . Assert . assertThat ( Resultid , org . hamcrest . core . Is . is ( \"1\" ) )", "total": "whenAddItemInBDThatWeMayGetFrom ( ) { ru . szhernovoy . model . Tracker myTrack = new ru . szhernovoy . model . Tracker ( ) ; myTrack . connect ( ) ; ru . szhernovoy . model . Item item = new ru . szhernovoy . model . Item ( \"first\" , \"opis\" , java . lang . System . currentTimeMillis ( ) ) ; java . lang . String beforeId = item . getId ( ) ; myTrack . addItem ( item ) ; java . lang . String Resultid = item . getId ( ) ; \"<AssertPlaceHolder>\" ; if ( ! ( myTrack . close ( ) ) ) { throw new java . lang . UnknownError ( \"connector<sp>in<sp>SQL<sp>base<sp>not<sp>close\" ) ; } } getId ( ) { return this . id ; }", "answer": "org . junit . Assert . assertThat ( Resultid , org . hamcrest . core . Is . is ( \"1\" ) )"}
{"focal": "getEnd ( ) { return end ; }", "testMethod": "shouldAllowSettingEnd ( ) { emptySession . setEnd ( date ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( emptySession . getEnd ( ) , org . hamcrest . CoreMatchers . equalTo ( date ) )", "total": "shouldAllowSettingEnd ( ) { emptySession . setEnd ( date ) ; \"<AssertPlaceHolder>\" ; } getEnd ( ) { return end ; }", "answer": "org . junit . Assert . assertThat ( emptySession . getEnd ( ) , org . hamcrest . CoreMatchers . equalTo ( date ) )"}
{"focal": "difference ( org . onosproject . store . resource . impl . DiscreteResources ) { if ( other instanceof org . onosproject . store . resource . impl . GenericDiscreteResources ) { return org . onosproject . store . resource . impl . GenericDiscreteResources . of ( new java . util . LinkedHashSet ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ) ; } else if ( other instanceof org . onosproject . store . resource . impl . EmptyDiscreteResources ) { return this ; } return org . onosproject . store . resource . impl . DiscreteResources . of ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ; }", "testMethod": "testIfDifferenceIsNotEmpty ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . net . resource . DiscreteResource res2 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"b\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 , res2 ) ) ; org . onosproject . store . resource . impl . DiscreteResources other = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; org . onosproject . store . resource . impl . DiscreteResources expected = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sut . difference ( other ) , org . hamcrest . Matchers . is ( expected ) )", "total": "testIfDifferenceIsNotEmpty ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . net . resource . DiscreteResource res2 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"b\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 , res2 ) ) ; org . onosproject . store . resource . impl . DiscreteResources other = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; org . onosproject . store . resource . impl . DiscreteResources expected = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res2 ) ) ; \"<AssertPlaceHolder>\" ; } difference ( org . onosproject . store . resource . impl . DiscreteResources ) { if ( other instanceof org . onosproject . store . resource . impl . GenericDiscreteResources ) { return org . onosproject . store . resource . impl . GenericDiscreteResources . of ( new java . util . LinkedHashSet ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ) ; } else if ( other instanceof org . onosproject . store . resource . impl . EmptyDiscreteResources ) { return this ; } return org . onosproject . store . resource . impl . DiscreteResources . of ( com . google . common . collect . Sets . difference ( this . values ( ) , other . values ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( sut . difference ( other ) , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "supports ( org . apache . poi . ss . usermodel . Sheet ) { if ( sheet == null ) { throw new java . lang . IllegalArgumentException ( \"sheet<sp>must<sp>not<sp>be<sp>null\" ) ; } com . asakusafw . testdriver . excel . RuleSheetFormat item = RuleSheetFormat . FORMAT ; java . lang . String title = com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor . getStringCell ( sheet , item . getRowIndex ( ) , item . getColumnIndex ( ) ) ; if ( ( title . equals ( item . getTitle ( ) ) ) == false ) { return false ; } java . lang . String format = com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor . getStringCell ( sheet , item . getRowIndex ( ) , ( ( item . getColumnIndex ( ) ) + 1 ) ) ; return com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor . SUPPORTED_FORMATS . contains ( format ) ; }", "testMethod": "supports ( ) { com . asakusafw . testdriver . excel . ExcelRuleExtractor extractor = new com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor ( ) ; org . apache . poi . ss . usermodel . Sheet sheet = sheet ( \"simple.xls\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( extractor . supports ( sheet ) , is ( true ) )", "total": "supports ( ) { com . asakusafw . testdriver . excel . ExcelRuleExtractor extractor = new com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor ( ) ; org . apache . poi . ss . usermodel . Sheet sheet = sheet ( \"simple.xls\" ) ; \"<AssertPlaceHolder>\" ; } supports ( org . apache . poi . ss . usermodel . Sheet ) { if ( sheet == null ) { throw new java . lang . IllegalArgumentException ( \"sheet<sp>must<sp>not<sp>be<sp>null\" ) ; } com . asakusafw . testdriver . excel . RuleSheetFormat item = RuleSheetFormat . FORMAT ; java . lang . String title = com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor . getStringCell ( sheet , item . getRowIndex ( ) , item . getColumnIndex ( ) ) ; if ( ( title . equals ( item . getTitle ( ) ) ) == false ) { return false ; } java . lang . String format = com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor . getStringCell ( sheet , item . getRowIndex ( ) , ( ( item . getColumnIndex ( ) ) + 1 ) ) ; return com . asakusafw . testdriver . excel . DefaultExcelRuleExtractor . SUPPORTED_FORMATS . contains ( format ) ; }", "answer": "org . junit . Assert . assertThat ( extractor . supports ( sheet ) , is ( true ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "testAdd ( ) { com . baidu . beidou . sample . annotation . vo . Department department101 = new com . baidu . beidou . sample . annotation . vo . Department ( 111 , \"Phone\" ) ; com . baidu . beidou . sample . annotation . vo . Department department102 = new com . baidu . beidou . sample . annotation . vo . Department ( 222 , \"Visio<sp>Studio\" ) ; java . util . List < com . baidu . beidou . sample . annotation . vo . Department > departmentList1 = new java . util . ArrayList < com . baidu . beidou . sample . annotation . vo . Department > ( ) ; departmentList1 . add ( department101 ) ; departmentList1 . add ( department102 ) ; com . baidu . beidou . sample . annotation . vo . Company company = new com . baidu . beidou . sample . annotation . vo . Company ( 114 , \"Mircosoft\" , new java . util . Date ( ) , departmentList1 ) ; try { com . baidu . beidou . sample . annotation . vo . Company result = companyMgr . add ( company ) ; System . out . println ( result ) ; \"<AssertPlaceHolder>\" ; } catch ( com . baidu . beidou . sample . annotation . exception . IdDuplicateException e ) { System . out . println ( \"got<sp>id<sp>dup<sp>exception<sp>here!!!!\" ) ; e . printStackTrace ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( result . getName ( ) , org . hamcrest . Matchers . is ( \"Mircosoft\" ) )", "total": "testAdd ( ) { com . baidu . beidou . sample . annotation . vo . Department department101 = new com . baidu . beidou . sample . annotation . vo . Department ( 111 , \"Phone\" ) ; com . baidu . beidou . sample . annotation . vo . Department department102 = new com . baidu . beidou . sample . annotation . vo . Department ( 222 , \"Visio<sp>Studio\" ) ; java . util . List < com . baidu . beidou . sample . annotation . vo . Department > departmentList1 = new java . util . ArrayList < com . baidu . beidou . sample . annotation . vo . Department > ( ) ; departmentList1 . add ( department101 ) ; departmentList1 . add ( department102 ) ; com . baidu . beidou . sample . annotation . vo . Company company = new com . baidu . beidou . sample . annotation . vo . Company ( 114 , \"Mircosoft\" , new java . util . Date ( ) , departmentList1 ) ; try { com . baidu . beidou . sample . annotation . vo . Company result = companyMgr . add ( company ) ; System . out . println ( result ) ; \"<AssertPlaceHolder>\" ; } catch ( com . baidu . beidou . sample . annotation . exception . IdDuplicateException e ) { System . out . println ( \"got<sp>id<sp>dup<sp>exception<sp>here!!!!\" ) ; e . printStackTrace ( ) ; } } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( result . getName ( ) , org . hamcrest . Matchers . is ( \"Mircosoft\" ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "dropWhile_A$Function1 ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . String > actual = nil . dropWhile ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . String v1 ) { return v1 . equals ( \"foo\" ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "dropWhile_A$Function1 ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . String > actual = nil . dropWhile ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . Boolean > ( ) { public com . m3 . scalaflavor4j . Boolean apply ( java . lang . String v1 ) { return v1 . equals ( \"foo\" ) ; } } ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getConnection ( ) { if ( isRedisClusterAware ( ) ) { return getClusterConnection ( ) ; } redis . clients . jedis . Jedis jedis = fetchJedisConnector ( ) ; java . lang . String clientName = clientConfiguration . getClientName ( ) . orElse ( null ) ; org . springframework . data . redis . connection . jedis . JedisConnection connection = ( getUsePool ( ) ) ? new org . springframework . data . redis . connection . jedis . JedisConnection ( jedis , pool , getDatabase ( ) , clientName ) : new org . springframework . data . redis . connection . jedis . JedisConnection ( jedis , null , getDatabase ( ) , clientName ) ; connection . setConvertPipelineAndTxResults ( convertPipelineAndTxResults ) ; return postProcessConnection ( connection ) ; }", "testMethod": "getClientNameShouldEqualWithFactorySetting ( ) { factory = new org . springframework . data . redis . connection . jedis . JedisConnectionFactory ( org . springframework . data . redis . connection . jedis . JedisConnectionFactorySentinelIntegrationTests . SENTINEL_CONFIG ) ; factory . setClientName ( \"clientName\" ) ; factory . afterPropertiesSet ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( factory . getConnection ( ) . getClientName ( ) , equalTo ( \"clientName\" ) )", "total": "getClientNameShouldEqualWithFactorySetting ( ) { factory = new org . springframework . data . redis . connection . jedis . JedisConnectionFactory ( org . springframework . data . redis . connection . jedis . JedisConnectionFactorySentinelIntegrationTests . SENTINEL_CONFIG ) ; factory . setClientName ( \"clientName\" ) ; factory . afterPropertiesSet ( ) ; \"<AssertPlaceHolder>\" ; } getConnection ( ) { if ( isRedisClusterAware ( ) ) { return getClusterConnection ( ) ; } redis . clients . jedis . Jedis jedis = fetchJedisConnector ( ) ; java . lang . String clientName = clientConfiguration . getClientName ( ) . orElse ( null ) ; org . springframework . data . redis . connection . jedis . JedisConnection connection = ( getUsePool ( ) ) ? new org . springframework . data . redis . connection . jedis . JedisConnection ( jedis , pool , getDatabase ( ) , clientName ) : new org . springframework . data . redis . connection . jedis . JedisConnection ( jedis , null , getDatabase ( ) , clientName ) ; connection . setConvertPipelineAndTxResults ( convertPipelineAndTxResults ) ; return postProcessConnection ( connection ) ; }", "answer": "org . junit . Assert . assertThat ( factory . getConnection ( ) . getClientName ( ) , equalTo ( \"clientName\" ) )"}
{"focal": "sortPostOrder ( com . asakusafw . utils . graph . Graph ) { if ( graph == null ) { throw new java . lang . IllegalArgumentException ( \"graph<sp>must<sp>not<sp>be<sp>null\" ) ; } java . util . List < ? extends V > postorder = com . asakusafw . utils . graph . Graphs . computePostOrderByDepth ( graph ) ; return new java . util . ArrayList ( postorder ) ; }", "testMethod": "testSortPostOrder_List ( ) { com . asakusafw . utils . graph . Graph < java . lang . Integer > graph = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . addPath ( graph , 1 , 2 , 3 , 4 , 5 ) ; java . util . List < java . lang . Integer > sorted = com . asakusafw . utils . graph . Graphs . sortPostOrder ( graph ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sorted , is ( java . util . Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) )", "total": "testSortPostOrder_List ( ) { com . asakusafw . utils . graph . Graph < java . lang . Integer > graph = com . asakusafw . utils . graph . Graphs . newInstance ( ) ; com . asakusafw . utils . graph . GraphsTest . addPath ( graph , 1 , 2 , 3 , 4 , 5 ) ; java . util . List < java . lang . Integer > sorted = com . asakusafw . utils . graph . Graphs . sortPostOrder ( graph ) ; \"<AssertPlaceHolder>\" ; } sortPostOrder ( com . asakusafw . utils . graph . Graph ) { if ( graph == null ) { throw new java . lang . IllegalArgumentException ( \"graph<sp>must<sp>not<sp>be<sp>null\" ) ; } java . util . List < ? extends V > postorder = com . asakusafw . utils . graph . Graphs . computePostOrderByDepth ( graph ) ; return new java . util . ArrayList ( postorder ) ; }", "answer": "org . junit . Assert . assertThat ( sorted , is ( java . util . Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) )"}
{"focal": "getValue ( ) { return value ; }", "testMethod": "xpathWithDefaultNode ( ) { java . io . InputStream stream = getDocumentStream ( ) ; org . mule . runtime . core . api . streaming . bytes . InMemoryCursorStreamProvider streamProvider = new org . mule . runtime . core . api . streaming . bytes . InMemoryCursorStreamProvider ( stream , org . mule . runtime . core . api . streaming . bytes . InMemoryCursorStreamConfig . getDefault ( ) , new org . mule . tck . core . streaming . SimpleByteBufferManager ( ) ) ; java . lang . Object value = flowRunner ( \"xpathWithDefaultNode\" ) . withVariable ( \"xmlPayload\" , streamProvider ) . run ( ) . getMessage ( ) . getPayload ( ) . getValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( \"xpathWithDefaultNode\" ) )", "total": "xpathWithDefaultNode ( ) { java . io . InputStream stream = getDocumentStream ( ) ; org . mule . runtime . core . api . streaming . bytes . InMemoryCursorStreamProvider streamProvider = new org . mule . runtime . core . api . streaming . bytes . InMemoryCursorStreamProvider ( stream , org . mule . runtime . core . api . streaming . bytes . InMemoryCursorStreamConfig . getDefault ( ) , new org . mule . tck . core . streaming . SimpleByteBufferManager ( ) ) ; java . lang . Object value = flowRunner ( \"xpathWithDefaultNode\" ) . withVariable ( \"xmlPayload\" , streamProvider ) . run ( ) . getMessage ( ) . getPayload ( ) . getValue ( ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return value ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( \"xpathWithDefaultNode\" ) )"}
{"focal": "aCollectionWithSize ( int ) { return new org . hamcrest . TypeSafeMatcher < java . util . Collection > ( ) { @ com . eviware . soapui . utils . Override public boolean matchesSafely ( java . util . Collection collection ) { return ( collection != null ) && ( ( collection . size ( ) ) == size ) ; } @ com . eviware . soapui . utils . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( ( ( \"a<sp>collection<sp>with<sp>\" + size ) + \"<sp>elements\" ) ) ; } } ; }", "testMethod": "createsResourceAsRootLevelResourceWhenUserRejects ( ) { stubbedDialogs . mockConfirmWithReturnValue ( false ) ; java . lang . String newResourcePath = \"anthony_jr\" ; action . createRestResource ( service , ( ( ( ( ( com . eviware . soapui . impl . rest . actions . support . NewRestResourceActionBaseTest . ENDPOINT ) + \"/\" ) + ( com . eviware . soapui . impl . rest . actions . support . NewRestResourceActionBaseTest . PARENT_RESOURCE_PATH ) ) + \"/\" ) + newResourcePath ) ) ; java . util . List < com . eviware . soapui . impl . rest . RestResource > rootLevelResources = service . getResourceList ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rootLevelResources , org . hamcrest . CoreMatchers . is ( aCollectionWithSize ( 2 ) ) )", "total": "createsResourceAsRootLevelResourceWhenUserRejects ( ) { stubbedDialogs . mockConfirmWithReturnValue ( false ) ; java . lang . String newResourcePath = \"anthony_jr\" ; action . createRestResource ( service , ( ( ( ( ( com . eviware . soapui . impl . rest . actions . support . NewRestResourceActionBaseTest . ENDPOINT ) + \"/\" ) + ( com . eviware . soapui . impl . rest . actions . support . NewRestResourceActionBaseTest . PARENT_RESOURCE_PATH ) ) + \"/\" ) + newResourcePath ) ) ; java . util . List < com . eviware . soapui . impl . rest . RestResource > rootLevelResources = service . getResourceList ( ) ; \"<AssertPlaceHolder>\" ; } aCollectionWithSize ( int ) { return new org . hamcrest . TypeSafeMatcher < java . util . Collection > ( ) { @ com . eviware . soapui . utils . Override public boolean matchesSafely ( java . util . Collection collection ) { return ( collection != null ) && ( ( collection . size ( ) ) == size ) ; } @ com . eviware . soapui . utils . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( ( ( \"a<sp>collection<sp>with<sp>\" + size ) + \"<sp>elements\" ) ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( rootLevelResources , org . hamcrest . CoreMatchers . is ( aCollectionWithSize ( 2 ) ) )"}
{"focal": "getBody ( ) { return java . util . Arrays . copyOf ( this . body , this . body . length ) ; }", "testMethod": "sendReturnsBody ( com . microsoft . azure . sdk . iot . deps . transport . http . HttpConnection , java . net . URL ) { final com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod . GET ; final byte [ ] requestBody = new byte [ 0 ] ; final byte [ ] responseBody = new byte [ ] { 1 , 2 , 3 , 0 , 4 } ; final byte [ ] expectedBody = responseBody ; new tests . unit . com . microsoft . azure . sdk . iot . deps . transport . http . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"http\" ; mockConn . readInput ( ) ; result = responseBody ; } } ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpRequest request = new com . microsoft . azure . sdk . iot . deps . transport . http . HttpRequest ( mockUrl , httpsMethod , requestBody ) ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpResponse response = request . send ( ) ; byte [ ] testBody = response . getBody ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testBody , org . hamcrest . CoreMatchers . is ( expectedBody ) )", "total": "sendReturnsBody ( com . microsoft . azure . sdk . iot . deps . transport . http . HttpConnection , java . net . URL ) { final com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod . GET ; final byte [ ] requestBody = new byte [ 0 ] ; final byte [ ] responseBody = new byte [ ] { 1 , 2 , 3 , 0 , 4 } ; final byte [ ] expectedBody = responseBody ; new tests . unit . com . microsoft . azure . sdk . iot . deps . transport . http . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"http\" ; mockConn . readInput ( ) ; result = responseBody ; } } ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpRequest request = new com . microsoft . azure . sdk . iot . deps . transport . http . HttpRequest ( mockUrl , httpsMethod , requestBody ) ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpResponse response = request . send ( ) ; byte [ ] testBody = response . getBody ( ) ; \"<AssertPlaceHolder>\" ; } getBody ( ) { return java . util . Arrays . copyOf ( this . body , this . body . length ) ; }", "answer": "org . junit . Assert . assertThat ( testBody , org . hamcrest . CoreMatchers . is ( expectedBody ) )"}
{"focal": "forField ( org . eol . globi . server . util . ResultField ) { java . util . Map < org . eol . globi . server . util . ResultField , org . eol . globi . server . util . ResultObject > fieldToObject = new java . util . TreeMap < org . eol . globi . server . util . ResultField , org . eol . globi . server . util . ResultObject > ( ) { { put ( ResultField . LATITUDE , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . LONGITUDE , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . LOCALITY , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . FOOTPRINT_WKT , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . ALTITUDE , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . SOURCE_TAXON_NAME , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_COMMON_NAMES , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_EXTERNAL_ID , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_PATH , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_PATH_IDS , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_PATH_RANKS , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_SPECIMEN_BASIS_OF_RECORD , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_BODY_PART , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_BODY_PART_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_LIFE_STAGE , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_LIFE_STAGE_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_PHYSIOLOGICAL_STATE , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_PHYSIOLOGICAL_STATE_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . TARGET_TAXON_NAME , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_COMMON_NAMES , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_EXTERNAL_ID , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_PATH , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_PATH_IDS , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_PATH_RANKS , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_SPECIMEN_BASIS_OF_RECORD , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_BODY_PART , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_BODY_PART_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_LIFE_STAGE , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_LIFE_STAGE_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_PHYSIOLOGICAL_STATE , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_PHYSIOLOGICAL_STATE_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_FREQUENCY_OF_OCCURRENCE , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_FREQUENCY_OF_OCCURRENCE_PERCENT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_VOLUME_ML , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_VOLUME_PERCENT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_COUNT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_COUNT_PERCENT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . STUDY_CITATION , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_DOI , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_SOURCE_CITATION , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_SOURCE_ID , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_TITLE , org .", "testMethod": "resultObjectForSourceTaxon ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . eol . globi . server . util . ResultObject . forField ( ResultField . SOURCE_TAXON_NAME ) , org . hamcrest . CoreMatchers . is ( ResultObject . SOURCE_TAXON ) )", "total": "resultObjectForSourceTaxon ( ) { \"<AssertPlaceHolder>\" ; } forField ( org . eol . globi . server . util . ResultField ) { java . util . Map < org . eol . globi . server . util . ResultField , org . eol . globi . server . util . ResultObject > fieldToObject = new java . util . TreeMap < org . eol . globi . server . util . ResultField , org . eol . globi . server . util . ResultObject > ( ) { { put ( ResultField . LATITUDE , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . LONGITUDE , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . LOCALITY , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . FOOTPRINT_WKT , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . ALTITUDE , org . eol . globi . server . util . ResultObject . LOCATION ) ; put ( ResultField . SOURCE_TAXON_NAME , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_COMMON_NAMES , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_EXTERNAL_ID , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_PATH , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_PATH_IDS , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_TAXON_PATH_RANKS , org . eol . globi . server . util . ResultObject . SOURCE_TAXON ) ; put ( ResultField . SOURCE_SPECIMEN_BASIS_OF_RECORD , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_BODY_PART , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_BODY_PART_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_LIFE_STAGE , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_LIFE_STAGE_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_PHYSIOLOGICAL_STATE , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . SOURCE_SPECIMEN_PHYSIOLOGICAL_STATE_ID , org . eol . globi . server . util . ResultObject . SOURCE_SPECIMEN ) ; put ( ResultField . TARGET_TAXON_NAME , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_COMMON_NAMES , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_EXTERNAL_ID , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_PATH , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_PATH_IDS , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_TAXON_PATH_RANKS , org . eol . globi . server . util . ResultObject . TARGET_TAXON ) ; put ( ResultField . TARGET_SPECIMEN_BASIS_OF_RECORD , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_BODY_PART , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_BODY_PART_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_LIFE_STAGE , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_LIFE_STAGE_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_PHYSIOLOGICAL_STATE , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_PHYSIOLOGICAL_STATE_ID , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_FREQUENCY_OF_OCCURRENCE , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_FREQUENCY_OF_OCCURRENCE_PERCENT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_VOLUME_ML , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_VOLUME_PERCENT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_COUNT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . TARGET_SPECIMEN_TOTAL_COUNT_PERCENT , org . eol . globi . server . util . ResultObject . TARGET_SPECIMEN ) ; put ( ResultField . STUDY_CITATION , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_DOI , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_SOURCE_CITATION , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_SOURCE_ID , org . eol . globi . server . util . ResultObject . STUDY ) ; put ( ResultField . STUDY_TITLE , org .", "answer": "org . junit . Assert . assertThat ( org . eol . globi . server . util . ResultObject . forField ( ResultField . SOURCE_TAXON_NAME ) , org . hamcrest . CoreMatchers . is ( ResultObject . SOURCE_TAXON ) )"}
{"focal": "fromInt ( java . lang . Integer ) { return value . toString ( ) ; }", "testMethod": "shouldComputeCorrectSubtraction ( ) { final io . confluent . ksql . function . udaf . sum . BaseSumKudafTest . TGenerator < T > tGenerator = getTGenerator ( ) ; final AT sumKudaf = getSumKudaf ( ) ; T currentVal = tGenerator . fromInt ( 30 ) ; final java . util . List < T > values = java . util . stream . Stream . of ( 3 , 5 , 8 , 2 , 3 , 4 , 5 ) . map ( tGenerator :: fromInt ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( final T i : values ) { currentVal = sumKudaf . undo ( i , currentVal ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( currentVal , org . hamcrest . CoreMatchers . equalTo ( tGenerator . fromInt ( 0 ) ) )", "total": "shouldComputeCorrectSubtraction ( ) { final io . confluent . ksql . function . udaf . sum . BaseSumKudafTest . TGenerator < T > tGenerator = getTGenerator ( ) ; final AT sumKudaf = getSumKudaf ( ) ; T currentVal = tGenerator . fromInt ( 30 ) ; final java . util . List < T > values = java . util . stream . Stream . of ( 3 , 5 , 8 , 2 , 3 , 4 , 5 ) . map ( tGenerator :: fromInt ) . collect ( java . util . stream . Collectors . toList ( ) ) ; for ( final T i : values ) { currentVal = sumKudaf . undo ( i , currentVal ) ; } \"<AssertPlaceHolder>\" ; } fromInt ( java . lang . Integer ) { return value . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( currentVal , org . hamcrest . CoreMatchers . equalTo ( tGenerator . fromInt ( 0 ) ) )"}
{"focal": "equalTo ( com . facebook . buck . query . QueryEnvironment$Argument ) { return ( ( ( type . equals ( other . type ) ) && ( ( integer ) == ( other . integer ) ) ) && ( java . util . Objects . equals ( expression , other . expression ) ) ) && ( java . util . Objects . equals ( word , other . word ) ) ; }", "testMethod": "testCopyFilesBuildPhase ( ) { com . facebook . buck . features . apple . project . NewNativeTargetProjectMutator mutator = mutatorWithCommonDefaults ( ) ; com . facebook . buck . apple . xcode . xcodeproj . CopyFilePhaseDestinationSpec . Builder specBuilder = com . facebook . buck . apple . xcode . xcodeproj . CopyFilePhaseDestinationSpec . builder ( ) ; specBuilder . setDestination ( PBXCopyFilesBuildPhase . Destination . FRAMEWORKS ) ; specBuilder . setPath ( \"foo.png\" ) ; com . facebook . buck . apple . xcode . xcodeproj . PBXBuildPhase copyPhase = new com . facebook . buck . apple . xcode . xcodeproj . PBXCopyFilesBuildPhase ( specBuilder . build ( ) ) ; mutator . setCopyFilesPhases ( com . google . common . collect . ImmutableList . of ( copyPhase ) ) ; com . facebook . buck . features . apple . project . NewNativeTargetProjectMutator . Result result = mutator . buildTargetAndAddToProject ( generatedProject , true ) ; com . facebook . buck . apple . xcode . xcodeproj . PBXBuildPhase buildPhaseToTest = com . facebook . buck . features . apple . project . ProjectGeneratorTestUtils . getSingletonPhaseByType ( result . target , com . facebook . buck . apple . xcode . xcodeproj . PBXCopyFilesBuildPhase . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( copyPhase , org . hamcrest . Matchers . equalTo ( buildPhaseToTest ) )", "total": "testCopyFilesBuildPhase ( ) { com . facebook . buck . features . apple . project . NewNativeTargetProjectMutator mutator = mutatorWithCommonDefaults ( ) ; com . facebook . buck . apple . xcode . xcodeproj . CopyFilePhaseDestinationSpec . Builder specBuilder = com . facebook . buck . apple . xcode . xcodeproj . CopyFilePhaseDestinationSpec . builder ( ) ; specBuilder . setDestination ( PBXCopyFilesBuildPhase . Destination . FRAMEWORKS ) ; specBuilder . setPath ( \"foo.png\" ) ; com . facebook . buck . apple . xcode . xcodeproj . PBXBuildPhase copyPhase = new com . facebook . buck . apple . xcode . xcodeproj . PBXCopyFilesBuildPhase ( specBuilder . build ( ) ) ; mutator . setCopyFilesPhases ( com . google . common . collect . ImmutableList . of ( copyPhase ) ) ; com . facebook . buck . features . apple . project . NewNativeTargetProjectMutator . Result result = mutator . buildTargetAndAddToProject ( generatedProject , true ) ; com . facebook . buck . apple . xcode . xcodeproj . PBXBuildPhase buildPhaseToTest = com . facebook . buck . features . apple . project . ProjectGeneratorTestUtils . getSingletonPhaseByType ( result . target , com . facebook . buck . apple . xcode . xcodeproj . PBXCopyFilesBuildPhase . class ) ; \"<AssertPlaceHolder>\" ; } equalTo ( com . facebook . buck . query . QueryEnvironment$Argument ) { return ( ( ( type . equals ( other . type ) ) && ( ( integer ) == ( other . integer ) ) ) && ( java . util . Objects . equals ( expression , other . expression ) ) ) && ( java . util . Objects . equals ( word , other . word ) ) ; }", "answer": "org . junit . Assert . assertThat ( copyPhase , org . hamcrest . Matchers . equalTo ( buildPhaseToTest ) )"}
{"focal": "getNumBands ( ) { return image . getSampleModel ( ) . getNumBands ( ) ; }", "testMethod": "testBandsSelection ( ) { org . geotools . coverage . grid . io . AbstractGridFormat format = org . geotools . gce . imagemosaic . TestUtils . getFormat ( rgbURL ) ; org . geotools . gce . imagemosaic . ImageMosaicReader reader = org . geotools . gce . imagemosaic . TestUtils . getReader ( rgbURL , format ) ; org . opengis . parameter . ParameterValue < int [ ] > selectedBands = AbstractGridFormat . BANDS . createValue ( ) ; selectedBands . setValue ( new int [ ] { 2 , 0 , 1 , 0 , 1 } ) ; org . geotools . coverage . grid . GridCoverage2D coverage = org . geotools . gce . imagemosaic . TestUtils . checkCoverage ( reader , new org . opengis . parameter . GeneralParameterValue [ ] { selectedBands } , null ) ; java . awt . image . SampleModel sampleModel = coverage . getRenderedImage ( ) . getSampleModel ( ) ; \"<AssertPlaceHolder>\" ; reader . dispose ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( sampleModel . getNumBands ( ) , org . hamcrest . CoreMatchers . is ( 5 ) )", "total": "testBandsSelection ( ) { org . geotools . coverage . grid . io . AbstractGridFormat format = org . geotools . gce . imagemosaic . TestUtils . getFormat ( rgbURL ) ; org . geotools . gce . imagemosaic . ImageMosaicReader reader = org . geotools . gce . imagemosaic . TestUtils . getReader ( rgbURL , format ) ; org . opengis . parameter . ParameterValue < int [ ] > selectedBands = AbstractGridFormat . BANDS . createValue ( ) ; selectedBands . setValue ( new int [ ] { 2 , 0 , 1 , 0 , 1 } ) ; org . geotools . coverage . grid . GridCoverage2D coverage = org . geotools . gce . imagemosaic . TestUtils . checkCoverage ( reader , new org . opengis . parameter . GeneralParameterValue [ ] { selectedBands } , null ) ; java . awt . image . SampleModel sampleModel = coverage . getRenderedImage ( ) . getSampleModel ( ) ; \"<AssertPlaceHolder>\" ; reader . dispose ( ) ; } getNumBands ( ) { return image . getSampleModel ( ) . getNumBands ( ) ; }", "answer": "org . junit . Assert . assertThat ( sampleModel . getNumBands ( ) , org . hamcrest . CoreMatchers . is ( 5 ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . GroupMarkedEvent event = new com . github . seratch . jslack . api . model . event . GroupMarkedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"group_marked\\\"}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . GroupMarkedEvent event = new com . github . seratch . jslack . api . model . event . GroupMarkedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"group_marked\\\"}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "exists ( ) { return new org . hamcrest . BaseMatcher < java . io . File > ( ) { @ com . asakusafw . operation . tools . directio . Override public boolean matches ( java . lang . Object item ) { return ( ( java . io . File ) ( item ) ) . exists ( ) ; } @ com . asakusafw . operation . tools . directio . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"exists\" ) ; } } ; }", "testMethod": "dumpActual_uri ( ) { java . io . File target = new java . io . File ( \"target/testing/dump/actual-uri.xls\" ) ; target . delete ( ) ; com . asakusafw . testdriver . JobFlowTester tester = new com . asakusafw . testdriver . JobFlowTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; tester . input ( \"simple\" , com . asakusafw . testdriver . testing . model . Simple . class ) . prepare ( \"data/simple-in.json\" ) ; tester . output ( \"simple\" , com . asakusafw . testdriver . testing . model . Simple . class ) . verify ( \"data/simple-out.json\" , new com . asakusafw . testdriver . IdentityVerifier ( ) ) . dumpActual ( target . toURI ( ) . toString ( ) ) ; tester . runTest ( com . asakusafw . testdriver . testing . dsl . SimpleJobflow . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . exists ( ) , is ( true ) )", "total": "dumpActual_uri ( ) { java . io . File target = new java . io . File ( \"target/testing/dump/actual-uri.xls\" ) ; target . delete ( ) ; com . asakusafw . testdriver . JobFlowTester tester = new com . asakusafw . testdriver . JobFlowTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; tester . input ( \"simple\" , com . asakusafw . testdriver . testing . model . Simple . class ) . prepare ( \"data/simple-in.json\" ) ; tester . output ( \"simple\" , com . asakusafw . testdriver . testing . model . Simple . class ) . verify ( \"data/simple-out.json\" , new com . asakusafw . testdriver . IdentityVerifier ( ) ) . dumpActual ( target . toURI ( ) . toString ( ) ) ; tester . runTest ( com . asakusafw . testdriver . testing . dsl . SimpleJobflow . class ) ; \"<AssertPlaceHolder>\" ; } exists ( ) { return new org . hamcrest . BaseMatcher < java . io . File > ( ) { @ com . asakusafw . operation . tools . directio . Override public boolean matches ( java . lang . Object item ) { return ( ( java . io . File ) ( item ) ) . exists ( ) ; } @ com . asakusafw . operation . tools . directio . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"exists\" ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( target . exists ( ) , is ( true ) )"}
{"focal": "text ( java . io . ByteArrayOutputStream ) { return text ( output . toByteArray ( ) ) ; }", "testMethod": "timezone_null ( ) { com . asakusafw . dmdl . directio . text . tabular . ModelLoader loaded = generateJavaFromLines ( new java . lang . String [ ] { \"@directio.text.tabular(\" , \"<sp>timezone<sp>=<sp>'UTC',\" , \")\" , \"simple<sp>=<sp>{\" , \"<sp>@directio.text.field(timezone<sp>=<sp>null)\" , \"<sp>a<sp>:<sp>DATETIME;\" , \"};\" 0 , \"};\" } ) ; byte [ ] contents = restore ( loaded , loaded . newModel ( \"Simple\" ) . setOption ( \"a\" , new com . asakusafw . runtime . value . DateTimeOption ( new com . asakusafw . runtime . value . DateTime ( 2017 , 1 , 2 , 12 , 34 , 56 ) ) ) . setOption ( \"b\" , new com . asakusafw . runtime . value . DateTimeOption ( new com . asakusafw . runtime . value . DateTime ( 2017 , 1 , 2 , 12 , 34 , 56 ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( text ( contents ) , is ( \"};\" 1 ) )", "total": "timezone_null ( ) { com . asakusafw . dmdl . directio . text . tabular . ModelLoader loaded = generateJavaFromLines ( new java . lang . String [ ] { \"@directio.text.tabular(\" , \"<sp>timezone<sp>=<sp>'UTC',\" , \")\" , \"simple<sp>=<sp>{\" , \"<sp>@directio.text.field(timezone<sp>=<sp>null)\" , \"<sp>a<sp>:<sp>DATETIME;\" , \"};\" 0 , \"};\" } ) ; byte [ ] contents = restore ( loaded , loaded . newModel ( \"Simple\" ) . setOption ( \"a\" , new com . asakusafw . runtime . value . DateTimeOption ( new com . asakusafw . runtime . value . DateTime ( 2017 , 1 , 2 , 12 , 34 , 56 ) ) ) . setOption ( \"b\" , new com . asakusafw . runtime . value . DateTimeOption ( new com . asakusafw . runtime . value . DateTime ( 2017 , 1 , 2 , 12 , 34 , 56 ) ) ) ) ; \"<AssertPlaceHolder>\" ; } text ( java . io . ByteArrayOutputStream ) { return text ( output . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( text ( contents ) , is ( \"};\" 1 ) )"}
{"focal": "jsonNumber ( com . fasterxml . jackson . databind . node . NumericNode ) { final com . fasterxml . jackson . core . JsonParser . NumberType numberType = value . numberType ( ) ; switch ( numberType ) { case INT : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonInt ( value . asInt ( ) ) ; case LONG : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonLong ( value . asLong ( ) ) ; case BIG_INTEGER : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonBigInteger ( value . bigIntegerValue ( ) ) ; case FLOAT : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonFloat ( value . floatValue ( ) ) ; case DOUBLE : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonDouble ( value . doubleValue ( ) ) ; case BIG_DECIMAL : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonBigDecimal ( value . decimalValue ( ) ) ; default : throw new java . lang . UnsupportedOperationException ( ( \"Unsupported<sp>number<sp>type<sp>\" + numberType ) ) ; } }", "testMethod": "testLiteralInt ( ) { final org . hamcrest . Matcher < com . fasterxml . jackson . databind . JsonNode > sut = com . spotify . hamcrest . jackson . IsJsonNumber . jsonNumber ( com . spotify . hamcrest . jackson . IsJsonNumberTest . NF . numberNode ( 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . spotify . hamcrest . jackson . IsJsonNumberTest . NF . numberNode ( 1 ) , org . hamcrest . core . Is . is ( sut ) )", "total": "testLiteralInt ( ) { final org . hamcrest . Matcher < com . fasterxml . jackson . databind . JsonNode > sut = com . spotify . hamcrest . jackson . IsJsonNumber . jsonNumber ( com . spotify . hamcrest . jackson . IsJsonNumberTest . NF . numberNode ( 1 ) ) ; \"<AssertPlaceHolder>\" ; } jsonNumber ( com . fasterxml . jackson . databind . node . NumericNode ) { final com . fasterxml . jackson . core . JsonParser . NumberType numberType = value . numberType ( ) ; switch ( numberType ) { case INT : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonInt ( value . asInt ( ) ) ; case LONG : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonLong ( value . asLong ( ) ) ; case BIG_INTEGER : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonBigInteger ( value . bigIntegerValue ( ) ) ; case FLOAT : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonFloat ( value . floatValue ( ) ) ; case DOUBLE : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonDouble ( value . doubleValue ( ) ) ; case BIG_DECIMAL : return com . spotify . hamcrest . jackson . IsJsonNumber . jsonBigDecimal ( value . decimalValue ( ) ) ; default : throw new java . lang . UnsupportedOperationException ( ( \"Unsupported<sp>number<sp>type<sp>\" + numberType ) ) ; } }", "answer": "org . junit . Assert . assertThat ( com . spotify . hamcrest . jackson . IsJsonNumberTest . NF . numberNode ( 1 ) , org . hamcrest . core . Is . is ( sut ) )"}
{"focal": "next ( ) { if ( ( _nextPI ) == null ) { computeNextPI ( ) ; } net . sf . javabdd . BDD result = _nextPI ; _nextPI = null ; return result ; }", "testMethod": "testProcessOneEntry ( ) { java . util . List < org . batfish . datamodel . table . Row > expected = com . google . common . collect . ImmutableList . of ( org . batfish . question . UnusedStructuresAnswererTest . BASIC_ROW ) ; java . util . List < org . batfish . datamodel . table . Row > rows = org . batfish . question . UnusedStructuresQuestionPlugin . UnusedStructuresAnswerer . processEntryToRows ( org . batfish . question . UnusedStructuresAnswererTest . BASIC_DEFINED_STRUCTS_MAP . entrySet ( ) . iterator ( ) . next ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rows , org . hamcrest . Matchers . equalTo ( expected ) )", "total": "testProcessOneEntry ( ) { java . util . List < org . batfish . datamodel . table . Row > expected = com . google . common . collect . ImmutableList . of ( org . batfish . question . UnusedStructuresAnswererTest . BASIC_ROW ) ; java . util . List < org . batfish . datamodel . table . Row > rows = org . batfish . question . UnusedStructuresQuestionPlugin . UnusedStructuresAnswerer . processEntryToRows ( org . batfish . question . UnusedStructuresAnswererTest . BASIC_DEFINED_STRUCTS_MAP . entrySet ( ) . iterator ( ) . next ( ) ) ; \"<AssertPlaceHolder>\" ; } next ( ) { if ( ( _nextPI ) == null ) { computeNextPI ( ) ; } net . sf . javabdd . BDD result = _nextPI ; _nextPI = null ; return result ; }", "answer": "org . junit . Assert . assertThat ( rows , org . hamcrest . Matchers . equalTo ( expected ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "testReplaceInternalImageIdInOtherInstance ( ) { java . io . InputStream in = org . silverpeas . core . contribution . content . wysiwyg . service . WysiwygControllerIT . class . getResourceAsStream ( \"24wysiwyg_fr.txt\" ) ; java . io . InputStream resultIn = org . silverpeas . core . contribution . content . wysiwyg . service . WysiwygControllerIT . class . getResourceAsStream ( \"move_out_result.txt\" ) ; try { java . lang . String content = org . apache . commons . io . IOUtils . toString ( in ) ; java . lang . String result = org . apache . commons . io . IOUtils . toString ( resultIn ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK oldPk = new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( \"359d2924-b6c6-461c-a459-2eef38f12c3c\" , \"kmelia1\" ) ; oldPk . setOldSilverpeasId ( 34L ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK newPk = new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( \"f2eb803f-cb46-4988-b89d-045c4e846da4\" , \"kmelia18\" ) ; newPk . setOldSilverpeasId ( 41L ) ; java . lang . String move = org . silverpeas . core . contribution . content . wysiwyg . service . WysiwygControllerIT . getWysiwygController ( ) . replaceInternalImageId ( content , oldPk , newPk ) ; \"<AssertPlaceHolder>\" ; } finally { org . apache . commons . io . IOUtils . closeQuietly ( in ) ; org . apache . commons . io . IOUtils . closeQuietly ( resultIn ) ; } }", "assertLine": "org . junit . Assert . assertThat ( move , is ( result ) )", "total": "testReplaceInternalImageIdInOtherInstance ( ) { java . io . InputStream in = org . silverpeas . core . contribution . content . wysiwyg . service . WysiwygControllerIT . class . getResourceAsStream ( \"24wysiwyg_fr.txt\" ) ; java . io . InputStream resultIn = org . silverpeas . core . contribution . content . wysiwyg . service . WysiwygControllerIT . class . getResourceAsStream ( \"move_out_result.txt\" ) ; try { java . lang . String content = org . apache . commons . io . IOUtils . toString ( in ) ; java . lang . String result = org . apache . commons . io . IOUtils . toString ( resultIn ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK oldPk = new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( \"359d2924-b6c6-461c-a459-2eef38f12c3c\" , \"kmelia1\" ) ; oldPk . setOldSilverpeasId ( 34L ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK newPk = new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( \"f2eb803f-cb46-4988-b89d-045c4e846da4\" , \"kmelia18\" ) ; newPk . setOldSilverpeasId ( 41L ) ; java . lang . String move = org . silverpeas . core . contribution . content . wysiwyg . service . WysiwygControllerIT . getWysiwygController ( ) . replaceInternalImageId ( content , oldPk , newPk ) ; \"<AssertPlaceHolder>\" ; } finally { org . apache . commons . io . IOUtils . closeQuietly ( in ) ; org . apache . commons . io . IOUtils . closeQuietly ( resultIn ) ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( move , is ( result ) )"}
{"focal": "completesTo ( T ) { return com . spotify . futures . CompletableFuturesTest . completesTo ( org . hamcrest . core . Is . is ( expected ) ) ; }", "testMethod": "exceptionallyCompose_complete ( ) { final java . util . concurrent . CompletionStage < java . lang . String > future = com . spotify . futures . CompletableFutures . exceptionallyCompletedFuture ( new java . lang . Exception ( \"boom\" ) ) ; final java . util . concurrent . CompletableFuture < java . lang . String > fallback = completedFuture ( \"hello\" ) ; final java . util . concurrent . CompletionStage < java . lang . String > composed = com . spotify . futures . CompletableFutures . exceptionallyCompose ( future , ( throwable ) -> fallback ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( composed , com . spotify . futures . CompletableFuturesTest . completesTo ( \"hello\" ) )", "total": "exceptionallyCompose_complete ( ) { final java . util . concurrent . CompletionStage < java . lang . String > future = com . spotify . futures . CompletableFutures . exceptionallyCompletedFuture ( new java . lang . Exception ( \"boom\" ) ) ; final java . util . concurrent . CompletableFuture < java . lang . String > fallback = completedFuture ( \"hello\" ) ; final java . util . concurrent . CompletionStage < java . lang . String > composed = com . spotify . futures . CompletableFutures . exceptionallyCompose ( future , ( throwable ) -> fallback ) ; \"<AssertPlaceHolder>\" ; } completesTo ( T ) { return com . spotify . futures . CompletableFuturesTest . completesTo ( org . hamcrest . core . Is . is ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( composed , com . spotify . futures . CompletableFuturesTest . completesTo ( \"hello\" ) )"}
{"focal": "get ( java . lang . String ) { final java . lang . String val = this . data . get ( key ) ; return org . apache . commons . lang . StringUtils . stripToEmpty ( val ) ; }", "testMethod": "shouldMapFirstValueOfMultiParams ( ) { request . setParameterMap ( com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . Object > of ( \":form\" , \"x\" , \"hello\" , new java . lang . String [ ] { \"world\" , \"mundo\" } ) ) ; final com . adobe . acs . commons . forms . Form form = formHelper . getForm ( \"x\" , request , response ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( form . get ( \"hello\" ) , is ( equalTo ( \"world\" ) ) )", "total": "shouldMapFirstValueOfMultiParams ( ) { request . setParameterMap ( com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . Object > of ( \":form\" , \"x\" , \"hello\" , new java . lang . String [ ] { \"world\" , \"mundo\" } ) ) ; final com . adobe . acs . commons . forms . Form form = formHelper . getForm ( \"x\" , request , response ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . String ) { final java . lang . String val = this . data . get ( key ) ; return org . apache . commons . lang . StringUtils . stripToEmpty ( val ) ; }", "answer": "org . junit . Assert . assertThat ( form . get ( \"hello\" ) , is ( equalTo ( \"world\" ) ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testAdd ( ) { org . mockito . ArgumentCaptor < java . util . List > captor = org . mockito . ArgumentCaptor . forClass ( java . util . List . class ) ; org . codice . ddf . persistence . PersistentItem props = new org . codice . ddf . persistence . PersistentItem ( ) ; props . addProperty ( \"property\" , \"value\" ) ; persistentStore . add ( \"testcore\" , props ) ; verify ( solrClient ) . add ( captor . capture ( ) , any ( org . codice . ddf . persistence . internal . Integer . class ) ) ; java . util . List docs = captor . getValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( docs . size ( ) , org . hamcrest . Matchers . equalTo ( 1 ) )", "total": "testAdd ( ) { org . mockito . ArgumentCaptor < java . util . List > captor = org . mockito . ArgumentCaptor . forClass ( java . util . List . class ) ; org . codice . ddf . persistence . PersistentItem props = new org . codice . ddf . persistence . PersistentItem ( ) ; props . addProperty ( \"property\" , \"value\" ) ; persistentStore . add ( \"testcore\" , props ) ; verify ( solrClient ) . add ( captor . capture ( ) , any ( org . codice . ddf . persistence . internal . Integer . class ) ) ; java . util . List docs = captor . getValue ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( docs . size ( ) , org . hamcrest . Matchers . equalTo ( 1 ) )"}
{"focal": "get ( ) { final com . squareup . okhttp . OkHttpClient client = new com . squareup . okhttp . OkHttpClient ( ) ; config . connectTimeoutMillis ( ) . ifPresent ( ( millis ) -> client . setConnectTimeout ( millis , TimeUnit . MILLISECONDS ) ) ; config . readTimeoutMillis ( ) . ifPresent ( ( millis ) -> client . setReadTimeout ( millis , TimeUnit . MILLISECONDS ) ) ; config . writeTimeoutMillis ( ) . ifPresent ( ( millis ) -> client . setWriteTimeout ( millis , TimeUnit . MILLISECONDS ) ) ; client . setConnectionPool ( new com . squareup . okhttp . ConnectionPool ( config . maxIdleConnections ( ) . orElse ( 5 ) , config . connectionKeepAliveDurationMillis ( ) . orElse ( ( ( 5 * 60 ) * 1000 ) ) ) ) ; config . maxAsyncRequests ( ) . ifPresent ( ( max ) -> client . getDispatcher ( ) . setMaxRequests ( max ) ) ; config . maxAsyncRequestsPerHost ( ) . ifPresent ( ( max ) -> client . getDispatcher ( ) . setMaxRequestsPerHost ( max ) ) ; config . followRedirects ( ) . ifPresent ( client :: setFollowRedirects ) ; closer . register ( ( ) -> client . getDispatcher ( ) . getExecutorService ( ) . shutdown ( ) ) ; return client ; }", "testMethod": "shouldReturnConfiguredStatusCode ( ) { stubClient . respond ( com . spotify . apollo . Response . of ( Status . IM_A_TEAPOT , okio . ByteString . encodeUtf8 ( \"Hello<sp>World\" ) ) ) . to ( \"http://ping\" ) ; com . spotify . apollo . Response < okio . ByteString > response = getResponseFromPing ( ) . toCompletableFuture ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . status ( ) , org . hamcrest . Matchers . is ( Status . IM_A_TEAPOT ) )", "total": "shouldReturnConfiguredStatusCode ( ) { stubClient . respond ( com . spotify . apollo . Response . of ( Status . IM_A_TEAPOT , okio . ByteString . encodeUtf8 ( \"Hello<sp>World\" ) ) ) . to ( \"http://ping\" ) ; com . spotify . apollo . Response < okio . ByteString > response = getResponseFromPing ( ) . toCompletableFuture ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; } get ( ) { final com . squareup . okhttp . OkHttpClient client = new com . squareup . okhttp . OkHttpClient ( ) ; config . connectTimeoutMillis ( ) . ifPresent ( ( millis ) -> client . setConnectTimeout ( millis , TimeUnit . MILLISECONDS ) ) ; config . readTimeoutMillis ( ) . ifPresent ( ( millis ) -> client . setReadTimeout ( millis , TimeUnit . MILLISECONDS ) ) ; config . writeTimeoutMillis ( ) . ifPresent ( ( millis ) -> client . setWriteTimeout ( millis , TimeUnit . MILLISECONDS ) ) ; client . setConnectionPool ( new com . squareup . okhttp . ConnectionPool ( config . maxIdleConnections ( ) . orElse ( 5 ) , config . connectionKeepAliveDurationMillis ( ) . orElse ( ( ( 5 * 60 ) * 1000 ) ) ) ) ; config . maxAsyncRequests ( ) . ifPresent ( ( max ) -> client . getDispatcher ( ) . setMaxRequests ( max ) ) ; config . maxAsyncRequestsPerHost ( ) . ifPresent ( ( max ) -> client . getDispatcher ( ) . setMaxRequestsPerHost ( max ) ) ; config . followRedirects ( ) . ifPresent ( client :: setFollowRedirects ) ; closer . register ( ( ) -> client . getDispatcher ( ) . getExecutorService ( ) . shutdown ( ) ) ; return client ; }", "answer": "org . junit . Assert . assertThat ( response . status ( ) , org . hamcrest . Matchers . is ( Status . IM_A_TEAPOT ) )"}
{"focal": "size ( ) { return ( ( ( historicProcessInstanceIds . size ( ) ) + ( historicDecisionInstanceIds . size ( ) ) ) + ( historicCaseInstanceIds . size ( ) ) ) + ( historicBatchIds . size ( ) ) ; }", "testMethod": "getReportByMultipleProcessDefinitionIdByMonthDisabledTenantCheck ( ) { testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_ONE , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . BPMN_PROCESS ) ; testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_TWO , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . BPMN_PROCESS ) ; startAndCompleteProcessInstance ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_ONE ) ; startAndCompleteProcessInstance ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_TWO ) ; java . lang . String processDefinitionIdOne = repositoryService . createProcessDefinitionQuery ( ) . tenantIdIn ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_ONE ) . singleResult ( ) . getId ( ) ; java . lang . String processDefinitionIdTwo = repositoryService . createProcessDefinitionQuery ( ) . tenantIdIn ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_TWO ) . singleResult ( ) . getId ( ) ; identityService . setAuthentication ( \"user\" , null , null ) ; processEngineConfiguration . setTenantCheckEnabled ( false ) ; java . util . List < org . camunda . bpm . engine . history . DurationReportResult > result = historyService . createHistoricProcessInstanceReport ( ) . processDefinitionIdIn ( processDefinitionIdOne , processDefinitionIdTwo ) . duration ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MONTH ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "getReportByMultipleProcessDefinitionIdByMonthDisabledTenantCheck ( ) { testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_ONE , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . BPMN_PROCESS ) ; testRule . deployForTenant ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_TWO , org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . BPMN_PROCESS ) ; startAndCompleteProcessInstance ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_ONE ) ; startAndCompleteProcessInstance ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_TWO ) ; java . lang . String processDefinitionIdOne = repositoryService . createProcessDefinitionQuery ( ) . tenantIdIn ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_ONE ) . singleResult ( ) . getId ( ) ; java . lang . String processDefinitionIdTwo = repositoryService . createProcessDefinitionQuery ( ) . tenantIdIn ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyHistoricProcessInstanceReportCmdTenantCheckTest . TENANT_TWO ) . singleResult ( ) . getId ( ) ; identityService . setAuthentication ( \"user\" , null , null ) ; processEngineConfiguration . setTenantCheckEnabled ( false ) ; java . util . List < org . camunda . bpm . engine . history . DurationReportResult > result = historyService . createHistoricProcessInstanceReport ( ) . processDefinitionIdIn ( processDefinitionIdOne , processDefinitionIdTwo ) . duration ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MONTH ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return ( ( ( historicProcessInstanceIds . size ( ) ) + ( historicDecisionInstanceIds . size ( ) ) ) + ( historicCaseInstanceIds . size ( ) ) ) + ( historicBatchIds . size ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "get_table_req ( org . apache . hadoop . hive . metastore . api . GetTableRequest ) { org . apache . hadoop . hive . metastore . api . Table table = client . get_table ( req . getDbName ( ) , req . getTblName ( ) ) ; return new org . apache . hadoop . hive . metastore . api . GetTableResult ( table ) ; }", "testMethod": "compatibilityExceptionIsThrownWhenCompatibilityFailsOnTException ( ) { com . hotels . bdp . waggledance . client . CloseableThriftHiveMetastoreIface thriftHiveMetastoreIface = factory . newInstance ( delegate ) ; org . apache . hadoop . hive . metastore . api . GetTableRequest tableRequest = new org . apache . hadoop . hive . metastore . api . GetTableRequest ( com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . DB_NAME , com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . TABLE_NAME ) ; when ( delegate . get_table_req ( tableRequest ) ) . thenThrow ( new org . apache . thrift . TApplicationException ( \"ApplicationException,<sp>should<sp>not<sp>be<sp>thrown\" ) ) ; org . apache . hadoop . hive . metastore . api . NoSuchObjectException cause = new org . apache . hadoop . hive . metastore . api . NoSuchObjectException ( \"Should<sp>be<sp>thrown,<sp>this<sp>is<sp>called<sp>from<sp>compatiblity<sp>layer\" ) ; when ( delegate . get_table ( com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . DB_NAME , com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . TABLE_NAME ) ) . thenThrow ( cause ) ; try { thriftHiveMetastoreIface . get_table_req ( tableRequest ) ; org . junit . Assert . fail ( \"exception<sp>should<sp>have<sp>been<sp>thrown\" ) ; } catch ( org . apache . hadoop . hive . metastore . api . NoSuchObjectException e ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( e , org . hamcrest . CoreMatchers . is ( cause ) )", "total": "compatibilityExceptionIsThrownWhenCompatibilityFailsOnTException ( ) { com . hotels . bdp . waggledance . client . CloseableThriftHiveMetastoreIface thriftHiveMetastoreIface = factory . newInstance ( delegate ) ; org . apache . hadoop . hive . metastore . api . GetTableRequest tableRequest = new org . apache . hadoop . hive . metastore . api . GetTableRequest ( com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . DB_NAME , com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . TABLE_NAME ) ; when ( delegate . get_table_req ( tableRequest ) ) . thenThrow ( new org . apache . thrift . TApplicationException ( \"ApplicationException,<sp>should<sp>not<sp>be<sp>thrown\" ) ) ; org . apache . hadoop . hive . metastore . api . NoSuchObjectException cause = new org . apache . hadoop . hive . metastore . api . NoSuchObjectException ( \"Should<sp>be<sp>thrown,<sp>this<sp>is<sp>called<sp>from<sp>compatiblity<sp>layer\" ) ; when ( delegate . get_table ( com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . DB_NAME , com . hotels . bdp . waggledance . client . compatibility . HiveCompatibleThriftHiveMetastoreIfaceFactoryTest . TABLE_NAME ) ) . thenThrow ( cause ) ; try { thriftHiveMetastoreIface . get_table_req ( tableRequest ) ; org . junit . Assert . fail ( \"exception<sp>should<sp>have<sp>been<sp>thrown\" ) ; } catch ( org . apache . hadoop . hive . metastore . api . NoSuchObjectException e ) { \"<AssertPlaceHolder>\" ; } } get_table_req ( org . apache . hadoop . hive . metastore . api . GetTableRequest ) { org . apache . hadoop . hive . metastore . api . Table table = client . get_table ( req . getDbName ( ) , req . getTblName ( ) ) ; return new org . apache . hadoop . hive . metastore . api . GetTableResult ( table ) ; }", "answer": "org . junit . Assert . assertThat ( e , org . hamcrest . CoreMatchers . is ( cause ) )"}
{"focal": "isBinaryCompatible ( ) { return true ; }", "testMethod": "test_JLS_13_4_8 ( ) { japicmp . model . JApiClass subclassExtendsSuperclassWithField = getJApiClass ( japicmp . test . CompatibilityChangesTest . jApiClasses , japicmp . test . binarycompatiblity . SubclassOverridesStaticField . class . getName ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( subclassExtendsSuperclassWithField . isBinaryCompatible ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "test_JLS_13_4_8 ( ) { japicmp . model . JApiClass subclassExtendsSuperclassWithField = getJApiClass ( japicmp . test . CompatibilityChangesTest . jApiClasses , japicmp . test . binarycompatiblity . SubclassOverridesStaticField . class . getName ( ) ) ; \"<AssertPlaceHolder>\" ; } isBinaryCompatible ( ) { return true ; }", "answer": "org . junit . Assert . assertThat ( subclassExtendsSuperclassWithField . isBinaryCompatible ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "killSimulatorProcesses ( ) { com . google . common . collect . ImmutableSet < java . lang . String > simulatorServiceNames = getMatchingServiceNames ( com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController . ALL_SIMULATOR_SERVICES_PATTERN ) ; com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController . LOG . debug ( \"Killing<sp>simulator<sp>services:<sp>%s\" , simulatorServiceNames ) ; boolean result = true ; for ( java . lang . String simulatorServiceName : simulatorServiceNames ) { if ( ! ( killService ( simulatorServiceName ) ) ) { result = false ; } } return result ; }", "testMethod": "coreSimulatorServicesKilledSuccessfully ( ) { ImmutableList . Builder < Map . Entry < com . facebook . buck . util . ProcessExecutorParams , com . facebook . buck . util . FakeProcess > > fakeProcessesBuilder = com . google . common . collect . ImmutableList . builder ( ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceControllerTest . LAUNCHCTL_LIST_PARAMS , new com . facebook . buck . util . FakeProcess ( 0 , ( \"87823\\t0\\tcom.apple.CoreSimulator.CoreSimulatorService.117.15.1.lkhDXxRPp5yy\\n\" + ( ( \"87823\\t0\\tcom.apple.CoreSimulator.CoreSimulatorService.117.15.1.lkhDXxRPp5yy\\n\" 0 + \".launchd_sim\\n\" ) + \"74614\\t0\\tcom.apple.iphonesimulator.6564\\n\" ) ) , \"\" ) ) ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . util . ProcessExecutorParams . builder ( ) . setCommand ( com . google . common . collect . ImmutableList . of ( \"launchctl\" , \"remove\" , \"com.apple.CoreSimulator.CoreSimulatorService.117.15.1.lkhDXxRPp5yy\" ) ) . build ( ) , new com . facebook . buck . util . FakeProcess ( 0 ) ) ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . util . ProcessExecutorParams . builder ( ) . setCommand ( com . google . common . collect . ImmutableList . of ( \"launchctl\" , \"remove\" , ( \"com.apple.CoreSimulator.SimDevice.CC1B0BAD-BAE6-4A53-92CF-F79850654057.\" + \"launchd_sim\" ) ) ) . build ( ) , new com . facebook . buck . util . FakeProcess ( 0 ) ) ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . util . ProcessExecutorParams . builder ( ) . setCommand ( com . google . common . collect . ImmutableList . of ( \"launchctl\" , \"remove\" , \"com.apple.iphonesimulator.6564\" ) ) . build ( ) , new com . facebook . buck . util . FakeProcess ( 0 ) ) ) ; com . facebook . buck . util . FakeProcessExecutor fakeProcessExecutor = new com . facebook . buck . util . FakeProcessExecutor ( fakeProcessesBuilder . build ( ) ) ; com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController appleCoreSimulatorServiceController = new com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController ( fakeProcessExecutor ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( appleCoreSimulatorServiceController . killSimulatorProcesses ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "coreSimulatorServicesKilledSuccessfully ( ) { ImmutableList . Builder < Map . Entry < com . facebook . buck . util . ProcessExecutorParams , com . facebook . buck . util . FakeProcess > > fakeProcessesBuilder = com . google . common . collect . ImmutableList . builder ( ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceControllerTest . LAUNCHCTL_LIST_PARAMS , new com . facebook . buck . util . FakeProcess ( 0 , ( \"87823\\t0\\tcom.apple.CoreSimulator.CoreSimulatorService.117.15.1.lkhDXxRPp5yy\\n\" + ( ( \"87823\\t0\\tcom.apple.CoreSimulator.CoreSimulatorService.117.15.1.lkhDXxRPp5yy\\n\" 0 + \".launchd_sim\\n\" ) + \"74614\\t0\\tcom.apple.iphonesimulator.6564\\n\" ) ) , \"\" ) ) ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . util . ProcessExecutorParams . builder ( ) . setCommand ( com . google . common . collect . ImmutableList . of ( \"launchctl\" , \"remove\" , \"com.apple.CoreSimulator.CoreSimulatorService.117.15.1.lkhDXxRPp5yy\" ) ) . build ( ) , new com . facebook . buck . util . FakeProcess ( 0 ) ) ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . util . ProcessExecutorParams . builder ( ) . setCommand ( com . google . common . collect . ImmutableList . of ( \"launchctl\" , \"remove\" , ( \"com.apple.CoreSimulator.SimDevice.CC1B0BAD-BAE6-4A53-92CF-F79850654057.\" + \"launchd_sim\" ) ) ) . build ( ) , new com . facebook . buck . util . FakeProcess ( 0 ) ) ) ; fakeProcessesBuilder . add ( new java . util . AbstractMap . SimpleImmutableEntry ( com . facebook . buck . util . ProcessExecutorParams . builder ( ) . setCommand ( com . google . common . collect . ImmutableList . of ( \"launchctl\" , \"remove\" , \"com.apple.iphonesimulator.6564\" ) ) . build ( ) , new com . facebook . buck . util . FakeProcess ( 0 ) ) ) ; com . facebook . buck . util . FakeProcessExecutor fakeProcessExecutor = new com . facebook . buck . util . FakeProcessExecutor ( fakeProcessesBuilder . build ( ) ) ; com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController appleCoreSimulatorServiceController = new com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController ( fakeProcessExecutor ) ; \"<AssertPlaceHolder>\" ; } killSimulatorProcesses ( ) { com . google . common . collect . ImmutableSet < java . lang . String > simulatorServiceNames = getMatchingServiceNames ( com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController . ALL_SIMULATOR_SERVICES_PATTERN ) ; com . facebook . buck . apple . simulator . AppleCoreSimulatorServiceController . LOG . debug ( \"Killing<sp>simulator<sp>services:<sp>%s\" , simulatorServiceNames ) ; boolean result = true ; for ( java . lang . String simulatorServiceName : simulatorServiceNames ) { if ( ! ( killService ( simulatorServiceName ) ) ) { result = false ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( appleCoreSimulatorServiceController . killSimulatorProcesses ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "build ( ) { return new org . batfish . referencelibrary . ReferenceBook ( _name , firstNonNull ( _addressGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _filterGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _interfaceGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _serviceEndpoints , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _serviceObjectGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _serviceObjects , com . google . common . collect . ImmutableList . of ( ) ) ) ; }", "testMethod": "testOne ( ) { _andBuilder . add ( org . batfish . datamodel . acl . explanation . ConjunctsBuilderTest . DST_IP ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( _andBuilder . build ( ) , org . hamcrest . Matchers . equalTo ( org . batfish . datamodel . acl . explanation . ConjunctsBuilderTest . DST_IP ) )", "total": "testOne ( ) { _andBuilder . add ( org . batfish . datamodel . acl . explanation . ConjunctsBuilderTest . DST_IP ) ; \"<AssertPlaceHolder>\" ; } build ( ) { return new org . batfish . referencelibrary . ReferenceBook ( _name , firstNonNull ( _addressGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _filterGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _interfaceGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _serviceEndpoints , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _serviceObjectGroups , com . google . common . collect . ImmutableList . of ( ) ) , firstNonNull ( _serviceObjects , com . google . common . collect . ImmutableList . of ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( _andBuilder . build ( ) , org . hamcrest . Matchers . equalTo ( org . batfish . datamodel . acl . explanation . ConjunctsBuilderTest . DST_IP ) )"}
{"focal": "size ( ) { return this . cells . size ( ) ; }", "testMethod": "norbornaneSize ( ) { org . openscience . cdk . graph . TripletShortCycles esssr = new org . openscience . cdk . graph . TripletShortCycles ( new org . openscience . cdk . graph . MinimumCycleBasis ( org . openscience . cdk . graph . InitialCyclesTest . norbornane ( ) ) , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( esssr . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "norbornaneSize ( ) { org . openscience . cdk . graph . TripletShortCycles esssr = new org . openscience . cdk . graph . TripletShortCycles ( new org . openscience . cdk . graph . MinimumCycleBasis ( org . openscience . cdk . graph . InitialCyclesTest . norbornane ( ) ) , false ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return this . cells . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( esssr . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "validateInputInstallments ( java . util . Date , java . lang . Integer , java . lang . Integer , java . math . BigDecimal , java . util . List , java . lang . Integer ) { java . lang . Short officeId = customerDao . findCustomerById ( customerId ) . getOfficeId ( ) ; org . mifos . accounts . productdefinition . business . VariableInstallmentDetailsBO variableInstallmentDetails = new org . mifos . accounts . productdefinition . business . VariableInstallmentDetailsBO ( ) ; variableInstallmentDetails . setMinGapInDays ( minGapInDays ) ; variableInstallmentDetails . setMaxGapInDays ( maxGapInDays ) ; org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext context = new org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext ( disbursementDate , variableInstallmentDetails , minInstallmentAmount , holidayServiceFacade , officeId ) ; org . mifos . application . master . business . MifosCurrency currency = org . mifos . framework . util . helpers . Money . getDefaultCurrency ( ) ; java . util . List < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > installments = new java . util . ArrayList < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > ( ) ; for ( org . mifos . dto . domain . LoanCreationInstallmentDto dto : dtoInstallments ) { org . mifos . framework . util . helpers . Money principal = new org . mifos . framework . util . helpers . Money ( currency , dto . getPrincipal ( ) ) ; org . mifos . framework . util . helpers . Money interest = new org . mifos . framework . util . helpers . Money ( currency , dto . getInterest ( ) ) ; org . mifos . framework . util . helpers . Money fees = new org . mifos . framework . util . helpers . Money ( currency , dto . getFees ( ) ) ; org . mifos . framework . util . helpers . Money miscFees = new org . mifos . framework . util . helpers . Money ( currency ) ; org . mifos . framework . util . helpers . Money miscPenalty = new org . mifos . framework . util . helpers . Money ( currency ) ; org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment = new org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment ( dto . getInstallmentNumber ( ) , dto . getDueDate ( ) , principal , interest , fees , miscFees , miscPenalty ) ; installment . setTotalAndTotalValue ( new org . mifos . framework . util . helpers . Money ( currency , dto . getTotal ( ) ) ) ; installments . add ( installment ) ; } return installmentsValidator . validateInputInstallments ( installments , context ) ; }", "testMethod": "shouldValidateInstallments ( ) { int customerId = 121 ; org . mifos . platform . validations . Errors errors = new org . mifos . platform . validations . Errors ( ) ; when ( installmentsValidator . validateInputInstallments ( anyListOf ( org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment . class ) , any ( org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext . class ) ) ) . thenReturn ( errors ) ; when ( customerDao . findCustomerById ( customerId ) ) . thenReturn ( customer ) ; when ( customer . getOfficeId ( ) ) . thenReturn ( java . lang . Short . valueOf ( \"1\" ) ) ; java . util . Date disbursementDate = null ; java . lang . Integer minGapInDays = java . lang . Integer . valueOf ( 0 ) ; java . lang . Integer maxGapInDays = java . lang . Integer . valueOf ( 0 ) ; java . math . BigDecimal minInstallmentAmount = java . math . BigDecimal . ZERO ; org . mifos . platform . validations . Errors actual = loanAccountServiceFacade . validateInputInstallments ( disbursementDate , minGapInDays , maxGapInDays , minInstallmentAmount , new java . util . ArrayList < org . mifos . dto . domain . LoanCreationInstallmentDto > ( ) , customerId ) ; \"<AssertPlaceHolder>\" ; verify ( installmentsValidator ) . validateInputInstallments ( anyListOf ( org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment . class ) , any ( org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext . class ) ) ; verify ( customerDao ) . findCustomerById ( customerId ) ; verify ( customer ) . getOfficeId ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( errors ) )", "total": "shouldValidateInstallments ( ) { int customerId = 121 ; org . mifos . platform . validations . Errors errors = new org . mifos . platform . validations . Errors ( ) ; when ( installmentsValidator . validateInputInstallments ( anyListOf ( org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment . class ) , any ( org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext . class ) ) ) . thenReturn ( errors ) ; when ( customerDao . findCustomerById ( customerId ) ) . thenReturn ( customer ) ; when ( customer . getOfficeId ( ) ) . thenReturn ( java . lang . Short . valueOf ( \"1\" ) ) ; java . util . Date disbursementDate = null ; java . lang . Integer minGapInDays = java . lang . Integer . valueOf ( 0 ) ; java . lang . Integer maxGapInDays = java . lang . Integer . valueOf ( 0 ) ; java . math . BigDecimal minInstallmentAmount = java . math . BigDecimal . ZERO ; org . mifos . platform . validations . Errors actual = loanAccountServiceFacade . validateInputInstallments ( disbursementDate , minGapInDays , maxGapInDays , minInstallmentAmount , new java . util . ArrayList < org . mifos . dto . domain . LoanCreationInstallmentDto > ( ) , customerId ) ; \"<AssertPlaceHolder>\" ; verify ( installmentsValidator ) . validateInputInstallments ( anyListOf ( org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment . class ) , any ( org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext . class ) ) ; verify ( customerDao ) . findCustomerById ( customerId ) ; verify ( customer ) . getOfficeId ( ) ; } validateInputInstallments ( java . util . Date , java . lang . Integer , java . lang . Integer , java . math . BigDecimal , java . util . List , java . lang . Integer ) { java . lang . Short officeId = customerDao . findCustomerById ( customerId ) . getOfficeId ( ) ; org . mifos . accounts . productdefinition . business . VariableInstallmentDetailsBO variableInstallmentDetails = new org . mifos . accounts . productdefinition . business . VariableInstallmentDetailsBO ( ) ; variableInstallmentDetails . setMinGapInDays ( minGapInDays ) ; variableInstallmentDetails . setMaxGapInDays ( maxGapInDays ) ; org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext context = new org . mifos . accounts . loan . business . service . validators . InstallmentValidationContext ( disbursementDate , variableInstallmentDetails , minInstallmentAmount , holidayServiceFacade , officeId ) ; org . mifos . application . master . business . MifosCurrency currency = org . mifos . framework . util . helpers . Money . getDefaultCurrency ( ) ; java . util . List < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > installments = new java . util . ArrayList < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > ( ) ; for ( org . mifos . dto . domain . LoanCreationInstallmentDto dto : dtoInstallments ) { org . mifos . framework . util . helpers . Money principal = new org . mifos . framework . util . helpers . Money ( currency , dto . getPrincipal ( ) ) ; org . mifos . framework . util . helpers . Money interest = new org . mifos . framework . util . helpers . Money ( currency , dto . getInterest ( ) ) ; org . mifos . framework . util . helpers . Money fees = new org . mifos . framework . util . helpers . Money ( currency , dto . getFees ( ) ) ; org . mifos . framework . util . helpers . Money miscFees = new org . mifos . framework . util . helpers . Money ( currency ) ; org . mifos . framework . util . helpers . Money miscPenalty = new org . mifos . framework . util . helpers . Money ( currency ) ; org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment = new org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment ( dto . getInstallmentNumber ( ) , dto . getDueDate ( ) , principal , interest , fees , miscFees , miscPenalty ) ; installment . setTotalAndTotalValue ( new org . mifos . framework . util . helpers . Money ( currency , dto . getTotal ( ) ) ) ; installments . add ( installment ) ; } return installmentsValidator . validateInputInstallments ( installments , context ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( errors ) )"}
{"focal": "getNamesByIp ( java . lang . String ) { return dataSource . getAllAuthsByIp ( address ) ; }", "testMethod": "shouldGetNamesByIp ( ) { java . lang . String ip = \"123.123.123.123\" ; java . util . List < java . lang . String > names = java . util . Arrays . asList ( \"Morgan\" , \"Batista\" , \"QUINN\" ) ; given ( dataSource . getAllAuthsByIp ( ip ) ) . willReturn ( names ) ; java . util . List < java . lang . String > result = api . getNamesByIp ( ip ) ; \"<AssertPlaceHolder>\" ; verify ( dataSource ) . getAllAuthsByIp ( ip ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( names ) )", "total": "shouldGetNamesByIp ( ) { java . lang . String ip = \"123.123.123.123\" ; java . util . List < java . lang . String > names = java . util . Arrays . asList ( \"Morgan\" , \"Batista\" , \"QUINN\" ) ; given ( dataSource . getAllAuthsByIp ( ip ) ) . willReturn ( names ) ; java . util . List < java . lang . String > result = api . getNamesByIp ( ip ) ; \"<AssertPlaceHolder>\" ; verify ( dataSource ) . getAllAuthsByIp ( ip ) ; } getNamesByIp ( java . lang . String ) { return dataSource . getAllAuthsByIp ( address ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( names ) )"}
{"focal": "normalize ( org . batfish . datamodel . acl . AclLineMatchExpr ) { return org . batfish . datamodel . acl . AclLineMatchExprNormalizer . normalize ( _toBDD , expr ) ; }", "testMethod": "visitOrMatchExpr_expandOr ( ) { org . batfish . datamodel . acl . AclLineMatchExpr expr = org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C ) ) ; org . batfish . datamodel . acl . AclLineMatchExpr nf = org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( normalize ( expr ) , org . hamcrest . Matchers . equalTo ( nf ) )", "total": "visitOrMatchExpr_expandOr ( ) { org . batfish . datamodel . acl . AclLineMatchExpr expr = org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C ) ) ; org . batfish . datamodel . acl . AclLineMatchExpr nf = org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C ) ; \"<AssertPlaceHolder>\" ; } normalize ( org . batfish . datamodel . acl . AclLineMatchExpr ) { return org . batfish . datamodel . acl . AclLineMatchExprNormalizer . normalize ( _toBDD , expr ) ; }", "answer": "org . junit . Assert . assertThat ( normalize ( expr ) , org . hamcrest . Matchers . equalTo ( nf ) )"}
{"focal": "getConfigurationInspectionClassLoader ( org . springframework . core . io . ResourceLoader ) { java . lang . ClassLoader classLoader = loader . getClassLoader ( ) ; return ( classLoader != null ) && ( org . springframework . data . jpa . repository . config . JpaRepositoryConfigExtension . LazyJvmAgent . isActive ( loader . getClassLoader ( ) ) ) ? new org . springframework . data . jpa . repository . config . InspectionClassLoader ( loader . getClassLoader ( ) ) : loader . getClassLoader ( ) ; }", "testMethod": "shouldUseInspectionClassLoader ( ) { org . springframework . data . jpa . repository . config . JpaRepositoryConfigExtension extension = new org . springframework . data . jpa . repository . config . JpaRepositoryConfigExtension ( ) ; java . lang . ClassLoader classLoader = extension . getConfigurationInspectionClassLoader ( new org . springframework . context . support . GenericApplicationContext ( ) ) ; \"<AssertPlaceHolder>\" . isInstanceOf ( org . springframework . data . jpa . repository . config . InspectionClassLoader . class ) ; }", "assertLine": "org . junit . Assert . assertThat ( classLoader )", "total": "shouldUseInspectionClassLoader ( ) { org . springframework . data . jpa . repository . config . JpaRepositoryConfigExtension extension = new org . springframework . data . jpa . repository . config . JpaRepositoryConfigExtension ( ) ; java . lang . ClassLoader classLoader = extension . getConfigurationInspectionClassLoader ( new org . springframework . context . support . GenericApplicationContext ( ) ) ; \"<AssertPlaceHolder>\" . isInstanceOf ( org . springframework . data . jpa . repository . config . InspectionClassLoader . class ) ; } getConfigurationInspectionClassLoader ( org . springframework . core . io . ResourceLoader ) { java . lang . ClassLoader classLoader = loader . getClassLoader ( ) ; return ( classLoader != null ) && ( org . springframework . data . jpa . repository . config . JpaRepositoryConfigExtension . LazyJvmAgent . isActive ( loader . getClassLoader ( ) ) ) ? new org . springframework . data . jpa . repository . config . InspectionClassLoader ( loader . getClassLoader ( ) ) : loader . getClassLoader ( ) ; }", "answer": "org . junit . Assert . assertThat ( classLoader )"}
{"focal": "doGet ( java . lang . String ) { final java . net . URI uri = java . net . URI . create ( url ) ; final com . spotify . apollo . Response < okio . ByteString > response = serviceHelper . request ( \"GET\" , uri ) . toCompletableFuture ( ) . get ( ) ; return response . payload ( ) . get ( ) . utf8 ( ) ; }", "testMethod": "callTest ( ) { stubClient . respond ( com . spotify . apollo . Response . forPayload ( okio . ByteString . encodeUtf8 ( \"hello<sp>from<sp>something\" ) ) ) . in ( 300 , TimeUnit . MILLISECONDS ) . to ( \"http://something/foo\" ) ; java . lang . String response = doGet ( \"/call/something/foo\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response , org . hamcrest . Matchers . is ( \"hello<sp>from<sp>something\" ) )", "total": "callTest ( ) { stubClient . respond ( com . spotify . apollo . Response . forPayload ( okio . ByteString . encodeUtf8 ( \"hello<sp>from<sp>something\" ) ) ) . in ( 300 , TimeUnit . MILLISECONDS ) . to ( \"http://something/foo\" ) ; java . lang . String response = doGet ( \"/call/something/foo\" ) ; \"<AssertPlaceHolder>\" ; } doGet ( java . lang . String ) { final java . net . URI uri = java . net . URI . create ( url ) ; final com . spotify . apollo . Response < okio . ByteString > response = serviceHelper . request ( \"GET\" , uri ) . toCompletableFuture ( ) . get ( ) ; return response . payload ( ) . get ( ) . utf8 ( ) ; }", "answer": "org . junit . Assert . assertThat ( response , org . hamcrest . Matchers . is ( \"hello<sp>from<sp>something\" ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldFindAnnotatedGeoMarkersInRangeForGivenCriteriaQueryUsingGeohashLocation ( ) { loadAnnotationBaseEntities ( ) ; org . springframework . data . elasticsearch . core . query . CriteriaQuery geoLocationCriteriaQuery = new org . springframework . data . elasticsearch . core . query . CriteriaQuery ( new org . springframework . data . elasticsearch . core . query . Criteria ( \"locationAsArray\" ) . within ( \"u1044\" , \"3km\" ) ) ; java . util . List < org . springframework . data . elasticsearch . core . geo . LocationMarkerEntity > geoAuthorsForGeoCriteria = elasticsearchTemplate . queryForList ( geoLocationCriteriaQuery , org . springframework . data . elasticsearch . core . geo . LocationMarkerEntity . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( geoAuthorsForGeoCriteria . size ( ) , is ( 3 ) )", "total": "shouldFindAnnotatedGeoMarkersInRangeForGivenCriteriaQueryUsingGeohashLocation ( ) { loadAnnotationBaseEntities ( ) ; org . springframework . data . elasticsearch . core . query . CriteriaQuery geoLocationCriteriaQuery = new org . springframework . data . elasticsearch . core . query . CriteriaQuery ( new org . springframework . data . elasticsearch . core . query . Criteria ( \"locationAsArray\" ) . within ( \"u1044\" , \"3km\" ) ) ; java . util . List < org . springframework . data . elasticsearch . core . geo . LocationMarkerEntity > geoAuthorsForGeoCriteria = elasticsearchTemplate . queryForList ( geoLocationCriteriaQuery , org . springframework . data . elasticsearch . core . geo . LocationMarkerEntity . class ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( geoAuthorsForGeoCriteria . size ( ) , is ( 3 ) )"}
{"focal": "getStatusCode ( ) { return statusCode ; }", "testMethod": "shouldNotFindFolder ( ) { final com . jayway . restassured . response . Response response = given ( ) . expect ( ) . statusCode ( 404 ) . log ( ) . ifError ( ) . when ( ) . get ( \"/folders?parentId={parentId}\" , \"unknownId\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . getStatusCode ( ) , org . hamcrest . Matchers . is ( 404 ) )", "total": "shouldNotFindFolder ( ) { final com . jayway . restassured . response . Response response = given ( ) . expect ( ) . statusCode ( 404 ) . log ( ) . ifError ( ) . when ( ) . get ( \"/folders?parentId={parentId}\" , \"unknownId\" ) ; \"<AssertPlaceHolder>\" ; } getStatusCode ( ) { return statusCode ; }", "answer": "org . junit . Assert . assertThat ( response . getStatusCode ( ) , org . hamcrest . Matchers . is ( 404 ) )"}
{"focal": "createReaderForViews ( java . util . Collection ) { if ( ! ( containedViews . containsAll ( newContainedViews ) ) ) { java . util . Set < org . apache . beam . sdk . values . PCollectionView < ? > > currentlyContained = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableSet . copyOf ( containedViews ) ; java . util . Set < org . apache . beam . sdk . values . PCollectionView < ? > > newRequested = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableSet . copyOf ( newContainedViews ) ; throw new java . lang . IllegalArgumentException ( ( \"Can't<sp>create<sp>a<sp>SideInputReader<sp>with<sp>unknown<sp>views<sp>\" + ( org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . Sets . difference ( newRequested , currentlyContained ) ) ) ) ; } return new org . apache . beam . runners . direct . SideInputContainer . SideInputContainerSideInputReader ( newContainedViews ) ; }", "testMethod": "writeForMultipleIdenticalElementsInSameWindowSucceeds ( ) { org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . Builder < org . apache . beam . sdk . util . WindowedValue < ? > > valuesBuilder = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . builder ( ) ; for ( java . lang . Object materializedValue : materializeValuesFor ( org . apache . beam . sdk . transforms . View . asIterable ( ) , 44 , 44 ) ) { valuesBuilder . add ( org . apache . beam . sdk . util . WindowedValue . of ( materializedValue , org . apache . beam . runners . direct . SideInputContainerTest . FIRST_WINDOW . maxTimestamp ( ) . minus ( 200L ) , org . apache . beam . runners . direct . SideInputContainerTest . FIRST_WINDOW , PaneInfo . ON_TIME_AND_ONLY_FIRING ) ) ; } container . write ( iterableView , valuesBuilder . build ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( container . createReaderForViews ( org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . of ( iterableView ) ) . get ( iterableView , org . apache . beam . runners . direct . SideInputContainerTest . FIRST_WINDOW ) , org . hamcrest . Matchers . contains ( 44 , 44 ) )", "total": "writeForMultipleIdenticalElementsInSameWindowSucceeds ( ) { org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . Builder < org . apache . beam . sdk . util . WindowedValue < ? > > valuesBuilder = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . builder ( ) ; for ( java . lang . Object materializedValue : materializeValuesFor ( org . apache . beam . sdk . transforms . View . asIterable ( ) , 44 , 44 ) ) { valuesBuilder . add ( org . apache . beam . sdk . util . WindowedValue . of ( materializedValue , org . apache . beam . runners . direct . SideInputContainerTest . FIRST_WINDOW . maxTimestamp ( ) . minus ( 200L ) , org . apache . beam . runners . direct . SideInputContainerTest . FIRST_WINDOW , PaneInfo . ON_TIME_AND_ONLY_FIRING ) ) ; } container . write ( iterableView , valuesBuilder . build ( ) ) ; \"<AssertPlaceHolder>\" ; } createReaderForViews ( java . util . Collection ) { if ( ! ( containedViews . containsAll ( newContainedViews ) ) ) { java . util . Set < org . apache . beam . sdk . values . PCollectionView < ? > > currentlyContained = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableSet . copyOf ( containedViews ) ; java . util . Set < org . apache . beam . sdk . values . PCollectionView < ? > > newRequested = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableSet . copyOf ( newContainedViews ) ; throw new java . lang . IllegalArgumentException ( ( \"Can't<sp>create<sp>a<sp>SideInputReader<sp>with<sp>unknown<sp>views<sp>\" + ( org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . Sets . difference ( newRequested , currentlyContained ) ) ) ) ; } return new org . apache . beam . runners . direct . SideInputContainer . SideInputContainerSideInputReader ( newContainedViews ) ; }", "answer": "org . junit . Assert . assertThat ( container . createReaderForViews ( org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . of ( iterableView ) ) . get ( iterableView , org . apache . beam . runners . direct . SideInputContainerTest . FIRST_WINDOW ) , org . hamcrest . Matchers . contains ( 44 , 44 ) )"}
{"focal": "isBriefAbuseContact ( ) { return queryParser . hasOption ( QueryFlag . ABUSE_CONTACT ) ; }", "testMethod": "not_isBrief ( ) { net . ripe . db . whois . query . query . Query query = net . ripe . db . whois . query . query . Query . parse ( \"foo\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . isBriefAbuseContact ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "not_isBrief ( ) { net . ripe . db . whois . query . query . Query query = net . ripe . db . whois . query . query . Query . parse ( \"foo\" ) ; \"<AssertPlaceHolder>\" ; } isBriefAbuseContact ( ) { return queryParser . hasOption ( QueryFlag . ABUSE_CONTACT ) ; }", "answer": "org . junit . Assert . assertThat ( query . isBriefAbuseContact ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "isSpinning ( ) { return ( ( dockerEnvPath . exists ( ) ) && ( dockerInitPath . exists ( ) ) ) && ( dockerSocketFile . exists ( ) ) ; }", "testMethod": "shouldStopSpinningIfRunningInsideDocker ( ) { temporaryFolder . newFile ( Top . DOCKER_SOCK ) ; temporaryFolder . newFile ( Top . DOCKERENV ) ; temporaryFolder . newFile ( Top . DOCKERINIT ) ; org . arquillian . cube . docker . impl . util . Top top = new org . arquillian . cube . docker . impl . util . Top ( temporaryFolder . getRoot ( ) . getAbsolutePath ( ) , temporaryFolder . getRoot ( ) . getAbsolutePath ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( top . isSpinning ( ) , org . hamcrest . core . Is . is ( true ) )", "total": "shouldStopSpinningIfRunningInsideDocker ( ) { temporaryFolder . newFile ( Top . DOCKER_SOCK ) ; temporaryFolder . newFile ( Top . DOCKERENV ) ; temporaryFolder . newFile ( Top . DOCKERINIT ) ; org . arquillian . cube . docker . impl . util . Top top = new org . arquillian . cube . docker . impl . util . Top ( temporaryFolder . getRoot ( ) . getAbsolutePath ( ) , temporaryFolder . getRoot ( ) . getAbsolutePath ( ) ) ; \"<AssertPlaceHolder>\" ; } isSpinning ( ) { return ( ( dockerEnvPath . exists ( ) ) && ( dockerInitPath . exists ( ) ) ) && ( dockerSocketFile . exists ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( top . isSpinning ( ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getImports ( ) { return org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . nullSafeArray ( imports ) ; }", "testMethod": "afterPropertiesSetCreatesSnapshotServiceAdapterAndDoesImportWithConfiguredImports ( ) { org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotMetadata expectedSnapshotMetadata = newSnapshotMetadata ( ) ; org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotServiceAdapter mockSnapshotService = org . mockito . Mockito . mock ( org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotServiceAdapter . class , \"MockSnapshotServiceAdapter\" ) ; org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean factoryBean = new org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean ( ) { @ org . springframework . data . gemfire . snapshot . Override protected org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotServiceAdapter create ( ) { return mockSnapshotService ; } } ; factoryBean . setImports ( toArray ( expectedSnapshotMetadata ) ) ; factoryBean . afterPropertiesSet ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( mockSnapshotService , org . mockito . Mockito . times ( 1 ) ) . doImport ( org . mockito . ArgumentMatchers . eq ( expectedSnapshotMetadata ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( factoryBean . getImports ( ) [ 0 ] , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expectedSnapshotMetadata ) ) )", "total": "afterPropertiesSetCreatesSnapshotServiceAdapterAndDoesImportWithConfiguredImports ( ) { org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotMetadata expectedSnapshotMetadata = newSnapshotMetadata ( ) ; org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotServiceAdapter mockSnapshotService = org . mockito . Mockito . mock ( org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotServiceAdapter . class , \"MockSnapshotServiceAdapter\" ) ; org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean factoryBean = new org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean ( ) { @ org . springframework . data . gemfire . snapshot . Override protected org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . SnapshotServiceAdapter create ( ) { return mockSnapshotService ; } } ; factoryBean . setImports ( toArray ( expectedSnapshotMetadata ) ) ; factoryBean . afterPropertiesSet ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( mockSnapshotService , org . mockito . Mockito . times ( 1 ) ) . doImport ( org . mockito . ArgumentMatchers . eq ( expectedSnapshotMetadata ) ) ; } getImports ( ) { return org . springframework . data . gemfire . snapshot . SnapshotServiceFactoryBean . nullSafeArray ( imports ) ; }", "answer": "org . junit . Assert . assertThat ( factoryBean . getImports ( ) [ 0 ] , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expectedSnapshotMetadata ) ) )"}
{"focal": "createConnection ( java . util . Properties , javax . sql . DataSource ) { org . pentaho . reporting . engine . classic . extensions . datasources . mondrian . DefaultMondrianConnectionProvider . logger . debug ( ( \"Creating<sp>Mondrian<sp>connection:<sp>\" + ( mondrian . olap . Util . parseConnectString ( computeConnectionString ( properties ) ) ) ) ) ; return mondrian . olap . DriverManager . getConnection ( mondrian . olap . Util . parseConnectString ( computeConnectionString ( properties ) ) , null , dataSource ) ; }", "testMethod": "testCreateConnection ( ) { java . sql . Connection connection = mock ( java . sql . Connection . class ) ; org . pentaho . reporting . engine . classic . core . modules . misc . datafactory . sql . StaticConnectionProvider provider = new org . pentaho . reporting . engine . classic . core . modules . misc . datafactory . sql . StaticConnectionProvider ( connection ) ; java . sql . Connection result = provider . createConnection ( \"user\" , \"password\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( connection ) ) )", "total": "testCreateConnection ( ) { java . sql . Connection connection = mock ( java . sql . Connection . class ) ; org . pentaho . reporting . engine . classic . core . modules . misc . datafactory . sql . StaticConnectionProvider provider = new org . pentaho . reporting . engine . classic . core . modules . misc . datafactory . sql . StaticConnectionProvider ( connection ) ; java . sql . Connection result = provider . createConnection ( \"user\" , \"password\" ) ; \"<AssertPlaceHolder>\" ; } createConnection ( java . util . Properties , javax . sql . DataSource ) { org . pentaho . reporting . engine . classic . extensions . datasources . mondrian . DefaultMondrianConnectionProvider . logger . debug ( ( \"Creating<sp>Mondrian<sp>connection:<sp>\" + ( mondrian . olap . Util . parseConnectString ( computeConnectionString ( properties ) ) ) ) ) ; return mondrian . olap . DriverManager . getConnection ( mondrian . olap . Util . parseConnectString ( computeConnectionString ( properties ) ) , null , dataSource ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( connection ) ) )"}
{"focal": "addToIndex ( org . springframework . jdbc . core . JdbcTemplate , net . ripe . db . whois . common . dao . RpslObjectInfo , net . ripe . db . whois . common . rpsl . RpslObject , java . lang . String ) { final net . ripe . db . whois . common . dao . jdbc . index . IndexStrategy referenceStrategy = net . ripe . db . whois . common . dao . jdbc . index . IndexStrategies . get ( getReferenceAttribute ( object . getType ( ) ) ) ; final net . ripe . db . whois . common . dao . RpslObjectInfo reference = uniqueResult ( referenceStrategy . findInIndex ( jdbcTemplate , value ) ) ; if ( reference == null ) { throw new java . lang . IllegalArgumentException ( ( \"Referenced<sp>object<sp>does<sp>not<sp>exist:<sp>\" + value ) ) ; } return addToIndex ( jdbcTemplate , objectInfo , reference ) ; }", "testMethod": "add_to_index_does_not_exist ( ) { net . ripe . db . whois . common . dao . RpslObjectInfo role = new net . ripe . db . whois . common . dao . RpslObjectInfo ( 1 , net . ripe . db . whois . common . rpsl . ObjectType . ROLE , \"NIC-TEST\" ) ; subject = new net . ripe . db . whois . common . dao . jdbc . index . IndexWithValue ( net . ripe . db . whois . common . rpsl . AttributeType . NIC_HDL , \"person_role\" , \"nic_hdl\" ) ; final int added = subject . addToIndex ( whoisTemplate , role , null , \"NIC-TEST\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( added , org . hamcrest . core . Is . is ( 1 ) )", "total": "add_to_index_does_not_exist ( ) { net . ripe . db . whois . common . dao . RpslObjectInfo role = new net . ripe . db . whois . common . dao . RpslObjectInfo ( 1 , net . ripe . db . whois . common . rpsl . ObjectType . ROLE , \"NIC-TEST\" ) ; subject = new net . ripe . db . whois . common . dao . jdbc . index . IndexWithValue ( net . ripe . db . whois . common . rpsl . AttributeType . NIC_HDL , \"person_role\" , \"nic_hdl\" ) ; final int added = subject . addToIndex ( whoisTemplate , role , null , \"NIC-TEST\" ) ; \"<AssertPlaceHolder>\" ; } addToIndex ( org . springframework . jdbc . core . JdbcTemplate , net . ripe . db . whois . common . dao . RpslObjectInfo , net . ripe . db . whois . common . rpsl . RpslObject , java . lang . String ) { final net . ripe . db . whois . common . dao . jdbc . index . IndexStrategy referenceStrategy = net . ripe . db . whois . common . dao . jdbc . index . IndexStrategies . get ( getReferenceAttribute ( object . getType ( ) ) ) ; final net . ripe . db . whois . common . dao . RpslObjectInfo reference = uniqueResult ( referenceStrategy . findInIndex ( jdbcTemplate , value ) ) ; if ( reference == null ) { throw new java . lang . IllegalArgumentException ( ( \"Referenced<sp>object<sp>does<sp>not<sp>exist:<sp>\" + value ) ) ; } return addToIndex ( jdbcTemplate , objectInfo , reference ) ; }", "answer": "org . junit . Assert . assertThat ( added , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "is ( java . lang . String ) { return isAnd ( IsEvaluator . IS_EVALUATOR , selector ) ; }", "testMethod": "not_eq__should_return_null_when_result_of_not_is_empty_no_matter_what_index_eq_is_applied_to ( ) { java . lang . String text = io . github . seleniumquery . SeleniumQuery . $ ( \"div:not(div):eq(1)\" ) . text ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( text , org . hamcrest . Matchers . is ( \"\" ) )", "total": "not_eq__should_return_null_when_result_of_not_is_empty_no_matter_what_index_eq_is_applied_to ( ) { java . lang . String text = io . github . seleniumquery . SeleniumQuery . $ ( \"div:not(div):eq(1)\" ) . text ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { return isAnd ( IsEvaluator . IS_EVALUATOR , selector ) ; }", "answer": "org . junit . Assert . assertThat ( text , org . hamcrest . Matchers . is ( \"\" ) )"}
{"focal": "upload ( org . mifos . platform . questionnaire . ui . model . UploadQuestionGroupForm , org . springframework . webflow . execution . RequestContext ) { java . lang . String result = \"success\" ; if ( selectedCountryNotPresent ( uploadQuestionGroupForm . getSelectedCountry ( ) ) ) { constructErrorMessage ( requestContext . getMessageContext ( ) , \"questionnaire.error.ppi.country\" , \"selectedCountry\" , \"Please<sp>specify<sp>the<sp>Country\" ) ; result = \"failure\" ; } else { try { questionnaireServiceFacade . uploadPPIQuestionGroup ( uploadQuestionGroupForm . getSelectedCountry ( ) ) ; } catch ( org . mifos . platform . validations . ValidationException e ) { handleValidationException ( e , requestContext ) ; result = \"failure\" ; } catch ( org . mifos . framework . exceptions . SystemException e ) { constructErrorMessage ( requestContext . getMessageContext ( ) , e . getKey ( ) , \"selectedCountry\" , e . getKey ( ) ) ; result = \"failure\" ; } catch ( java . lang . Exception e ) { constructAndLogSystemError ( requestContext . getMessageContext ( ) , new org . mifos . framework . exceptions . SystemException ( e . getMessage ( ) , e ) ) ; result = \"failure\" ; } } return result ; }", "testMethod": "testUploadQuestionGroup_UploadFailureDueToGenericError ( ) { when ( requestContext . getMessageContext ( ) ) . thenReturn ( messageContext ) ; java . lang . String exceptionCode = \"Random<sp>Exception\" ; doThrow ( new java . lang . RuntimeException ( exceptionCode ) ) . when ( questionnaireServiceFacade ) . uploadPPIQuestionGroup ( \"INDIA\" ) ; org . mifos . platform . questionnaire . ui . model . UploadQuestionGroupForm form = new org . mifos . platform . questionnaire . ui . model . UploadQuestionGroupForm ( ) ; form . setSelectedCountry ( \"INDIA\" ) ; java . lang . String result = controller . upload ( form , requestContext ) ; \"<AssertPlaceHolder>\" ; verify ( requestContext ) . getMessageContext ( ) ; verify ( messageContext ) . addMessage ( argThat ( new org . mifos . platform . matchers . MessageMatcher ( exceptionCode ) ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( \"failure\" ) )", "total": "testUploadQuestionGroup_UploadFailureDueToGenericError ( ) { when ( requestContext . getMessageContext ( ) ) . thenReturn ( messageContext ) ; java . lang . String exceptionCode = \"Random<sp>Exception\" ; doThrow ( new java . lang . RuntimeException ( exceptionCode ) ) . when ( questionnaireServiceFacade ) . uploadPPIQuestionGroup ( \"INDIA\" ) ; org . mifos . platform . questionnaire . ui . model . UploadQuestionGroupForm form = new org . mifos . platform . questionnaire . ui . model . UploadQuestionGroupForm ( ) ; form . setSelectedCountry ( \"INDIA\" ) ; java . lang . String result = controller . upload ( form , requestContext ) ; \"<AssertPlaceHolder>\" ; verify ( requestContext ) . getMessageContext ( ) ; verify ( messageContext ) . addMessage ( argThat ( new org . mifos . platform . matchers . MessageMatcher ( exceptionCode ) ) ) ; } upload ( org . mifos . platform . questionnaire . ui . model . UploadQuestionGroupForm , org . springframework . webflow . execution . RequestContext ) { java . lang . String result = \"success\" ; if ( selectedCountryNotPresent ( uploadQuestionGroupForm . getSelectedCountry ( ) ) ) { constructErrorMessage ( requestContext . getMessageContext ( ) , \"questionnaire.error.ppi.country\" , \"selectedCountry\" , \"Please<sp>specify<sp>the<sp>Country\" ) ; result = \"failure\" ; } else { try { questionnaireServiceFacade . uploadPPIQuestionGroup ( uploadQuestionGroupForm . getSelectedCountry ( ) ) ; } catch ( org . mifos . platform . validations . ValidationException e ) { handleValidationException ( e , requestContext ) ; result = \"failure\" ; } catch ( org . mifos . framework . exceptions . SystemException e ) { constructErrorMessage ( requestContext . getMessageContext ( ) , e . getKey ( ) , \"selectedCountry\" , e . getKey ( ) ) ; result = \"failure\" ; } catch ( java . lang . Exception e ) { constructAndLogSystemError ( requestContext . getMessageContext ( ) , new org . mifos . framework . exceptions . SystemException ( e . getMessage ( ) , e ) ) ; result = \"failure\" ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( \"failure\" ) )"}
{"focal": "is ( java . lang . String ) { return org . tessell . generators . css . JavaKeywords . keywords . contains ( keyword ) ; }", "testMethod": "derivedItselfDoesNotFireChangedIfPropertyAlreadySet ( ) { f . name . set ( \"foo\" ) ; final org . tessell . tests . model . properties . DerivedPropertiesTest . CountChanged < java . lang . Integer > count = new org . tessell . tests . model . properties . DerivedPropertiesTest . CountChanged < java . lang . Integer > ( ) ; f . name . remaining ( ) . addPropertyChangedHandler ( count ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count . count , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "derivedItselfDoesNotFireChangedIfPropertyAlreadySet ( ) { f . name . set ( \"foo\" ) ; final org . tessell . tests . model . properties . DerivedPropertiesTest . CountChanged < java . lang . Integer > count = new org . tessell . tests . model . properties . DerivedPropertiesTest . CountChanged < java . lang . Integer > ( ) ; f . name . remaining ( ) . addPropertyChangedHandler ( count ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { return org . tessell . generators . css . JavaKeywords . keywords . contains ( keyword ) ; }", "answer": "org . junit . Assert . assertThat ( count . count , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getDestination ( ) { return \"jms.queue.box\" ; }", "testMethod": "testSendingMessagesWithTrailingLine ( ) { options . setTrailingLine ( true ) ; java . util . concurrent . atomic . AtomicReference < io . vertx . ext . stomp . impl . Frame > ref = new java . util . concurrent . atomic . AtomicReference ( ) ; io . vertx . ext . stomp . impl . StompClient client = io . vertx . ext . stomp . impl . StompClient . create ( vertx , new io . vertx . ext . stomp . impl . StompClientOptions ( ) . setTrailingLine ( true ) ) ; client . connect ( ( ar ) -> { if ( ar . failed ( ) ) { return ; } ar . result ( ) . send ( \"/hello\" , io . vertx . core . buffer . Buffer . buffer ( \"this<sp>is<sp>my<sp>content\" ) , ref :: set ) ; } ) ; await ( ) . atMost ( 5 , TimeUnit . SECONDS ) . untilAtomic ( ref , org . hamcrest . Matchers . notNullValue ( io . vertx . ext . stomp . impl . Frame . class ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"/hello\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( ref . get ( ) . getDestination ( ) )", "total": "testSendingMessagesWithTrailingLine ( ) { options . setTrailingLine ( true ) ; java . util . concurrent . atomic . AtomicReference < io . vertx . ext . stomp . impl . Frame > ref = new java . util . concurrent . atomic . AtomicReference ( ) ; io . vertx . ext . stomp . impl . StompClient client = io . vertx . ext . stomp . impl . StompClient . create ( vertx , new io . vertx . ext . stomp . impl . StompClientOptions ( ) . setTrailingLine ( true ) ) ; client . connect ( ( ar ) -> { if ( ar . failed ( ) ) { return ; } ar . result ( ) . send ( \"/hello\" , io . vertx . core . buffer . Buffer . buffer ( \"this<sp>is<sp>my<sp>content\" ) , ref :: set ) ; } ) ; await ( ) . atMost ( 5 , TimeUnit . SECONDS ) . untilAtomic ( ref , org . hamcrest . Matchers . notNullValue ( io . vertx . ext . stomp . impl . Frame . class ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"/hello\" ) ; } getDestination ( ) { return \"jms.queue.box\" ; }", "answer": "org . junit . Assert . assertThat ( ref . get ( ) . getDestination ( ) )"}
{"focal": "success ( ) { return 42 ; }", "testMethod": "testCloseableShouldBeClosedAfterConsumption ( ) { verify ( closeableMock , never ( ) ) . close ( ) ; final int result = com . lambdista . util . Try . apply ( ( closeable ) -> success ( ) ) . apply ( closeableMock ) . get ( ) ; verify ( closeableMock ) . close ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 42 ) ) )", "total": "testCloseableShouldBeClosedAfterConsumption ( ) { verify ( closeableMock , never ( ) ) . close ( ) ; final int result = com . lambdista . util . Try . apply ( ( closeable ) -> success ( ) ) . apply ( closeableMock ) . get ( ) ; verify ( closeableMock ) . close ( ) ; \"<AssertPlaceHolder>\" ; } success ( ) { return 42 ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 42 ) ) )"}
{"focal": "getBucket ( ) { return bucket ; }", "testMethod": "testToDeployConfiguration_bucketNameContainsProtocol ( ) { when ( preferences . get ( eq ( DeployPreferences . PREF_CUSTOM_BUCKET ) , anyString ( ) ) ) . thenReturn ( \"gs://bucket\" ) ; com . google . cloud . tools . appengine . configuration . DeployConfiguration configuration = com . google . cloud . tools . eclipse . appengine . deploy . DeployPreferencesConverter . toDeployConfiguration ( new com . google . cloud . tools . eclipse . appengine . deploy . DeployPreferences ( preferences ) , deployables ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( configuration . getBucket ( ) , org . hamcrest . CoreMatchers . is ( \"gs://bucket\" ) )", "total": "testToDeployConfiguration_bucketNameContainsProtocol ( ) { when ( preferences . get ( eq ( DeployPreferences . PREF_CUSTOM_BUCKET ) , anyString ( ) ) ) . thenReturn ( \"gs://bucket\" ) ; com . google . cloud . tools . appengine . configuration . DeployConfiguration configuration = com . google . cloud . tools . eclipse . appengine . deploy . DeployPreferencesConverter . toDeployConfiguration ( new com . google . cloud . tools . eclipse . appengine . deploy . DeployPreferences ( preferences ) , deployables ) ; \"<AssertPlaceHolder>\" ; } getBucket ( ) { return bucket ; }", "answer": "org . junit . Assert . assertThat ( configuration . getBucket ( ) , org . hamcrest . CoreMatchers . is ( \"gs://bucket\" ) )"}
{"focal": "getIndexIds ( ) { java . lang . Object [ ] ids = getIds ( ) ; java . util . List < java . lang . Integer > indices = new java . util . ArrayList < java . lang . Integer > ( ids . length ) ; for ( java . lang . Object id : ids ) { int int32Id = org . mozilla . javascript . ScriptRuntime . toInt32 ( id ) ; if ( ( int32Id >= 0 ) && ( org . mozilla . javascript . ScriptRuntime . toString ( int32Id ) . equals ( org . mozilla . javascript . ScriptRuntime . toString ( id ) ) ) ) { indices . add ( int32Id ) ; } } return indices . toArray ( new java . lang . Integer [ indices . size ( ) ] ) ; }", "testMethod": "getIndexIdsShouldNotReturnNonNumericIds ( ) { array . put ( \"x\" , array , \"a\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( array . getIndexIds ( ) , org . hamcrest . core . Is . is ( new java . lang . Integer [ ] { } ) )", "total": "getIndexIdsShouldNotReturnNonNumericIds ( ) { array . put ( \"x\" , array , \"a\" ) ; \"<AssertPlaceHolder>\" ; } getIndexIds ( ) { java . lang . Object [ ] ids = getIds ( ) ; java . util . List < java . lang . Integer > indices = new java . util . ArrayList < java . lang . Integer > ( ids . length ) ; for ( java . lang . Object id : ids ) { int int32Id = org . mozilla . javascript . ScriptRuntime . toInt32 ( id ) ; if ( ( int32Id >= 0 ) && ( org . mozilla . javascript . ScriptRuntime . toString ( int32Id ) . equals ( org . mozilla . javascript . ScriptRuntime . toString ( id ) ) ) ) { indices . add ( int32Id ) ; } } return indices . toArray ( new java . lang . Integer [ indices . size ( ) ] ) ; }", "answer": "org . junit . Assert . assertThat ( array . getIndexIds ( ) , org . hamcrest . core . Is . is ( new java . lang . Integer [ ] { } ) )"}
{"focal": "buildQuery ( java . lang . String , org . springframework . data . repository . query . Parameters , java . lang . Object [ ] ) { java . lang . String replacedRawQuery = rawQuery ; for ( java . util . Iterator < org . springframework . data . repository . query . Parameter > iterator = parameters . iterator ( ) ; iterator . hasNext ( ) ; ) { org . springframework . data . repository . query . Parameter eachParameter = iterator . next ( ) ; if ( ( org . springframework . data . domain . Pageable . class . isAssignableFrom ( eachParameter . getType ( ) ) ) || ( org . springframework . data . domain . Sort . class . isAssignableFrom ( eachParameter . getType ( ) ) ) ) { continue ; } replacedRawQuery = org . springframework . data . simpledb . query . QueryUtils . replaceOneParameterInQuery ( replacedRawQuery , eachParameter , parameterValues [ eachParameter . getIndex ( ) ] ) ; } return replacedRawQuery . trim ( ) ; }", "testMethod": "buildQueryConditionsWithParameters_should_construct_tricky_query_for_in_operator ( ) { final java . lang . String bind_query = \"select<sp>*<sp>from<sp>customer_all<sp>WHERE<sp>age<sp>in<sp>('1','2')<sp>and<sp>age=?\" ; final long firstAge = 23 ; final java . lang . String convertedFirstAge = org . springframework . data . simpledb . attributeutil . SimpleDBAttributeConverter . encode ( firstAge ) ; java . lang . String expectedQuery = ( \"select<sp>*<sp>from<sp>customer_all<sp>WHERE<sp>age<sp>in<sp>('1','2')<sp>and<sp>age='\" + convertedFirstAge ) + \"'\" ; final org . springframework . data . repository . query . Parameters parameters = getMockParameters ( new java . lang . String [ ] { \"?\" } , new java . lang . Class [ ] { long . class } ) ; java . lang . String resultedQuery = org . springframework . data . simpledb . query . QueryUtils . buildQuery ( bind_query , parameters , firstAge ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultedQuery , org . hamcrest . CoreMatchers . is ( expectedQuery ) )", "total": "buildQueryConditionsWithParameters_should_construct_tricky_query_for_in_operator ( ) { final java . lang . String bind_query = \"select<sp>*<sp>from<sp>customer_all<sp>WHERE<sp>age<sp>in<sp>('1','2')<sp>and<sp>age=?\" ; final long firstAge = 23 ; final java . lang . String convertedFirstAge = org . springframework . data . simpledb . attributeutil . SimpleDBAttributeConverter . encode ( firstAge ) ; java . lang . String expectedQuery = ( \"select<sp>*<sp>from<sp>customer_all<sp>WHERE<sp>age<sp>in<sp>('1','2')<sp>and<sp>age='\" + convertedFirstAge ) + \"'\" ; final org . springframework . data . repository . query . Parameters parameters = getMockParameters ( new java . lang . String [ ] { \"?\" } , new java . lang . Class [ ] { long . class } ) ; java . lang . String resultedQuery = org . springframework . data . simpledb . query . QueryUtils . buildQuery ( bind_query , parameters , firstAge ) ; \"<AssertPlaceHolder>\" ; } buildQuery ( java . lang . String , org . springframework . data . repository . query . Parameters , java . lang . Object [ ] ) { java . lang . String replacedRawQuery = rawQuery ; for ( java . util . Iterator < org . springframework . data . repository . query . Parameter > iterator = parameters . iterator ( ) ; iterator . hasNext ( ) ; ) { org . springframework . data . repository . query . Parameter eachParameter = iterator . next ( ) ; if ( ( org . springframework . data . domain . Pageable . class . isAssignableFrom ( eachParameter . getType ( ) ) ) || ( org . springframework . data . domain . Sort . class . isAssignableFrom ( eachParameter . getType ( ) ) ) ) { continue ; } replacedRawQuery = org . springframework . data . simpledb . query . QueryUtils . replaceOneParameterInQuery ( replacedRawQuery , eachParameter , parameterValues [ eachParameter . getIndex ( ) ] ) ; } return replacedRawQuery . trim ( ) ; }", "answer": "org . junit . Assert . assertThat ( resultedQuery , org . hamcrest . CoreMatchers . is ( expectedQuery ) )"}
{"focal": "getServer ( org . eclipse . wst . server . core . IServer ) { checkStarted ( ) ; org . teiid . core . designer . util . CoreArgCheck . isNotNull ( parentServer , \"parentServer\" ) ; for ( org . teiid . designer . runtime . spi . ITeiidServer teiidServer : getServers ( ) ) { if ( parentServer . equals ( teiidServer . getParent ( ) ) ) { return teiidServer ; } } return null ; }", "testMethod": "shouldGetServerById ( ) { java . lang . String serverId = \"mm://server:4321-8.2-12345\" ; this . mgr . addServer ( server1 ) ; when ( server1 . getId ( ) ) . thenReturn ( serverId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . mgr . getServer ( serverId ) , org . hamcrest . core . Is . is ( server1 ) )", "total": "shouldGetServerById ( ) { java . lang . String serverId = \"mm://server:4321-8.2-12345\" ; this . mgr . addServer ( server1 ) ; when ( server1 . getId ( ) ) . thenReturn ( serverId ) ; \"<AssertPlaceHolder>\" ; } getServer ( org . eclipse . wst . server . core . IServer ) { checkStarted ( ) ; org . teiid . core . designer . util . CoreArgCheck . isNotNull ( parentServer , \"parentServer\" ) ; for ( org . teiid . designer . runtime . spi . ITeiidServer teiidServer : getServers ( ) ) { if ( parentServer . equals ( teiidServer . getParent ( ) ) ) { return teiidServer ; } } return null ; }", "answer": "org . junit . Assert . assertThat ( this . mgr . getServer ( serverId ) , org . hamcrest . core . Is . is ( server1 ) )"}
{"focal": "isRegistrationAdmitted ( fr . xephi . authme . process . register . executors . TwoFactorRegisterParams ) { return true ; }", "testMethod": "shouldCheckPasswordValidity ( ) { java . lang . String password = \"myPass\" ; java . lang . String name = \"player040\" ; given ( validationService . validatePassword ( password , name ) ) . willReturn ( new fr . xephi . authme . service . ValidationService . ValidationResult ( ) ) ; org . bukkit . entity . Player player = fr . xephi . authme . process . register . executors . PasswordRegisterExecutorTest . mockPlayerWithName ( name ) ; fr . xephi . authme . process . register . executors . PasswordRegisterParams params = fr . xephi . authme . process . register . executors . PasswordRegisterParams . of ( player , password , null ) ; boolean result = executor . isRegistrationAdmitted ( params ) ; \"<AssertPlaceHolder>\" ; verify ( validationService ) . validatePassword ( password , name ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldCheckPasswordValidity ( ) { java . lang . String password = \"myPass\" ; java . lang . String name = \"player040\" ; given ( validationService . validatePassword ( password , name ) ) . willReturn ( new fr . xephi . authme . service . ValidationService . ValidationResult ( ) ) ; org . bukkit . entity . Player player = fr . xephi . authme . process . register . executors . PasswordRegisterExecutorTest . mockPlayerWithName ( name ) ; fr . xephi . authme . process . register . executors . PasswordRegisterParams params = fr . xephi . authme . process . register . executors . PasswordRegisterParams . of ( player , password , null ) ; boolean result = executor . isRegistrationAdmitted ( params ) ; \"<AssertPlaceHolder>\" ; verify ( validationService ) . validatePassword ( password , name ) ; } isRegistrationAdmitted ( fr . xephi . authme . process . register . executors . TwoFactorRegisterParams ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "count ( ) { throw new java . lang . UnsupportedOperationException ( ) ; }", "testMethod": "testInsertVars ( ) { int before = count ( ) ; repository . saveVars ( \"mOer\" , 28 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count ( ) , org . hamcrest . CoreMatchers . is ( ( before + 1 ) ) )", "total": "testInsertVars ( ) { int before = count ( ) ; repository . saveVars ( \"mOer\" , 28 ) ; \"<AssertPlaceHolder>\" ; } count ( ) { throw new java . lang . UnsupportedOperationException ( ) ; }", "answer": "org . junit . Assert . assertThat ( count ( ) , org . hamcrest . CoreMatchers . is ( ( before + 1 ) ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "readOrder ( ) { com . oreilly . springdata . gemfire . core . Product iPad = productRepository . findByName ( \"iPad\" ) . get ( 0 ) ; com . oreilly . springdata . gemfire . core . Customer dave = customerRepository . findByEmailAddress ( new com . oreilly . springdata . gemfire . core . EmailAddress ( \"dave@dmband.com\" ) ) ; java . util . List < com . oreilly . springdata . gemfire . order . Order > orders = orderRepository . findByCustomerId ( dave . getId ( ) ) ; org . hamcrest . Matcher < java . lang . Iterable < ? super com . oreilly . springdata . gemfire . order . Order > > hasOrderForiPad = containsOrder ( with ( LineItem ( with ( ProductId ( equalTo ( iPad . getId ( ) ) ) ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( orders , hasOrderForiPad )", "total": "readOrder ( ) { com . oreilly . springdata . gemfire . core . Product iPad = productRepository . findByName ( \"iPad\" ) . get ( 0 ) ; com . oreilly . springdata . gemfire . core . Customer dave = customerRepository . findByEmailAddress ( new com . oreilly . springdata . gemfire . core . EmailAddress ( \"dave@dmband.com\" ) ) ; java . util . List < com . oreilly . springdata . gemfire . order . Order > orders = orderRepository . findByCustomerId ( dave . getId ( ) ) ; org . hamcrest . Matcher < java . lang . Iterable < ? super com . oreilly . springdata . gemfire . order . Order > > hasOrderForiPad = containsOrder ( with ( LineItem ( with ( ProductId ( equalTo ( iPad . getId ( ) ) ) ) ) ) ) ; \"<AssertPlaceHolder>\" ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( orders , hasOrderForiPad )"}
{"focal": "isDaylightSaving ( net . time4j . base . UnixTime ) { return false ; }", "testMethod": "isDaylightSavingSTD ( ) { net . time4j . tz . Timezone tz = net . time4j . tz . PlatformTimezoneTest . loadFromPlatform ( \"Europe/Berlin\" ) ; net . time4j . Moment utc = net . time4j . Moment . of ( ( ( 40 * 365 ) * 86400 ) , TimeScale . POSIX ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tz . isDaylightSaving ( utc ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "isDaylightSavingSTD ( ) { net . time4j . tz . Timezone tz = net . time4j . tz . PlatformTimezoneTest . loadFromPlatform ( \"Europe/Berlin\" ) ; net . time4j . Moment utc = net . time4j . Moment . of ( ( ( 40 * 365 ) * 86400 ) , TimeScale . POSIX ) ; \"<AssertPlaceHolder>\" ; } isDaylightSaving ( net . time4j . base . UnixTime ) { return false ; }", "answer": "org . junit . Assert . assertThat ( tz . isDaylightSaving ( utc ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldReturnFalseGivenDocumentWithIdDoesNotExist ( ) { java . util . UUID documentId = java . util . UUID . randomUUID ( ) ; boolean exist = repository . existsById ( documentId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( exist , is ( false ) )", "total": "shouldReturnFalseGivenDocumentWithIdDoesNotExist ( ) { java . util . UUID documentId = java . util . UUID . randomUUID ( ) ; boolean exist = repository . existsById ( documentId ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( exist , is ( false ) )"}
{"focal": "isNull ( ) { return nullValue ; }", "testMethod": "writableOption ( ) { com . asakusafw . runtime . value . DateOption option = new com . asakusafw . runtime . value . DateOption ( ) ; com . asakusafw . runtime . value . DateOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . isNull ( ) , is ( true ) )", "total": "writableOption ( ) { com . asakusafw . runtime . value . DateOption option = new com . asakusafw . runtime . value . DateOption ( ) ; com . asakusafw . runtime . value . DateOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } isNull ( ) { return nullValue ; }", "answer": "org . junit . Assert . assertThat ( restored . isNull ( ) , is ( true ) )"}
{"focal": "store ( javax . ws . rs . core . Request , javax . ws . rs . core . HttpHeaders , com . wesabe . grendel . auth . Credentials , java . lang . String , java . lang . String , byte [ ] ) { final com . wesabe . grendel . auth . Session session = credentials . buildSession ( userDAO , userId ) ; com . wesabe . grendel . entities . Document doc = documentDAO . findByOwnerAndName ( session . getUser ( ) , name ) ; if ( doc == null ) { doc = documentDAO . newDocument ( session . getUser ( ) , name , headers . getMediaType ( ) ) ; } else { checkPreconditions ( request , doc ) ; } doc . setModifiedAt ( new org . joda . time . DateTime ( org . joda . time . DateTimeZone . UTC ) ) ; doc . encryptAndSetBody ( session . getKeySet ( ) , randomProvider . get ( ) , body ) ; documentDAO . saveOrUpdate ( doc ) ; return javax . ws . rs . core . Response . noContent ( ) . tag ( doc . getEtag ( ) ) . build ( ) ; }", "testMethod": "itCreatesANewDocumentIfTheDocumentDoesntExist ( ) { when ( documentDAO . findByOwnerAndName ( user , \"document1.txt\" ) ) . thenReturn ( null ) ; final javax . ws . rs . core . Response response = resource . store ( request , headers , credentials , \"bob\" , \"document1.txt\" , body ) ; \"<AssertPlaceHolder>\" . isEqualTo ( Status . NO_CONTENT . getStatusCode ( ) ) ; final org . mockito . InOrder inOrder = inOrder ( document , documentDAO ) ; inOrder . verify ( document ) . setModifiedAt ( now ) ; inOrder . verify ( document ) . encryptAndSetBody ( keySet , random , body ) ; inOrder . verify ( documentDAO ) . saveOrUpdate ( document ) ; }", "assertLine": "org . junit . Assert . assertThat ( response . getStatus ( ) )", "total": "itCreatesANewDocumentIfTheDocumentDoesntExist ( ) { when ( documentDAO . findByOwnerAndName ( user , \"document1.txt\" ) ) . thenReturn ( null ) ; final javax . ws . rs . core . Response response = resource . store ( request , headers , credentials , \"bob\" , \"document1.txt\" , body ) ; \"<AssertPlaceHolder>\" . isEqualTo ( Status . NO_CONTENT . getStatusCode ( ) ) ; final org . mockito . InOrder inOrder = inOrder ( document , documentDAO ) ; inOrder . verify ( document ) . setModifiedAt ( now ) ; inOrder . verify ( document ) . encryptAndSetBody ( keySet , random , body ) ; inOrder . verify ( documentDAO ) . saveOrUpdate ( document ) ; } store ( javax . ws . rs . core . Request , javax . ws . rs . core . HttpHeaders , com . wesabe . grendel . auth . Credentials , java . lang . String , java . lang . String , byte [ ] ) { final com . wesabe . grendel . auth . Session session = credentials . buildSession ( userDAO , userId ) ; com . wesabe . grendel . entities . Document doc = documentDAO . findByOwnerAndName ( session . getUser ( ) , name ) ; if ( doc == null ) { doc = documentDAO . newDocument ( session . getUser ( ) , name , headers . getMediaType ( ) ) ; } else { checkPreconditions ( request , doc ) ; } doc . setModifiedAt ( new org . joda . time . DateTime ( org . joda . time . DateTimeZone . UTC ) ) ; doc . encryptAndSetBody ( session . getKeySet ( ) , randomProvider . get ( ) , body ) ; documentDAO . saveOrUpdate ( doc ) ; return javax . ws . rs . core . Response . noContent ( ) . tag ( doc . getEtag ( ) ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( response . getStatus ( ) )"}
{"focal": "pokes ( ) { org . junit . Assert . assertThat ( facebook . pokes ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . PokeMethods . class ) ) ; }", "testMethod": "pokes ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( facebook . pokes ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . PokeMethods . class ) )", "total": "pokes ( ) { \"<AssertPlaceHolder>\" ; } pokes ( ) { org . junit . Assert . assertThat ( facebook . pokes ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . PokeMethods . class ) ) ; }", "answer": "org . junit . Assert . assertThat ( facebook . pokes ( ) , org . hamcrest . CoreMatchers . instanceOf ( facebook4j . PokeMethods . class ) )"}
{"focal": "clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "testMethod": "testJsonSerialization ( ) { org . batfish . datamodel . packet_policy . If ifExpr = new org . batfish . datamodel . packet_policy . If ( new org . batfish . datamodel . packet_policy . PacketMatchExpr ( org . batfish . datamodel . acl . FalseExpr . INSTANCE ) , com . google . common . collect . ImmutableList . of ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( ifExpr , org . batfish . datamodel . packet_policy . If . class ) , org . hamcrest . Matchers . equalTo ( ifExpr ) )", "total": "testJsonSerialization ( ) { org . batfish . datamodel . packet_policy . If ifExpr = new org . batfish . datamodel . packet_policy . If ( new org . batfish . datamodel . packet_policy . PacketMatchExpr ( org . batfish . datamodel . acl . FalseExpr . INSTANCE ) , com . google . common . collect . ImmutableList . of ( ) ) ; \"<AssertPlaceHolder>\" ; } clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "answer": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( ifExpr , org . batfish . datamodel . packet_policy . If . class ) , org . hamcrest . Matchers . equalTo ( ifExpr ) )"}
{"focal": "equalTo ( java . util . List ) { return org . codice . ddf . catalog . ui . forms . builder . XmlModelBuilder . FACTORY . createPropertyIsEqualTo ( org . codice . ddf . catalog . ui . forms . builder . XmlModelBuilder . Mapper . binaryComparisonType ( children ) ) ; }", "testMethod": "testDoConditionallyPrivilegedSupplierAndFalseCondition ( ) { final java . lang . String result = org . codice . ddf . configuration . migration . AccessUtils . doConditionallyPrivileged ( false , ( ) -> org . codice . ddf . configuration . migration . AccessUtilsTest . RESULT ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( org . codice . ddf . configuration . migration . AccessUtilsTest . RESULT ) )", "total": "testDoConditionallyPrivilegedSupplierAndFalseCondition ( ) { final java . lang . String result = org . codice . ddf . configuration . migration . AccessUtils . doConditionallyPrivileged ( false , ( ) -> org . codice . ddf . configuration . migration . AccessUtilsTest . RESULT ) ; \"<AssertPlaceHolder>\" ; } equalTo ( java . util . List ) { return org . codice . ddf . catalog . ui . forms . builder . XmlModelBuilder . FACTORY . createPropertyIsEqualTo ( org . codice . ddf . catalog . ui . forms . builder . XmlModelBuilder . Mapper . binaryComparisonType ( children ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( org . codice . ddf . configuration . migration . AccessUtilsTest . RESULT ) )"}
{"focal": "changeSize ( ) { return changeCounter . value ( ) ; }", "testMethod": "shouldCountChanges ( ) { org . neo4j . kernel . impl . transaction . state . RecordChanges < java . lang . Object , java . lang . Object > change = new org . neo4j . kernel . impl . transaction . state . RecordChanges ( loader , new org . neo4j . kernel . impl . util . statistics . IntCounter ( ) ) ; change . getOrLoad ( 1 , null ) . forChangingData ( ) ; change . getOrLoad ( 1 , null ) . forChangingData ( ) ; change . getOrLoad ( 2 , null ) . forChangingData ( ) ; change . getOrLoad ( 3 , null ) . forReadingData ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( change . changeSize ( ) , org . hamcrest . CoreMatchers . equalTo ( 2 ) )", "total": "shouldCountChanges ( ) { org . neo4j . kernel . impl . transaction . state . RecordChanges < java . lang . Object , java . lang . Object > change = new org . neo4j . kernel . impl . transaction . state . RecordChanges ( loader , new org . neo4j . kernel . impl . util . statistics . IntCounter ( ) ) ; change . getOrLoad ( 1 , null ) . forChangingData ( ) ; change . getOrLoad ( 1 , null ) . forChangingData ( ) ; change . getOrLoad ( 2 , null ) . forChangingData ( ) ; change . getOrLoad ( 3 , null ) . forReadingData ( ) ; \"<AssertPlaceHolder>\" ; } changeSize ( ) { return changeCounter . value ( ) ; }", "answer": "org . junit . Assert . assertThat ( change . changeSize ( ) , org . hamcrest . CoreMatchers . equalTo ( 2 ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"remove<sp>propertx<sp>myProperty\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"remove<sp>propertx<sp>myProperty\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "calculate ( java . lang . String ) { return modder . calculate ( org . commonjava . maven . ext . core . impl . VersioningCalculatorTest . GROUP_ID , org . commonjava . maven . ext . core . impl . VersioningCalculatorTest . ARTIFACT_ID , version , session ) ; }", "testMethod": "incrementExistingSerialSuffix8 ( ) { final java . util . Properties props = new java . util . Properties ( ) ; props . setProperty ( VersioningState . INCREMENT_SERIAL_SUFFIX_SYSPROP . getCurrent ( ) , \"foo\" ) ; setupSession ( props , \"1.2.0-foo-1\" , \"1.2.0-foo-4\" ) ; final java . lang . String origVersion = \"1.2.0.foo_2\" ; final java . lang . String newVersion = \"1.2.0.foo_5\" ; final java . lang . String result = calculate ( origVersion ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( newVersion ) )", "total": "incrementExistingSerialSuffix8 ( ) { final java . util . Properties props = new java . util . Properties ( ) ; props . setProperty ( VersioningState . INCREMENT_SERIAL_SUFFIX_SYSPROP . getCurrent ( ) , \"foo\" ) ; setupSession ( props , \"1.2.0-foo-1\" , \"1.2.0-foo-4\" ) ; final java . lang . String origVersion = \"1.2.0.foo_2\" ; final java . lang . String newVersion = \"1.2.0.foo_5\" ; final java . lang . String result = calculate ( origVersion ) ; \"<AssertPlaceHolder>\" ; } calculate ( java . lang . String ) { return modder . calculate ( org . commonjava . maven . ext . core . impl . VersioningCalculatorTest . GROUP_ID , org . commonjava . maven . ext . core . impl . VersioningCalculatorTest . ARTIFACT_ID , version , session ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( newVersion ) )"}
{"focal": "clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "testMethod": "testJsonSerialization ( ) { org . batfish . datamodel . Mlag m = org . batfish . datamodel . Mlag . builder ( ) . setId ( \"ID\" ) . setPeerAddress ( org . batfish . datamodel . Ip . parse ( \"1.1.1.1\" ) ) . setLocalInterface ( \"Ethernet1\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( m , org . batfish . datamodel . Mlag . class ) , org . hamcrest . Matchers . equalTo ( m ) )", "total": "testJsonSerialization ( ) { org . batfish . datamodel . Mlag m = org . batfish . datamodel . Mlag . builder ( ) . setId ( \"ID\" ) . setPeerAddress ( org . batfish . datamodel . Ip . parse ( \"1.1.1.1\" ) ) . setLocalInterface ( \"Ethernet1\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } clone ( java . lang . Object , java . lang . Class ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER . readValue ( org . batfish . common . util . BatfishObjectMapper . WRITER . writeValueAsBytes ( o ) , clazz ) ; }", "answer": "org . junit . Assert . assertThat ( org . batfish . common . util . BatfishObjectMapper . clone ( m , org . batfish . datamodel . Mlag . class ) , org . hamcrest . Matchers . equalTo ( m ) )"}
{"focal": "getMessage ( java . util . Locale , java . lang . String ) { java . util . Map < java . lang . String , java . lang . String > localeMessages = messages . get ( locale ) ; if ( localeMessages == null ) { return null ; } return localeMessages . get ( key ) ; }", "testMethod": "testFileSystemImport ( ) { java . io . File file = null ; java . io . File tempfile = null ; try { java . lang . String basename = \"base\" ; java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( \"key\" , \"value\" ) ; tempfile = java . io . File . createTempFile ( \"messagesourcetext\" , null ) ; if ( tempfile . exists ( ) ) { tempfile . delete ( ) ; tempfile . mkdir ( ) ; } file = new java . io . File ( tempfile , ( basename + \".properties\" ) ) ; java . io . PrintStream stream = new java . io . PrintStream ( file ) ; p . store ( stream , ( \"generated<sp>by<sp>\" + ( this . getClass ( ) . getName ( ) ) ) ) ; stream . close ( ) ; org . synyx . messagesource . importer . Importer importer = new org . synyx . messagesource . importer . Importer ( tempfile , target ) ; importer . importMessages ( basename ) ; org . synyx . messagesource . Messages messages = target . getMessages ( basename ) ; java . lang . String imported = messages . getMessage ( null , \"key\" ) ; \"<AssertPlaceHolder>\" ; } finally { if ( file != null ) { file . delete ( ) ; } if ( tempfile != null ) { tempfile . delete ( ) ; } } }", "assertLine": "org . junit . Assert . assertThat ( imported , org . hamcrest . CoreMatchers . is ( \"value\" ) )", "total": "testFileSystemImport ( ) { java . io . File file = null ; java . io . File tempfile = null ; try { java . lang . String basename = \"base\" ; java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( \"key\" , \"value\" ) ; tempfile = java . io . File . createTempFile ( \"messagesourcetext\" , null ) ; if ( tempfile . exists ( ) ) { tempfile . delete ( ) ; tempfile . mkdir ( ) ; } file = new java . io . File ( tempfile , ( basename + \".properties\" ) ) ; java . io . PrintStream stream = new java . io . PrintStream ( file ) ; p . store ( stream , ( \"generated<sp>by<sp>\" + ( this . getClass ( ) . getName ( ) ) ) ) ; stream . close ( ) ; org . synyx . messagesource . importer . Importer importer = new org . synyx . messagesource . importer . Importer ( tempfile , target ) ; importer . importMessages ( basename ) ; org . synyx . messagesource . Messages messages = target . getMessages ( basename ) ; java . lang . String imported = messages . getMessage ( null , \"key\" ) ; \"<AssertPlaceHolder>\" ; } finally { if ( file != null ) { file . delete ( ) ; } if ( tempfile != null ) { tempfile . delete ( ) ; } } } getMessage ( java . util . Locale , java . lang . String ) { java . util . Map < java . lang . String , java . lang . String > localeMessages = messages . get ( locale ) ; if ( localeMessages == null ) { return null ; } return localeMessages . get ( key ) ; }", "answer": "org . junit . Assert . assertThat ( imported , org . hamcrest . CoreMatchers . is ( \"value\" ) )"}
{"focal": "toString ( ) { return \"MaxKey\" ; }", "testMethod": "shouldHaveToStringThatIsTheSameAsEquivalentArrayList ( ) { java . util . List < java . lang . String > copy = new java . util . ArrayList < java . lang . String > ( list ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . toString ( ) , org . hamcrest . core . Is . is ( copy . toString ( ) ) )", "total": "shouldHaveToStringThatIsTheSameAsEquivalentArrayList ( ) { java . util . List < java . lang . String > copy = new java . util . ArrayList < java . lang . String > ( list ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return \"MaxKey\" ; }", "answer": "org . junit . Assert . assertThat ( list . toString ( ) , org . hamcrest . core . Is . is ( copy . toString ( ) ) )"}
{"focal": "serialize ( org . apache . hadoop . io . Writable ) { java . io . ByteArrayOutputStream out = new java . io . ByteArrayOutputStream ( ) ; java . io . DataOutputStream dataOut = new java . io . DataOutputStream ( out ) ; writable . write ( dataOut ) ; dataOut . close ( ) ; return out . toByteArray ( ) ; }", "testMethod": "test ( ) { org . apache . hadoop . io . NullWritable writable = org . apache . hadoop . io . NullWritable . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serialize ( writable ) . length , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "test ( ) { org . apache . hadoop . io . NullWritable writable = org . apache . hadoop . io . NullWritable . get ( ) ; \"<AssertPlaceHolder>\" ; } serialize ( org . apache . hadoop . io . Writable ) { java . io . ByteArrayOutputStream out = new java . io . ByteArrayOutputStream ( ) ; java . io . DataOutputStream dataOut = new java . io . DataOutputStream ( out ) ; writable . write ( dataOut ) ; dataOut . close ( ) ; return out . toByteArray ( ) ; }", "answer": "org . junit . Assert . assertThat ( serialize ( writable ) . length , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "empty ( ) { return new org . apache . beam . runners . core . NullSideInputReader ( java . util . Collections . emptySet ( ) ) ; }", "testMethod": "testNarrowingNullableToNotNullable ( ) { org . apache . beam . sdk . schemas . Schema input = org . apache . beam . sdk . schemas . Schema . of ( Schema . Field . nullable ( \"f0\" , FieldType . INT32 ) ) ; org . apache . beam . sdk . schemas . Schema output = org . apache . beam . sdk . schemas . Schema . of ( Schema . Field . of ( \"f0\" , FieldType . INT32 ) ) ; java . util . List < org . apache . beam . sdk . schemas . transforms . Cast . CompatibilityError > errors = Cast . Narrowing . of ( ) . apply ( input , output ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( errors , org . hamcrest . Matchers . empty ( ) )", "total": "testNarrowingNullableToNotNullable ( ) { org . apache . beam . sdk . schemas . Schema input = org . apache . beam . sdk . schemas . Schema . of ( Schema . Field . nullable ( \"f0\" , FieldType . INT32 ) ) ; org . apache . beam . sdk . schemas . Schema output = org . apache . beam . sdk . schemas . Schema . of ( Schema . Field . of ( \"f0\" , FieldType . INT32 ) ) ; java . util . List < org . apache . beam . sdk . schemas . transforms . Cast . CompatibilityError > errors = Cast . Narrowing . of ( ) . apply ( input , output ) ; \"<AssertPlaceHolder>\" ; } empty ( ) { return new org . apache . beam . runners . core . NullSideInputReader ( java . util . Collections . emptySet ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( errors , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "collect ( com . annimon . stream . Collector ) { A container = collector . supplier ( ) . get ( ) ; while ( iterator . hasNext ( ) ) { final T value = iterator . next ( ) ; collector . accumulator ( ) . accept ( container , value ) ; } return collector . finisher ( ) . apply ( container ) ; }", "testMethod": "testToList ( ) { java . util . List < java . lang . Integer > expected = java . util . Arrays . asList ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; java . util . List < java . lang . Integer > list = com . annimon . stream . Stream . range ( 0 , 10 ) . collect ( com . annimon . stream . Collectors . < java . lang . Integer > toList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list , is ( expected ) )", "total": "testToList ( ) { java . util . List < java . lang . Integer > expected = java . util . Arrays . asList ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; java . util . List < java . lang . Integer > list = com . annimon . stream . Stream . range ( 0 , 10 ) . collect ( com . annimon . stream . Collectors . < java . lang . Integer > toList ( ) ) ; \"<AssertPlaceHolder>\" ; } collect ( com . annimon . stream . Collector ) { A container = collector . supplier ( ) . get ( ) ; while ( iterator . hasNext ( ) ) { final T value = iterator . next ( ) ; collector . accumulator ( ) . accept ( container , value ) ; } return collector . finisher ( ) . apply ( container ) ; }", "answer": "org . junit . Assert . assertThat ( list , is ( expected ) )"}
{"focal": "equals ( java . lang . Object ) { if ( ( this ) == other ) { return true ; } if ( ! ( other instanceof org . eclipse . che . ide . ext . runner . client . tabs . common . Tab ) ) { return false ; } org . eclipse . che . ide . ext . runner . client . tabs . common . Tab tab = ( ( org . eclipse . che . ide . ext . runner . client . tabs . common . Tab ) ( other ) ) ; return java . util . Objects . equals ( title , tab . title ) ; }", "testMethod": "equalsShouldReturnFalseForRunnerObjectsWithDifferentTitleAndCreationTime ( ) { org . eclipse . che . ide . ext . runner . client . models . RunnerImpl runner1 = new org . eclipse . che . ide . ext . runner . client . models . RunnerImpl ( locale , runnerCounter , util , runOptions ) ; runner1 . setTitle ( org . eclipse . che . ide . ext . runner . client . models . RunnerImplTest . TEXT ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( runner . equals ( runner1 ) , org . hamcrest . core . Is . is ( false ) )", "total": "equalsShouldReturnFalseForRunnerObjectsWithDifferentTitleAndCreationTime ( ) { org . eclipse . che . ide . ext . runner . client . models . RunnerImpl runner1 = new org . eclipse . che . ide . ext . runner . client . models . RunnerImpl ( locale , runnerCounter , util , runOptions ) ; runner1 . setTitle ( org . eclipse . che . ide . ext . runner . client . models . RunnerImplTest . TEXT ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( ( this ) == other ) { return true ; } if ( ! ( other instanceof org . eclipse . che . ide . ext . runner . client . tabs . common . Tab ) ) { return false ; } org . eclipse . che . ide . ext . runner . client . tabs . common . Tab tab = ( ( org . eclipse . che . ide . ext . runner . client . tabs . common . Tab ) ( other ) ) ; return java . util . Objects . equals ( title , tab . title ) ; }", "answer": "org . junit . Assert . assertThat ( runner . equals ( runner1 ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "toPrimitiveDouble ( java . lang . Object ) { java . lang . Double d = org . slim3 . util . DoubleUtil . toDouble ( o ) ; if ( d == null ) { return 0 ; } return d . doubleValue ( ) ; }", "testMethod": "toPrimitiveDoubleForNumber ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . slim3 . util . DoubleUtil . toPrimitiveDouble ( 1 ) , org . hamcrest . CoreMatchers . is ( 1.0 ) )", "total": "toPrimitiveDoubleForNumber ( ) { \"<AssertPlaceHolder>\" ; } toPrimitiveDouble ( java . lang . Object ) { java . lang . Double d = org . slim3 . util . DoubleUtil . toDouble ( o ) ; if ( d == null ) { return 0 ; } return d . doubleValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . slim3 . util . DoubleUtil . toPrimitiveDouble ( 1 ) , org . hamcrest . CoreMatchers . is ( 1.0 ) )"}
{"focal": "error ( java . lang . String , java . lang . Throwable ) { logger . error ( msg , t ) ; }", "testMethod": "compileTest ( ) { for ( hu . elte . txtuml . export . cpp . wizardz . CompileTests . Config config : hu . elte . txtuml . export . cpp . wizardz . CompileTests . TEST_PROJECTS ) { try { java . lang . String projectName = hu . elte . txtuml . export . cpp . wizardz . CompileTests . generateCPP ( config , hu . elte . txtuml . export . cpp . wizardz . CompileTests . COMPILE_TEST_PROJECT_PREFIX , true , true ) ; if ( hu . elte . txtuml . export . cpp . wizardz . CompileTests . buildStuffPresent ) { hu . elte . txtuml . export . cpp . wizardz . CompileTests . compileCPP ( projectName , config ) ; } } catch ( java . lang . Exception e ) { Logger . sys . error ( \"\" , e ) ; \"<AssertPlaceHolder>\" ; } } }", "assertLine": "org . junit . Assert . assertThat ( false , org . hamcrest . core . Is . is ( true ) )", "total": "compileTest ( ) { for ( hu . elte . txtuml . export . cpp . wizardz . CompileTests . Config config : hu . elte . txtuml . export . cpp . wizardz . CompileTests . TEST_PROJECTS ) { try { java . lang . String projectName = hu . elte . txtuml . export . cpp . wizardz . CompileTests . generateCPP ( config , hu . elte . txtuml . export . cpp . wizardz . CompileTests . COMPILE_TEST_PROJECT_PREFIX , true , true ) ; if ( hu . elte . txtuml . export . cpp . wizardz . CompileTests . buildStuffPresent ) { hu . elte . txtuml . export . cpp . wizardz . CompileTests . compileCPP ( projectName , config ) ; } } catch ( java . lang . Exception e ) { Logger . sys . error ( \"\" , e ) ; \"<AssertPlaceHolder>\" ; } } } error ( java . lang . String , java . lang . Throwable ) { logger . error ( msg , t ) ; }", "answer": "org . junit . Assert . assertThat ( false , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getEnvironmentId ( ) { return runOptions . getEnvironmentId ( ) ; }", "testMethod": "environmentIdShouldBeReturned ( ) { reset ( runOptions ) ; when ( runOptions . getEnvironmentId ( ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . models . RunnerImplTest . TEXT ) ; runner . getEnvironmentId ( ) ; verify ( runOptions ) . getEnvironmentId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( runner . getEnvironmentId ( ) , org . hamcrest . core . Is . is ( org . eclipse . che . ide . ext . runner . client . models . RunnerImplTest . TEXT ) )", "total": "environmentIdShouldBeReturned ( ) { reset ( runOptions ) ; when ( runOptions . getEnvironmentId ( ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . models . RunnerImplTest . TEXT ) ; runner . getEnvironmentId ( ) ; verify ( runOptions ) . getEnvironmentId ( ) ; \"<AssertPlaceHolder>\" ; } getEnvironmentId ( ) { return runOptions . getEnvironmentId ( ) ; }", "answer": "org . junit . Assert . assertThat ( runner . getEnvironmentId ( ) , org . hamcrest . core . Is . is ( org . eclipse . che . ide . ext . runner . client . models . RunnerImplTest . TEXT ) )"}
{"focal": "heartbeat ( java . lang . String ) { java . lang . Long val = voters . computeIfPresent ( id , ( key , timeStamp ) -> { long currentTime = timeSource . currentTimeMillis ( ) ; if ( ( currentTime - timeStamp ) < ( com . tc . l2 . state . ServerVoterManagerImpl . VOTEBEAT_TIMEOUT ) ) { return currentTime ; } else { votes . remove ( key ) ; voters . remove ( key ) ; return null ; } } ) ; if ( val == null ) { return INVALID_VOTER_RESPONSE ; } if ( votingInProgress ) { return electionTerm ; } return HEARTBEAT_RESPONSE ; }", "testMethod": "testHeartbeatFromInvalidVoter ( ) { com . tc . l2 . state . ServerVoterManagerImpl manager = new com . tc . l2 . state . ServerVoterManagerImpl ( 1 , timeSource , false ) ; manager . voters . put ( \"foo\" , 1L ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( manager . heartbeat ( \"bar\" ) , org . hamcrest . Matchers . is ( ( - 1L ) ) )", "total": "testHeartbeatFromInvalidVoter ( ) { com . tc . l2 . state . ServerVoterManagerImpl manager = new com . tc . l2 . state . ServerVoterManagerImpl ( 1 , timeSource , false ) ; manager . voters . put ( \"foo\" , 1L ) ; \"<AssertPlaceHolder>\" ; } heartbeat ( java . lang . String ) { java . lang . Long val = voters . computeIfPresent ( id , ( key , timeStamp ) -> { long currentTime = timeSource . currentTimeMillis ( ) ; if ( ( currentTime - timeStamp ) < ( com . tc . l2 . state . ServerVoterManagerImpl . VOTEBEAT_TIMEOUT ) ) { return currentTime ; } else { votes . remove ( key ) ; voters . remove ( key ) ; return null ; } } ) ; if ( val == null ) { return INVALID_VOTER_RESPONSE ; } if ( votingInProgress ) { return electionTerm ; } return HEARTBEAT_RESPONSE ; }", "answer": "org . junit . Assert . assertThat ( manager . heartbeat ( \"bar\" ) , org . hamcrest . Matchers . is ( ( - 1L ) ) )"}
{"focal": "getEffectiveResourcePermissions ( com . acciente . oacc . Resource , com . acciente . oacc . Resource ) { com . acciente . oacc . sql . internal . persister . SQLConnection connection = null ; __assertAuthenticated ( ) ; __assertResourceSpecified ( accessorResource ) ; __assertResourceSpecified ( accessedResource ) ; try { connection = __getConnection ( ) ; accessorResource = __resolveResource ( connection , accessorResource ) ; accessedResource = __resolveResource ( connection , accessedResource ) ; __assertQueryAuthorization ( connection , accessorResource ) ; return __getEffectiveResourcePermissions ( connection , accessorResource , accessedResource ) ; } finally { __closeConnection ( connection ) ; } }", "testMethod": "hasResourcePermissions_noPermissions_shouldFailAsAuthenticated ( ) { authenticateSystemResource ( ) ; final java . lang . String resourceClassName = generateResourceClass ( true , false ) ; final java . lang . String customPermissionName = generateResourceClassPermission ( resourceClassName ) ; final char [ ] password = generateUniquePassword ( ) ; final com . acciente . oacc . Resource accessorResource = generateAuthenticatableResource ( password ) ; final com . acciente . oacc . Resource accessedResource = accessControlContext . createResource ( resourceClassName , accessControlContext . getDomainNameByResource ( com . acciente . oacc . SYS_RESOURCE ) , com . acciente . oacc . PasswordCredentials . newInstance ( generateUniquePassword ( ) ) ) ; final java . util . Set < com . acciente . oacc . ResourcePermission > allResourcePermissions = accessControlContext . getEffectiveResourcePermissions ( accessorResource , accessedResource ) ; \"<AssertPlaceHolder>\" ; accessControlContext . authenticate ( accessorResource , com . acciente . oacc . PasswordCredentials . newInstance ( password ) ) ; if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) ) ) { org . junit . Assert . fail ( \"checking<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) , com . acciente . oacc . ResourcePermissions . getInstance ( ResourcePermissions . INHERIT ) ) ) { org . junit . Assert . fail ( \"checking<sp>multiple<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , setOf ( com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) ) ) ) { org . junit . Assert . fail ( \"checking<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , setOf ( com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) , com . acciente . oacc . ResourcePermissions . getInstance ( ResourcePermissions . INHERIT ) ) ) ) { org . junit . Assert . fail ( \"checking<sp>multiple<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } }", "assertLine": "org . junit . Assert . assertThat ( allResourcePermissions . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "hasResourcePermissions_noPermissions_shouldFailAsAuthenticated ( ) { authenticateSystemResource ( ) ; final java . lang . String resourceClassName = generateResourceClass ( true , false ) ; final java . lang . String customPermissionName = generateResourceClassPermission ( resourceClassName ) ; final char [ ] password = generateUniquePassword ( ) ; final com . acciente . oacc . Resource accessorResource = generateAuthenticatableResource ( password ) ; final com . acciente . oacc . Resource accessedResource = accessControlContext . createResource ( resourceClassName , accessControlContext . getDomainNameByResource ( com . acciente . oacc . SYS_RESOURCE ) , com . acciente . oacc . PasswordCredentials . newInstance ( generateUniquePassword ( ) ) ) ; final java . util . Set < com . acciente . oacc . ResourcePermission > allResourcePermissions = accessControlContext . getEffectiveResourcePermissions ( accessorResource , accessedResource ) ; \"<AssertPlaceHolder>\" ; accessControlContext . authenticate ( accessorResource , com . acciente . oacc . PasswordCredentials . newInstance ( password ) ) ; if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) ) ) { org . junit . Assert . fail ( \"checking<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) , com . acciente . oacc . ResourcePermissions . getInstance ( ResourcePermissions . INHERIT ) ) ) { org . junit . Assert . fail ( \"checking<sp>multiple<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , setOf ( com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) ) ) ) { org . junit . Assert . fail ( \"checking<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } if ( accessControlContext . hasResourcePermissions ( accessorResource , accessedResource , setOf ( com . acciente . oacc . ResourcePermissions . getInstance ( customPermissionName ) , com . acciente . oacc . ResourcePermissions . getInstance ( ResourcePermissions . INHERIT ) ) ) ) { org . junit . Assert . fail ( \"checking<sp>multiple<sp>resource<sp>permission<sp>for<sp>domain<sp>when<sp>none<sp>has<sp>been<sp>granted<sp>should<sp>not<sp>have<sp>succeeded<sp>for<sp>authenticated<sp>resource\" ) ; } } getEffectiveResourcePermissions ( com . acciente . oacc . Resource , com . acciente . oacc . Resource ) { com . acciente . oacc . sql . internal . persister . SQLConnection connection = null ; __assertAuthenticated ( ) ; __assertResourceSpecified ( accessorResource ) ; __assertResourceSpecified ( accessedResource ) ; try { connection = __getConnection ( ) ; accessorResource = __resolveResource ( connection , accessorResource ) ; accessedResource = __resolveResource ( connection , accessedResource ) ; __assertQueryAuthorization ( connection , accessorResource ) ; return __getEffectiveResourcePermissions ( connection , accessorResource , accessedResource ) ; } finally { __closeConnection ( connection ) ; } }", "answer": "org . junit . Assert . assertThat ( allResourcePermissions . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getLoadCount ( ) { return loadCount . get ( ) ; }", "testMethod": "shouldNotLoadWithNullKeysUsingLoadAll ( ) { org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > cacheLoader = new org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > ( ) ; cacheLoaderServer . setCacheLoader ( cacheLoader ) ; try { javax . cache . integration . CompletionListenerFuture future = new javax . cache . integration . CompletionListenerFuture ( ) ; cache . loadAll ( null , false , future ) ; org . junit . Assert . fail ( \"Expected<sp>a<sp>NullPointerException\" ) ; } catch ( java . lang . NullPointerException e ) { } finally { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( cacheLoader . getLoadCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "shouldNotLoadWithNullKeysUsingLoadAll ( ) { org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > cacheLoader = new org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > ( ) ; cacheLoaderServer . setCacheLoader ( cacheLoader ) ; try { javax . cache . integration . CompletionListenerFuture future = new javax . cache . integration . CompletionListenerFuture ( ) ; cache . loadAll ( null , false , future ) ; org . junit . Assert . fail ( \"Expected<sp>a<sp>NullPointerException\" ) ; } catch ( java . lang . NullPointerException e ) { } finally { \"<AssertPlaceHolder>\" ; } } getLoadCount ( ) { return loadCount . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( cacheLoader . getLoadCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "is ( java . lang . Comparable ) { return new org . drools . verifier . core . index . matchers . ExactMatcher ( keyDefinition , comparable ) ; }", "testMethod": "test_filterPath_tricky2 ( ) { org . kie . dmn . feel . codegen . feel11 . CompiledFEELExpression nameRef = parse ( \"[<sp>{x:1,<sp>y:2},<sp>{x:2,<sp>y:3}<sp>][x]\" ) ; org . kie . dmn . feel . codegen . feel11 . DirectCompilerTest . LOG . debug ( \"{}\" , nameRef ) ; org . kie . dmn . feel . lang . EvaluationContext context = org . kie . dmn . feel . codegen . feel11 . CodegenTestUtil . newEmptyEvaluationContext ( ) ; context . setValue ( \"x\" , false ) ; java . lang . Object result = nameRef . apply ( context ) ; org . kie . dmn . feel . codegen . feel11 . DirectCompilerTest . LOG . debug ( \"{}\" , result ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Collections . emptyList ( ) ) )", "total": "test_filterPath_tricky2 ( ) { org . kie . dmn . feel . codegen . feel11 . CompiledFEELExpression nameRef = parse ( \"[<sp>{x:1,<sp>y:2},<sp>{x:2,<sp>y:3}<sp>][x]\" ) ; org . kie . dmn . feel . codegen . feel11 . DirectCompilerTest . LOG . debug ( \"{}\" , nameRef ) ; org . kie . dmn . feel . lang . EvaluationContext context = org . kie . dmn . feel . codegen . feel11 . CodegenTestUtil . newEmptyEvaluationContext ( ) ; context . setValue ( \"x\" , false ) ; java . lang . Object result = nameRef . apply ( context ) ; org . kie . dmn . feel . codegen . feel11 . DirectCompilerTest . LOG . debug ( \"{}\" , result ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Comparable ) { return new org . drools . verifier . core . index . matchers . ExactMatcher ( keyDefinition , comparable ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Collections . emptyList ( ) ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testNeighbor ( ) { isisNeighborTlv . addNeighbor ( macAddress ) ; resultList = isisNeighborTlv . neighbor ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultList . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testNeighbor ( ) { isisNeighborTlv . addNeighbor ( macAddress ) ; resultList = isisNeighborTlv . neighbor ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( resultList . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getApplicationsByCandidateDTO ( com . epam . rft . atsy . service . domain . CandidateDTO ) { org . springframework . util . Assert . notNull ( candidateDTO ) ; org . springframework . util . Assert . notNull ( candidateDTO . getId ( ) ) ; com . epam . rft . atsy . persistence . entities . CandidateEntity candidateEntity = candidateRepository . findOne ( candidateDTO . getId ( ) ) ; java . util . List < com . epam . rft . atsy . persistence . entities . ApplicationEntity > applicationEntities = applicationsRepository . findByCandidateEntity ( candidateEntity ) ; return converterService . convert ( applicationEntities , com . epam . rft . atsy . service . domain . ApplicationDTO . class ) ; }", "testMethod": "getApplicationByCandidateDTOShouldReturnThreeElementListOfApplicationDTOWhenCandidateIdExists ( ) { com . epam . rft . atsy . service . domain . CandidateDTO candidateDTO = com . epam . rft . atsy . service . domain . CandidateDTO . builder ( ) . id ( com . epam . rft . atsy . service . impl . ApplicationsServiceImplTest . CANDIDATE_ID ) . build ( ) ; java . util . List < com . epam . rft . atsy . persistence . entities . ApplicationEntity > applicationEntities = java . util . Arrays . asList ( applicationEntity , applicationEntity , applicationEntity ) ; java . util . List < com . epam . rft . atsy . service . domain . ApplicationDTO > applicationDTOs = java . util . Arrays . asList ( applicationDTO , applicationDTO , applicationDTO ) ; given ( candidateRepository . findOne ( com . epam . rft . atsy . service . impl . ApplicationsServiceImplTest . CANDIDATE_ID ) ) . willReturn ( candidateEntity ) ; given ( applicationsRepository . findByCandidateEntity ( candidateEntity ) ) . willReturn ( applicationEntities ) ; given ( converterService . convert ( applicationEntities , com . epam . rft . atsy . service . domain . ApplicationDTO . class ) ) . willReturn ( applicationDTOs ) ; java . util . List < com . epam . rft . atsy . service . domain . ApplicationDTO > result = applicationsService . getApplicationsByCandidateDTO ( candidateDTO ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( applicationDTOs ) )", "total": "getApplicationByCandidateDTOShouldReturnThreeElementListOfApplicationDTOWhenCandidateIdExists ( ) { com . epam . rft . atsy . service . domain . CandidateDTO candidateDTO = com . epam . rft . atsy . service . domain . CandidateDTO . builder ( ) . id ( com . epam . rft . atsy . service . impl . ApplicationsServiceImplTest . CANDIDATE_ID ) . build ( ) ; java . util . List < com . epam . rft . atsy . persistence . entities . ApplicationEntity > applicationEntities = java . util . Arrays . asList ( applicationEntity , applicationEntity , applicationEntity ) ; java . util . List < com . epam . rft . atsy . service . domain . ApplicationDTO > applicationDTOs = java . util . Arrays . asList ( applicationDTO , applicationDTO , applicationDTO ) ; given ( candidateRepository . findOne ( com . epam . rft . atsy . service . impl . ApplicationsServiceImplTest . CANDIDATE_ID ) ) . willReturn ( candidateEntity ) ; given ( applicationsRepository . findByCandidateEntity ( candidateEntity ) ) . willReturn ( applicationEntities ) ; given ( converterService . convert ( applicationEntities , com . epam . rft . atsy . service . domain . ApplicationDTO . class ) ) . willReturn ( applicationDTOs ) ; java . util . List < com . epam . rft . atsy . service . domain . ApplicationDTO > result = applicationsService . getApplicationsByCandidateDTO ( candidateDTO ) ; \"<AssertPlaceHolder>\" ; } getApplicationsByCandidateDTO ( com . epam . rft . atsy . service . domain . CandidateDTO ) { org . springframework . util . Assert . notNull ( candidateDTO ) ; org . springframework . util . Assert . notNull ( candidateDTO . getId ( ) ) ; com . epam . rft . atsy . persistence . entities . CandidateEntity candidateEntity = candidateRepository . findOne ( candidateDTO . getId ( ) ) ; java . util . List < com . epam . rft . atsy . persistence . entities . ApplicationEntity > applicationEntities = applicationsRepository . findByCandidateEntity ( candidateEntity ) ; return converterService . convert ( applicationEntities , com . epam . rft . atsy . service . domain . ApplicationDTO . class ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( applicationDTOs ) )"}
{"focal": "getWidgetCount ( ) { return delegate . getWidgetCount ( ) ; }", "testMethod": "bindDoesNotNullPointerExceptionForPresenters ( ) { names . set ( null ) ; org . tessell . tests . model . dsl . ListPropertyBinderTest . ParentPresenter parent = org . tessell . tests . model . dsl . ListPropertyBinderTest . bind ( new org . tessell . tests . model . dsl . ListPropertyBinderTest . ParentPresenter ( ) ) ; binder . bind ( names ) . to ( parent , panel , presenterFactory ) ; names . set ( joist . util . Copy . list ( \"one\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( panel . getWidgetCount ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "bindDoesNotNullPointerExceptionForPresenters ( ) { names . set ( null ) ; org . tessell . tests . model . dsl . ListPropertyBinderTest . ParentPresenter parent = org . tessell . tests . model . dsl . ListPropertyBinderTest . bind ( new org . tessell . tests . model . dsl . ListPropertyBinderTest . ParentPresenter ( ) ) ; binder . bind ( names ) . to ( parent , panel , presenterFactory ) ; names . set ( joist . util . Copy . list ( \"one\" ) ) ; \"<AssertPlaceHolder>\" ; } getWidgetCount ( ) { return delegate . getWidgetCount ( ) ; }", "answer": "org . junit . Assert . assertThat ( panel . getWidgetCount ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getPageElements ( ) { return new java . util . ArrayList < T > ( pageElements ) ; }", "testMethod": "shouldGetChanges ( ) { edu . stanford . bmir . protege . web . shared . pagination . Page < edu . stanford . bmir . protege . web . shared . change . ProjectChange > projectChanges = changesManager . getProjectChanges ( java . util . Optional . empty ( ) , edu . stanford . bmir . protege . web . shared . pagination . PageRequest . requestFirstPage ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( projectChanges . getPageElements ( ) . size ( ) , org . hamcrest . Matchers . is ( 1 ) )", "total": "shouldGetChanges ( ) { edu . stanford . bmir . protege . web . shared . pagination . Page < edu . stanford . bmir . protege . web . shared . change . ProjectChange > projectChanges = changesManager . getProjectChanges ( java . util . Optional . empty ( ) , edu . stanford . bmir . protege . web . shared . pagination . PageRequest . requestFirstPage ( ) ) ; \"<AssertPlaceHolder>\" ; } getPageElements ( ) { return new java . util . ArrayList < T > ( pageElements ) ; }", "answer": "org . junit . Assert . assertThat ( projectChanges . getPageElements ( ) . size ( ) , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "initCounterForLayerWithIndexAndCountInLayer ( int ) { setUpIds ( ) ; int numPorts = 0 ; for ( org . eclipse . elk . alg . layered . graph . Layer l : getGraph ( ) ) { for ( org . eclipse . elk . alg . layered . graph . LNode lNode : l ) { numPorts += lNode . getPorts ( ) . size ( ) ; } } org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter counter = new org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter ( new int [ numPorts ] ) ; return counter . countNorthSouthPortCrossingsInLayer ( getGraph ( ) . toNodeArray ( ) [ layerIndex ] ) ; }", "testMethod": "normalNodesNorthSouthEdgesHaveCrossingsToLongEdgeDummyOnBothSides ( ) { getMultipleNorthSouthAndLongEdgeDummiesOnBothSides ( ) ; int crossingCount = initCounterForLayerWithIndexAndCountInLayer ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( crossingCount , org . hamcrest . CoreMatchers . is ( 4 ) )", "total": "normalNodesNorthSouthEdgesHaveCrossingsToLongEdgeDummyOnBothSides ( ) { getMultipleNorthSouthAndLongEdgeDummiesOnBothSides ( ) ; int crossingCount = initCounterForLayerWithIndexAndCountInLayer ( 1 ) ; \"<AssertPlaceHolder>\" ; } initCounterForLayerWithIndexAndCountInLayer ( int ) { setUpIds ( ) ; int numPorts = 0 ; for ( org . eclipse . elk . alg . layered . graph . Layer l : getGraph ( ) ) { for ( org . eclipse . elk . alg . layered . graph . LNode lNode : l ) { numPorts += lNode . getPorts ( ) . size ( ) ; } } org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter counter = new org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter ( new int [ numPorts ] ) ; return counter . countNorthSouthPortCrossingsInLayer ( getGraph ( ) . toNodeArray ( ) [ layerIndex ] ) ; }", "answer": "org . junit . Assert . assertThat ( crossingCount , org . hamcrest . CoreMatchers . is ( 4 ) )"}
{"focal": "getInternalDebugHttpPort ( ) { return internalDebugHttpPort ; }", "testMethod": "InternalDebugHttpPortIsGettableStringValue ( ) { operatorValues . internalDebugHttpPort ( stringValue ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( operatorValues . getInternalDebugHttpPort ( ) , org . hamcrest . Matchers . equalTo ( stringValue ) )", "total": "InternalDebugHttpPortIsGettableStringValue ( ) { operatorValues . internalDebugHttpPort ( stringValue ) ; \"<AssertPlaceHolder>\" ; } getInternalDebugHttpPort ( ) { return internalDebugHttpPort ; }", "answer": "org . junit . Assert . assertThat ( operatorValues . getInternalDebugHttpPort ( ) , org . hamcrest . Matchers . equalTo ( stringValue ) )"}
{"focal": "getInstance ( ) { return org . apache . shardingsphere . orchestration . internal . eventbus . ShardingOrchestrationEventBus . INSTANCE ; }", "testMethod": "assertGetInstance ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . apache . shardingsphere . orchestration . internal . eventbus . ShardingOrchestrationEventBus . getInstance ( ) , org . hamcrest . CoreMatchers . is ( org . apache . shardingsphere . orchestration . internal . eventbus . ShardingOrchestrationEventBus . getInstance ( ) ) )", "total": "assertGetInstance ( ) { \"<AssertPlaceHolder>\" ; } getInstance ( ) { return org . apache . shardingsphere . orchestration . internal . eventbus . ShardingOrchestrationEventBus . INSTANCE ; }", "answer": "org . junit . Assert . assertThat ( org . apache . shardingsphere . orchestration . internal . eventbus . ShardingOrchestrationEventBus . getInstance ( ) , org . hamcrest . CoreMatchers . is ( org . apache . shardingsphere . orchestration . internal . eventbus . ShardingOrchestrationEventBus . getInstance ( ) ) )"}
{"focal": "getProperty ( java . lang . Object , java . lang . String ) { org . apache . commons . lang3 . Validate . notNull ( bean , \"bean<sp>can't<sp>be<sp>null!\" ) ; org . apache . commons . lang3 . Validate . notBlank ( propertyName , \"propertyName<sp>can't<sp>be<sp>blank!\" ) ; return com . feilong . core . bean . PropertyValueObtainer . obtain ( bean , propertyName ) ; }", "testMethod": "testGetPropertyNest ( ) { com . feilong . store . member . User user = new com . feilong . store . member . User ( ) ; user . setId ( 5L ) ; user . setDate ( new java . util . Date ( ) ) ; java . util . List < com . feilong . store . member . User > list = com . feilong . core . bean . ConvertUtil . toList ( user , user , user ) ; java . lang . Long id = com . feilong . core . bean . PropertyUtil . getProperty ( list , \"[0].id\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( id , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . equalTo ( 5L ) ) )", "total": "testGetPropertyNest ( ) { com . feilong . store . member . User user = new com . feilong . store . member . User ( ) ; user . setId ( 5L ) ; user . setDate ( new java . util . Date ( ) ) ; java . util . List < com . feilong . store . member . User > list = com . feilong . core . bean . ConvertUtil . toList ( user , user , user ) ; java . lang . Long id = com . feilong . core . bean . PropertyUtil . getProperty ( list , \"[0].id\" ) ; \"<AssertPlaceHolder>\" ; } getProperty ( java . lang . Object , java . lang . String ) { org . apache . commons . lang3 . Validate . notNull ( bean , \"bean<sp>can't<sp>be<sp>null!\" ) ; org . apache . commons . lang3 . Validate . notBlank ( propertyName , \"propertyName<sp>can't<sp>be<sp>blank!\" ) ; return com . feilong . core . bean . PropertyValueObtainer . obtain ( bean , propertyName ) ; }", "answer": "org . junit . Assert . assertThat ( id , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . equalTo ( 5L ) ) )"}
{"focal": "contains ( org . joda . time . Interval ) { return ( this . interval . contains ( interval ) ) || ( isZeroDurationAtEndOfThisInterval ( interval ) ) ; }", "testMethod": "mergerPreservesBroadcastOnDifferentChannel ( ) { org . atlasapi . query . content . merge . BroadcastMerger merger = org . atlasapi . query . content . merge . BroadcastMerger . parse ( \"\\\"channelUri\\\"|\\\"2016-01-05T00:00:00Z\\\"|\\\"2016-01-06T00:00:00Z\\\"\" ) ; org . atlasapi . media . entity . Broadcast broadcast = new org . atlasapi . media . entity . Broadcast ( \"otherChannelUri\" , new org . joda . time . DateTime ( 2016 , 1 , 5 , 0 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) , new org . joda . time . DateTime ( 2016 , 1 , 6 , 0 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) ) ; com . google . common . collect . ImmutableSet < org . atlasapi . media . entity . Broadcast > merge = merger . merge ( com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( broadcast ) , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( merge . contains ( broadcast ) , org . hamcrest . core . Is . is ( true ) )", "total": "mergerPreservesBroadcastOnDifferentChannel ( ) { org . atlasapi . query . content . merge . BroadcastMerger merger = org . atlasapi . query . content . merge . BroadcastMerger . parse ( \"\\\"channelUri\\\"|\\\"2016-01-05T00:00:00Z\\\"|\\\"2016-01-06T00:00:00Z\\\"\" ) ; org . atlasapi . media . entity . Broadcast broadcast = new org . atlasapi . media . entity . Broadcast ( \"otherChannelUri\" , new org . joda . time . DateTime ( 2016 , 1 , 5 , 0 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) , new org . joda . time . DateTime ( 2016 , 1 , 6 , 0 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) ) ; com . google . common . collect . ImmutableSet < org . atlasapi . media . entity . Broadcast > merge = merger . merge ( com . google . common . collect . ImmutableSet . of ( ) , com . google . common . collect . ImmutableSet . of ( broadcast ) , true ) ; \"<AssertPlaceHolder>\" ; } contains ( org . joda . time . Interval ) { return ( this . interval . contains ( interval ) ) || ( isZeroDurationAtEndOfThisInterval ( interval ) ) ; }", "answer": "org . junit . Assert . assertThat ( merge . contains ( broadcast ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "between ( net . time4j . Moment , net . time4j . Moment ) { return new net . time4j . range . MomentInterval ( net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . CLOSED , start ) , net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . OPEN , end ) ) ; }", "testMethod": "containsTemporalLeftEdgeClosed ( ) { net . time4j . Moment start = net . time4j . PlainTimestamp . of ( 2014 , 2 , 27 , 0 , 0 ) . atUTC ( ) ; net . time4j . Moment end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 ) . atUTC ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . range . MomentInterval . between ( start , end ) . contains ( start ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "containsTemporalLeftEdgeClosed ( ) { net . time4j . Moment start = net . time4j . PlainTimestamp . of ( 2014 , 2 , 27 , 0 , 0 ) . atUTC ( ) ; net . time4j . Moment end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 ) . atUTC ( ) ; \"<AssertPlaceHolder>\" ; } between ( net . time4j . Moment , net . time4j . Moment ) { return new net . time4j . range . MomentInterval ( net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . CLOSED , start ) , net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . OPEN , end ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . range . MomentInterval . between ( start , end ) . contains ( start ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getStartFor ( org . joda . time . LocalDate ) { return hasNoStart ( ) ? allocationStart : start ; }", "testMethod": "ifTheIntervalStartIsNullReturnsThePassedStartDate ( ) { org . joda . time . LocalDate end = new org . joda . time . LocalDate ( ) . plusMonths ( 1 ) ; org . libreplan . business . planner . entities . StretchesFunction . Interval interval = new org . libreplan . business . planner . entities . StretchesFunction . Interval ( new java . math . BigDecimal ( 0.3 ) , null , end ) ; org . joda . time . LocalDate now = new org . joda . time . LocalDate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interval . getStartFor ( now ) , org . hamcrest . CoreMatchers . equalTo ( now ) )", "total": "ifTheIntervalStartIsNullReturnsThePassedStartDate ( ) { org . joda . time . LocalDate end = new org . joda . time . LocalDate ( ) . plusMonths ( 1 ) ; org . libreplan . business . planner . entities . StretchesFunction . Interval interval = new org . libreplan . business . planner . entities . StretchesFunction . Interval ( new java . math . BigDecimal ( 0.3 ) , null , end ) ; org . joda . time . LocalDate now = new org . joda . time . LocalDate ( ) ; \"<AssertPlaceHolder>\" ; } getStartFor ( org . joda . time . LocalDate ) { return hasNoStart ( ) ? allocationStart : start ; }", "answer": "org . junit . Assert . assertThat ( interval . getStartFor ( now ) , org . hamcrest . CoreMatchers . equalTo ( now ) )"}
{"focal": "matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "testMethod": "testMatchExactlyActionMatchErr ( ) { queriesString = org . apache . commons . lang . StringUtils . join ( new java . lang . String [ ] { \"type=node\" , \"enabled=true\" , \"type=node\" 0 } , \"&\" ) ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; target . parse ( ) ; java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlow flow = new org . o3project . odenos . core . component . network . flow . basic . BasicFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , path , edgeAction , flowAttributes ) ; @ org . o3project . odenos . core . component . network . flow . query . SuppressWarnings ( \"serial\" ) java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port1\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port2\" ; } } ) ; } } ; flow . addEdgeAction ( \"type=node\" 1 , actions . get ( 0 ) ) ; flow . addEdgeAction ( \"node02\" , actions . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testMatchExactlyActionMatchErr ( ) { queriesString = org . apache . commons . lang . StringUtils . join ( new java . lang . String [ ] { \"type=node\" , \"enabled=true\" , \"type=node\" 0 } , \"&\" ) ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; target . parse ( ) ; java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = null ; java . util . List < java . lang . String > path = null ; java . util . Map < java . lang . String , java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > > edgeAction = null ; java . util . Map < java . lang . String , java . lang . String > flowAttributes = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlow flow = new org . o3project . odenos . core . component . network . flow . basic . BasicFlow ( \"1\" , \"\" , \"\" , true , \"\" , \"established\" , matches , path , edgeAction , flowAttributes ) ; @ org . o3project . odenos . core . component . network . flow . query . SuppressWarnings ( \"serial\" ) java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port1\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port2\" ; } } ) ; } } ; flow . addEdgeAction ( \"type=node\" 1 , actions . get ( 0 ) ) ; flow . addEdgeAction ( \"node02\" , actions . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; } matchExactly ( org . o3project . odenos . core . component . network . flow . basic . FlowAction ) { if ( ( target == null ) || ( ! ( target . getType ( ) . equals ( org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionCopyTtlOut . class . getSimpleName ( ) ) ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . matchExactly ( flow ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "foldRight_A$Object ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > target = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . String z = \"\" ; com . m3 . scalaflavor4j . F2 < java . lang . String , java . lang . String , java . lang . String > op = new com . m3 . scalaflavor4j . F2 < java . lang . String , java . lang . String , java . lang . String > ( ) { public java . lang . String apply ( java . lang . String v1 , java . lang . String v2 ) { return v1 + v2 ; } } ; java . lang . String actual = target . foldRight ( z ) . apply ( op ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "foldRight_A$Object ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > target = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . String z = \"\" ; com . m3 . scalaflavor4j . F2 < java . lang . String , java . lang . String , java . lang . String > op = new com . m3 . scalaflavor4j . F2 < java . lang . String , java . lang . String , java . lang . String > ( ) { public java . lang . String apply ( java . lang . String v1 , java . lang . String v2 ) { return v1 + v2 ; } } ; java . lang . String actual = target . foldRight ( z ) . apply ( op ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getConvNodeId ( java . lang . String , java . lang . String ) { org . o3project . odenos . component . federator . FederatorOnFlow . log . debug ( \"\" ) ; if ( ( networkId == null ) || ( nodeId == null ) ) { org . o3project . odenos . component . federator . FederatorOnFlow . log . warn ( \"invalid<sp>param\" ) ; return null ; } java . util . ArrayList < java . lang . String > convNodeId = conversionTable . getNode ( networkId , nodeId ) ; if ( ( convNodeId . size ( ) ) == 0 ) { org . o3project . odenos . component . federator . FederatorOnFlow . log . warn ( \"invalid<sp>convNodeId\" ) ; return null ; } return convNodeId . get ( 0 ) ; }", "testMethod": "testGetConvNodeId ( ) { java . lang . String nwId = \"network01\" ; java . lang . String nodeId = \"node01\" ; java . util . ArrayList < java . lang . String > nodeList = new java . util . ArrayList < java . lang . String > ( ) { { add ( \"node01\" ) ; add ( \"node02\" ) ; } } ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( nodeList ) . when ( conversionTable , \"getNode\" , nwId , nodeId ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getConvNodeId ( nwId , nodeId ) , org . hamcrest . CoreMatchers . is ( \"node01\" ) )", "total": "testGetConvNodeId ( ) { java . lang . String nwId = \"network01\" ; java . lang . String nodeId = \"node01\" ; java . util . ArrayList < java . lang . String > nodeList = new java . util . ArrayList < java . lang . String > ( ) { { add ( \"node01\" ) ; add ( \"node02\" ) ; } } ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( nodeList ) . when ( conversionTable , \"getNode\" , nwId , nodeId ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; } getConvNodeId ( java . lang . String , java . lang . String ) { org . o3project . odenos . component . federator . FederatorOnFlow . log . debug ( \"\" ) ; if ( ( networkId == null ) || ( nodeId == null ) ) { org . o3project . odenos . component . federator . FederatorOnFlow . log . warn ( \"invalid<sp>param\" ) ; return null ; } java . util . ArrayList < java . lang . String > convNodeId = conversionTable . getNode ( networkId , nodeId ) ; if ( ( convNodeId . size ( ) ) == 0 ) { org . o3project . odenos . component . federator . FederatorOnFlow . log . warn ( \"invalid<sp>convNodeId\" ) ; return null ; } return convNodeId . get ( 0 ) ; }", "answer": "org . junit . Assert . assertThat ( target . getConvNodeId ( nwId , nodeId ) , org . hamcrest . CoreMatchers . is ( \"node01\" ) )"}
{"focal": "size ( ) { return locationPks . size ( ) ; }", "testMethod": "matchDateOnlyTestOpenEndedIntervalRangeInclusive ( ) { org . dcm4che3 . data . Attributes testAttrs = new org . dcm4che3 . data . Attributes ( ) ; java . lang . String daString = \"20151007-\" ; java . util . List < org . dcm4chee . archive . entity . Study > studies = createDateRangeQuery ( testAttrs , daString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( studies . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "matchDateOnlyTestOpenEndedIntervalRangeInclusive ( ) { org . dcm4che3 . data . Attributes testAttrs = new org . dcm4che3 . data . Attributes ( ) ; java . lang . String daString = \"20151007-\" ; java . util . List < org . dcm4chee . archive . entity . Study > studies = createDateRangeQuery ( testAttrs , daString ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return locationPks . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( studies . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "deserialize ( java . lang . String , java . lang . Object , com . fasterxml . jackson . core . JsonParser , com . fasterxml . jackson . databind . DeserializationContext , com . fasterxml . jackson . core . JsonGenerator ) { generator . writeFieldName ( fieldName ) ; java . lang . Object value ; try { value = deserializeValue ( defaultValue ) ; } catch ( java . lang . RuntimeException e ) { if ( ( e . getCause ( ) ) instanceof java . io . IOException ) { throw ( ( java . io . IOException ) ( e . getCause ( ) ) ) ; } throw e ; } if ( ( java . util . Objects . nonNull ( value ) ) || ( ( parser . currentTokenId ( ) ) == ( com . fasterxml . jackson . core . JsonTokenId . ID_NULL ) ) ) { generator . writeObject ( value ) ; } return value ; }", "testMethod": "should_Deserialize_Default_Value ( ) { java . lang . Object value = underTest . deserialize ( org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_NAME , org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_VALUE , parser , context , generator ) ; \"<AssertPlaceHolder>\" ; verify ( generator ) . writeFieldName ( eq ( org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_NAME ) ) ; verify ( generator ) . writeObject ( eq ( org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_VALUE ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . equalTo ( value ) )", "total": "should_Deserialize_Default_Value ( ) { java . lang . Object value = underTest . deserialize ( org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_NAME , org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_VALUE , parser , context , generator ) ; \"<AssertPlaceHolder>\" ; verify ( generator ) . writeFieldName ( eq ( org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_NAME ) ) ; verify ( generator ) . writeObject ( eq ( org . sonatype . nexus . repository . npm . internal . NpmFieldDeserializerTest . FIELD_VALUE ) ) ; } deserialize ( java . lang . String , java . lang . Object , com . fasterxml . jackson . core . JsonParser , com . fasterxml . jackson . databind . DeserializationContext , com . fasterxml . jackson . core . JsonGenerator ) { generator . writeFieldName ( fieldName ) ; java . lang . Object value ; try { value = deserializeValue ( defaultValue ) ; } catch ( java . lang . RuntimeException e ) { if ( ( e . getCause ( ) ) instanceof java . io . IOException ) { throw ( ( java . io . IOException ) ( e . getCause ( ) ) ) ; } throw e ; } if ( ( java . util . Objects . nonNull ( value ) ) || ( ( parser . currentTokenId ( ) ) == ( com . fasterxml . jackson . core . JsonTokenId . ID_NULL ) ) ) { generator . writeObject ( value ) ; } return value ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . equalTo ( value ) )"}
{"focal": "performPreDataProcessing ( org . pentaho . reporting . engine . classic . core . SubReport , org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController ) { if ( ( ( script ) == null ) || ( ( language ) == null ) ) { return definition ; } try { final org . apache . bsf . BSFManager interpreter = new org . apache . bsf . BSFManager ( ) ; interpreter . declareBean ( \"definition\" , definition , org . pentaho . reporting . engine . classic . core . MasterReport . class ) ; interpreter . declareBean ( \"flowController\" , flowController , org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController . class ) ; final java . lang . Object o = interpreter . eval ( getLanguage ( ) , \"expression\" , 1 , 1 , preDataScript ) ; if ( ( o instanceof org . pentaho . reporting . engine . classic . core . SubReport ) == false ) { throw new org . pentaho . reporting . engine . classic . core . ReportDataFactoryException ( \"Not<sp>a<sp>SubReport\" ) ; } return ( ( org . pentaho . reporting . engine . classic . core . SubReport ) ( o ) ) ; } catch ( org . apache . bsf . BSFException e ) { throw new org . pentaho . reporting . engine . classic . core . ReportDataFactoryException ( \"Failed<sp>to<sp>initialize<sp>the<sp>BSF-Framework\" , e ) ; } }", "testMethod": "testPerformPreDataProcessingSubReport ( ) { org . pentaho . reporting . engine . classic . core . SubReport definition = mock ( org . pentaho . reporting . engine . classic . core . SubReport . class ) ; org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController flowController = mock ( org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController . class ) ; org . pentaho . reporting . engine . classic . core . SubReport result = preProcessor . performPreDataProcessing ( definition , flowController ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( definition ) ) )", "total": "testPerformPreDataProcessingSubReport ( ) { org . pentaho . reporting . engine . classic . core . SubReport definition = mock ( org . pentaho . reporting . engine . classic . core . SubReport . class ) ; org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController flowController = mock ( org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController . class ) ; org . pentaho . reporting . engine . classic . core . SubReport result = preProcessor . performPreDataProcessing ( definition , flowController ) ; \"<AssertPlaceHolder>\" ; } performPreDataProcessing ( org . pentaho . reporting . engine . classic . core . SubReport , org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController ) { if ( ( ( script ) == null ) || ( ( language ) == null ) ) { return definition ; } try { final org . apache . bsf . BSFManager interpreter = new org . apache . bsf . BSFManager ( ) ; interpreter . declareBean ( \"definition\" , definition , org . pentaho . reporting . engine . classic . core . MasterReport . class ) ; interpreter . declareBean ( \"flowController\" , flowController , org . pentaho . reporting . engine . classic . core . states . datarow . DefaultFlowController . class ) ; final java . lang . Object o = interpreter . eval ( getLanguage ( ) , \"expression\" , 1 , 1 , preDataScript ) ; if ( ( o instanceof org . pentaho . reporting . engine . classic . core . SubReport ) == false ) { throw new org . pentaho . reporting . engine . classic . core . ReportDataFactoryException ( \"Not<sp>a<sp>SubReport\" ) ; } return ( ( org . pentaho . reporting . engine . classic . core . SubReport ) ( o ) ) ; } catch ( org . apache . bsf . BSFException e ) { throw new org . pentaho . reporting . engine . classic . core . ReportDataFactoryException ( \"Failed<sp>to<sp>initialize<sp>the<sp>BSF-Framework\" , e ) ; } }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( definition ) ) )"}
{"focal": "onOutPacketAddedPre ( java . lang . String , org . o3project . odenos . core . component . network . packet . OutPacketAdded ) { org . o3project . odenos . component . aggregator . Aggregator . log . debug ( \"\" ) ; org . o3project . odenos . component . aggregator . Aggregator . log . debug ( \"###Received<sp>OutPacketAdded:id({})\" , msg . getId ( ) ) ; java . lang . String connType = conversionTable ( ) . getConnectionType ( networkId ) ; if ( ( connType != null ) && ( connType . equals ( org . o3project . odenos . component . aggregator . Aggregator . ORIGINAL ) ) ) { return false ; } return true ; }", "testMethod": "testOnOutPacketAddedPreSuccess ( ) { org . o3project . odenos . core . component . network . packet . OutPacketAdded msg = new org . o3project . odenos . core . component . network . packet . OutPacketAdded ( ) ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( \"aggregated\" ) . when ( conversionTable , \"getConnectionType\" , org . o3project . odenos . component . aggregator . AggregatorTest . ORIGINAL_NW_ID ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . onOutPacketAddedPre ( org . o3project . odenos . component . aggregator . AggregatorTest . ORIGINAL_NW_ID , msg ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testOnOutPacketAddedPreSuccess ( ) { org . o3project . odenos . core . component . network . packet . OutPacketAdded msg = new org . o3project . odenos . core . component . network . packet . OutPacketAdded ( ) ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( \"aggregated\" ) . when ( conversionTable , \"getConnectionType\" , org . o3project . odenos . component . aggregator . AggregatorTest . ORIGINAL_NW_ID ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; } onOutPacketAddedPre ( java . lang . String , org . o3project . odenos . core . component . network . packet . OutPacketAdded ) { org . o3project . odenos . component . aggregator . Aggregator . log . debug ( \"\" ) ; org . o3project . odenos . component . aggregator . Aggregator . log . debug ( \"###Received<sp>OutPacketAdded:id({})\" , msg . getId ( ) ) ; java . lang . String connType = conversionTable ( ) . getConnectionType ( networkId ) ; if ( ( connType != null ) && ( connType . equals ( org . o3project . odenos . component . aggregator . Aggregator . ORIGINAL ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . onOutPacketAddedPre ( org . o3project . odenos . component . aggregator . AggregatorTest . ORIGINAL_NW_ID , msg ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "hasPort ( int ) { for ( com . oracle . bedrock . runtime . options . Ports . Port port : ports . values ( ) ) { if ( ( port . getMappedPort ( ) ) == mappedPort ) { return true ; } } return false ; }", "testMethod": "shouldHaveMappedPort ( ) { com . oracle . bedrock . runtime . options . Ports . Port port = new com . oracle . bedrock . runtime . options . Ports . Port ( \"foo.1\" , 1 , 2 ) ; com . oracle . bedrock . runtime . options . Ports ports = com . oracle . bedrock . runtime . options . Ports . of ( port ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ports . hasPort ( port . getMappedPort ( ) ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "shouldHaveMappedPort ( ) { com . oracle . bedrock . runtime . options . Ports . Port port = new com . oracle . bedrock . runtime . options . Ports . Port ( \"foo.1\" , 1 , 2 ) ; com . oracle . bedrock . runtime . options . Ports ports = com . oracle . bedrock . runtime . options . Ports . of ( port ) ; \"<AssertPlaceHolder>\" ; } hasPort ( int ) { for ( com . oracle . bedrock . runtime . options . Ports . Port port : ports . values ( ) ) { if ( ( port . getMappedPort ( ) ) == mappedPort ) { return true ; } } return false ; }", "answer": "org . junit . Assert . assertThat ( ports . hasPort ( port . getMappedPort ( ) ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "playAGameWithAPlayerOfPosition ( com . blogspot . toomuchcoding . service . PositionType ) { com . blogspot . toomuchcoding . service . Player player = playerFactory . createPlayer ( positionType ) ; player . run ( ) ; performAdditionalActions ( player ) ; return player ; }", "testMethod": "shouldReturnDefensivePlayerButHeWontBeADjNorAJavaDev ( ) { given ( playerFactory . createPlayer ( PositionType . GK ) ) . willReturn ( defensivePlayer ) ; com . blogspot . toomuchcoding . service . Player createdPlayer = objectUnderTest . playAGameWithAPlayerOfPosition ( PositionType . GK ) ; \"<AssertPlaceHolder>\" ; verify ( defensivePlayer ) . run ( ) ; verify ( defensivePlayer ) . defend ( ) ; verifyNoMoreInteractions ( defensivePlayer ) ; }", "assertLine": "org . junit . Assert . assertThat ( ( createdPlayer == ( defensivePlayer ) ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "shouldReturnDefensivePlayerButHeWontBeADjNorAJavaDev ( ) { given ( playerFactory . createPlayer ( PositionType . GK ) ) . willReturn ( defensivePlayer ) ; com . blogspot . toomuchcoding . service . Player createdPlayer = objectUnderTest . playAGameWithAPlayerOfPosition ( PositionType . GK ) ; \"<AssertPlaceHolder>\" ; verify ( defensivePlayer ) . run ( ) ; verify ( defensivePlayer ) . defend ( ) ; verifyNoMoreInteractions ( defensivePlayer ) ; } playAGameWithAPlayerOfPosition ( com . blogspot . toomuchcoding . service . PositionType ) { com . blogspot . toomuchcoding . service . Player player = playerFactory . createPlayer ( positionType ) ; player . run ( ) ; performAdditionalActions ( player ) ; return player ; }", "answer": "org . junit . Assert . assertThat ( ( createdPlayer == ( defensivePlayer ) ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getValueForAttribute ( net . ripe . db . whois . common . rpsl . AttributeType ) { return findAttribute ( attributeType ) . getCleanValue ( ) ; }", "testMethod": "transform_ds_rdata_remove_parentheses ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( \"domain:<sp>17.45.212.in-addr.arpa\\n\" + \"ds-rdata:<sp>52314<sp>5<sp>1<sp>(<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF<sp>)\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject result = attributeSanitizer . sanitize ( rpslObject , objectMessages ) ; \"<AssertPlaceHolder>\" ; verify ( objectMessages ) . addMessage ( result . findAttribute ( AttributeType . DS_RDATA ) , net . ripe . db . whois . common . rpsl . ValidationMessages . attributeValueConverted ( \"52314<sp>5<sp>1<sp>(<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF<sp>)\" , \"52314<sp>5<sp>1<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF\" ) ) ; verifyNoMoreInteractions ( objectMessages ) ; }", "assertLine": "org . junit . Assert . assertThat ( result . getValueForAttribute ( AttributeType . DS_RDATA ) . toString ( ) , org . hamcrest . Matchers . is ( \"52314<sp>5<sp>1<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF\" ) )", "total": "transform_ds_rdata_remove_parentheses ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( \"domain:<sp>17.45.212.in-addr.arpa\\n\" + \"ds-rdata:<sp>52314<sp>5<sp>1<sp>(<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF<sp>)\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject result = attributeSanitizer . sanitize ( rpslObject , objectMessages ) ; \"<AssertPlaceHolder>\" ; verify ( objectMessages ) . addMessage ( result . findAttribute ( AttributeType . DS_RDATA ) , net . ripe . db . whois . common . rpsl . ValidationMessages . attributeValueConverted ( \"52314<sp>5<sp>1<sp>(<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF<sp>)\" , \"52314<sp>5<sp>1<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF\" ) ) ; verifyNoMoreInteractions ( objectMessages ) ; } getValueForAttribute ( net . ripe . db . whois . common . rpsl . AttributeType ) { return findAttribute ( attributeType ) . getCleanValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . getValueForAttribute ( AttributeType . DS_RDATA ) . toString ( ) , org . hamcrest . Matchers . is ( \"52314<sp>5<sp>1<sp>93B5837D4E5C063A3728FAA72BA64068F89B39DF\" ) )"}
{"focal": "loadFromClassPath ( java . lang . String ) { jscover . util . InputStream is = null ; try { is = jscover . util . IoUtils . class . getResourceAsStream ( dataFile ) ; return toString ( is ) ; } catch ( java . lang . Throwable e ) { throw new java . lang . RuntimeException ( java . lang . String . format ( \"Problem<sp>loading<sp>resource:<sp>'%s'\" , dataFile ) , e ) ; } finally { closeQuietly ( is ) ; } }", "testMethod": "shouldMergeData ( ) { java . lang . String data1 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1.json\" ) ; java . lang . String data2 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-3.json\" ) ; java . lang . String expected = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1-3.json\" ) ; java . lang . String merged = jsonMerger . toJSON ( jsonMerger . mergeJSONCoverageStrings ( data1 , data2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( merged , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "shouldMergeData ( ) { java . lang . String data1 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1.json\" ) ; java . lang . String data2 = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-3.json\" ) ; java . lang . String expected = ioUtils . loadFromClassPath ( \"/jscover/report/jscoverage-select-1-3.json\" ) ; java . lang . String merged = jsonMerger . toJSON ( jsonMerger . mergeJSONCoverageStrings ( data1 , data2 ) ) ; \"<AssertPlaceHolder>\" ; } loadFromClassPath ( java . lang . String ) { jscover . util . InputStream is = null ; try { is = jscover . util . IoUtils . class . getResourceAsStream ( dataFile ) ; return toString ( is ) ; } catch ( java . lang . Throwable e ) { throw new java . lang . RuntimeException ( java . lang . String . format ( \"Problem<sp>loading<sp>resource:<sp>'%s'\" , dataFile ) , e ) ; } finally { closeQuietly ( is ) ; } }", "answer": "org . junit . Assert . assertThat ( merged , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "getList ( net . vvakame . util . jsonpullparser . JsonPullParser ) { return getList ( parser , null ) ; }", "testMethod": "jsonArray ( ) { java . lang . String json = \"[{\\\"bool\\\":false,\\\"c\\\":1,\\\"1CHAR\\\",\\\"b\\\":-128,\\\"s\\\":1,\\\"i\\\":1,\\\"l\\\":1,\\\"f\\\":1,\\\"d\\\":1},<sp>{\\\"bool\\\":true,\\\"c\\\":1,\\\"1char\\\",\\\"b\\\":127,\\\"s\\\":1,\\\"2i\\\":2147483647,\\\"l\\\":2147483647,\\\"f\\\":1,\\\"0d\\\":1.7976931348623157E308}]\" ; net . vvakame . util . jsonpullparser . JsonPullParser parser = net . vvakame . util . jsonpullparser . JsonPullParser . newParser ( json ) ; java . util . List < net . vvakame . sample . PrimitiveTypeData > list = net . vvakame . sample . PrimitiveTypeDataGenerated . getList ( parser ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "jsonArray ( ) { java . lang . String json = \"[{\\\"bool\\\":false,\\\"c\\\":1,\\\"1CHAR\\\",\\\"b\\\":-128,\\\"s\\\":1,\\\"i\\\":1,\\\"l\\\":1,\\\"f\\\":1,\\\"d\\\":1},<sp>{\\\"bool\\\":true,\\\"c\\\":1,\\\"1char\\\",\\\"b\\\":127,\\\"s\\\":1,\\\"2i\\\":2147483647,\\\"l\\\":2147483647,\\\"f\\\":1,\\\"0d\\\":1.7976931348623157E308}]\" ; net . vvakame . util . jsonpullparser . JsonPullParser parser = net . vvakame . util . jsonpullparser . JsonPullParser . newParser ( json ) ; java . util . List < net . vvakame . sample . PrimitiveTypeData > list = net . vvakame . sample . PrimitiveTypeDataGenerated . getList ( parser ) ; \"<AssertPlaceHolder>\" ; } getList ( net . vvakame . util . jsonpullparser . JsonPullParser ) { return getList ( parser , null ) ; }", "answer": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "name ( ) { return name ; }", "testMethod": "tablesShouldFormatAsAsciiDoc ( ) { org . neo4j . doc . server . rest . transactional . error . ErrorDocumentationGenerator . Table table = new org . neo4j . doc . server . rest . transactional . error . ErrorDocumentationGenerator . Table ( ) ; table . setCols ( \"COLS\" ) ; table . setHeader ( \"A\" , \"B\" ) ; table . addRow ( 1 , 2 ) ; table . addRow ( 3 , 4 ) ; java . io . ByteArrayOutputStream buf = new java . io . ByteArrayOutputStream ( ) ; java . io . PrintStream out = new java . io . PrintStream ( buf , false , StandardCharsets . UTF_8 . name ( ) ) ; table . print ( out ) ; out . flush ( ) ; java . lang . String result = buf . toString ( StandardCharsets . UTF_8 . name ( ) ) ; java . lang . String n = java . lang . System . lineSeparator ( ) ; java . lang . String expected = ( ( ( ( ( ( ( ( ( ( \"[options=\\\"header\\\",<sp>cols=\\\"COLS\\\"]\" + n ) + \"|===\" ) + n ) + \"|A<sp>|B<sp>\" ) + n ) + \"|1<sp>|2<sp>\" ) + n ) + \"|3<sp>|4<sp>\" ) + n ) + \"|===\" ) + n ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expected ) ) )", "total": "tablesShouldFormatAsAsciiDoc ( ) { org . neo4j . doc . server . rest . transactional . error . ErrorDocumentationGenerator . Table table = new org . neo4j . doc . server . rest . transactional . error . ErrorDocumentationGenerator . Table ( ) ; table . setCols ( \"COLS\" ) ; table . setHeader ( \"A\" , \"B\" ) ; table . addRow ( 1 , 2 ) ; table . addRow ( 3 , 4 ) ; java . io . ByteArrayOutputStream buf = new java . io . ByteArrayOutputStream ( ) ; java . io . PrintStream out = new java . io . PrintStream ( buf , false , StandardCharsets . UTF_8 . name ( ) ) ; table . print ( out ) ; out . flush ( ) ; java . lang . String result = buf . toString ( StandardCharsets . UTF_8 . name ( ) ) ; java . lang . String n = java . lang . System . lineSeparator ( ) ; java . lang . String expected = ( ( ( ( ( ( ( ( ( ( \"[options=\\\"header\\\",<sp>cols=\\\"COLS\\\"]\" + n ) + \"|===\" ) + n ) + \"|A<sp>|B<sp>\" ) + n ) + \"|1<sp>|2<sp>\" ) + n ) + \"|3<sp>|4<sp>\" ) + n ) + \"|===\" ) + n ; \"<AssertPlaceHolder>\" ; } name ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expected ) ) )"}
{"focal": "parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "testMethod": "testParseActionKeyErr ( ) { queriesString = \"type=node&enabled=true&status=established&actions=node_id=Network\" ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testParseActionKeyErr ( ) { queriesString = \"type=node&enabled=true&status=established&actions=node_id=Network\" ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; } parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "needValidate ( ) { return tokenType . needValidate ( ) ; }", "testMethod": "testNeedValidate05 ( ) { java . lang . String tokenName = \"aaa\" ; org . terasoluna . gfw . web . token . transaction . TransactionTokenType tokenType = TransactionTokenType . CHECK ; org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo info = new org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo ( tokenName , tokenType ) ; boolean output = info . needValidate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( output , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testNeedValidate05 ( ) { java . lang . String tokenName = \"aaa\" ; org . terasoluna . gfw . web . token . transaction . TransactionTokenType tokenType = TransactionTokenType . CHECK ; org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo info = new org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo ( tokenName , tokenType ) ; boolean output = info . needValidate ( ) ; \"<AssertPlaceHolder>\" ; } needValidate ( ) { return tokenType . needValidate ( ) ; }", "answer": "org . junit . Assert . assertThat ( output , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getConfigStatusMessages ( ) { return java . util . Collections . unmodifiableCollection ( configStatusMessages ) ; }", "testMethod": "assertCorrectConfigErrorHandlingForEmptyResultObject ( ) { org . eclipse . smarthome . config . core . status . ConfigStatusInfo info = new org . eclipse . smarthome . config . core . status . ConfigStatusInfo ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( info . getConfigStatusMessages ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "assertCorrectConfigErrorHandlingForEmptyResultObject ( ) { org . eclipse . smarthome . config . core . status . ConfigStatusInfo info = new org . eclipse . smarthome . config . core . status . ConfigStatusInfo ( ) ; \"<AssertPlaceHolder>\" ; } getConfigStatusMessages ( ) { return java . util . Collections . unmodifiableCollection ( configStatusMessages ) ; }", "answer": "org . junit . Assert . assertThat ( info . getConfigStatusMessages ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "allMatch ( com . arangodb . Predicate ) { boolean match = false ; for ( final T t : this ) { match = predicate . test ( t ) ; if ( ! match ) { break ; } } return match ; }", "testMethod": "allMatch ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final boolean match = cursor . allMatch ( new com . arangodb . Predicate < com . arangodb . velocypack . VPackSlice > ( ) { @ com . arangodb . Override public boolean test ( final com . arangodb . velocypack . VPackSlice t ) { return ( t . getAsLong ( ) ) < 100L ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( match , org . hamcrest . Matchers . is ( true ) )", "total": "allMatch ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final boolean match = cursor . allMatch ( new com . arangodb . Predicate < com . arangodb . velocypack . VPackSlice > ( ) { @ com . arangodb . Override public boolean test ( final com . arangodb . velocypack . VPackSlice t ) { return ( t . getAsLong ( ) ) < 100L ; } } ) ; \"<AssertPlaceHolder>\" ; } allMatch ( com . arangodb . Predicate ) { boolean match = false ; for ( final T t : this ) { match = predicate . test ( t ) ; if ( ! match ) { break ; } } return match ; }", "answer": "org . junit . Assert . assertThat ( match , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getInterfaces ( ) { if ( ( interfaces ) == null ) { interfaces = java . util . Collections . unmodifiableList ( getCanonicalizer ( ) . getCanonicalTypes ( underlyingElement . getInterfaces ( ) , getTreePath ( ) , tree . getImplementsClause ( ) ) ) ; } return interfaces ; }", "testMethod": "testGetInterfacesDefaultsEmptyForClass ( ) { compile ( java . lang . String . join ( java . lang . System . lineSeparator ( ) , \"package<sp>com.facebook.foo;\" , \"public<sp>class<sp>Foo<sp>{<sp>}\" ) ) ; javax . lang . model . element . TypeElement fooElement = elements . getTypeElement ( \"com.facebook.foo.Foo\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fooElement . getInterfaces ( ) , org . hamcrest . Matchers . empty ( ) )", "total": "testGetInterfacesDefaultsEmptyForClass ( ) { compile ( java . lang . String . join ( java . lang . System . lineSeparator ( ) , \"package<sp>com.facebook.foo;\" , \"public<sp>class<sp>Foo<sp>{<sp>}\" ) ) ; javax . lang . model . element . TypeElement fooElement = elements . getTypeElement ( \"com.facebook.foo.Foo\" ) ; \"<AssertPlaceHolder>\" ; } getInterfaces ( ) { if ( ( interfaces ) == null ) { interfaces = java . util . Collections . unmodifiableList ( getCanonicalizer ( ) . getCanonicalTypes ( underlyingElement . getInterfaces ( ) , getTreePath ( ) , tree . getImplementsClause ( ) ) ) ; } return interfaces ; }", "answer": "org . junit . Assert . assertThat ( fooElement . getInterfaces ( ) , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getText ( ) { return stb . getText ( ) ; }", "testMethod": "testWillSimulateAKeyUpWhenEnteringTextIntoTextAreas ( ) { driver . get ( pages . javascriptPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"keyUpArea\" ) ) ; element . sendKeys ( \"I<sp>like<sp>cheese\" ) ; org . openqa . selenium . WebElement result = driver . findElement ( org . openqa . selenium . By . id ( \"result\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . getText ( ) , org . hamcrest . Matchers . equalTo ( \"I<sp>like<sp>cheese\" ) )", "total": "testWillSimulateAKeyUpWhenEnteringTextIntoTextAreas ( ) { driver . get ( pages . javascriptPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"keyUpArea\" ) ) ; element . sendKeys ( \"I<sp>like<sp>cheese\" ) ; org . openqa . selenium . WebElement result = driver . findElement ( org . openqa . selenium . By . id ( \"result\" ) ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { return stb . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . getText ( ) , org . hamcrest . Matchers . equalTo ( \"I<sp>like<sp>cheese\" ) )"}
{"focal": "size ( ) { return whiteList . size ( ) ; }", "testMethod": "negativeDisconnectConnectionDelay ( ) { waggleDanceConfiguration . setDisconnectConnectionDelay ( ( - 1 ) ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . waggledance . conf . WaggleDanceConfiguration > > violations = validator . validate ( waggleDanceConfiguration ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "negativeDisconnectConnectionDelay ( ) { waggleDanceConfiguration . setDisconnectConnectionDelay ( ( - 1 ) ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . waggledance . conf . WaggleDanceConfiguration > > violations = validator . validate ( waggleDanceConfiguration ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return whiteList . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "hasOnlyPrivateConstructors ( ) { return new com . annimon . stream . test . hamcrest . CommonMatcher . PrivateConstructorsMatcher ( ) ; }", "testMethod": "testPrivateConstructor ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . annimon . stream . test . hamcrest . CommonMatcher . class , com . annimon . stream . test . hamcrest . CommonMatcher . hasOnlyPrivateConstructors ( ) )", "total": "testPrivateConstructor ( ) { \"<AssertPlaceHolder>\" ; } hasOnlyPrivateConstructors ( ) { return new com . annimon . stream . test . hamcrest . CommonMatcher . PrivateConstructorsMatcher ( ) ; }", "answer": "org . junit . Assert . assertThat ( com . annimon . stream . test . hamcrest . CommonMatcher . class , com . annimon . stream . test . hamcrest . CommonMatcher . hasOnlyPrivateConstructors ( ) )"}
{"focal": "getSequenceId ( ) { return 0 ; }", "testMethod": "assertWriteWithResultSetMetaData ( ) { when ( resultSetMetaData . getSchemaName ( 1 ) ) . thenReturn ( ShardingConstant . LOGIC_SCHEMA_NAME ) ; when ( resultSetMetaData . getTableName ( 1 ) ) . thenReturn ( \"tbl\" ) ; when ( resultSetMetaData . getColumnLabel ( 1 ) ) . thenReturn ( \"id\" ) ; when ( resultSetMetaData . getColumnName ( 1 ) ) . thenReturn ( \"id\" ) ; when ( resultSetMetaData . getColumnDisplaySize ( 1 ) ) . thenReturn ( 10 ) ; when ( resultSetMetaData . getColumnType ( 1 ) ) . thenReturn ( Types . INTEGER ) ; org . apache . shardingsphere . shardingproxy . transport . mysql . packet . command . query . MySQLColumnDefinition41Packet actual = new org . apache . shardingsphere . shardingproxy . transport . mysql . packet . command . query . MySQLColumnDefinition41Packet ( 1 , resultSetMetaData , 1 ) ; \"<AssertPlaceHolder>\" ; actual . write ( payload ) ; verifyWrite ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( actual . getSequenceId ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "assertWriteWithResultSetMetaData ( ) { when ( resultSetMetaData . getSchemaName ( 1 ) ) . thenReturn ( ShardingConstant . LOGIC_SCHEMA_NAME ) ; when ( resultSetMetaData . getTableName ( 1 ) ) . thenReturn ( \"tbl\" ) ; when ( resultSetMetaData . getColumnLabel ( 1 ) ) . thenReturn ( \"id\" ) ; when ( resultSetMetaData . getColumnName ( 1 ) ) . thenReturn ( \"id\" ) ; when ( resultSetMetaData . getColumnDisplaySize ( 1 ) ) . thenReturn ( 10 ) ; when ( resultSetMetaData . getColumnType ( 1 ) ) . thenReturn ( Types . INTEGER ) ; org . apache . shardingsphere . shardingproxy . transport . mysql . packet . command . query . MySQLColumnDefinition41Packet actual = new org . apache . shardingsphere . shardingproxy . transport . mysql . packet . command . query . MySQLColumnDefinition41Packet ( 1 , resultSetMetaData , 1 ) ; \"<AssertPlaceHolder>\" ; actual . write ( payload ) ; verifyWrite ( ) ; } getSequenceId ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( actual . getSequenceId ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getReferenceValue ( ) { final java . util . Set < net . ripe . db . whois . common . domain . CIString > values = getReferenceValues ( ) ; switch ( values . size ( ) ) { case 0 : throw new java . lang . IllegalStateException ( \"No<sp>value<sp>found\" ) ; case 1 : return values . iterator ( ) . next ( ) ; default : throw new java . lang . IllegalStateException ( ( \"Multiple<sp>reference<sp>values<sp>found:<sp>\" + values ) ) ; } }", "testMethod": "reference_value_reference ( ) { subject = new net . ripe . db . whois . common . rpsl . RpslAttribute ( \"mnt-by\" , \"DEV-MNT\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( subject . getReferenceValue ( ) . toString ( ) , org . hamcrest . Matchers . is ( \"DEV-MNT\" ) )", "total": "reference_value_reference ( ) { subject = new net . ripe . db . whois . common . rpsl . RpslAttribute ( \"mnt-by\" , \"DEV-MNT\" ) ; \"<AssertPlaceHolder>\" ; } getReferenceValue ( ) { final java . util . Set < net . ripe . db . whois . common . domain . CIString > values = getReferenceValues ( ) ; switch ( values . size ( ) ) { case 0 : throw new java . lang . IllegalStateException ( \"No<sp>value<sp>found\" ) ; case 1 : return values . iterator ( ) . next ( ) ; default : throw new java . lang . IllegalStateException ( ( \"Multiple<sp>reference<sp>values<sp>found:<sp>\" + values ) ) ; } }", "answer": "org . junit . Assert . assertThat ( subject . getReferenceValue ( ) . toString ( ) , org . hamcrest . Matchers . is ( \"DEV-MNT\" ) )"}
{"focal": "onCreate ( ) { final com . google . inject . Injector injector = roboguice . RoboGuice . getInjector ( this ) ; eventManager = injector . getInstance ( roboguice . event . EventManager . class ) ; injector . injectMembers ( this ) ; super . onCreate ( ) ; eventManager . fire ( new roboguice . context . event . OnCreateEvent < android . app . Service > ( this , null ) ) ; }", "testMethod": "shouldBeAbleToInjectInRoboService ( ) { final roboguice . service . ServiceInjectionTest . RoboServiceA roboService = new roboguice . service . ServiceInjectionTest . RoboServiceA ( ) ; roboService . onCreate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( roboService . context , org . hamcrest . CoreMatchers . equalTo ( ( ( android . content . Context ) ( roboService ) ) ) )", "total": "shouldBeAbleToInjectInRoboService ( ) { final roboguice . service . ServiceInjectionTest . RoboServiceA roboService = new roboguice . service . ServiceInjectionTest . RoboServiceA ( ) ; roboService . onCreate ( ) ; \"<AssertPlaceHolder>\" ; } onCreate ( ) { final com . google . inject . Injector injector = roboguice . RoboGuice . getInjector ( this ) ; eventManager = injector . getInstance ( roboguice . event . EventManager . class ) ; injector . injectMembers ( this ) ; super . onCreate ( ) ; eventManager . fire ( new roboguice . context . event . OnCreateEvent < android . app . Service > ( this , null ) ) ; }", "answer": "org . junit . Assert . assertThat ( roboService . context , org . hamcrest . CoreMatchers . equalTo ( ( ( android . content . Context ) ( roboService ) ) ) )"}
{"focal": "nowUtc ( ) { org . joda . time . DateTime now = com . hotels . bdp . circustrain . core . conf . ExpressionParserFunctions . nowUtc ( ) ; org . junit . Assert . assertThat ( now . getZone ( ) , org . hamcrest . CoreMatchers . is ( DateTimeZone . UTC ) ) ; }", "testMethod": "nowUtc ( ) { org . joda . time . DateTime now = com . hotels . bdp . circustrain . core . conf . ExpressionParserFunctions . nowUtc ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( now . getZone ( ) , org . hamcrest . CoreMatchers . is ( DateTimeZone . UTC ) )", "total": "nowUtc ( ) { org . joda . time . DateTime now = com . hotels . bdp . circustrain . core . conf . ExpressionParserFunctions . nowUtc ( ) ; \"<AssertPlaceHolder>\" ; } nowUtc ( ) { org . joda . time . DateTime now = com . hotels . bdp . circustrain . core . conf . ExpressionParserFunctions . nowUtc ( ) ; org . junit . Assert . assertThat ( now . getZone ( ) , org . hamcrest . CoreMatchers . is ( DateTimeZone . UTC ) ) ; }", "answer": "org . junit . Assert . assertThat ( now . getZone ( ) , org . hamcrest . CoreMatchers . is ( DateTimeZone . UTC ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "size1 ( ) { int actual = sut . size ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "size1 ( ) { int actual = sut . size ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "isEmpty_A$_true ( ) { com . m3 . scalaflavor4j . arm . Resource . Resource resource = new com . m3 . scalaflavor4j . arm . Resource . Resource ( null ) ; com . m3 . scalaflavor4j . arm . ManagedResource < java . io . InputStream > mr = new com . m3 . scalaflavor4j . arm . ManagedResource < java . io . InputStream > ( resource ) ; boolean actual = mr . isEmpty ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( true ) )", "total": "isEmpty_A$_true ( ) { com . m3 . scalaflavor4j . arm . Resource . Resource resource = new com . m3 . scalaflavor4j . arm . Resource . Resource ( null ) ; com . m3 . scalaflavor4j . arm . ManagedResource < java . io . InputStream > mr = new com . m3 . scalaflavor4j . arm . ManagedResource < java . io . InputStream > ( resource ) ; boolean actual = mr . isEmpty ( ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getRoot ( ) { return root ; }", "testMethod": "simple ( ) { com . asakusafw . workflow . executor . TaskExecutor executor = new com . asakusafw . workflow . executor . basic . BasicDeleteTaskExecutor ( ) ; temporary . newFile ( ) ; executor . execute ( context , new com . asakusafw . workflow . model . basic . BasicDeleteTaskInfo ( \"testing\" , com . asakusafw . workflow . model . DeleteTaskInfo . PathKind . LOCAL_FILE_SYSTEM , temporary . getRoot ( ) . getAbsolutePath ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( temporary . getRoot ( ) . exists ( ) , is ( false ) )", "total": "simple ( ) { com . asakusafw . workflow . executor . TaskExecutor executor = new com . asakusafw . workflow . executor . basic . BasicDeleteTaskExecutor ( ) ; temporary . newFile ( ) ; executor . execute ( context , new com . asakusafw . workflow . model . basic . BasicDeleteTaskInfo ( \"testing\" , com . asakusafw . workflow . model . DeleteTaskInfo . PathKind . LOCAL_FILE_SYSTEM , temporary . getRoot ( ) . getAbsolutePath ( ) ) ) ; \"<AssertPlaceHolder>\" ; } getRoot ( ) { return root ; }", "answer": "org . junit . Assert . assertThat ( temporary . getRoot ( ) . exists ( ) , is ( false ) )"}
{"focal": "trimAll ( java . lang . String ) { if ( src == null ) { return null ; } return src . replaceFirst ( \"@interface\" , \"interface\" ) . replaceAll ( \"@[^\\\\s\\r\\n\\\\(]+(\\\\([^\\\\)]*\\\\))*\" , \"<sp>\" ) . replaceAll ( \"@[^\\\\s\\r\\n]+\" , \"\" ) ; }", "testMethod": "trimAll_A$String_StringIsNull ( ) { org . junithelper . core . filter . impl . TrimInsideOfStringFilter target = new org . junithelper . core . filter . impl . TrimInsideOfStringFilter ( ) ; java . lang . String src = null ; java . lang . String actual = target . trimAll ( src ) ; java . lang . String expected = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , is ( equalTo ( expected ) ) )", "total": "trimAll_A$String_StringIsNull ( ) { org . junithelper . core . filter . impl . TrimInsideOfStringFilter target = new org . junithelper . core . filter . impl . TrimInsideOfStringFilter ( ) ; java . lang . String src = null ; java . lang . String actual = target . trimAll ( src ) ; java . lang . String expected = null ; \"<AssertPlaceHolder>\" ; } trimAll ( java . lang . String ) { if ( src == null ) { return null ; } return src . replaceFirst ( \"@interface\" , \"interface\" ) . replaceAll ( \"@[^\\\\s\\r\\n\\\\(]+(\\\\([^\\\\)]*\\\\))*\" , \"<sp>\" ) . replaceAll ( \"@[^\\\\s\\r\\n]+\" , \"\" ) ; }", "answer": "org . junit . Assert . assertThat ( actual , is ( equalTo ( expected ) ) )"}
{"focal": "is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "testMethod": "shouldNotCleanupPodIfNotTerminated ( ) { final java . lang . String name = createdPod . getMetadata ( ) . getName ( ) ; when ( k8sClient . pods ( ) . withName ( name ) ) . thenReturn ( namedPod ) ; when ( namedPod . get ( ) ) . thenReturn ( createdPod ) ; createdPod . setStatus ( podStatus ) ; when ( podStatus . getContainerStatuses ( ) ) . thenReturn ( java . util . List . of ( containerStatus , keepaliveContainerStatus ) ) ; when ( containerStatus . getName ( ) ) . thenReturn ( com . spotify . styx . docker . KubernetesDockerRunner . MAIN_CONTAINER_NAME ) ; when ( containerStatus . getState ( ) ) . thenReturn ( containerState ) ; com . spotify . styx . docker . var runState = com . spotify . styx . state . RunState . create ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , State . TERMINATED ) ; com . spotify . styx . docker . var shouldDelete = kdr . shouldDeletePodWithRunState ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , createdPod , runState ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( shouldDelete , org . hamcrest . Matchers . is ( false ) )", "total": "shouldNotCleanupPodIfNotTerminated ( ) { final java . lang . String name = createdPod . getMetadata ( ) . getName ( ) ; when ( k8sClient . pods ( ) . withName ( name ) ) . thenReturn ( namedPod ) ; when ( namedPod . get ( ) ) . thenReturn ( createdPod ) ; createdPod . setStatus ( podStatus ) ; when ( podStatus . getContainerStatuses ( ) ) . thenReturn ( java . util . List . of ( containerStatus , keepaliveContainerStatus ) ) ; when ( containerStatus . getName ( ) ) . thenReturn ( com . spotify . styx . docker . KubernetesDockerRunner . MAIN_CONTAINER_NAME ) ; when ( containerStatus . getState ( ) ) . thenReturn ( containerState ) ; com . spotify . styx . docker . var runState = com . spotify . styx . state . RunState . create ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , State . TERMINATED ) ; com . spotify . styx . docker . var shouldDelete = kdr . shouldDeletePodWithRunState ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , createdPod , runState ) ; \"<AssertPlaceHolder>\" ; } is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( shouldDelete , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "hasEnoughNodes ( ) { return ( interpreter . minNodes ( ) ) <= ( polygon . size ( ) ) ; }", "testMethod": "hasEnoughNodes_BUILDING_true ( ) { polygon . clear ( ) ; touchview . setInterpretationType ( InterpretationType . BUILDING ) ; polygon . add ( point1 ) ; polygon . add ( point2 ) ; polygon . add ( point3 ) ; polygon . add ( point4 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( touchview . hasEnoughNodes ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "hasEnoughNodes_BUILDING_true ( ) { polygon . clear ( ) ; touchview . setInterpretationType ( InterpretationType . BUILDING ) ; polygon . add ( point1 ) ; polygon . add ( point2 ) ; polygon . add ( point3 ) ; polygon . add ( point4 ) ; \"<AssertPlaceHolder>\" ; } hasEnoughNodes ( ) { return ( interpreter . minNodes ( ) ) <= ( polygon . size ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( touchview . hasEnoughNodes ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "isLightWeight ( ) { return ( ( myForwardCallback ) instanceof com . allanbank . mongodb . client . FutureCallback ) || ( ( ( myForwardCallback ) instanceof com . allanbank . mongodb . client . callback . ReplyCallback ) && ( ( ( com . allanbank . mongodb . client . callback . ReplyCallback ) ( myForwardCallback ) ) . isLightWeight ( ) ) ) ; }", "testMethod": "testIsLightWeight ( ) { final com . allanbank . mongodb . client . callback . NoOpCallback cb = new com . allanbank . mongodb . client . callback . NoOpCallback ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cb . isLightWeight ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "testIsLightWeight ( ) { final com . allanbank . mongodb . client . callback . NoOpCallback cb = new com . allanbank . mongodb . client . callback . NoOpCallback ( ) ; \"<AssertPlaceHolder>\" ; } isLightWeight ( ) { return ( ( myForwardCallback ) instanceof com . allanbank . mongodb . client . FutureCallback ) || ( ( ( myForwardCallback ) instanceof com . allanbank . mongodb . client . callback . ReplyCallback ) && ( ( ( com . allanbank . mongodb . client . callback . ReplyCallback ) ( myForwardCallback ) ) . isLightWeight ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( cb . isLightWeight ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "run ( ) { return runResult ( ) . get ( ) ; }", "testMethod": "commandRetainsSlashes ( ) { commandHandler = ( com . fizzed . blaze . ssh . SshCommand command ) -> { if ( command . line . equals ( \"/path/to/exec<sp>a=1<sp>b=2\" ) ) { command . exit . onExit ( 0 ) ; } else { command . exit . onExit ( 1 ) ; } } ; com . fizzed . blaze . ssh . SshSession session = startAndConnect ( ) ; java . lang . Integer exitValue = new com . fizzed . blaze . ssh . impl . JschExec ( context , session ) . command ( \"/path/to/exec\" ) . arg ( \"a=1\" ) . args ( \"b=2\" ) . run ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( exitValue , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "commandRetainsSlashes ( ) { commandHandler = ( com . fizzed . blaze . ssh . SshCommand command ) -> { if ( command . line . equals ( \"/path/to/exec<sp>a=1<sp>b=2\" ) ) { command . exit . onExit ( 0 ) ; } else { command . exit . onExit ( 1 ) ; } } ; com . fizzed . blaze . ssh . SshSession session = startAndConnect ( ) ; java . lang . Integer exitValue = new com . fizzed . blaze . ssh . impl . JschExec ( context , session ) . command ( \"/path/to/exec\" ) . arg ( \"a=1\" ) . args ( \"b=2\" ) . run ( ) ; \"<AssertPlaceHolder>\" ; } run ( ) { return runResult ( ) . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( exitValue , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getMessages ( ) { return java . util . Collections . unmodifiableList ( myMessages ) ; }", "testMethod": "testEmbeddedItemInChoice ( ) { java . lang . String questionnaireRef = \"http://example.com/Questionnaire/q1\" ; java . lang . String valueSetRef = \"http://somevalueset\" ; java . lang . String codeSystemUrl = \"http://codesystems.com/system\" ; java . lang . String codeValue = \"code0\" ; org . hl7 . fhir . r4 . model . Questionnaire . QuestionnaireItemComponent item1 = new org . hl7 . fhir . r4 . model . Questionnaire . QuestionnaireItemComponent ( ) ; item1 . setLinkId ( \"link1\" ) . setType ( QuestionnaireItemType . CHOICE ) . setAnswerValueSet ( valueSetRef ) ; item1 . addItem ( ) . setLinkId ( \"link11\" ) . setType ( QuestionnaireItemType . TEXT ) ; org . hl7 . fhir . r4 . validation . Questionnaire q = new org . hl7 . fhir . r4 . validation . Questionnaire ( ) ; q . addItem ( item1 ) ; when ( myValSupport . fetchResource ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( org . hl7 . fhir . r4 . validation . Questionnaire . class ) , eq ( questionnaireRef ) ) ) . thenReturn ( q ) ; org . hl7 . fhir . r4 . validation . CodeSystem codeSystem = new org . hl7 . fhir . r4 . validation . CodeSystem ( ) ; codeSystem . setContent ( CodeSystemContentMode . COMPLETE ) ; codeSystem . setUrl ( codeSystemUrl ) ; codeSystem . addConcept ( ) . setCode ( codeValue ) ; when ( myValSupport . fetchCodeSystem ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( codeSystemUrl ) ) ) . thenReturn ( codeSystem ) ; org . hl7 . fhir . r4 . validation . ValueSet options = new org . hl7 . fhir . r4 . validation . ValueSet ( ) ; options . getCompose ( ) . addInclude ( ) . setSystem ( codeSystemUrl ) . addConcept ( ) . setCode ( codeValue ) ; when ( myValSupport . fetchResource ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( org . hl7 . fhir . r4 . validation . ValueSet . class ) , eq ( valueSetRef ) ) ) . thenReturn ( options ) ; when ( myValSupport . validateCode ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( codeSystemUrl ) , eq ( codeValue ) , any ( java . lang . String . class ) ) ) . thenReturn ( new org . hl7 . fhir . r4 . hapi . ctx . IValidationSupport . CodeValidationResult ( new org . hl7 . fhir . r4 . model . CodeSystem . ConceptDefinitionComponent ( new org . hl7 . fhir . r4 . validation . CodeType ( codeValue ) ) ) ) ; ca . uhn . fhir . parser . IParser xmlParser = org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourCtx . newXmlParser ( ) . setPrettyPrint ( true ) ; java . lang . String qXml = xmlParser . encodeResourceToString ( q ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourLog . info ( qXml ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponse qa = new org . hl7 . fhir . r4 . validation . QuestionnaireResponse ( ) ; qa . getText ( ) . setDiv ( new org . hl7 . fhir . utilities . xhtml . XhtmlNode ( ) . setValue ( \"<div>AA</div>\" ) ) . setStatus ( Narrative . NarrativeStatus . GENERATED ) ; qa . setStatus ( QuestionnaireResponseStatus . INPROGRESS ) ; qa . setQuestionnaire ( questionnaireRef ) ; qa . addItem ( ) . setLinkId ( \"link1\" ) . addAnswer ( ) . addItem ( ) . setLinkId ( \"link11\" ) ; java . lang . String rXml = xmlParser . encodeResourceToString ( qa ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourLog . info ( rXml ) ; ca . uhn . fhir . validation . ValidationResult errors = myVal . validateWithResult ( qa ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourLog . info ( errors . toString ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( errors . getMessages ( ) , empty ( ) )", "total": "testEmbeddedItemInChoice ( ) { java . lang . String questionnaireRef = \"http://example.com/Questionnaire/q1\" ; java . lang . String valueSetRef = \"http://somevalueset\" ; java . lang . String codeSystemUrl = \"http://codesystems.com/system\" ; java . lang . String codeValue = \"code0\" ; org . hl7 . fhir . r4 . model . Questionnaire . QuestionnaireItemComponent item1 = new org . hl7 . fhir . r4 . model . Questionnaire . QuestionnaireItemComponent ( ) ; item1 . setLinkId ( \"link1\" ) . setType ( QuestionnaireItemType . CHOICE ) . setAnswerValueSet ( valueSetRef ) ; item1 . addItem ( ) . setLinkId ( \"link11\" ) . setType ( QuestionnaireItemType . TEXT ) ; org . hl7 . fhir . r4 . validation . Questionnaire q = new org . hl7 . fhir . r4 . validation . Questionnaire ( ) ; q . addItem ( item1 ) ; when ( myValSupport . fetchResource ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( org . hl7 . fhir . r4 . validation . Questionnaire . class ) , eq ( questionnaireRef ) ) ) . thenReturn ( q ) ; org . hl7 . fhir . r4 . validation . CodeSystem codeSystem = new org . hl7 . fhir . r4 . validation . CodeSystem ( ) ; codeSystem . setContent ( CodeSystemContentMode . COMPLETE ) ; codeSystem . setUrl ( codeSystemUrl ) ; codeSystem . addConcept ( ) . setCode ( codeValue ) ; when ( myValSupport . fetchCodeSystem ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( codeSystemUrl ) ) ) . thenReturn ( codeSystem ) ; org . hl7 . fhir . r4 . validation . ValueSet options = new org . hl7 . fhir . r4 . validation . ValueSet ( ) ; options . getCompose ( ) . addInclude ( ) . setSystem ( codeSystemUrl ) . addConcept ( ) . setCode ( codeValue ) ; when ( myValSupport . fetchResource ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( org . hl7 . fhir . r4 . validation . ValueSet . class ) , eq ( valueSetRef ) ) ) . thenReturn ( options ) ; when ( myValSupport . validateCode ( any ( ca . uhn . fhir . context . FhirContext . class ) , eq ( codeSystemUrl ) , eq ( codeValue ) , any ( java . lang . String . class ) ) ) . thenReturn ( new org . hl7 . fhir . r4 . hapi . ctx . IValidationSupport . CodeValidationResult ( new org . hl7 . fhir . r4 . model . CodeSystem . ConceptDefinitionComponent ( new org . hl7 . fhir . r4 . validation . CodeType ( codeValue ) ) ) ) ; ca . uhn . fhir . parser . IParser xmlParser = org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourCtx . newXmlParser ( ) . setPrettyPrint ( true ) ; java . lang . String qXml = xmlParser . encodeResourceToString ( q ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourLog . info ( qXml ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponse qa = new org . hl7 . fhir . r4 . validation . QuestionnaireResponse ( ) ; qa . getText ( ) . setDiv ( new org . hl7 . fhir . utilities . xhtml . XhtmlNode ( ) . setValue ( \"<div>AA</div>\" ) ) . setStatus ( Narrative . NarrativeStatus . GENERATED ) ; qa . setStatus ( QuestionnaireResponseStatus . INPROGRESS ) ; qa . setQuestionnaire ( questionnaireRef ) ; qa . addItem ( ) . setLinkId ( \"link1\" ) . addAnswer ( ) . addItem ( ) . setLinkId ( \"link11\" ) ; java . lang . String rXml = xmlParser . encodeResourceToString ( qa ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourLog . info ( rXml ) ; ca . uhn . fhir . validation . ValidationResult errors = myVal . validateWithResult ( qa ) ; org . hl7 . fhir . r4 . validation . QuestionnaireResponseValidatorR4Test . ourLog . info ( errors . toString ( ) ) ; \"<AssertPlaceHolder>\" ; } getMessages ( ) { return java . util . Collections . unmodifiableList ( myMessages ) ; }", "answer": "org . junit . Assert . assertThat ( errors . getMessages ( ) , empty ( ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testSetRemainingLifetime ( ) { defaultLspWrapper . setLsdbAge ( defaultIsisLsdbAge ) ; defaultLspWrapper . setAgeCounterWhenReceived ( 1 ) ; defaultLspWrapper . currentAge ( ) ; defaultLspWrapper . setRemainingLifetime ( 1 ) ; result1 = defaultLspWrapper . remainingLifetime ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testSetRemainingLifetime ( ) { defaultLspWrapper . setLsdbAge ( defaultIsisLsdbAge ) ; defaultLspWrapper . setAgeCounterWhenReceived ( 1 ) ; defaultLspWrapper . currentAge ( ) ; defaultLspWrapper . setRemainingLifetime ( 1 ) ; result1 = defaultLspWrapper . remainingLifetime ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "transformOutboundDatabaseName ( com . hotels . bdp . waggledance . mapping . model . MetaStoreMapping , java . lang . String ) { org . apache . hadoop . hive . ql . parse . ASTNode root ; try { root = org . apache . hadoop . hive . ql . parse . ParseUtils . parse ( query ) ; } catch ( org . apache . hadoop . hive . ql . parse . ParseException e ) { throw new com . hotels . bdp . waggledance . api . WaggleDanceException ( ( ( \"Can't<sp>parse<sp>query:<sp>'\" + query ) + \"'\" ) , e ) ; } java . util . SortedSet < org . antlr . runtime . CommonToken > dbNameTokens = extractDbNameTokens ( root ) ; java . lang . StringBuilder result = new java . lang . StringBuilder ( ) ; int startIndex = 0 ; for ( org . antlr . runtime . CommonToken dbNameNode : dbNameTokens ) { final java . lang . String dbName = dbNameNode . getText ( ) ; final boolean escaped = ( dbName . startsWith ( \"`\" ) ) && ( dbName . endsWith ( \"`\" ) ) ; java . lang . String transformedDbName = metaStoreMapping . transformOutboundDatabaseName ( unescapeIdentifier ( dbName ) ) ; if ( escaped ) { transformedDbName = ( \"`\" + transformedDbName ) + \"`\" ; } result . append ( query . substring ( startIndex , dbNameNode . getStartIndex ( ) ) ) ; result . append ( transformedDbName ) ; startIndex = ( dbNameNode . getStopIndex ( ) ) + 1 ; } result . append ( query . substring ( startIndex ) ) ; return result . toString ( ) ; }", "testMethod": "transformOutboundDatabaseNameAliasWithBackTicks ( ) { com . hotels . bdp . waggledance . mapping . model . ASTQueryMapping queryMapping = ASTQueryMapping . INSTANCE ; com . hotels . bdp . waggledance . mapping . model . MetaStoreMapping metaStoreMapping = new com . hotels . bdp . waggledance . mapping . model . MetaStoreMappingImpl ( com . hotels . bdp . waggledance . mapping . model . ASTQueryMappingTest . PREFIX , \"mapping\" , null , null , DIRECT , com . hotels . bdp . waggledance . mapping . model . ASTQueryMappingTest . LATENCY ) ; java . lang . String query = \"\" ; query += \"SELECT<sp>col_id<sp>AS<sp>id<sp>\" ; query += \"FROM<sp>(SELECT<sp>`table1`.id\" ; query += \"<sp>FROM<sp>`db1`.`table1`)<sp>`db1.table1`\" ; java . lang . String expected = \"\" ; expected += \"SELECT<sp>col_id<sp>AS<sp>id<sp>\" ; expected += \"FROM<sp>(SELECT<sp>`table1`.id\" ; expected += ( \"<sp>FROM<sp>`\" + ( com . hotels . bdp . waggledance . mapping . model . ASTQueryMappingTest . PREFIX ) ) + \"db1`.`table1`)<sp>`db1.table1`\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( queryMapping . transformOutboundDatabaseName ( metaStoreMapping , query ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "transformOutboundDatabaseNameAliasWithBackTicks ( ) { com . hotels . bdp . waggledance . mapping . model . ASTQueryMapping queryMapping = ASTQueryMapping . INSTANCE ; com . hotels . bdp . waggledance . mapping . model . MetaStoreMapping metaStoreMapping = new com . hotels . bdp . waggledance . mapping . model . MetaStoreMappingImpl ( com . hotels . bdp . waggledance . mapping . model . ASTQueryMappingTest . PREFIX , \"mapping\" , null , null , DIRECT , com . hotels . bdp . waggledance . mapping . model . ASTQueryMappingTest . LATENCY ) ; java . lang . String query = \"\" ; query += \"SELECT<sp>col_id<sp>AS<sp>id<sp>\" ; query += \"FROM<sp>(SELECT<sp>`table1`.id\" ; query += \"<sp>FROM<sp>`db1`.`table1`)<sp>`db1.table1`\" ; java . lang . String expected = \"\" ; expected += \"SELECT<sp>col_id<sp>AS<sp>id<sp>\" ; expected += \"FROM<sp>(SELECT<sp>`table1`.id\" ; expected += ( \"<sp>FROM<sp>`\" + ( com . hotels . bdp . waggledance . mapping . model . ASTQueryMappingTest . PREFIX ) ) + \"db1`.`table1`)<sp>`db1.table1`\" ; \"<AssertPlaceHolder>\" ; } transformOutboundDatabaseName ( com . hotels . bdp . waggledance . mapping . model . MetaStoreMapping , java . lang . String ) { org . apache . hadoop . hive . ql . parse . ASTNode root ; try { root = org . apache . hadoop . hive . ql . parse . ParseUtils . parse ( query ) ; } catch ( org . apache . hadoop . hive . ql . parse . ParseException e ) { throw new com . hotels . bdp . waggledance . api . WaggleDanceException ( ( ( \"Can't<sp>parse<sp>query:<sp>'\" + query ) + \"'\" ) , e ) ; } java . util . SortedSet < org . antlr . runtime . CommonToken > dbNameTokens = extractDbNameTokens ( root ) ; java . lang . StringBuilder result = new java . lang . StringBuilder ( ) ; int startIndex = 0 ; for ( org . antlr . runtime . CommonToken dbNameNode : dbNameTokens ) { final java . lang . String dbName = dbNameNode . getText ( ) ; final boolean escaped = ( dbName . startsWith ( \"`\" ) ) && ( dbName . endsWith ( \"`\" ) ) ; java . lang . String transformedDbName = metaStoreMapping . transformOutboundDatabaseName ( unescapeIdentifier ( dbName ) ) ; if ( escaped ) { transformedDbName = ( \"`\" + transformedDbName ) + \"`\" ; } result . append ( query . substring ( startIndex , dbNameNode . getStartIndex ( ) ) ) ; result . append ( transformedDbName ) ; startIndex = ( dbNameNode . getStopIndex ( ) ) + 1 ; } result . append ( query . substring ( startIndex ) ) ; return result . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( queryMapping . transformOutboundDatabaseName ( metaStoreMapping , query ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "addQuestion ( org . mifos . platform . questionnaire . ui . model . QuestionGroupForm , org . springframework . webflow . execution . RequestContext ) { org . springframework . binding . message . MessageContext context = requestContext . getMessageContext ( ) ; boolean result = validateQuestion ( questionGroupForm , context ) ; if ( result ) { questionGroupForm . addCurrentSection ( ) ; } return result ? \"success\" : \"failure\" ; }", "testMethod": "testAddQuestionForInvalidAnswerChoices ( ) { org . mifos . platform . questionnaire . ui . model . QuestionGroupForm questionGroupForm = getQuestionGroupForm ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE , \"Create.Client\" , \"Default\" ) ; questionGroupForm . setValidator ( validator ) ; questionGroupForm . getCurrentQuestion ( ) . setText ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) ; questionGroupForm . getCurrentQuestion ( ) . setType ( \"singleSelect\" ) ; questionGroupForm . getCurrentQuestion ( ) . setCurrentChoice ( \"Choice1\" ) ; questionGroupForm . getCurrentQuestion ( ) . addAnswerChoice ( ) ; when ( requestContext . getMessageContext ( ) ) . thenReturn ( messageContext ) ; java . lang . String result = questionGroupController . addQuestion ( questionGroupForm , requestContext ) ; \"<AssertPlaceHolder>\" ; verify ( requestContext , times ( 1 ) ) . getMessageContext ( ) ; verify ( messageContext ) . addMessage ( argThat ( new org . mifos . platform . matchers . MessageMatcher ( \"questionnaire.error.question.choices\" ) ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( \"failure\" ) )", "total": "testAddQuestionForInvalidAnswerChoices ( ) { org . mifos . platform . questionnaire . ui . model . QuestionGroupForm questionGroupForm = getQuestionGroupForm ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE , \"Create.Client\" , \"Default\" ) ; questionGroupForm . setValidator ( validator ) ; questionGroupForm . getCurrentQuestion ( ) . setText ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) ; questionGroupForm . getCurrentQuestion ( ) . setType ( \"singleSelect\" ) ; questionGroupForm . getCurrentQuestion ( ) . setCurrentChoice ( \"Choice1\" ) ; questionGroupForm . getCurrentQuestion ( ) . addAnswerChoice ( ) ; when ( requestContext . getMessageContext ( ) ) . thenReturn ( messageContext ) ; java . lang . String result = questionGroupController . addQuestion ( questionGroupForm , requestContext ) ; \"<AssertPlaceHolder>\" ; verify ( requestContext , times ( 1 ) ) . getMessageContext ( ) ; verify ( messageContext ) . addMessage ( argThat ( new org . mifos . platform . matchers . MessageMatcher ( \"questionnaire.error.question.choices\" ) ) ) ; } addQuestion ( org . mifos . platform . questionnaire . ui . model . QuestionGroupForm , org . springframework . webflow . execution . RequestContext ) { org . springframework . binding . message . MessageContext context = requestContext . getMessageContext ( ) ; boolean result = validateQuestion ( questionGroupForm , context ) ; if ( result ) { questionGroupForm . addCurrentSection ( ) ; } return result ? \"success\" : \"failure\" ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( \"failure\" ) )"}
{"focal": "parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "testMethod": "testParsePathMapErr ( ) { queriesString = \"type=node&enabled=true&status=established&path=port01\" ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testParsePathMapErr ( ) { queriesString = \"type=node&enabled=true&status=established&path=port01\" ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; } parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "size ( ) { return locationPks . size ( ) ; }", "testMethod": "matchTimeOnlyTestOpenEndedIntervalRangeInclusive ( ) { org . dcm4che3 . data . Attributes testAttrs = new org . dcm4che3 . data . Attributes ( ) ; java . lang . String tmString = \"121212.000-\" ; java . util . List < org . dcm4chee . archive . entity . Study > studies = createTimeRangeQuery ( testAttrs , tmString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( studies . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "matchTimeOnlyTestOpenEndedIntervalRangeInclusive ( ) { org . dcm4che3 . data . Attributes testAttrs = new org . dcm4che3 . data . Attributes ( ) ; java . lang . String tmString = \"121212.000-\" ; java . util . List < org . dcm4chee . archive . entity . Study > studies = createTimeRangeQuery ( testAttrs , tmString ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return locationPks . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( studies . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "toString ( ) { if ( ( ( resourceId ) != null ) && ( ( externalId ) != null ) ) { return ( ( ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \",<sp>externalId:<sp>\\\"\" ) + ( externalId ) ) + \"\\\"}\" ; } if ( ( resourceId ) != null ) { return ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \"}\" ; } if ( ( externalId ) != null ) { return ( \"{externalId:<sp>\\\"\" + ( externalId ) ) + \"\\\"}\" ; } return \"{}\" ; }", "testMethod": "toString_systemPermission ( ) { for ( java . lang . String systemPermissionName : com . acciente . oacc . ResourceCreatePermissions . getSysPermissionNames ( ) ) { final com . acciente . oacc . ResourceCreatePermission resourceCreatePermission = com . acciente . oacc . ResourceCreatePermissions . getInstance ( systemPermissionName ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( resourceCreatePermission . toString ( ) , org . hamcrest . CoreMatchers . is ( systemPermissionName ) )", "total": "toString_systemPermission ( ) { for ( java . lang . String systemPermissionName : com . acciente . oacc . ResourceCreatePermissions . getSysPermissionNames ( ) ) { final com . acciente . oacc . ResourceCreatePermission resourceCreatePermission = com . acciente . oacc . ResourceCreatePermissions . getInstance ( systemPermissionName ) ; \"<AssertPlaceHolder>\" ; } } toString ( ) { if ( ( ( resourceId ) != null ) && ( ( externalId ) != null ) ) { return ( ( ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \",<sp>externalId:<sp>\\\"\" ) + ( externalId ) ) + \"\\\"}\" ; } if ( ( resourceId ) != null ) { return ( \"{resourceId:<sp>\" + ( java . lang . String . valueOf ( resourceId ) ) ) + \"}\" ; } if ( ( externalId ) != null ) { return ( \"{externalId:<sp>\\\"\" + ( externalId ) ) + \"\\\"}\" ; } return \"{}\" ; }", "answer": "org . junit . Assert . assertThat ( resourceCreatePermission . toString ( ) , org . hamcrest . CoreMatchers . is ( systemPermissionName ) )"}
{"focal": "getRegion ( ) { return isClustered ( ) ? ( doRealOnRegion ) == true ? super . getRegion ( ) : \"TestRegion\" : NONE_REGION ; }", "testMethod": "testLoadExtendProperties ( ) { config . cluster = true ; java . util . Properties wrapper = new java . util . Properties ( ) ; wrapper . put ( org . ngrinder . infra . config . PROP_CLUSTER_REGION , \"TestNewRegion\" ) ; config . doRealOnRegion = true ; org . ngrinder . common . model . Home mockExHome = mock ( org . ngrinder . common . model . Home . class ) ; when ( mockExHome . getProperties ( \"system-ex.conf\" ) ) . thenReturn ( wrapper ) ; when ( mockExHome . exists ( ) ) . thenReturn ( true ) ; org . springframework . test . util . ReflectionTestUtils . setField ( config , \"exHome\" , mockExHome ) ; config . loadProperties ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( config . getRegion ( ) , is ( \"TestNewRegion\" ) )", "total": "testLoadExtendProperties ( ) { config . cluster = true ; java . util . Properties wrapper = new java . util . Properties ( ) ; wrapper . put ( org . ngrinder . infra . config . PROP_CLUSTER_REGION , \"TestNewRegion\" ) ; config . doRealOnRegion = true ; org . ngrinder . common . model . Home mockExHome = mock ( org . ngrinder . common . model . Home . class ) ; when ( mockExHome . getProperties ( \"system-ex.conf\" ) ) . thenReturn ( wrapper ) ; when ( mockExHome . exists ( ) ) . thenReturn ( true ) ; org . springframework . test . util . ReflectionTestUtils . setField ( config , \"exHome\" , mockExHome ) ; config . loadProperties ( ) ; \"<AssertPlaceHolder>\" ; } getRegion ( ) { return isClustered ( ) ? ( doRealOnRegion ) == true ? super . getRegion ( ) : \"TestRegion\" : NONE_REGION ; }", "answer": "org . junit . Assert . assertThat ( config . getRegion ( ) , is ( \"TestNewRegion\" ) )"}
{"focal": "is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "testMethod": "skip_empty ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withSkipEmptyInput ( true ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"A\" , \"B\" , \"\" , \"\" , \"C\" , \"\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" , \"C\" } } ) )", "total": "skip_empty ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withSkipEmptyInput ( true ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"A\" , \"B\" , \"\" , \"\" , \"C\" , \"\" } } ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" , \"C\" } } ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "houdtRekeningMetGeldigheidDienst ( ) { dienst . setDatumEinde ( nl . bzk . algemeenbrp . util . common . DatumUtil . gisteren ( ) ) ; java . util . Collection < nl . bzk . brp . beheer . service . selectie . SelectieTaakDTO > taken = service . filter ( java . util . Collections . singleton ( taak ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( taken . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "houdtRekeningMetGeldigheidDienst ( ) { dienst . setDatumEinde ( nl . bzk . algemeenbrp . util . common . DatumUtil . gisteren ( ) ) ; java . util . Collection < nl . bzk . brp . beheer . service . selectie . SelectieTaakDTO > taken = service . filter ( java . util . Collections . singleton ( taak ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( taken . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "houdtRekeningMetGeldigheidLeveringsautorisatie ( ) { dienst . getDienstbundel ( ) . getLeveringsautorisatie ( ) . setDatumEinde ( nl . bzk . algemeenbrp . util . common . DatumUtil . gisteren ( ) ) ; java . util . Collection < nl . bzk . brp . beheer . service . selectie . SelectieTaakDTO > taken = service . filter ( java . util . Collections . singleton ( taak ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( taken . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "houdtRekeningMetGeldigheidLeveringsautorisatie ( ) { dienst . getDienstbundel ( ) . getLeveringsautorisatie ( ) . setDatumEinde ( nl . bzk . algemeenbrp . util . common . DatumUtil . gisteren ( ) ) ; java . util . Collection < nl . bzk . brp . beheer . service . selectie . SelectieTaakDTO > taken = service . filter ( java . util . Collections . singleton ( taak ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( taken . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "equalTo ( com . facebook . buck . query . QueryEnvironment$Argument ) { return ( ( ( type . equals ( other . type ) ) && ( ( integer ) == ( other . integer ) ) ) && ( java . util . Objects . equals ( expression , other . expression ) ) ) && ( java . util . Objects . equals ( word , other . word ) ) ; }", "testMethod": "testPersistentJobIsExecutedAndResultIsReceived ( ) { com . facebook . buck . core . build . execution . context . ExecutionContext context = createExecutionContextWith ( 0 , \"\" , \"\" ) ; com . facebook . buck . shell . WorkerShellStep step = createWorkerShellStep ( createJobParams ( com . google . common . collect . ImmutableList . of ( com . facebook . buck . shell . WorkerShellStepTest . startupCommand , com . facebook . buck . shell . WorkerShellStepTest . persistentStartupArg ) , com . google . common . collect . ImmutableMap . of ( ) , \"myJobArgs\" , 1 , com . facebook . buck . shell . WorkerShellStepTest . persistentWorkerKey , com . google . common . hash . Hashing . sha1 ( ) . hashString ( com . facebook . buck . shell . WorkerShellStepTest . fakePersistentWorkerStartupCommand , Charsets . UTF_8 ) ) , null , null ) ; int exitCode = step . execute ( context ) . getExitCode ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( exitCode , org . hamcrest . Matchers . equalTo ( 0 ) )", "total": "testPersistentJobIsExecutedAndResultIsReceived ( ) { com . facebook . buck . core . build . execution . context . ExecutionContext context = createExecutionContextWith ( 0 , \"\" , \"\" ) ; com . facebook . buck . shell . WorkerShellStep step = createWorkerShellStep ( createJobParams ( com . google . common . collect . ImmutableList . of ( com . facebook . buck . shell . WorkerShellStepTest . startupCommand , com . facebook . buck . shell . WorkerShellStepTest . persistentStartupArg ) , com . google . common . collect . ImmutableMap . of ( ) , \"myJobArgs\" , 1 , com . facebook . buck . shell . WorkerShellStepTest . persistentWorkerKey , com . google . common . hash . Hashing . sha1 ( ) . hashString ( com . facebook . buck . shell . WorkerShellStepTest . fakePersistentWorkerStartupCommand , Charsets . UTF_8 ) ) , null , null ) ; int exitCode = step . execute ( context ) . getExitCode ( ) ; \"<AssertPlaceHolder>\" ; } equalTo ( com . facebook . buck . query . QueryEnvironment$Argument ) { return ( ( ( type . equals ( other . type ) ) && ( ( integer ) == ( other . integer ) ) ) && ( java . util . Objects . equals ( expression , other . expression ) ) ) && ( java . util . Objects . equals ( word , other . word ) ) ; }", "answer": "org . junit . Assert . assertThat ( exitCode , org . hamcrest . Matchers . equalTo ( 0 ) )"}
{"focal": "read ( java . lang . Class , org . bson . conversions . Bson ) { return ( ( S ) ( person ) ) ; }", "testMethod": "readsURLFromStringOutOfTheBox ( ) { org . bson . Document document = new org . bson . Document ( \"url\" , \"https://springsource.org\" ) ; org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . URLWrapper result = converter . read ( org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . URLWrapper . class , document ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . url , is ( new java . net . URL ( \"https://springsource.org\" ) ) )", "total": "readsURLFromStringOutOfTheBox ( ) { org . bson . Document document = new org . bson . Document ( \"url\" , \"https://springsource.org\" ) ; org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . URLWrapper result = converter . read ( org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . URLWrapper . class , document ) ; \"<AssertPlaceHolder>\" ; } read ( java . lang . Class , org . bson . conversions . Bson ) { return ( ( S ) ( person ) ) ; }", "answer": "org . junit . Assert . assertThat ( result . url , is ( new java . net . URL ( \"https://springsource.org\" ) ) )"}
{"focal": "shouldResourceBeIncluded ( java . lang . Module , java . net . URL , java . lang . String , java . util . Map ) { boolean include = true ; for ( org . openmrs . module . ModuleConditionalResource conditionalResource : module . getConditionalResources ( ) ) { if ( fileUrl . getPath ( ) . matches ( ( ( \".*\" + ( conditionalResource . getPath ( ) ) ) + \"$\" ) ) ) { include = false ; if ( org . apache . commons . lang3 . StringUtils . isNotBlank ( conditionalResource . getOpenmrsPlatformVersion ( ) ) ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( openmrsVersion , conditionalResource . getOpenmrsPlatformVersion ( ) ) ; if ( ! include ) { return false ; } } if ( ( conditionalResource . getModules ( ) ) != null ) { for ( org . openmrs . module . ModuleConditionalResource . ModuleAndVersion conditionalModuleResource : conditionalResource . getModules ( ) ) { if ( \"!\" . equals ( conditionalModuleResource . getVersion ( ) ) ) { include = ! ( org . openmrs . module . ModuleFactory . isModuleStarted ( conditionalModuleResource . getModuleId ( ) ) ) ; if ( ! include ) { return false ; } } else { java . lang . String moduleVersion = startedRelatedModules . get ( conditionalModuleResource . getModuleId ( ) ) ; if ( moduleVersion != null ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( moduleVersion , conditionalModuleResource . getVersion ( ) ) ; if ( ! include ) { return false ; } } } } } } } return include ; }", "testMethod": "shouldResourceBeIncluded_shouldReturnTrueIfFileDoesNotMatchAndOpenmrsVersionDoesNotMatch ( ) { org . openmrs . module . ModuleConditionalResource resource = new org . openmrs . module . ModuleConditionalResource ( ) ; resource . setPath ( \"lib/mockmodule-api.jar\" ) ; resource . setOpenmrsPlatformVersion ( \"1.10-1.11\" ) ; mockModule . getConditionalResources ( ) . add ( resource ) ; boolean result = org . openmrs . module . ModuleClassLoader . shouldResourceBeIncluded ( mockModule , java . net . URI . create ( \"file://module/mockmodule/lib/mockmodule-api-1.10.jar\" ) . toURL ( ) , \"1.9.8-SNAPSHOT\" , mockModules ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )", "total": "shouldResourceBeIncluded_shouldReturnTrueIfFileDoesNotMatchAndOpenmrsVersionDoesNotMatch ( ) { org . openmrs . module . ModuleConditionalResource resource = new org . openmrs . module . ModuleConditionalResource ( ) ; resource . setPath ( \"lib/mockmodule-api.jar\" ) ; resource . setOpenmrsPlatformVersion ( \"1.10-1.11\" ) ; mockModule . getConditionalResources ( ) . add ( resource ) ; boolean result = org . openmrs . module . ModuleClassLoader . shouldResourceBeIncluded ( mockModule , java . net . URI . create ( \"file://module/mockmodule/lib/mockmodule-api-1.10.jar\" ) . toURL ( ) , \"1.9.8-SNAPSHOT\" , mockModules ) ; \"<AssertPlaceHolder>\" ; } shouldResourceBeIncluded ( java . lang . Module , java . net . URL , java . lang . String , java . util . Map ) { boolean include = true ; for ( org . openmrs . module . ModuleConditionalResource conditionalResource : module . getConditionalResources ( ) ) { if ( fileUrl . getPath ( ) . matches ( ( ( \".*\" + ( conditionalResource . getPath ( ) ) ) + \"$\" ) ) ) { include = false ; if ( org . apache . commons . lang3 . StringUtils . isNotBlank ( conditionalResource . getOpenmrsPlatformVersion ( ) ) ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( openmrsVersion , conditionalResource . getOpenmrsPlatformVersion ( ) ) ; if ( ! include ) { return false ; } } if ( ( conditionalResource . getModules ( ) ) != null ) { for ( org . openmrs . module . ModuleConditionalResource . ModuleAndVersion conditionalModuleResource : conditionalResource . getModules ( ) ) { if ( \"!\" . equals ( conditionalModuleResource . getVersion ( ) ) ) { include = ! ( org . openmrs . module . ModuleFactory . isModuleStarted ( conditionalModuleResource . getModuleId ( ) ) ) ; if ( ! include ) { return false ; } } else { java . lang . String moduleVersion = startedRelatedModules . get ( conditionalModuleResource . getModuleId ( ) ) ; if ( moduleVersion != null ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( moduleVersion , conditionalModuleResource . getVersion ( ) ) ; if ( ! include ) { return false ; } } } } } } } return include ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "is ( java . lang . String ) { return isAnd ( IsEvaluator . IS_EVALUATOR , selector ) ; }", "testMethod": "withCapabilities__should_return_the_current_PhantomJSDriverBuilder_instance_to_allow_further_chaining ( ) { io . github . seleniumquery . browser . driver . builders . PhantomJSDriverBuilder phantomJSDriverBuilderAfterFirstCall = io . github . seleniumquery . SeleniumQuery . $ . driver ( ) . usePhantomJS ( ) . withCapabilities ( null ) ; io . github . seleniumquery . browser . driver . builders . PhantomJSDriverBuilder phantomJSDriverBuilderAfterSecondCall = phantomJSDriverBuilderAfterFirstCall . withPathToPhantomJS ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( phantomJSDriverBuilderAfterSecondCall , org . hamcrest . CoreMatchers . is ( phantomJSDriverBuilderAfterFirstCall ) )", "total": "withCapabilities__should_return_the_current_PhantomJSDriverBuilder_instance_to_allow_further_chaining ( ) { io . github . seleniumquery . browser . driver . builders . PhantomJSDriverBuilder phantomJSDriverBuilderAfterFirstCall = io . github . seleniumquery . SeleniumQuery . $ . driver ( ) . usePhantomJS ( ) . withCapabilities ( null ) ; io . github . seleniumquery . browser . driver . builders . PhantomJSDriverBuilder phantomJSDriverBuilderAfterSecondCall = phantomJSDriverBuilderAfterFirstCall . withPathToPhantomJS ( null ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { return isAnd ( IsEvaluator . IS_EVALUATOR , selector ) ; }", "answer": "org . junit . Assert . assertThat ( phantomJSDriverBuilderAfterSecondCall , org . hamcrest . CoreMatchers . is ( phantomJSDriverBuilderAfterFirstCall ) )"}
{"focal": "getConstituents ( ) { return ( constituents ) == null ? java . util . Collections . emptyList ( ) : java . util . Collections . unmodifiableList ( constituents ) ; }", "testMethod": "addImpliedRepoWhenRepoAddedToGroup ( ) { final org . commonjava . indy . model . core . Group g = new org . commonjava . indy . model . core . Group ( MAVEN_PKG_KEY , \"test\" ) ; storeDataManager . storeArtifactStore ( g , summary , false , true , new org . commonjava . maven . galley . event . EventMetadata ( ) ) ; final org . commonjava . indy . model . core . RemoteRepository repo1 = new org . commonjava . indy . model . core . RemoteRepository ( MAVEN_PKG_KEY , \"one\" , \"http://www.foo.com/repo\" ) ; storeDataManager . storeArtifactStore ( repo1 , summary , false , true , new org . commonjava . maven . galley . event . EventMetadata ( ) ) ; final org . commonjava . indy . model . core . RemoteRepository repo2 = new org . commonjava . indy . model . core . RemoteRepository ( MAVEN_PKG_KEY , \"one\" , \"http://www.foo.com/repo\" ) ; storeDataManager . storeArtifactStore ( repo2 , summary , false , true , new org . commonjava . maven . galley . event . EventMetadata ( ) ) ; metadataManager . addImpliedMetadata ( repo1 , java . util . Collections . singletonList ( repo2 ) ) ; g . addConstituent ( repo1 ) ; final org . commonjava . indy . change . event . ArtifactStorePreUpdateEvent event = new org . commonjava . indy . change . event . ArtifactStorePreUpdateEvent ( org . commonjava . indy . change . event . ArtifactStoreUpdateType . UPDATE , new org . commonjava . maven . galley . event . EventMetadata ( ) , java . util . Collections . singletonMap ( g . copyOf ( ) , g ) ) ; maintainer . updateImpliedStores ( event ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( g . getConstituents ( ) . contains ( repo2 . getKey ( ) ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "addImpliedRepoWhenRepoAddedToGroup ( ) { final org . commonjava . indy . model . core . Group g = new org . commonjava . indy . model . core . Group ( MAVEN_PKG_KEY , \"test\" ) ; storeDataManager . storeArtifactStore ( g , summary , false , true , new org . commonjava . maven . galley . event . EventMetadata ( ) ) ; final org . commonjava . indy . model . core . RemoteRepository repo1 = new org . commonjava . indy . model . core . RemoteRepository ( MAVEN_PKG_KEY , \"one\" , \"http://www.foo.com/repo\" ) ; storeDataManager . storeArtifactStore ( repo1 , summary , false , true , new org . commonjava . maven . galley . event . EventMetadata ( ) ) ; final org . commonjava . indy . model . core . RemoteRepository repo2 = new org . commonjava . indy . model . core . RemoteRepository ( MAVEN_PKG_KEY , \"one\" , \"http://www.foo.com/repo\" ) ; storeDataManager . storeArtifactStore ( repo2 , summary , false , true , new org . commonjava . maven . galley . event . EventMetadata ( ) ) ; metadataManager . addImpliedMetadata ( repo1 , java . util . Collections . singletonList ( repo2 ) ) ; g . addConstituent ( repo1 ) ; final org . commonjava . indy . change . event . ArtifactStorePreUpdateEvent event = new org . commonjava . indy . change . event . ArtifactStorePreUpdateEvent ( org . commonjava . indy . change . event . ArtifactStoreUpdateType . UPDATE , new org . commonjava . maven . galley . event . EventMetadata ( ) , java . util . Collections . singletonMap ( g . copyOf ( ) , g ) ) ; maintainer . updateImpliedStores ( event ) ; \"<AssertPlaceHolder>\" ; } getConstituents ( ) { return ( constituents ) == null ? java . util . Collections . emptyList ( ) : java . util . Collections . unmodifiableList ( constituents ) ; }", "answer": "org . junit . Assert . assertThat ( g . getConstituents ( ) . contains ( repo2 . getKey ( ) ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "paths ( ) { int [ ] [ ] paths = new int [ this . paths . size ( ) ] [ 0 ] ; for ( int i = 0 ; i < ( this . paths . size ( ) ) ; i ++ ) paths [ i ] = this . paths . get ( i ) ; return paths ; }", "testMethod": "paths_cyclophane_even ( ) { int [ ] [ ] cyclophane_even = org . openscience . cdk . graph . InitialCyclesTest . cyclophane_even ( ) ; org . openscience . cdk . graph . EdgeShortCycles esc = new org . openscience . cdk . graph . EdgeShortCycles ( cyclophane_even ) ; int [ ] [ ] paths = esc . paths ( ) ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { 3 , 2 , 1 , 0 , 5 , 4 , 3 } , new int [ ] { 3 , 6 , 7 , 8 , 9 , 10 , 11 , 0 , 1 , 2 , 3 } , new int [ ] { 3 , 6 , 7 , 8 , 9 , 10 , 11 , 0 , 5 , 4 , 3 } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( paths , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "paths_cyclophane_even ( ) { int [ ] [ ] cyclophane_even = org . openscience . cdk . graph . InitialCyclesTest . cyclophane_even ( ) ; org . openscience . cdk . graph . EdgeShortCycles esc = new org . openscience . cdk . graph . EdgeShortCycles ( cyclophane_even ) ; int [ ] [ ] paths = esc . paths ( ) ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { 3 , 2 , 1 , 0 , 5 , 4 , 3 } , new int [ ] { 3 , 6 , 7 , 8 , 9 , 10 , 11 , 0 , 1 , 2 , 3 } , new int [ ] { 3 , 6 , 7 , 8 , 9 , 10 , 11 , 0 , 5 , 4 , 3 } } ; \"<AssertPlaceHolder>\" ; } paths ( ) { int [ ] [ ] paths = new int [ this . paths . size ( ) ] [ 0 ] ; for ( int i = 0 ; i < ( this . paths . size ( ) ) ; i ++ ) paths [ i ] = this . paths . get ( i ) ; return paths ; }", "answer": "org . junit . Assert . assertThat ( paths , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "contains ( java . lang . String ) { return ( id != null ) && ( super . contains ( id ) ) ; }", "testMethod": "testGetLinkedReleases ( ) { final org . eclipse . sw360 . components . db . Map < java . lang . String , org . eclipse . sw360 . datahandler . thrift . ReleaseRelationship > relations = new org . eclipse . sw360 . components . db . HashMap ( ) ; relations . put ( \"R1A\" , ReleaseRelationship . REFERRED ) ; final org . eclipse . sw360 . components . db . Release r1A = handler . getRelease ( \"R1A\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 ) ; r1A . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R1B\" , ReleaseRelationship . CONTAINED , \"R2A\" , ReleaseRelationship . REFERRED ) ) ; handler . updateRelease ( r1A , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . Release r1B = handler . getRelease ( \"R1B\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 ) ; r1B . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R2A\" , ReleaseRelationship . REFERRED ) ) ; handler . updateRelease ( r1B , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . Release r2A = handler . getRelease ( \"R2A\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 ) ; r2A . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R2B\" , ReleaseRelationship . CONTAINED ) ) ; handler . updateRelease ( r2A , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . Release r2B = handler . getRelease ( \"R2B\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 ) ; r2B . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R1B\" , ReleaseRelationship . CONTAINED , \"R1A\" , ReleaseRelationship . REFERRED ) ) ; handler . updateRelease ( r2B , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . ExecutorService service = org . eclipse . sw360 . components . db . Executors . newSingleThreadExecutor ( ) ; final org . eclipse . sw360 . components . db . Future < org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ReleaseLink > > completionFuture = service . submit ( ( ) -> handler . getLinkedReleases ( relations ) ) ; service . shutdown ( ) ; service . awaitTermination ( 10 , TimeUnit . SECONDS ) ; final org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ReleaseLink > linkedReleases = completionFuture . get ( ) ; org . eclipse . sw360 . components . db . ReleaseLink releaseLinkR1A = createReleaseLinkTo ( r1A ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setNodeId ( \"R1A\" ) ; stripRandomPartsOfNodeIds ( linkedReleases ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( linkedReleases , contains ( releaseLinkR1A ) )", "total": "testGetLinkedReleases ( ) { final org . eclipse . sw360 . components . db . Map < java . lang . String , org . eclipse . sw360 . datahandler . thrift . ReleaseRelationship > relations = new org . eclipse . sw360 . components . db . HashMap ( ) ; relations . put ( \"R1A\" , ReleaseRelationship . REFERRED ) ; final org . eclipse . sw360 . components . db . Release r1A = handler . getRelease ( \"R1A\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 ) ; r1A . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R1B\" , ReleaseRelationship . CONTAINED , \"R2A\" , ReleaseRelationship . REFERRED ) ) ; handler . updateRelease ( r1A , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . Release r1B = handler . getRelease ( \"R1B\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 ) ; r1B . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R2A\" , ReleaseRelationship . REFERRED ) ) ; handler . updateRelease ( r1B , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . Release r2A = handler . getRelease ( \"R2A\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 ) ; r2A . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R2B\" , ReleaseRelationship . CONTAINED ) ) ; handler . updateRelease ( r2A , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user1 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . Release r2B = handler . getRelease ( \"R2B\" , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 ) ; r2B . setReleaseIdToRelationship ( com . google . common . collect . ImmutableMap . of ( \"R1B\" , ReleaseRelationship . CONTAINED , \"R1A\" , ReleaseRelationship . REFERRED ) ) ; handler . updateRelease ( r2B , org . eclipse . sw360 . components . db . ComponentDatabaseHandlerTest . user2 , ThriftUtils . IMMUTABLE_OF_RELEASE ) ; final org . eclipse . sw360 . components . db . ExecutorService service = org . eclipse . sw360 . components . db . Executors . newSingleThreadExecutor ( ) ; final org . eclipse . sw360 . components . db . Future < org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ReleaseLink > > completionFuture = service . submit ( ( ) -> handler . getLinkedReleases ( relations ) ) ; service . shutdown ( ) ; service . awaitTermination ( 10 , TimeUnit . SECONDS ) ; final org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ReleaseLink > linkedReleases = completionFuture . get ( ) ; org . eclipse . sw360 . components . db . ReleaseLink releaseLinkR1A = createReleaseLinkTo ( r1A ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setNodeId ( \"R1A\" ) ; stripRandomPartsOfNodeIds ( linkedReleases ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . String ) { return ( id != null ) && ( super . contains ( id ) ) ; }", "answer": "org . junit . Assert . assertThat ( linkedReleases , contains ( releaseLinkR1A ) )"}
{"focal": "getStudents ( ) { return students ; }", "testMethod": "shouldRemoveGroupMembers ( ) { users . loginAsTeacher ( ) ; org . adaptiveplatform . surveys . acceptance . ChangeGroupMembersCommand cmd = org . adaptiveplatform . surveys . acceptance . StudentGroupsSystemTest . removeMemberCmd ( 1L , org . adaptiveplatform . surveys . acceptance . STUDENT_EMAIL ) ; groupFacade . changeGroupMembers ( cmd ) ; org . adaptiveplatform . surveys . acceptance . StudentGroupDto group = groupDao . getGroup ( 1L ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( group . getStudents ( ) )", "total": "shouldRemoveGroupMembers ( ) { users . loginAsTeacher ( ) ; org . adaptiveplatform . surveys . acceptance . ChangeGroupMembersCommand cmd = org . adaptiveplatform . surveys . acceptance . StudentGroupsSystemTest . removeMemberCmd ( 1L , org . adaptiveplatform . surveys . acceptance . STUDENT_EMAIL ) ; groupFacade . changeGroupMembers ( cmd ) ; org . adaptiveplatform . surveys . acceptance . StudentGroupDto group = groupDao . getGroup ( 1L ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; } getStudents ( ) { return students ; }", "answer": "org . junit . Assert . assertThat ( group . getStudents ( ) )"}
{"focal": "toBuilder ( ) { return new org . batfish . datamodel . GeneratedRoute . Builder ( ) . setNetwork ( getNetwork ( ) ) . setAdmin ( getAdministrativeCost ( ) ) . setNonForwarding ( getNonForwarding ( ) ) . setNonRouting ( getNonRouting ( ) ) . setMetric ( firstNonNull ( getMetric ( ) , 0L ) ) . setNextHopIp ( getNextHopIp ( ) ) . setAsPath ( getAsPath ( ) ) . setAttributePolicy ( getAttributePolicy ( ) ) . setCommunities ( getCommunities ( ) ) . setDiscard ( getDiscard ( ) ) . setGenerationPolicy ( getGenerationPolicy ( ) ) . setNextHopInterface ( getNextHopInterface ( ) ) ; }", "testMethod": "testToBuilder ( ) { org . batfish . datamodel . ConnectedRoute cr = new org . batfish . datamodel . ConnectedRoute ( org . batfish . datamodel . Prefix . parse ( \"1.1.1.0/24\" ) , \"Ethernet0\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cr , org . hamcrest . Matchers . equalTo ( cr . toBuilder ( ) . build ( ) ) )", "total": "testToBuilder ( ) { org . batfish . datamodel . ConnectedRoute cr = new org . batfish . datamodel . ConnectedRoute ( org . batfish . datamodel . Prefix . parse ( \"1.1.1.0/24\" ) , \"Ethernet0\" ) ; \"<AssertPlaceHolder>\" ; } toBuilder ( ) { return new org . batfish . datamodel . GeneratedRoute . Builder ( ) . setNetwork ( getNetwork ( ) ) . setAdmin ( getAdministrativeCost ( ) ) . setNonForwarding ( getNonForwarding ( ) ) . setNonRouting ( getNonRouting ( ) ) . setMetric ( firstNonNull ( getMetric ( ) , 0L ) ) . setNextHopIp ( getNextHopIp ( ) ) . setAsPath ( getAsPath ( ) ) . setAttributePolicy ( getAttributePolicy ( ) ) . setCommunities ( getCommunities ( ) ) . setDiscard ( getDiscard ( ) ) . setGenerationPolicy ( getGenerationPolicy ( ) ) . setNextHopInterface ( getNextHopInterface ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( cr , org . hamcrest . Matchers . equalTo ( cr . toBuilder ( ) . build ( ) ) )"}
{"focal": "matchMaterial ( java . lang . String ) { org . apache . commons . lang . Validate . notNull ( name , \"Name<sp>cannot<sp>be<sp>null\" ) ; org . bukkit . Material result = null ; try { result = org . bukkit . Material . getMaterial ( java . lang . Integer . parseInt ( name ) ) ; } catch ( java . lang . NumberFormatException ex ) { } if ( result == null ) { java . lang . String filtered = name . toUpperCase ( java . util . Locale . ENGLISH ) ; filtered = filtered . replaceAll ( \"\\\\s+\" , \"_\" ) . replaceAll ( \"\\\\W\" , \"\" ) ; result = org . bukkit . Material . BY_NAME . get ( filtered ) ; } return result ; }", "testMethod": "matchMaterialById ( ) { for ( org . bukkit . Material material : org . bukkit . Material . values ( ) ) { if ( ( material . getClass ( ) . getField ( material . name ( ) ) . getAnnotation ( org . bukkit . Deprecated . class ) ) != null ) { continue ; } \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( org . bukkit . Material . matchMaterial ( java . lang . String . valueOf ( material . getId ( ) ) ) , is ( material ) )", "total": "matchMaterialById ( ) { for ( org . bukkit . Material material : org . bukkit . Material . values ( ) ) { if ( ( material . getClass ( ) . getField ( material . name ( ) ) . getAnnotation ( org . bukkit . Deprecated . class ) ) != null ) { continue ; } \"<AssertPlaceHolder>\" ; } } matchMaterial ( java . lang . String ) { org . apache . commons . lang . Validate . notNull ( name , \"Name<sp>cannot<sp>be<sp>null\" ) ; org . bukkit . Material result = null ; try { result = org . bukkit . Material . getMaterial ( java . lang . Integer . parseInt ( name ) ) ; } catch ( java . lang . NumberFormatException ex ) { } if ( result == null ) { java . lang . String filtered = name . toUpperCase ( java . util . Locale . ENGLISH ) ; filtered = filtered . replaceAll ( \"\\\\s+\" , \"_\" ) . replaceAll ( \"\\\\W\" , \"\" ) ; result = org . bukkit . Material . BY_NAME . get ( filtered ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( org . bukkit . Material . matchMaterial ( java . lang . String . valueOf ( material . getId ( ) ) ) , is ( material ) )"}
{"focal": "valueOf ( T ) { return new org . drools . model . impl . ValueImpl ( value ) ; }", "testMethod": "testManualContext ( ) { org . kie . dmn . feel . codegen . feel11 . CompiledFEELExpression compiledExpression = new org . kie . dmn . feel . codegen . feel11 . ManualFilterTest . ManualFilterExpression ( ) ; org . kie . dmn . feel . codegen . feel11 . ManualFilterTest . LOG . debug ( \"{}\" , compiledExpression ) ; org . kie . dmn . feel . lang . EvaluationContext emptyContext = org . kie . dmn . feel . codegen . feel11 . CodegenTestUtil . newEmptyEvaluationContext ( ) ; java . lang . Object result = compiledExpression . apply ( emptyContext ) ; org . kie . dmn . feel . codegen . feel11 . ManualFilterTest . LOG . debug ( \"{}\" , result ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( java . math . BigDecimal . valueOf ( 3 ) , java . math . BigDecimal . valueOf ( 4 ) ) ) )", "total": "testManualContext ( ) { org . kie . dmn . feel . codegen . feel11 . CompiledFEELExpression compiledExpression = new org . kie . dmn . feel . codegen . feel11 . ManualFilterTest . ManualFilterExpression ( ) ; org . kie . dmn . feel . codegen . feel11 . ManualFilterTest . LOG . debug ( \"{}\" , compiledExpression ) ; org . kie . dmn . feel . lang . EvaluationContext emptyContext = org . kie . dmn . feel . codegen . feel11 . CodegenTestUtil . newEmptyEvaluationContext ( ) ; java . lang . Object result = compiledExpression . apply ( emptyContext ) ; org . kie . dmn . feel . codegen . feel11 . ManualFilterTest . LOG . debug ( \"{}\" , result ) ; \"<AssertPlaceHolder>\" ; } valueOf ( T ) { return new org . drools . model . impl . ValueImpl ( value ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( java . math . BigDecimal . valueOf ( 3 ) , java . math . BigDecimal . valueOf ( 4 ) ) ) )"}
{"focal": "parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "testMethod": "testParseSuperErr ( ) { actions = new java . util . HashMap < java . lang . String , java . lang . String > ( ) { { put ( \"aaa\" , \"bbb\" ) ; } } ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowActionPopPbbQuery ( actions ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testParseSuperErr ( ) { actions = new java . util . HashMap < java . lang . String , java . lang . String > ( ) { { put ( \"aaa\" , \"bbb\" ) ; } } ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowActionPopPbbQuery ( actions ) ; \"<AssertPlaceHolder>\" ; } parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getServiceAccount ( ) { return serviceAccount ; }", "testMethod": "whenCreatedFromMapWithoutServiceAccount_hasEmptyString ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( values . getServiceAccount ( ) , org . hamcrest . Matchers . equalTo ( \"\" ) )", "total": "whenCreatedFromMapWithoutServiceAccount_hasEmptyString ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( ) ) ; \"<AssertPlaceHolder>\" ; } getServiceAccount ( ) { return serviceAccount ; }", "answer": "org . junit . Assert . assertThat ( values . getServiceAccount ( ) , org . hamcrest . Matchers . equalTo ( \"\" ) )"}
{"focal": "createMinimalSqlStatement ( java . lang . String , java . lang . String ) { java . lang . String expected = ( ( ( ( ( ( \"SELECT<sp>\" + selectClause ) + \"\\n\" ) + \"FROM\" ) + \"\\n\" ) + \"<sp>\" ) + fromClause ) + \"\\n\" ; return expected ; }", "testMethod": "shouldAppendOrderByClause ( ) { java . lang . String selectClause = uniqueString ( ) ; java . lang . String fromClause = uniqueString ( ) ; setupSelectAndFromClause ( selectClause , fromClause ) ; java . lang . String orderBy = uniqueString ( ) ; @ annis . sqlgen . SuppressWarnings ( \"unchecked\" ) annis . sqlgen . OrderByClauseSqlGenerator < annis . ql . parser . QueryData > orderByClauseSqlGenerator = mock ( annis . sqlgen . OrderByClauseSqlGenerator . class ) ; generator . setOrderByClauseSqlGenerator ( orderByClauseSqlGenerator ) ; given ( orderByClauseSqlGenerator . orderByClause ( eq ( queryData ) , eq ( alternative ) , anyString ( ) ) ) . willReturn ( orderBy ) ; java . lang . String sql = generator . toSql ( queryData ) ; java . lang . String expected = createMinimalSqlStatement ( selectClause , fromClause ) ; expected += ( \"ORDER<sp>BY<sp>\" + orderBy ) + \"\\n\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sql , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldAppendOrderByClause ( ) { java . lang . String selectClause = uniqueString ( ) ; java . lang . String fromClause = uniqueString ( ) ; setupSelectAndFromClause ( selectClause , fromClause ) ; java . lang . String orderBy = uniqueString ( ) ; @ annis . sqlgen . SuppressWarnings ( \"unchecked\" ) annis . sqlgen . OrderByClauseSqlGenerator < annis . ql . parser . QueryData > orderByClauseSqlGenerator = mock ( annis . sqlgen . OrderByClauseSqlGenerator . class ) ; generator . setOrderByClauseSqlGenerator ( orderByClauseSqlGenerator ) ; given ( orderByClauseSqlGenerator . orderByClause ( eq ( queryData ) , eq ( alternative ) , anyString ( ) ) ) . willReturn ( orderBy ) ; java . lang . String sql = generator . toSql ( queryData ) ; java . lang . String expected = createMinimalSqlStatement ( selectClause , fromClause ) ; expected += ( \"ORDER<sp>BY<sp>\" + orderBy ) + \"\\n\" ; \"<AssertPlaceHolder>\" ; } createMinimalSqlStatement ( java . lang . String , java . lang . String ) { java . lang . String expected = ( ( ( ( ( ( \"SELECT<sp>\" + selectClause ) + \"\\n\" ) + \"FROM\" ) + \"\\n\" ) + \"<sp>\" ) + fromClause ) + \"\\n\" ; return expected ; }", "answer": "org . junit . Assert . assertThat ( sql , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getRealPath ( java . lang . String ) { return servletContext . getRealPath ( path ) ; }", "testMethod": "realPath ( ) { java . lang . String realPath = \"real/path\" ; java . lang . String path = \"aaa\" ; servletContext . addRealPath ( path , realPath ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( servletContext . getRealPath ( path ) , org . hamcrest . CoreMatchers . is ( realPath ) )", "total": "realPath ( ) { java . lang . String realPath = \"real/path\" ; java . lang . String path = \"aaa\" ; servletContext . addRealPath ( path , realPath ) ; \"<AssertPlaceHolder>\" ; } getRealPath ( java . lang . String ) { return servletContext . getRealPath ( path ) ; }", "answer": "org . junit . Assert . assertThat ( servletContext . getRealPath ( path ) , org . hamcrest . CoreMatchers . is ( realPath ) )"}
{"focal": "hashCode ( ) { return value . hashCode ( ) ; }", "testMethod": "testHashCodeSameEquals ( ) { org . eclipse . lyo . oslc4j . core . model . Link linkA = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_A ) ) ; org . eclipse . lyo . oslc4j . core . model . Link linkB = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_A ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( linkA . hashCode ( ) , org . hamcrest . CoreMatchers . equalTo ( linkB . hashCode ( ) ) )", "total": "testHashCodeSameEquals ( ) { org . eclipse . lyo . oslc4j . core . model . Link linkA = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_A ) ) ; org . eclipse . lyo . oslc4j . core . model . Link linkB = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_A ) ) ; \"<AssertPlaceHolder>\" ; } hashCode ( ) { return value . hashCode ( ) ; }", "answer": "org . junit . Assert . assertThat ( linkA . hashCode ( ) , org . hamcrest . CoreMatchers . equalTo ( linkB . hashCode ( ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testSystemId ( ) { defaultIsisInterface . setSystemId ( sysId ) ; resultStr = defaultIsisInterface . systemId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultStr , org . hamcrest . CoreMatchers . is ( sysId ) )", "total": "testSystemId ( ) { defaultIsisInterface . setSystemId ( sysId ) ; resultStr = defaultIsisInterface . systemId ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( resultStr , org . hamcrest . CoreMatchers . is ( sysId ) )"}
{"focal": "isValidEvent ( nl . topicus . bitbucket . events . Event , nl . topicus . bitbucket . persistence . WebHookConfiguration ) { return ( ! ( event instanceof nl . topicus . bitbucket . events . Ignorable ) ) || ( ! ( isIgnoredEvent ( ( ( nl . topicus . bitbucket . events . Ignorable ) ( event ) ) , configuration ) ) ) ; }", "testMethod": "testIgnoreCommitter ( ) { nl . topicus . bitbucket . persistence . WebHookConfiguration dummyConfiguration = createDummyConfiguration ( ) ; dummyConfiguration . setCommittersToIgnore ( \"foo.mc.fooface\" ) ; nl . topicus . bitbucket . api . PushEventService pushEventService = new nl . topicus . bitbucket . api . PushEventService ( dummyConfiguration ) ; nl . topicus . bitbucket . events . BitbucketPushEvent dummyEvent = createDummyEvent ( ) ; nl . topicus . bitbucket . model . repository . BitbucketServerRepositoryOwner owner = new nl . topicus . bitbucket . model . repository . BitbucketServerRepositoryOwner ( \"foo.mc.fooface\" , \"FOO\" ) ; dummyEvent . setActor ( owner ) ; com . google . common . collect . ImmutableList < nl . topicus . bitbucket . events . BitbucketPushChange > changes = com . google . common . collect . ImmutableList . of ( createDummyChange ( \"feature/foo\" ) , createDummyChange ( \"bar\" ) ) ; dummyEvent . getPush ( ) . setChanges ( changes ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pushEventService . isValidEvent ( dummyEvent , dummyConfiguration ) , org . hamcrest . Matchers . is ( false ) )", "total": "testIgnoreCommitter ( ) { nl . topicus . bitbucket . persistence . WebHookConfiguration dummyConfiguration = createDummyConfiguration ( ) ; dummyConfiguration . setCommittersToIgnore ( \"foo.mc.fooface\" ) ; nl . topicus . bitbucket . api . PushEventService pushEventService = new nl . topicus . bitbucket . api . PushEventService ( dummyConfiguration ) ; nl . topicus . bitbucket . events . BitbucketPushEvent dummyEvent = createDummyEvent ( ) ; nl . topicus . bitbucket . model . repository . BitbucketServerRepositoryOwner owner = new nl . topicus . bitbucket . model . repository . BitbucketServerRepositoryOwner ( \"foo.mc.fooface\" , \"FOO\" ) ; dummyEvent . setActor ( owner ) ; com . google . common . collect . ImmutableList < nl . topicus . bitbucket . events . BitbucketPushChange > changes = com . google . common . collect . ImmutableList . of ( createDummyChange ( \"feature/foo\" ) , createDummyChange ( \"bar\" ) ) ; dummyEvent . getPush ( ) . setChanges ( changes ) ; \"<AssertPlaceHolder>\" ; } isValidEvent ( nl . topicus . bitbucket . events . Event , nl . topicus . bitbucket . persistence . WebHookConfiguration ) { return ( ! ( event instanceof nl . topicus . bitbucket . events . Ignorable ) ) || ( ! ( isIgnoredEvent ( ( ( nl . topicus . bitbucket . events . Ignorable ) ( event ) ) , configuration ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( pushEventService . isValidEvent ( dummyEvent , dummyConfiguration ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "serialize ( java . lang . Object ) { if ( t == null ) { return SerializationUtils . EMPTY_ARRAY ; } try { return this . objectMapper . writeValueAsBytes ( t ) ; } catch ( java . lang . Exception ex ) { throw new org . springframework . data . redis . serializer . SerializationException ( ( \"Could<sp>not<sp>write<sp>JSON:<sp>\" + ( ex . getMessage ( ) ) ) , ex ) ; } }", "testMethod": "testJackson2JsonSerializerShouldReturnEmptyByteArrayWhenSerializingNull ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serializer . serialize ( null ) , org . hamcrest . core . Is . is ( new byte [ 0 ] ) )", "total": "testJackson2JsonSerializerShouldReturnEmptyByteArrayWhenSerializingNull ( ) { \"<AssertPlaceHolder>\" ; } serialize ( java . lang . Object ) { if ( t == null ) { return SerializationUtils . EMPTY_ARRAY ; } try { return this . objectMapper . writeValueAsBytes ( t ) ; } catch ( java . lang . Exception ex ) { throw new org . springframework . data . redis . serializer . SerializationException ( ( \"Could<sp>not<sp>write<sp>JSON:<sp>\" + ( ex . getMessage ( ) ) ) , ex ) ; } }", "answer": "org . junit . Assert . assertThat ( serializer . serialize ( null ) , org . hamcrest . core . Is . is ( new byte [ 0 ] ) )"}
{"focal": "parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "testMethod": "testParseActionMapErr ( ) { queriesString = \"type=node&enabled=true&status=established&actions=port01\" ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testParseActionMapErr ( ) { queriesString = \"type=node&enabled=true&status=established&actions=port01\" ; target = new org . o3project . odenos . core . component . network . flow . query . BasicFlowQuery ( queriesString ) ; \"<AssertPlaceHolder>\" ; } parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isSignedIn ( ) { if ( ! ( inIsisSession ( ) ) ) { return false ; } if ( ( getAuthenticationSession ( ) ) == null ) { return false ; } return getWicketAuthenticationSession ( ) . isSignedIn ( ) ; }", "testMethod": "signInJustDelegatesToAuthenticateAndSavesState ( ) { context . checking ( new org . jmock . Expectations ( ) { { one ( mockAuthMgr ) . authenticate ( with ( any ( org . apache . isis . core . runtime . authentication . AuthenticationRequest . class ) ) ) ; } } ) ; webSession = new org . apache . isis . viewer . wicket . viewer . integration . wicket . AuthenticatedWebSessionForIsis ( stubRequest ) { private static final long serialVersionUID = 1L ; @ org . apache . isis . viewer . wicket . viewer . app . wicket . Override protected org . apache . isis . core . runtime . authentication . AuthenticationManager getAuthenticationManager ( ) { return mockAuthMgr ; } } ; webSession . signIn ( \"john\" , \"secret\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( webSession . isSignedIn ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "signInJustDelegatesToAuthenticateAndSavesState ( ) { context . checking ( new org . jmock . Expectations ( ) { { one ( mockAuthMgr ) . authenticate ( with ( any ( org . apache . isis . core . runtime . authentication . AuthenticationRequest . class ) ) ) ; } } ) ; webSession = new org . apache . isis . viewer . wicket . viewer . integration . wicket . AuthenticatedWebSessionForIsis ( stubRequest ) { private static final long serialVersionUID = 1L ; @ org . apache . isis . viewer . wicket . viewer . app . wicket . Override protected org . apache . isis . core . runtime . authentication . AuthenticationManager getAuthenticationManager ( ) { return mockAuthMgr ; } } ; webSession . signIn ( \"john\" , \"secret\" ) ; \"<AssertPlaceHolder>\" ; } isSignedIn ( ) { if ( ! ( inIsisSession ( ) ) ) { return false ; } if ( ( getAuthenticationSession ( ) ) == null ) { return false ; } return getWicketAuthenticationSession ( ) . isSignedIn ( ) ; }", "answer": "org . junit . Assert . assertThat ( webSession . isSignedIn ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "defaultHeaders ( org . axonframework . eventhandling . EventMessage , org . axonframework . serialization . SerializedObject ) { org . axonframework . common . Assert . notNull ( message , ( ) -> \"Event<sp>message<sp>cannot<sp>be<sp>null\" ) ; org . axonframework . common . Assert . notNull ( serializedObject , ( ) -> \"Serialized<sp>Object<sp>cannot<sp>be<sp>null\" ) ; org . axonframework . common . Assert . notNull ( serializedObject . getType ( ) , ( ) -> \"SerializedObject<sp>Type<sp>cannot<sp>be<sp>null\" ) ; java . util . HashMap < java . lang . String , java . lang . Object > headers = new java . util . HashMap ( ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_ID , message . getIdentifier ( ) ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_TYPE , serializedObject . getType ( ) . getName ( ) ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_REVISION , serializedObject . getType ( ) . getRevision ( ) ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_TIMESTAMP , message . getTimestamp ( ) ) ; if ( message instanceof org . axonframework . eventhandling . DomainEventMessage ) { headers . put ( org . axonframework . messaging . Headers . AGGREGATE_ID , ( ( org . axonframework . eventhandling . DomainEventMessage < ? > ) ( message ) ) . getAggregateIdentifier ( ) ) ; headers . put ( org . axonframework . messaging . Headers . AGGREGATE_SEQ , ( ( org . axonframework . eventhandling . DomainEventMessage < ? > ) ( message ) ) . getSequenceNumber ( ) ) ; headers . put ( org . axonframework . messaging . Headers . AGGREGATE_TYPE , ( ( org . axonframework . eventhandling . DomainEventMessage < ? > ) ( message ) ) . getType ( ) ) ; } return java . util . Collections . unmodifiableMap ( headers ) ; }", "testMethod": "testGeneratingDefaultMessagingHeaders ( ) { org . axonframework . eventhandling . EventMessage < java . lang . Object > message = asEventMessage ( \"foo\" ) ; org . axonframework . serialization . SerializedObject < byte [ ] > serializedObject = message . serializePayload ( serializer , byte [ ] . class ) ; java . util . Map < java . lang . String , java . lang . Object > expected = new java . util . HashMap < java . lang . String , java . lang . Object > ( ) { { put ( org . axonframework . messaging . MESSAGE_ID , message . getIdentifier ( ) ) ; put ( org . axonframework . messaging . MESSAGE_TYPE , serializedObject . getType ( ) . getName ( ) ) ; put ( org . axonframework . messaging . MESSAGE_REVISION , serializedObject . getType ( ) . getRevision ( ) ) ; put ( org . axonframework . messaging . MESSAGE_TIMESTAMP , message . getTimestamp ( ) ) ; } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( defaultHeaders ( message , serializedObject ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testGeneratingDefaultMessagingHeaders ( ) { org . axonframework . eventhandling . EventMessage < java . lang . Object > message = asEventMessage ( \"foo\" ) ; org . axonframework . serialization . SerializedObject < byte [ ] > serializedObject = message . serializePayload ( serializer , byte [ ] . class ) ; java . util . Map < java . lang . String , java . lang . Object > expected = new java . util . HashMap < java . lang . String , java . lang . Object > ( ) { { put ( org . axonframework . messaging . MESSAGE_ID , message . getIdentifier ( ) ) ; put ( org . axonframework . messaging . MESSAGE_TYPE , serializedObject . getType ( ) . getName ( ) ) ; put ( org . axonframework . messaging . MESSAGE_REVISION , serializedObject . getType ( ) . getRevision ( ) ) ; put ( org . axonframework . messaging . MESSAGE_TIMESTAMP , message . getTimestamp ( ) ) ; } } ; \"<AssertPlaceHolder>\" ; } defaultHeaders ( org . axonframework . eventhandling . EventMessage , org . axonframework . serialization . SerializedObject ) { org . axonframework . common . Assert . notNull ( message , ( ) -> \"Event<sp>message<sp>cannot<sp>be<sp>null\" ) ; org . axonframework . common . Assert . notNull ( serializedObject , ( ) -> \"Serialized<sp>Object<sp>cannot<sp>be<sp>null\" ) ; org . axonframework . common . Assert . notNull ( serializedObject . getType ( ) , ( ) -> \"SerializedObject<sp>Type<sp>cannot<sp>be<sp>null\" ) ; java . util . HashMap < java . lang . String , java . lang . Object > headers = new java . util . HashMap ( ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_ID , message . getIdentifier ( ) ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_TYPE , serializedObject . getType ( ) . getName ( ) ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_REVISION , serializedObject . getType ( ) . getRevision ( ) ) ; headers . put ( org . axonframework . messaging . Headers . MESSAGE_TIMESTAMP , message . getTimestamp ( ) ) ; if ( message instanceof org . axonframework . eventhandling . DomainEventMessage ) { headers . put ( org . axonframework . messaging . Headers . AGGREGATE_ID , ( ( org . axonframework . eventhandling . DomainEventMessage < ? > ) ( message ) ) . getAggregateIdentifier ( ) ) ; headers . put ( org . axonframework . messaging . Headers . AGGREGATE_SEQ , ( ( org . axonframework . eventhandling . DomainEventMessage < ? > ) ( message ) ) . getSequenceNumber ( ) ) ; headers . put ( org . axonframework . messaging . Headers . AGGREGATE_TYPE , ( ( org . axonframework . eventhandling . DomainEventMessage < ? > ) ( message ) ) . getType ( ) ) ; } return java . util . Collections . unmodifiableMap ( headers ) ; }", "answer": "org . junit . Assert . assertThat ( defaultHeaders ( message , serializedObject ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "testMethod": "hashWildcardExpression ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , FlattenObject ( ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo.*\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "hashWildcardExpression ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , FlattenObject ( ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo.*\" ) ; \"<AssertPlaceHolder>\" ; } compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "getKilometers ( ) { return kilometers ; }", "testMethod": "testGoingForward ( ) { car . setFuel ( 100 ) ; car . moveForward ( 10 ) ; int actualKilometers = car . getKilometers ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualKilometers , org . hamcrest . CoreMatchers . is ( 10 ) )", "total": "testGoingForward ( ) { car . setFuel ( 100 ) ; car . moveForward ( 10 ) ; int actualKilometers = car . getKilometers ( ) ; \"<AssertPlaceHolder>\" ; } getKilometers ( ) { return kilometers ; }", "answer": "org . junit . Assert . assertThat ( actualKilometers , org . hamcrest . CoreMatchers . is ( 10 ) )"}
{"focal": "getOutput ( ) { return output ; }", "testMethod": "testSetOutput ( ) { target . setOutput ( \"newOutput\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getOutput ( ) , org . hamcrest . CoreMatchers . is ( \"newOutput\" ) )", "total": "testSetOutput ( ) { target . setOutput ( \"newOutput\" ) ; \"<AssertPlaceHolder>\" ; } getOutput ( ) { return output ; }", "answer": "org . junit . Assert . assertThat ( target . getOutput ( ) , org . hamcrest . CoreMatchers . is ( \"newOutput\" ) )"}
{"focal": "getText ( ) { return stb . getText ( ) ; }", "testMethod": "testUppercaseAlphaKeys ( ) { org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"enabeledTextElement\" ) ) ; element . clear ( ) ; java . lang . String upperAlphas = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ; element . sendKeys ( upperAlphas ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( element . getText ( ) , org . hamcrest . Matchers . is ( upperAlphas ) )", "total": "testUppercaseAlphaKeys ( ) { org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"enabeledTextElement\" ) ) ; element . clear ( ) ; java . lang . String upperAlphas = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ; element . sendKeys ( upperAlphas ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { return stb . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( element . getText ( ) , org . hamcrest . Matchers . is ( upperAlphas ) )"}
{"focal": "getPropertyInfo ( java . lang . String , java . util . Properties ) { org . modeshape . jdbc . delegate . RepositoryDelegate repositoryDelegate = delegateFactory . createRepositoryDelegate ( url , info , this . contextFactory ) ; org . modeshape . jdbc . delegate . ConnectionInfo connectionInfo = repositoryDelegate . getConnectionInfo ( ) ; return connectionInfo . getPropertyInfos ( ) ; }", "testMethod": "shouldReturnEmptyPropertyInfosWhenSuppliedValidUrlAndAllPropertiesWithRepositoryInJndi ( ) { validUrl = ( JcrDriver . JNDI_URL_PREFIX ) + ( jndiNameForRepository ) ; validProperties . put ( JcrDriver . WORKSPACE_PROPERTY_NAME , \"MyWorkspace\" ) ; validProperties . put ( JcrDriver . USERNAME_PROPERTY_NAME , \"jsmith\" ) ; validProperties . put ( JcrDriver . PASSWORD_PROPERTY_NAME , \"secret\" ) ; validProperties . put ( JcrDriver . REPOSITORY_PROPERTY_NAME , validRepositoryName ) ; java . sql . DriverPropertyInfo [ ] infos = driver . getPropertyInfo ( validUrl , validProperties ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( infos . length , org . hamcrest . core . Is . is ( 0 ) )", "total": "shouldReturnEmptyPropertyInfosWhenSuppliedValidUrlAndAllPropertiesWithRepositoryInJndi ( ) { validUrl = ( JcrDriver . JNDI_URL_PREFIX ) + ( jndiNameForRepository ) ; validProperties . put ( JcrDriver . WORKSPACE_PROPERTY_NAME , \"MyWorkspace\" ) ; validProperties . put ( JcrDriver . USERNAME_PROPERTY_NAME , \"jsmith\" ) ; validProperties . put ( JcrDriver . PASSWORD_PROPERTY_NAME , \"secret\" ) ; validProperties . put ( JcrDriver . REPOSITORY_PROPERTY_NAME , validRepositoryName ) ; java . sql . DriverPropertyInfo [ ] infos = driver . getPropertyInfo ( validUrl , validProperties ) ; \"<AssertPlaceHolder>\" ; } getPropertyInfo ( java . lang . String , java . util . Properties ) { org . modeshape . jdbc . delegate . RepositoryDelegate repositoryDelegate = delegateFactory . createRepositoryDelegate ( url , info , this . contextFactory ) ; org . modeshape . jdbc . delegate . ConnectionInfo connectionInfo = repositoryDelegate . getConnectionInfo ( ) ; return connectionInfo . getPropertyInfos ( ) ; }", "answer": "org . junit . Assert . assertThat ( infos . length , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "withComplement ( net . time4j . range . ChronoInterval ) { if ( timeWindow . isEmpty ( ) ) { java . util . List < net . time4j . range . ChronoInterval < T > > zero = java . util . Collections . emptyList ( ) ; return this . create ( zero ) ; } net . time4j . range . ChronoInterval < T > window = this . adjust ( timeWindow ) ; net . time4j . range . IntervalCollection < T > coll = this . withFilter ( window ) ; if ( coll . isEmpty ( ) ) { return this . create ( java . util . Collections . singletonList ( window ) ) ; } net . time4j . range . Boundary < T > lower = window . getStart ( ) ; net . time4j . range . Boundary < T > upper = window . getEnd ( ) ; java . util . List < net . time4j . range . ChronoInterval < T > > gaps = new java . util . ArrayList ( ) ; T min = coll . getMinimum ( ) ; if ( min != null ) { if ( lower . isInfinite ( ) ) { this . addLeft ( gaps , min ) ; } else { T s = lower . getTemporal ( ) ; if ( lower . isOpen ( ) ) { s = this . getTimeLine ( ) . stepBackwards ( s ) ; if ( s == null ) { this . addLeft ( gaps , min ) ; } else { this . addLeft ( gaps , s , min ) ; } } else { this . addLeft ( gaps , s , min ) ; } } } gaps . addAll ( coll . withGaps ( ) . getIntervals ( ) ) ; T max = coll . getMaximum ( ) ; if ( max != null ) { T s = this . getTimeLine ( ) . stepForward ( max ) ; if ( s != null ) { net . time4j . range . Boundary < T > bs = net . time4j . range . Boundary . ofClosed ( s ) ; net . time4j . range . Boundary < T > be ; if ( upper . isInfinite ( ) ) { be = upper ; gaps . add ( this . newInterval ( bs , be ) ) ; } else if ( this . isCalendrical ( ) ) { if ( upper . isClosed ( ) ) { be = upper ; } else { T e = upper . getTemporal ( ) ; e = this . getTimeLine ( ) . stepBackwards ( e ) ; be = net . time4j . range . Boundary . ofClosed ( e ) ; } if ( ! ( this . isAfter ( s , be . getTemporal ( ) ) ) ) { gaps . add ( this . newInterval ( bs , be ) ) ; } } else { if ( upper . isOpen ( ) ) { be = upper ; } else { T e = upper . getTemporal ( ) ; e = this . getTimeLine ( ) . stepForward ( e ) ; if ( e == null ) { be = net . time4j . range . Boundary . infiniteFuture ( ) ; } else { be = net . time4j . range . Boundary . ofOpen ( e ) ; } } if ( this . isBefore ( s , be . getTemporal ( ) ) ) { gaps . add ( this . newInterval ( bs , be ) ) ; } } } } return this . create ( gaps ) ; }", "testMethod": "complementIfOverlap2 ( ) { net . time4j . range . IntervalCollection < net . time4j . PlainDate > coll = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2011-01-01/2013-12-31\" ) ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-06-30/2014-08-01\" ) ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-09-01/2015-09-30\" ) ) ; net . time4j . range . ChronoInterval < net . time4j . PlainDate > window = net . time4j . range . DateInterval . parseISO ( \"2012-06-30/2014-12-31\" ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > expected = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-01-01/2014-06-29\" ) ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-08-02/2014-08-31\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( coll . withComplement ( window ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "complementIfOverlap2 ( ) { net . time4j . range . IntervalCollection < net . time4j . PlainDate > coll = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2011-01-01/2013-12-31\" ) ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-06-30/2014-08-01\" ) ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-09-01/2015-09-30\" ) ) ; net . time4j . range . ChronoInterval < net . time4j . PlainDate > window = net . time4j . range . DateInterval . parseISO ( \"2012-06-30/2014-12-31\" ) ; net . time4j . range . IntervalCollection < net . time4j . PlainDate > expected = net . time4j . range . IntervalCollection . onDateAxis ( ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-01-01/2014-06-29\" ) ) . plus ( net . time4j . range . DateInterval . parseISO ( \"2014-08-02/2014-08-31\" ) ) ; \"<AssertPlaceHolder>\" ; } withComplement ( net . time4j . range . ChronoInterval ) { if ( timeWindow . isEmpty ( ) ) { java . util . List < net . time4j . range . ChronoInterval < T > > zero = java . util . Collections . emptyList ( ) ; return this . create ( zero ) ; } net . time4j . range . ChronoInterval < T > window = this . adjust ( timeWindow ) ; net . time4j . range . IntervalCollection < T > coll = this . withFilter ( window ) ; if ( coll . isEmpty ( ) ) { return this . create ( java . util . Collections . singletonList ( window ) ) ; } net . time4j . range . Boundary < T > lower = window . getStart ( ) ; net . time4j . range . Boundary < T > upper = window . getEnd ( ) ; java . util . List < net . time4j . range . ChronoInterval < T > > gaps = new java . util . ArrayList ( ) ; T min = coll . getMinimum ( ) ; if ( min != null ) { if ( lower . isInfinite ( ) ) { this . addLeft ( gaps , min ) ; } else { T s = lower . getTemporal ( ) ; if ( lower . isOpen ( ) ) { s = this . getTimeLine ( ) . stepBackwards ( s ) ; if ( s == null ) { this . addLeft ( gaps , min ) ; } else { this . addLeft ( gaps , s , min ) ; } } else { this . addLeft ( gaps , s , min ) ; } } } gaps . addAll ( coll . withGaps ( ) . getIntervals ( ) ) ; T max = coll . getMaximum ( ) ; if ( max != null ) { T s = this . getTimeLine ( ) . stepForward ( max ) ; if ( s != null ) { net . time4j . range . Boundary < T > bs = net . time4j . range . Boundary . ofClosed ( s ) ; net . time4j . range . Boundary < T > be ; if ( upper . isInfinite ( ) ) { be = upper ; gaps . add ( this . newInterval ( bs , be ) ) ; } else if ( this . isCalendrical ( ) ) { if ( upper . isClosed ( ) ) { be = upper ; } else { T e = upper . getTemporal ( ) ; e = this . getTimeLine ( ) . stepBackwards ( e ) ; be = net . time4j . range . Boundary . ofClosed ( e ) ; } if ( ! ( this . isAfter ( s , be . getTemporal ( ) ) ) ) { gaps . add ( this . newInterval ( bs , be ) ) ; } } else { if ( upper . isOpen ( ) ) { be = upper ; } else { T e = upper . getTemporal ( ) ; e = this . getTimeLine ( ) . stepForward ( e ) ; if ( e == null ) { be = net . time4j . range . Boundary . infiniteFuture ( ) ; } else { be = net . time4j . range . Boundary . ofOpen ( e ) ; } } if ( this . isBefore ( s , be . getTemporal ( ) ) ) { gaps . add ( this . newInterval ( bs , be ) ) ; } } } } return this . create ( gaps ) ; }", "answer": "org . junit . Assert . assertThat ( coll . withComplement ( window ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getQuality ( ) { return quality ; }", "testMethod": "testThatBackstagePassesQualityIncreasesBy2WhenSellInBetween6And10 ( ) { int initialQuality = 1 ; int initialSellIn = 10 ; Item sulfuras = new Item ( \"Backstage<sp>passes<sp>to<sp>a<sp>TAFKAL80ETC<sp>concert\" , initialSellIn , initialQuality ) ; GildedRose sut = new GildedRose ( sulfuras ) ; sut . updateQuality ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sulfuras . getQuality ( ) , org . hamcrest . core . Is . is ( ( initialQuality + 2 ) ) )", "total": "testThatBackstagePassesQualityIncreasesBy2WhenSellInBetween6And10 ( ) { int initialQuality = 1 ; int initialSellIn = 10 ; Item sulfuras = new Item ( \"Backstage<sp>passes<sp>to<sp>a<sp>TAFKAL80ETC<sp>concert\" , initialSellIn , initialQuality ) ; GildedRose sut = new GildedRose ( sulfuras ) ; sut . updateQuality ( ) ; \"<AssertPlaceHolder>\" ; } getQuality ( ) { return quality ; }", "answer": "org . junit . Assert . assertThat ( sulfuras . getQuality ( ) , org . hamcrest . core . Is . is ( ( initialQuality + 2 ) ) )"}
{"focal": "get ( java . lang . Class ) { return getPage ( pageClass , null ) ; }", "testMethod": "shouldFindFromModel ( ) { setupFacesContext ( ) ; org . springframework . springfaces . mvc . model . SpringFacesModel model = new org . springframework . springfaces . mvc . model . SpringFacesModel ( ) ; model . put ( \"key\" , \"value\" ) ; javax . faces . context . FacesContext facesContext = javax . faces . context . FacesContext . getCurrentInstance ( ) ; org . springframework . springfaces . mvc . model . SpringFacesModelHolder . attach ( facesContext , facesContext . getViewRoot ( ) , model ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . resolver . get ( \"key\" ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( ( ( java . lang . Object ) ( \"value\" ) ) ) ) )", "total": "shouldFindFromModel ( ) { setupFacesContext ( ) ; org . springframework . springfaces . mvc . model . SpringFacesModel model = new org . springframework . springfaces . mvc . model . SpringFacesModel ( ) ; model . put ( \"key\" , \"value\" ) ; javax . faces . context . FacesContext facesContext = javax . faces . context . FacesContext . getCurrentInstance ( ) ; org . springframework . springfaces . mvc . model . SpringFacesModelHolder . attach ( facesContext , facesContext . getViewRoot ( ) , model ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . Class ) { return getPage ( pageClass , null ) ; }", "answer": "org . junit . Assert . assertThat ( this . resolver . get ( \"key\" ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( ( ( java . lang . Object ) ( \"value\" ) ) ) ) )"}
{"focal": "toByteArray ( ) { return buffer . toByteArray ( ) ; }", "testMethod": "shouldHandleIdAnnotation ( ) { org . jongo . marshall . jackson . configuration . Mapping build = new org . jongo . marshall . jackson . configuration . Mapping . Builder ( ) . build ( ) ; com . fasterxml . jackson . databind . ObjectReader reader = build . getReader ( org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoId . class ) ; org . jongo . bson . BsonDocument document = org . jongo . bson . Bson . createDocument ( new com . mongodb . BasicDBObject ( \"_id\" , \"53a499be60b2a2248d956875\" ) ) ; org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoId friend = reader . readValue ( document . toByteArray ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( friend . id , org . hamcrest . CoreMatchers . equalTo ( \"53a499be60b2a2248d956875\" ) )", "total": "shouldHandleIdAnnotation ( ) { org . jongo . marshall . jackson . configuration . Mapping build = new org . jongo . marshall . jackson . configuration . Mapping . Builder ( ) . build ( ) ; com . fasterxml . jackson . databind . ObjectReader reader = build . getReader ( org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoId . class ) ; org . jongo . bson . BsonDocument document = org . jongo . bson . Bson . createDocument ( new com . mongodb . BasicDBObject ( \"_id\" , \"53a499be60b2a2248d956875\" ) ) ; org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoId friend = reader . readValue ( document . toByteArray ( ) ) ; \"<AssertPlaceHolder>\" ; } toByteArray ( ) { return buffer . toByteArray ( ) ; }", "answer": "org . junit . Assert . assertThat ( friend . id , org . hamcrest . CoreMatchers . equalTo ( \"53a499be60b2a2248d956875\" ) )"}
{"focal": "getIssue ( ) { return issue ; }", "testMethod": "testThatWeCanBuild ( ) { com . ontometrics . integrations . events . Issue issue = new com . ontometrics . integrations . events . Issue . Builder ( ) . projectPrefix ( \"ASOC\" ) . id ( 408 ) . title ( \"ProcessEvents<sp>need<sp>to<sp>be<sp>persisted\" ) . description ( \"Right<sp>now<sp>we<sp>are<sp>pulling<sp>them<sp>from<sp>the<sp>stream,<sp>we<sp>have<sp>to<sp>save<sp>them.\" ) . build ( ) ; com . ontometrics . integrations . events . ProcessEventChange change = new com . ontometrics . integrations . events . ProcessEventChange . Builder ( ) . issue ( issue ) . field ( \"State\" ) . priorValue ( \"Assigned\" ) . currentValue ( \"Fixed\" ) . updated ( new java . util . Date ( ) ) . updater ( \"Noura\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( change . getIssue ( ) . getId ( ) , org . hamcrest . CoreMatchers . is ( 408 ) )", "total": "testThatWeCanBuild ( ) { com . ontometrics . integrations . events . Issue issue = new com . ontometrics . integrations . events . Issue . Builder ( ) . projectPrefix ( \"ASOC\" ) . id ( 408 ) . title ( \"ProcessEvents<sp>need<sp>to<sp>be<sp>persisted\" ) . description ( \"Right<sp>now<sp>we<sp>are<sp>pulling<sp>them<sp>from<sp>the<sp>stream,<sp>we<sp>have<sp>to<sp>save<sp>them.\" ) . build ( ) ; com . ontometrics . integrations . events . ProcessEventChange change = new com . ontometrics . integrations . events . ProcessEventChange . Builder ( ) . issue ( issue ) . field ( \"State\" ) . priorValue ( \"Assigned\" ) . currentValue ( \"Fixed\" ) . updated ( new java . util . Date ( ) ) . updater ( \"Noura\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getIssue ( ) { return issue ; }", "answer": "org . junit . Assert . assertThat ( change . getIssue ( ) . getId ( ) , org . hamcrest . CoreMatchers . is ( 408 ) )"}
{"focal": "isConfigured ( ) { return isConfigured ; }", "testMethod": "shouldNotBeConfiguredIfNoInitializers ( ) { constraintChecker = datawave . ingest . mapreduce . job . ConstraintChecker . create ( new org . apache . hadoop . conf . Configuration ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( constraintChecker . isConfigured ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "shouldNotBeConfiguredIfNoInitializers ( ) { constraintChecker = datawave . ingest . mapreduce . job . ConstraintChecker . create ( new org . apache . hadoop . conf . Configuration ( ) ) ; \"<AssertPlaceHolder>\" ; } isConfigured ( ) { return isConfigured ; }", "answer": "org . junit . Assert . assertThat ( constraintChecker . isConfigured ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "allTables ( ) { return tables . values ( ) ; }", "testMethod": "emptySchema ( ) { com . google . cloud . teleport . spanner . AvroSchemaToDdlConverter converter = new com . google . cloud . teleport . spanner . AvroSchemaToDdlConverter ( ) ; com . google . cloud . teleport . spanner . ddl . Ddl ddl = converter . toDdl ( java . util . Collections . emptyList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ddl . allTables ( ) , org . hamcrest . Matchers . empty ( ) )", "total": "emptySchema ( ) { com . google . cloud . teleport . spanner . AvroSchemaToDdlConverter converter = new com . google . cloud . teleport . spanner . AvroSchemaToDdlConverter ( ) ; com . google . cloud . teleport . spanner . ddl . Ddl ddl = converter . toDdl ( java . util . Collections . emptyList ( ) ) ; \"<AssertPlaceHolder>\" ; } allTables ( ) { return tables . values ( ) ; }", "answer": "org . junit . Assert . assertThat ( ddl . allTables ( ) , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getMessage ( java . lang . Object , java . lang . Object [ ] , java . util . Locale ) { java . lang . String message = getFullyResolvedMessage ( object , args , locale , false ) ; if ( ( message == null ) && ( object != null ) ) { throw new org . springframework . springfaces . message . NoSuchObjectMessageException ( object , locale ) ; } return message ; }", "testMethod": "shouldGetMessageForEnum ( ) { java . lang . String actual = this . messageSource . getMessage ( org . springframework . springfaces . message . DefaultObjectMessageSourceTest . NumberEnum . ONE , null , org . springframework . springfaces . message . DefaultObjectMessageSourceTest . LOCALE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( \"1\" ) )", "total": "shouldGetMessageForEnum ( ) { java . lang . String actual = this . messageSource . getMessage ( org . springframework . springfaces . message . DefaultObjectMessageSourceTest . NumberEnum . ONE , null , org . springframework . springfaces . message . DefaultObjectMessageSourceTest . LOCALE ) ; \"<AssertPlaceHolder>\" ; } getMessage ( java . lang . Object , java . lang . Object [ ] , java . util . Locale ) { java . lang . String message = getFullyResolvedMessage ( object , args , locale , false ) ; if ( ( message == null ) && ( object != null ) ) { throw new org . springframework . springfaces . message . NoSuchObjectMessageException ( object , locale ) ; } return message ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( \"1\" ) )"}
{"focal": "equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "testMethod": "applyDelegates ( ) { @ org . apache . beam . runners . core . construction . SuppressWarnings ( \"unchecked\" ) org . apache . beam . sdk . values . PCollection < java . lang . Integer > collection = mock ( org . apache . beam . sdk . values . PCollection . class ) ; @ org . apache . beam . runners . core . construction . SuppressWarnings ( \"unchecked\" ) org . apache . beam . sdk . values . PCollection < java . lang . String > output = mock ( org . apache . beam . sdk . values . PCollection . class ) ; when ( delegate . expand ( collection ) ) . thenReturn ( output ) ; org . apache . beam . sdk . values . PCollection < java . lang . String > result = forwarding . expand ( collection ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( output ) )", "total": "applyDelegates ( ) { @ org . apache . beam . runners . core . construction . SuppressWarnings ( \"unchecked\" ) org . apache . beam . sdk . values . PCollection < java . lang . Integer > collection = mock ( org . apache . beam . sdk . values . PCollection . class ) ; @ org . apache . beam . runners . core . construction . SuppressWarnings ( \"unchecked\" ) org . apache . beam . sdk . values . PCollection < java . lang . String > output = mock ( org . apache . beam . sdk . values . PCollection . class ) ; when ( delegate . expand ( collection ) ) . thenReturn ( output ) ; org . apache . beam . sdk . values . PCollection < java . lang . String > result = forwarding . expand ( collection ) ; \"<AssertPlaceHolder>\" ; } equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( output ) )"}
{"focal": "getRequestAttribute ( java . lang . String ) { return getRequest ( ) . getHttpServletRequest ( ) . getAttribute ( name ) ; }", "testMethod": "shouldSetAttributeOnUnderlyingRequestWithSpecifiedNameAndValue ( ) { java . lang . String expectedAttributeName = \"foo\" ; java . lang . String expectedAttributeValue = \"fooAttrValue\" ; when ( mockHttpRequest . getAttribute ( anyString ( ) ) ) . thenReturn ( expectedAttributeValue ) ; ro . pippo . pac4j . PippoWebContext context = makePippoWebContext ( ) ; context . setRequestAttribute ( expectedAttributeName , expectedAttributeValue ) ; \"<AssertPlaceHolder>\" ; verify ( mockHttpRequest , times ( 1 ) ) . setAttribute ( expectedAttributeName , expectedAttributeValue ) ; verify ( mockHttpRequest , times ( 1 ) ) . getAttribute ( expectedAttributeName ) ; }", "assertLine": "org . junit . Assert . assertThat ( context . getRequestAttribute ( expectedAttributeName ) , org . hamcrest . core . Is . is ( expectedAttributeValue ) )", "total": "shouldSetAttributeOnUnderlyingRequestWithSpecifiedNameAndValue ( ) { java . lang . String expectedAttributeName = \"foo\" ; java . lang . String expectedAttributeValue = \"fooAttrValue\" ; when ( mockHttpRequest . getAttribute ( anyString ( ) ) ) . thenReturn ( expectedAttributeValue ) ; ro . pippo . pac4j . PippoWebContext context = makePippoWebContext ( ) ; context . setRequestAttribute ( expectedAttributeName , expectedAttributeValue ) ; \"<AssertPlaceHolder>\" ; verify ( mockHttpRequest , times ( 1 ) ) . setAttribute ( expectedAttributeName , expectedAttributeValue ) ; verify ( mockHttpRequest , times ( 1 ) ) . getAttribute ( expectedAttributeName ) ; } getRequestAttribute ( java . lang . String ) { return getRequest ( ) . getHttpServletRequest ( ) . getAttribute ( name ) ; }", "answer": "org . junit . Assert . assertThat ( context . getRequestAttribute ( expectedAttributeName ) , org . hamcrest . core . Is . is ( expectedAttributeValue ) )"}
{"focal": "next ( ) { try { java . lang . Object object = input . readObject ( ) ; next = type . cast ( object ) ; canGet = true ; return true ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . io . IOException ( e ) ; } catch ( java . io . EOFException e ) { next = null ; canGet = true ; return false ; } catch ( java . io . OptionalDataException e ) { if ( e . eof ) { next = null ; canGet = true ; return false ; } throw e ; } }", "testMethod": "unexpected_header ( ) { java . io . File file = folder . newFile ( \"testing.filelist\" ) ; try ( java . io . FileOutputStream output = new java . io . FileOutputStream ( file ) ) { output . write ( \"Hello,<sp>world!@A_INVALID_HEADER@\" . getBytes ( StandardCharsets . UTF_8 ) ) ; try ( com . asakusafw . windgate . hadoopfs . ssh . FileList . Writer writer = com . asakusafw . windgate . hadoopfs . ssh . FileList . createWriter ( output ) ) { write ( writer , \"example.txt\" , \"Hello,<sp>world!\" ) ; } } try ( java . io . FileInputStream input = new java . io . FileInputStream ( file ) ; com . asakusafw . windgate . hadoopfs . ssh . FileList . Reader reader = com . asakusafw . windgate . hadoopfs . ssh . FileList . createReader ( input ) ) { read ( reader , \"example.txt\" , \"Hello,<sp>world!\" ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( reader . next ( ) , is ( false ) )", "total": "unexpected_header ( ) { java . io . File file = folder . newFile ( \"testing.filelist\" ) ; try ( java . io . FileOutputStream output = new java . io . FileOutputStream ( file ) ) { output . write ( \"Hello,<sp>world!@A_INVALID_HEADER@\" . getBytes ( StandardCharsets . UTF_8 ) ) ; try ( com . asakusafw . windgate . hadoopfs . ssh . FileList . Writer writer = com . asakusafw . windgate . hadoopfs . ssh . FileList . createWriter ( output ) ) { write ( writer , \"example.txt\" , \"Hello,<sp>world!\" ) ; } } try ( java . io . FileInputStream input = new java . io . FileInputStream ( file ) ; com . asakusafw . windgate . hadoopfs . ssh . FileList . Reader reader = com . asakusafw . windgate . hadoopfs . ssh . FileList . createReader ( input ) ) { read ( reader , \"example.txt\" , \"Hello,<sp>world!\" ) ; \"<AssertPlaceHolder>\" ; } } next ( ) { try { java . lang . Object object = input . readObject ( ) ; next = type . cast ( object ) ; canGet = true ; return true ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . io . IOException ( e ) ; } catch ( java . io . EOFException e ) { next = null ; canGet = true ; return false ; } catch ( java . io . OptionalDataException e ) { if ( e . eof ) { next = null ; canGet = true ; return false ; } throw e ; } }", "answer": "org . junit . Assert . assertThat ( reader . next ( ) , is ( false ) )"}
{"focal": "size ( ) { return sizeInList ; }", "testMethod": "parallel ( ) { com . asakusafw . yaess . core . JobScheduler instance = create ( \"parallel.default\" , \"1\" , \"parallel.para\" , \"2\" ) ; java . util . concurrent . CyclicBarrier barrier = new java . util . concurrent . CyclicBarrier ( 3 ) ; java . util . List < com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock > jobs = new java . util . ArrayList ( ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a0\" ) { @ com . asakusafw . yaess . paralleljob . Override protected void hook ( ) throws com . asakusafw . yaess . paralleljob . InterruptedException , java . io . IOException { try { barrier . await ( ) ; } catch ( java . util . concurrent . BrokenBarrierException e ) { throw new java . io . IOException ( e ) ; } } } . resource ( \"para\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a2\" ) { @ com . asakusafw . yaess . paralleljob . Override protected void hook ( ) throws com . asakusafw . yaess . paralleljob . InterruptedException , java . io . IOException { try { barrier . await ( ) ; } catch ( java . util . concurrent . BrokenBarrierException e ) { throw new java . io . IOException ( e ) ; } } } . resource ( \"para\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a3\" ) { @ com . asakusafw . yaess . paralleljob . Override protected void hook ( ) throws com . asakusafw . yaess . paralleljob . InterruptedException , java . io . IOException { try { barrier . await ( ) ; } catch ( java . util . concurrent . BrokenBarrierException e ) { throw new java . io . IOException ( e ) ; } } } . resource ( \"otherwise\" ) ) ; instance . execute ( PhaseMonitor . NULL , com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . CONTEXT , jobs , JobScheduler . STRICT ) ; java . util . Set < java . lang . String > rest = collectRest ( jobs ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rest . size ( ) , is ( 0 ) )", "total": "parallel ( ) { com . asakusafw . yaess . core . JobScheduler instance = create ( \"parallel.default\" , \"1\" , \"parallel.para\" , \"2\" ) ; java . util . concurrent . CyclicBarrier barrier = new java . util . concurrent . CyclicBarrier ( 3 ) ; java . util . List < com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock > jobs = new java . util . ArrayList ( ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a0\" ) { @ com . asakusafw . yaess . paralleljob . Override protected void hook ( ) throws com . asakusafw . yaess . paralleljob . InterruptedException , java . io . IOException { try { barrier . await ( ) ; } catch ( java . util . concurrent . BrokenBarrierException e ) { throw new java . io . IOException ( e ) ; } } } . resource ( \"para\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a2\" ) { @ com . asakusafw . yaess . paralleljob . Override protected void hook ( ) throws com . asakusafw . yaess . paralleljob . InterruptedException , java . io . IOException { try { barrier . await ( ) ; } catch ( java . util . concurrent . BrokenBarrierException e ) { throw new java . io . IOException ( e ) ; } } } . resource ( \"para\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a3\" ) { @ com . asakusafw . yaess . paralleljob . Override protected void hook ( ) throws com . asakusafw . yaess . paralleljob . InterruptedException , java . io . IOException { try { barrier . await ( ) ; } catch ( java . util . concurrent . BrokenBarrierException e ) { throw new java . io . IOException ( e ) ; } } } . resource ( \"otherwise\" ) ) ; instance . execute ( PhaseMonitor . NULL , com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . CONTEXT , jobs , JobScheduler . STRICT ) ; java . util . Set < java . lang . String > rest = collectRest ( jobs ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return sizeInList ; }", "answer": "org . junit . Assert . assertThat ( rest . size ( ) , is ( 0 ) )"}
{"focal": "size ( ) { return size ; }", "testMethod": "hashZero ( ) { java . util . List < org . sonatype . nexus . common . hash . HashAlgorithm > zeroAlgorithms = com . google . common . collect . ImmutableList . of ( ) ; java . util . Map < org . sonatype . nexus . common . hash . HashAlgorithm , com . google . common . hash . HashCode > hashes = org . sonatype . nexus . common . hash . Hashes . hash ( zeroAlgorithms , org . sonatype . nexus . common . hash . HashesTest . inputStream ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( hashes . size ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "hashZero ( ) { java . util . List < org . sonatype . nexus . common . hash . HashAlgorithm > zeroAlgorithms = com . google . common . collect . ImmutableList . of ( ) ; java . util . Map < org . sonatype . nexus . common . hash . HashAlgorithm , com . google . common . hash . HashCode > hashes = org . sonatype . nexus . common . hash . Hashes . hash ( zeroAlgorithms , org . sonatype . nexus . common . hash . HashesTest . inputStream ( ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return size ; }", "answer": "org . junit . Assert . assertThat ( hashes . size ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "addToClassPool ( javassist . ClassPool ) { javassist . CtClass ctClass ; if ( this . superclass . isPresent ( ) ) { ctClass = classPool . makeClass ( this . name , this . superclass . get ( ) ) ; } else { ctClass = classPool . makeClass ( this . name ) ; } ctClass . setModifiers ( this . modifier ) ; for ( java . lang . String annotation : annotations ) { javassist . bytecode . ClassFile classFile = ctClass . getClassFile ( ) ; javassist . bytecode . ConstPool constPool = classFile . getConstPool ( ) ; javassist . bytecode . AnnotationsAttribute attr = new javassist . bytecode . AnnotationsAttribute ( constPool , javassist . bytecode . AnnotationsAttribute . visibleTag ) ; javassist . bytecode . annotation . Annotation annot = new javassist . bytecode . annotation . Annotation ( annotation , constPool ) ; attr . setAnnotation ( annot ) ; ctClass . getClassFile2 ( ) . addAttribute ( attr ) ; } for ( javassist . CtClass interfaceCtClass : interfaces ) { ctClass . addInterface ( interfaceCtClass ) ; } return ctClass ; }", "testMethod": "testTwoClassesTwoExcludeWithWildcardOneLetter ( ) { japicmp . cmp . JarArchiveComparatorOptions options = new japicmp . cmp . JarArchiveComparatorOptions ( ) ; options . getFilters ( ) . getExcludes ( ) . add ( new japicmp . filter . JavaDocLikeClassFilter ( \"japicmp.T*\" ) ) ; java . util . List < japicmp . model . JApiClass > jApiClasses = japicmp . cmp . ClassesHelper . compareClasses ( options , new japicmp . cmp . ClassesHelper . ClassesGenerator ( ) { @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createOldClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test1\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test2\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createNewClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test1\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test2\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( jApiClasses . size ( ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "testTwoClassesTwoExcludeWithWildcardOneLetter ( ) { japicmp . cmp . JarArchiveComparatorOptions options = new japicmp . cmp . JarArchiveComparatorOptions ( ) ; options . getFilters ( ) . getExcludes ( ) . add ( new japicmp . filter . JavaDocLikeClassFilter ( \"japicmp.T*\" ) ) ; java . util . List < japicmp . model . JApiClass > jApiClasses = japicmp . cmp . ClassesHelper . compareClasses ( options , new japicmp . cmp . ClassesHelper . ClassesGenerator ( ) { @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createOldClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test1\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test2\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createNewClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test1\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test2\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } } ) ; \"<AssertPlaceHolder>\" ; } addToClassPool ( javassist . ClassPool ) { javassist . CtClass ctClass ; if ( this . superclass . isPresent ( ) ) { ctClass = classPool . makeClass ( this . name , this . superclass . get ( ) ) ; } else { ctClass = classPool . makeClass ( this . name ) ; } ctClass . setModifiers ( this . modifier ) ; for ( java . lang . String annotation : annotations ) { javassist . bytecode . ClassFile classFile = ctClass . getClassFile ( ) ; javassist . bytecode . ConstPool constPool = classFile . getConstPool ( ) ; javassist . bytecode . AnnotationsAttribute attr = new javassist . bytecode . AnnotationsAttribute ( constPool , javassist . bytecode . AnnotationsAttribute . visibleTag ) ; javassist . bytecode . annotation . Annotation annot = new javassist . bytecode . annotation . Annotation ( annotation , constPool ) ; attr . setAnnotation ( annot ) ; ctClass . getClassFile2 ( ) . addAttribute ( attr ) ; } for ( javassist . CtClass interfaceCtClass : interfaces ) { ctClass . addInterface ( interfaceCtClass ) ; } return ctClass ; }", "answer": "org . junit . Assert . assertThat ( jApiClasses . size ( ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testIsErrorMetricSupported ( ) { reachability . setErrorMetricSupported ( true ) ; result1 = reachability . isErrorMetricSupported ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testIsErrorMetricSupported ( ) { reachability . setErrorMetricSupported ( true ) ; result1 = reachability . isErrorMetricSupported ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "validateZipFile ( java . lang . String ) { try ( java . util . jar . JarFile jarFile = new java . util . jar . JarFile ( filePath ) ) { java . util . jar . Manifest man = jarFile . getManifest ( ) ; if ( man == null ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( \"Zip<sp>validation<sp>failed,<sp>missing<sp>manifest<sp>file.\" ) ; } java . util . List < java . util . jar . JarEntry > entriesVec = new java . util . ArrayList ( ) ; byte [ ] buffer = new byte [ ZipDecompression . BUFFER_SIZE ] ; java . util . Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { java . util . jar . JarEntry je = ( ( java . util . jar . JarEntry ) ( entries . nextElement ( ) ) ) ; if ( je . isDirectory ( ) ) { continue ; } entriesVec . add ( je ) ; try ( java . io . InputStream is = jarFile . getInputStream ( je ) ) { while ( ( is . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { } is . close ( ) ; } catch ( java . io . IOException e ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed,<sp>unable<sp>to<sp>get<sp>input<sp>stream<sp>for<sp>entry<sp>%s\" , je . getName ( ) ) ) ; } } java . util . Iterator < java . util . jar . JarEntry > iter = entriesVec . iterator ( ) ; while ( iter . hasNext ( ) ) { java . util . jar . JarEntry je = iter . next ( ) ; java . security . cert . Certificate [ ] certs = je . getCertificates ( ) ; if ( ( certs == null ) || ( ( certs . length ) == 0 ) ) { if ( ! ( je . getName ( ) . startsWith ( \"META-INF\" ) ) ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed,<sp>unable<sp>to<sp>get<sp>certificates<sp>for<sp>entry<sp>%s\" , je . getName ( ) ) ) ; } } else { int startIndex = 0 ; java . security . cert . X509Certificate [ ] certChain ; while ( ( certChain = getAChain ( certs , startIndex ) ) != null ) { try { merlin . verifyTrust ( certChain [ 0 ] . getPublicKey ( ) ) ; } catch ( org . apache . wss4j . common . ext . WSSecurityException e1 ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed,<sp>untrusted<sp>certificates<sp>for<sp>entry<sp>%s\" , je . getName ( ) ) ) ; } startIndex += certChain . length ; } } } } catch ( java . io . IOException e ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed<sp>for<sp>file<sp>:<sp>%s\" , filePath ) ) ; } return true ; }", "testMethod": "testZipWithModifiedExistingFile ( ) { boolean result = zipValidator . validateZipFile ( org . codice . ddf . catalog . transformer . zip . ZipValidatorTest . MODIFIED_EXISTING_FILE_ZIP_PATH ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testZipWithModifiedExistingFile ( ) { boolean result = zipValidator . validateZipFile ( org . codice . ddf . catalog . transformer . zip . ZipValidatorTest . MODIFIED_EXISTING_FILE_ZIP_PATH ) ; \"<AssertPlaceHolder>\" ; } validateZipFile ( java . lang . String ) { try ( java . util . jar . JarFile jarFile = new java . util . jar . JarFile ( filePath ) ) { java . util . jar . Manifest man = jarFile . getManifest ( ) ; if ( man == null ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( \"Zip<sp>validation<sp>failed,<sp>missing<sp>manifest<sp>file.\" ) ; } java . util . List < java . util . jar . JarEntry > entriesVec = new java . util . ArrayList ( ) ; byte [ ] buffer = new byte [ ZipDecompression . BUFFER_SIZE ] ; java . util . Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { java . util . jar . JarEntry je = ( ( java . util . jar . JarEntry ) ( entries . nextElement ( ) ) ) ; if ( je . isDirectory ( ) ) { continue ; } entriesVec . add ( je ) ; try ( java . io . InputStream is = jarFile . getInputStream ( je ) ) { while ( ( is . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { } is . close ( ) ; } catch ( java . io . IOException e ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed,<sp>unable<sp>to<sp>get<sp>input<sp>stream<sp>for<sp>entry<sp>%s\" , je . getName ( ) ) ) ; } } java . util . Iterator < java . util . jar . JarEntry > iter = entriesVec . iterator ( ) ; while ( iter . hasNext ( ) ) { java . util . jar . JarEntry je = iter . next ( ) ; java . security . cert . Certificate [ ] certs = je . getCertificates ( ) ; if ( ( certs == null ) || ( ( certs . length ) == 0 ) ) { if ( ! ( je . getName ( ) . startsWith ( \"META-INF\" ) ) ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed,<sp>unable<sp>to<sp>get<sp>certificates<sp>for<sp>entry<sp>%s\" , je . getName ( ) ) ) ; } } else { int startIndex = 0 ; java . security . cert . X509Certificate [ ] certChain ; while ( ( certChain = getAChain ( certs , startIndex ) ) != null ) { try { merlin . verifyTrust ( certChain [ 0 ] . getPublicKey ( ) ) ; } catch ( org . apache . wss4j . common . ext . WSSecurityException e1 ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed,<sp>untrusted<sp>certificates<sp>for<sp>entry<sp>%s\" , je . getName ( ) ) ) ; } startIndex += certChain . length ; } } } } catch ( java . io . IOException e ) { throw new org . codice . ddf . catalog . transformer . zip . ZipValidationException ( java . lang . String . format ( \"Zip<sp>validation<sp>failed<sp>for<sp>file<sp>:<sp>%s\" , filePath ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "size ( ) { return ( this . list . size ( ) ) + 2 ; }", "testMethod": "data_should_be_removed_from_infinispan ( ) { org . infinispan . manager . EmbeddedCacheManager defaultEmbeddedInstance = com . lordofthejars . nosqlunit . infinispan . EmbeddedInfinispanInstancesFactory . getInstance ( ) . getDefaultEmbeddedInstance ( ) ; com . lordofthejars . nosqlunit . infinispan . InfinispanOperation infinispanOperation = new com . lordofthejars . nosqlunit . infinispan . InfinispanOperation ( defaultEmbeddedInstance . getCache ( ) ) ; infinispanOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . WhenEmbeddedInfinispanOperationsAreRequired . SIMPLE_DATA . getBytes ( ) ) ) ; infinispanOperation . deleteAll ( ) ; org . infinispan . commons . api . BasicCache < java . lang . String , java . lang . String > cache = infinispanOperation . connectionManager ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cache . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "data_should_be_removed_from_infinispan ( ) { org . infinispan . manager . EmbeddedCacheManager defaultEmbeddedInstance = com . lordofthejars . nosqlunit . infinispan . EmbeddedInfinispanInstancesFactory . getInstance ( ) . getDefaultEmbeddedInstance ( ) ; com . lordofthejars . nosqlunit . infinispan . InfinispanOperation infinispanOperation = new com . lordofthejars . nosqlunit . infinispan . InfinispanOperation ( defaultEmbeddedInstance . getCache ( ) ) ; infinispanOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . WhenEmbeddedInfinispanOperationsAreRequired . SIMPLE_DATA . getBytes ( ) ) ) ; infinispanOperation . deleteAll ( ) ; org . infinispan . commons . api . BasicCache < java . lang . String , java . lang . String > cache = infinispanOperation . connectionManager ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return ( this . list . size ( ) ) + 2 ; }", "answer": "org . junit . Assert . assertThat ( cache . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "buildQuery ( java . lang . String , org . springframework . data . repository . query . Parameters , java . lang . Object [ ] ) { java . lang . String replacedRawQuery = rawQuery ; for ( java . util . Iterator < org . springframework . data . repository . query . Parameter > iterator = parameters . iterator ( ) ; iterator . hasNext ( ) ; ) { org . springframework . data . repository . query . Parameter eachParameter = iterator . next ( ) ; if ( ( org . springframework . data . domain . Pageable . class . isAssignableFrom ( eachParameter . getType ( ) ) ) || ( org . springframework . data . domain . Sort . class . isAssignableFrom ( eachParameter . getType ( ) ) ) ) { continue ; } replacedRawQuery = org . springframework . data . simpledb . query . QueryUtils . replaceOneParameterInQuery ( replacedRawQuery , eachParameter , parameterValues [ eachParameter . getIndex ( ) ] ) ; } return replacedRawQuery . trim ( ) ; }", "testMethod": "buildQueryConditionsWithParameters_should_work_with_WHERE_clause ( ) { final java . lang . String expectedQuery = \"select<sp>*<sp>from<sp>spring_data<sp>where<sp>type<sp>=<sp>'spring-type'\" ; final java . lang . String rawQuery = \"select<sp>*<sp>from<sp>spring_data<sp>where<sp>type<sp>=<sp>:type\" ; final org . springframework . data . repository . query . Parameters parameters = getMockParameters ( new java . lang . String [ ] { \":type\" } , new java . lang . Class [ ] { java . lang . String . class } ) ; java . lang . String resultedQuery = org . springframework . data . simpledb . query . QueryUtils . buildQuery ( rawQuery , parameters , \"spring-type\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultedQuery , org . hamcrest . CoreMatchers . is ( expectedQuery ) )", "total": "buildQueryConditionsWithParameters_should_work_with_WHERE_clause ( ) { final java . lang . String expectedQuery = \"select<sp>*<sp>from<sp>spring_data<sp>where<sp>type<sp>=<sp>'spring-type'\" ; final java . lang . String rawQuery = \"select<sp>*<sp>from<sp>spring_data<sp>where<sp>type<sp>=<sp>:type\" ; final org . springframework . data . repository . query . Parameters parameters = getMockParameters ( new java . lang . String [ ] { \":type\" } , new java . lang . Class [ ] { java . lang . String . class } ) ; java . lang . String resultedQuery = org . springframework . data . simpledb . query . QueryUtils . buildQuery ( rawQuery , parameters , \"spring-type\" ) ; \"<AssertPlaceHolder>\" ; } buildQuery ( java . lang . String , org . springframework . data . repository . query . Parameters , java . lang . Object [ ] ) { java . lang . String replacedRawQuery = rawQuery ; for ( java . util . Iterator < org . springframework . data . repository . query . Parameter > iterator = parameters . iterator ( ) ; iterator . hasNext ( ) ; ) { org . springframework . data . repository . query . Parameter eachParameter = iterator . next ( ) ; if ( ( org . springframework . data . domain . Pageable . class . isAssignableFrom ( eachParameter . getType ( ) ) ) || ( org . springframework . data . domain . Sort . class . isAssignableFrom ( eachParameter . getType ( ) ) ) ) { continue ; } replacedRawQuery = org . springframework . data . simpledb . query . QueryUtils . replaceOneParameterInQuery ( replacedRawQuery , eachParameter , parameterValues [ eachParameter . getIndex ( ) ] ) ; } return replacedRawQuery . trim ( ) ; }", "answer": "org . junit . Assert . assertThat ( resultedQuery , org . hamcrest . CoreMatchers . is ( expectedQuery ) )"}
{"focal": "getCause ( ) { return ( super . getCause ( ) ) == null ? fCause : super . getCause ( ) ; }", "testMethod": "canSetCauseWithInstanceCreatedWithExplicitThrowableConstructor ( ) { java . lang . Throwable cause = new java . lang . Exception ( ) ; org . junit . AssumptionViolatedException e = new org . junit . AssumptionViolatedException ( \"invalid<sp>number\" , cause ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( e . getCause ( ) , org . hamcrest . CoreMatchers . is ( cause ) )", "total": "canSetCauseWithInstanceCreatedWithExplicitThrowableConstructor ( ) { java . lang . Throwable cause = new java . lang . Exception ( ) ; org . junit . AssumptionViolatedException e = new org . junit . AssumptionViolatedException ( \"invalid<sp>number\" , cause ) ; \"<AssertPlaceHolder>\" ; } getCause ( ) { return ( super . getCause ( ) ) == null ? fCause : super . getCause ( ) ; }", "answer": "org . junit . Assert . assertThat ( e . getCause ( ) , org . hamcrest . CoreMatchers . is ( cause ) )"}
{"focal": "getImplementation ( ) { return implementation ; }", "testMethod": "implementation_setToAxon ( ) { eventBusService . init ( com . google . common . collect . ImmutableMap . of ( EventBusServiceDefault . KEY_EVENT_BUS_IMPLEMENTATION , \"axon\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( eventBusService . getImplementation ( ) , org . hamcrest . Matchers . is ( \"axon\" ) )", "total": "implementation_setToAxon ( ) { eventBusService . init ( com . google . common . collect . ImmutableMap . of ( EventBusServiceDefault . KEY_EVENT_BUS_IMPLEMENTATION , \"axon\" ) ) ; \"<AssertPlaceHolder>\" ; } getImplementation ( ) { return implementation ; }", "answer": "org . junit . Assert . assertThat ( eventBusService . getImplementation ( ) , org . hamcrest . Matchers . is ( \"axon\" ) )"}
{"focal": "matchMaterial ( java . lang . String ) { org . apache . commons . lang . Validate . notNull ( name , \"Name<sp>cannot<sp>be<sp>null\" ) ; org . bukkit . Material result = null ; try { result = org . bukkit . Material . getMaterial ( java . lang . Integer . parseInt ( name ) ) ; } catch ( java . lang . NumberFormatException ex ) { } if ( result == null ) { java . lang . String filtered = name . toUpperCase ( ) ; filtered = filtered . replaceAll ( \"\\\\s+\" , \"_\" ) . replaceAll ( \"\\\\W\" , \"\" ) ; result = org . bukkit . Material . BY_NAME . get ( filtered ) ; } return result ; }", "testMethod": "matchMaterialByLowerCaseAndSpaces ( ) { for ( org . bukkit . Material material : org . bukkit . Material . values ( ) ) { java . lang . String name = material . toString ( ) . replaceAll ( \"_\" , \"<sp>\" ) . toLowerCase ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( org . bukkit . Material . matchMaterial ( name ) , is ( material ) )", "total": "matchMaterialByLowerCaseAndSpaces ( ) { for ( org . bukkit . Material material : org . bukkit . Material . values ( ) ) { java . lang . String name = material . toString ( ) . replaceAll ( \"_\" , \"<sp>\" ) . toLowerCase ( ) ; \"<AssertPlaceHolder>\" ; } } matchMaterial ( java . lang . String ) { org . apache . commons . lang . Validate . notNull ( name , \"Name<sp>cannot<sp>be<sp>null\" ) ; org . bukkit . Material result = null ; try { result = org . bukkit . Material . getMaterial ( java . lang . Integer . parseInt ( name ) ) ; } catch ( java . lang . NumberFormatException ex ) { } if ( result == null ) { java . lang . String filtered = name . toUpperCase ( ) ; filtered = filtered . replaceAll ( \"\\\\s+\" , \"_\" ) . replaceAll ( \"\\\\W\" , \"\" ) ; result = org . bukkit . Material . BY_NAME . get ( filtered ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( org . bukkit . Material . matchMaterial ( name ) , is ( material ) )"}
{"focal": "hasLabel ( java . lang . String ) { return org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasLabel ( org . hamcrest . Matchers . is ( label ) ) ; }", "testMethod": "testItemProperties ( ) { final org . joda . time . Instant value = org . joda . time . Instant . now ( ) ; org . apache . beam . sdk . transforms . display . DisplayData data = org . apache . beam . sdk . transforms . display . DisplayData . from ( new org . apache . beam . sdk . transforms . display . HasDisplayData ( ) { @ org . apache . beam . sdk . transforms . display . Override public void populateDisplayData ( org . apache . beam . sdk . transforms . display . DisplayData . Builder builder ) { builder . add ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"now\" , value ) . withLabel ( \"the<sp>current<sp>instant\" ) . withLinkUrl ( \"http://time.gov\" ) . withNamespace ( org . apache . beam . sdk . transforms . display . DisplayDataTest . class ) ) ; } } ) ; @ org . apache . beam . sdk . transforms . display . SuppressWarnings ( \"unchecked\" ) org . apache . beam . sdk . transforms . display . DisplayData . Item item = ( ( org . apache . beam . sdk . transforms . display . DisplayData . Item ) ( data . items ( ) . toArray ( ) [ 0 ] ) ) ; @ org . apache . beam . sdk . transforms . display . SuppressWarnings ( \"unchecked\" ) org . hamcrest . Matcher < org . apache . beam . sdk . transforms . display . DisplayData . Item > matchesAllOf = org . hamcrest . Matchers . allOf ( org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasNamespace ( org . apache . beam . sdk . transforms . display . DisplayDataTest . class ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasKey ( \"now\" ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasType ( DisplayData . Type . TIMESTAMP ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasValue ( org . apache . beam . sdk . transforms . display . DisplayDataTest . ISO_FORMATTER . print ( value ) ) , org . apache . beam . sdk . transforms . display . DisplayDataTest . hasShortValue ( org . hamcrest . Matchers . nullValue ( java . lang . String . class ) ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasLabel ( \"the<sp>current<sp>instant\" ) , org . apache . beam . sdk . transforms . display . DisplayDataTest . hasUrl ( org . hamcrest . Matchers . is ( \"http://time.gov\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( item , matchesAllOf )", "total": "testItemProperties ( ) { final org . joda . time . Instant value = org . joda . time . Instant . now ( ) ; org . apache . beam . sdk . transforms . display . DisplayData data = org . apache . beam . sdk . transforms . display . DisplayData . from ( new org . apache . beam . sdk . transforms . display . HasDisplayData ( ) { @ org . apache . beam . sdk . transforms . display . Override public void populateDisplayData ( org . apache . beam . sdk . transforms . display . DisplayData . Builder builder ) { builder . add ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"now\" , value ) . withLabel ( \"the<sp>current<sp>instant\" ) . withLinkUrl ( \"http://time.gov\" ) . withNamespace ( org . apache . beam . sdk . transforms . display . DisplayDataTest . class ) ) ; } } ) ; @ org . apache . beam . sdk . transforms . display . SuppressWarnings ( \"unchecked\" ) org . apache . beam . sdk . transforms . display . DisplayData . Item item = ( ( org . apache . beam . sdk . transforms . display . DisplayData . Item ) ( data . items ( ) . toArray ( ) [ 0 ] ) ) ; @ org . apache . beam . sdk . transforms . display . SuppressWarnings ( \"unchecked\" ) org . hamcrest . Matcher < org . apache . beam . sdk . transforms . display . DisplayData . Item > matchesAllOf = org . hamcrest . Matchers . allOf ( org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasNamespace ( org . apache . beam . sdk . transforms . display . DisplayDataTest . class ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasKey ( \"now\" ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasType ( DisplayData . Type . TIMESTAMP ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasValue ( org . apache . beam . sdk . transforms . display . DisplayDataTest . ISO_FORMATTER . print ( value ) ) , org . apache . beam . sdk . transforms . display . DisplayDataTest . hasShortValue ( org . hamcrest . Matchers . nullValue ( java . lang . String . class ) ) , org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasLabel ( \"the<sp>current<sp>instant\" ) , org . apache . beam . sdk . transforms . display . DisplayDataTest . hasUrl ( org . hamcrest . Matchers . is ( \"http://time.gov\" ) ) ) ; \"<AssertPlaceHolder>\" ; } hasLabel ( java . lang . String ) { return org . apache . beam . sdk . transforms . display . DisplayDataMatchers . hasLabel ( org . hamcrest . Matchers . is ( label ) ) ; }", "answer": "org . junit . Assert . assertThat ( item , matchesAllOf )"}
{"focal": "size ( ) { return classMappings . size ( ) ; }", "testMethod": "viaInterface ( ) { container . register ( java . util . HashSet . class ) ; container . register ( java . util . ArrayList . class ) ; java . util . Collection < java . util . Collection > beans = container . getBeans ( java . util . Collection . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( beans . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 2 ) )", "total": "viaInterface ( ) { container . register ( java . util . HashSet . class ) ; container . register ( java . util . ArrayList . class ) ; java . util . Collection < java . util . Collection > beans = container . getBeans ( java . util . Collection . class ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return classMappings . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( beans . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 2 ) )"}
{"focal": "getBody ( ) { return java . util . Arrays . copyOf ( this . body , this . body . length ) ; }", "testMethod": "constructorInitializesEmptyArrayBody ( ) { com . microsoft . azure . sdk . iot . device . transport . https . HttpsBatchMessage batchMsg = new com . microsoft . azure . sdk . iot . device . transport . https . HttpsBatchMessage ( ) ; java . lang . String testBatchBody = new java . lang . String ( batchMsg . getBody ( ) , tests . unit . com . microsoft . azure . sdk . iot . device . transport . https . HttpsBatchMessageTest . UTF8 ) ; final java . lang . String expectedBatchBody = \"[]\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testBatchBody , org . hamcrest . CoreMatchers . is ( expectedBatchBody ) )", "total": "constructorInitializesEmptyArrayBody ( ) { com . microsoft . azure . sdk . iot . device . transport . https . HttpsBatchMessage batchMsg = new com . microsoft . azure . sdk . iot . device . transport . https . HttpsBatchMessage ( ) ; java . lang . String testBatchBody = new java . lang . String ( batchMsg . getBody ( ) , tests . unit . com . microsoft . azure . sdk . iot . device . transport . https . HttpsBatchMessageTest . UTF8 ) ; final java . lang . String expectedBatchBody = \"[]\" ; \"<AssertPlaceHolder>\" ; } getBody ( ) { return java . util . Arrays . copyOf ( this . body , this . body . length ) ; }", "answer": "org . junit . Assert . assertThat ( testBatchBody , org . hamcrest . CoreMatchers . is ( expectedBatchBody ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testHoldingTime ( ) { defaultIsisInterface . setHoldingTime ( 10 ) ; resultInt = defaultIsisInterface . holdingTime ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultInt , org . hamcrest . CoreMatchers . is ( 10 ) )", "total": "testHoldingTime ( ) { defaultIsisInterface . setHoldingTime ( 10 ) ; resultInt = defaultIsisInterface . holdingTime ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( resultInt , org . hamcrest . CoreMatchers . is ( 10 ) )"}
{"focal": "is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "testMethod": "shouldHaveCorrectNumberOfMiddlewares ( ) { when ( route . withMiddleware ( any ( com . spotify . apollo . route . Middleware . class ) ) ) . thenReturn ( route ) ; final java . util . List < com . spotify . apollo . route . Route < com . spotify . apollo . route . AsyncHandler < com . spotify . apollo . Response < okio . ByteString > > > > originalRoutes = java . util . List . of ( route ) ; final java . util . List < com . spotify . apollo . route . Route < com . spotify . apollo . route . AsyncHandler < com . spotify . apollo . Response < okio . ByteString > > > > routes = com . spotify . styx . api . Api . withCommonMiddleware ( originalRoutes . stream ( ) , requestAuthenticator , \"test\" ) . collect ( toList ( ) ) ; verify ( route , times ( 5 ) ) . withMiddleware ( any ( com . spotify . apollo . route . Middleware . class ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( routes , org . hamcrest . Matchers . is ( originalRoutes ) )", "total": "shouldHaveCorrectNumberOfMiddlewares ( ) { when ( route . withMiddleware ( any ( com . spotify . apollo . route . Middleware . class ) ) ) . thenReturn ( route ) ; final java . util . List < com . spotify . apollo . route . Route < com . spotify . apollo . route . AsyncHandler < com . spotify . apollo . Response < okio . ByteString > > > > originalRoutes = java . util . List . of ( route ) ; final java . util . List < com . spotify . apollo . route . Route < com . spotify . apollo . route . AsyncHandler < com . spotify . apollo . Response < okio . ByteString > > > > routes = com . spotify . styx . api . Api . withCommonMiddleware ( originalRoutes . stream ( ) , requestAuthenticator , \"test\" ) . collect ( toList ( ) ) ; verify ( route , times ( 5 ) ) . withMiddleware ( any ( com . spotify . apollo . route . Middleware . class ) ) ; \"<AssertPlaceHolder>\" ; } is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( routes , org . hamcrest . Matchers . is ( originalRoutes ) )"}
{"focal": "informational ( ) { return new org . hamcrest . CustomMatcher < javax . ws . rs . core . Response > ( \"1xx<sp>(informational)<sp>family<sp>of<sp>responses\" ) { @ com . airhacks . rulz . jaxrsclient . Override public boolean matches ( java . lang . Object o ) { return ( o instanceof javax . ws . rs . core . Response ) && ( ( ( ( javax . ws . rs . core . Response ) ( o ) ) . getStatusInfo ( ) . getFamily ( ) ) == ( Response . Status . Family . INFORMATIONAL ) ) ; } @ com . airhacks . rulz . jaxrsclient . Override public void describeMismatch ( java . lang . Object item , org . hamcrest . Description description ) { javax . ws . rs . core . Response response = ( ( javax . ws . rs . core . Response ) ( item ) ) ; com . airhacks . rulz . jaxrsclient . HttpMatchers . provideDescription ( response , description ) ; } } ; }", "testMethod": "informationalMessage ( ) { expected . expect ( com . airhacks . rulz . jaxrsclient . AssertionError . class ) ; expected . expectMessage ( org . hamcrest . CoreMatchers . containsString ( \"Internal<sp>Server<sp>Error<sp>500<sp>returned\" ) ) ; expected . expectMessage ( org . hamcrest . CoreMatchers . containsString ( \"1xx<sp>(informational)<sp>family<sp>of<sp>responses\" ) ) ; javax . ws . rs . core . Response response = this . tut . request ( ) . header ( \"status\" , 500 ) . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response , org . hamcrest . CoreMatchers . is ( com . airhacks . rulz . jaxrsclient . HttpMatchers . informational ( ) ) )", "total": "informationalMessage ( ) { expected . expect ( com . airhacks . rulz . jaxrsclient . AssertionError . class ) ; expected . expectMessage ( org . hamcrest . CoreMatchers . containsString ( \"Internal<sp>Server<sp>Error<sp>500<sp>returned\" ) ) ; expected . expectMessage ( org . hamcrest . CoreMatchers . containsString ( \"1xx<sp>(informational)<sp>family<sp>of<sp>responses\" ) ) ; javax . ws . rs . core . Response response = this . tut . request ( ) . header ( \"status\" , 500 ) . get ( ) ; \"<AssertPlaceHolder>\" ; } informational ( ) { return new org . hamcrest . CustomMatcher < javax . ws . rs . core . Response > ( \"1xx<sp>(informational)<sp>family<sp>of<sp>responses\" ) { @ com . airhacks . rulz . jaxrsclient . Override public boolean matches ( java . lang . Object o ) { return ( o instanceof javax . ws . rs . core . Response ) && ( ( ( ( javax . ws . rs . core . Response ) ( o ) ) . getStatusInfo ( ) . getFamily ( ) ) == ( Response . Status . Family . INFORMATIONAL ) ) ; } @ com . airhacks . rulz . jaxrsclient . Override public void describeMismatch ( java . lang . Object item , org . hamcrest . Description description ) { javax . ws . rs . core . Response response = ( ( javax . ws . rs . core . Response ) ( item ) ) ; com . airhacks . rulz . jaxrsclient . HttpMatchers . provideDescription ( response , description ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( response , org . hamcrest . CoreMatchers . is ( com . airhacks . rulz . jaxrsclient . HttpMatchers . informational ( ) ) )"}
{"focal": "getRootPackages ( ) { return roots ; }", "testMethod": "givenKnownPackageNameIsUsedWithPackageManager_WhenPackageIsBuiltAndRootPackagesAreRequested_ThenRootPackagesAreReturned ( ) { java . util . List < org . adoptopenjdk . jitwatch . model . MetaPackage > expectedRootPackages = java . util . Arrays . asList ( new org . adoptopenjdk . jitwatch . model . MetaPackage ( \"com\" ) ) ; org . adoptopenjdk . jitwatch . model . PackageManager packageManager = new org . adoptopenjdk . jitwatch . model . PackageManager ( ) ; packageManager . buildPackage ( \"com.sun.java\" ) ; java . util . List < org . adoptopenjdk . jitwatch . model . MetaPackage > actualRootPackages = packageManager . getRootPackages ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualRootPackages , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expectedRootPackages ) ) )", "total": "givenKnownPackageNameIsUsedWithPackageManager_WhenPackageIsBuiltAndRootPackagesAreRequested_ThenRootPackagesAreReturned ( ) { java . util . List < org . adoptopenjdk . jitwatch . model . MetaPackage > expectedRootPackages = java . util . Arrays . asList ( new org . adoptopenjdk . jitwatch . model . MetaPackage ( \"com\" ) ) ; org . adoptopenjdk . jitwatch . model . PackageManager packageManager = new org . adoptopenjdk . jitwatch . model . PackageManager ( ) ; packageManager . buildPackage ( \"com.sun.java\" ) ; java . util . List < org . adoptopenjdk . jitwatch . model . MetaPackage > actualRootPackages = packageManager . getRootPackages ( ) ; \"<AssertPlaceHolder>\" ; } getRootPackages ( ) { return roots ; }", "answer": "org . junit . Assert . assertThat ( actualRootPackages , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expectedRootPackages ) ) )"}
{"focal": "orElse ( boolean ) { return isPresent ? value : other ; }", "testMethod": "testCustomTerminal ( ) { java . lang . Long result = com . annimon . stream . OptionalLong . empty ( ) . custom ( new com . annimon . stream . function . Function < com . annimon . stream . OptionalLong , java . lang . Long > ( ) { @ com . annimon . stream . Override public com . annimon . stream . Long apply ( com . annimon . stream . OptionalLong optional ) { return optional . orElse ( 0L ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( 0L ) )", "total": "testCustomTerminal ( ) { java . lang . Long result = com . annimon . stream . OptionalLong . empty ( ) . custom ( new com . annimon . stream . function . Function < com . annimon . stream . OptionalLong , java . lang . Long > ( ) { @ com . annimon . stream . Override public com . annimon . stream . Long apply ( com . annimon . stream . OptionalLong optional ) { return optional . orElse ( 0L ) ; } } ) ; \"<AssertPlaceHolder>\" ; } orElse ( boolean ) { return isPresent ? value : other ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( 0L ) )"}
{"focal": "of ( int ) { return org . batfish . datamodel . IntegerSpace . builder ( ) . including ( com . google . common . collect . Range . singleton ( value ) ) . build ( ) ; }", "testMethod": "testNoReverseFlow ( ) { org . batfish . datamodel . flow . Trace forwardTrace = new org . batfish . datamodel . flow . Trace ( NO_ROUTE , com . google . common . collect . ImmutableList . of ( ) ) ; org . batfish . datamodel . flow . TraceAndReverseFlow traceAndReverseFlow = new org . batfish . datamodel . flow . TraceAndReverseFlow ( forwardTrace , null ) ; org . batfish . common . plugin . TracerouteEngine tracerouteEngine = org . batfish . question . traceroute . MockTracerouteEngine . forFlow ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , com . google . common . collect . ImmutableList . of ( traceAndReverseFlow ) ) ; java . util . List < org . batfish . datamodel . flow . BidirectionalTrace > bidirectionalTraces = org . batfish . question . traceroute . BidirectionalTracerouteAnswerer . computeBidirectionalTraces ( com . google . common . collect . ImmutableSet . of ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW ) , tracerouteEngine , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( bidirectionalTraces , org . hamcrest . Matchers . contains ( new org . batfish . datamodel . flow . BidirectionalTrace ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , forwardTrace , com . google . common . collect . ImmutableSet . of ( ) , null , null ) ) )", "total": "testNoReverseFlow ( ) { org . batfish . datamodel . flow . Trace forwardTrace = new org . batfish . datamodel . flow . Trace ( NO_ROUTE , com . google . common . collect . ImmutableList . of ( ) ) ; org . batfish . datamodel . flow . TraceAndReverseFlow traceAndReverseFlow = new org . batfish . datamodel . flow . TraceAndReverseFlow ( forwardTrace , null ) ; org . batfish . common . plugin . TracerouteEngine tracerouteEngine = org . batfish . question . traceroute . MockTracerouteEngine . forFlow ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , com . google . common . collect . ImmutableList . of ( traceAndReverseFlow ) ) ; java . util . List < org . batfish . datamodel . flow . BidirectionalTrace > bidirectionalTraces = org . batfish . question . traceroute . BidirectionalTracerouteAnswerer . computeBidirectionalTraces ( com . google . common . collect . ImmutableSet . of ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW ) , tracerouteEngine , false ) ; \"<AssertPlaceHolder>\" ; } of ( int ) { return org . batfish . datamodel . IntegerSpace . builder ( ) . including ( com . google . common . collect . Range . singleton ( value ) ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( bidirectionalTraces , org . hamcrest . Matchers . contains ( new org . batfish . datamodel . flow . BidirectionalTrace ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , forwardTrace , com . google . common . collect . ImmutableSet . of ( ) , null , null ) ) )"}
{"focal": "isCompletePathMatch ( ) { return ( ( path ) != null ) && ( ( seed ) == null ) ; }", "testMethod": "findsCompleteMatch ( ) { org . springframework . ide . eclipse . data . jdt . core . QueryMethodCandidate candidate = new org . springframework . ide . eclipse . data . jdt . core . QueryMethodCandidate ( \"findByFirstname\" , org . springframework . ide . eclipse . data . jdt . core . QueryMethodCandidateUnitTests . User . class ) ; org . springframework . ide . eclipse . data . jdt . core . QueryMethodPart part = candidate . getPartAtPosition ( 6 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( part . isCompletePathMatch ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "findsCompleteMatch ( ) { org . springframework . ide . eclipse . data . jdt . core . QueryMethodCandidate candidate = new org . springframework . ide . eclipse . data . jdt . core . QueryMethodCandidate ( \"findByFirstname\" , org . springframework . ide . eclipse . data . jdt . core . QueryMethodCandidateUnitTests . User . class ) ; org . springframework . ide . eclipse . data . jdt . core . QueryMethodPart part = candidate . getPartAtPosition ( 6 ) ; \"<AssertPlaceHolder>\" ; } isCompletePathMatch ( ) { return ( ( path ) != null ) && ( ( seed ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( part . isCompletePathMatch ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "hasTree ( java . lang . String ) { return org . apache . calcite . test . Matchers . compose ( org . hamcrest . core . Is . is ( value ) , ( input ) -> { return org . apache . calcite . util . Util . toLinux ( org . apache . calcite . plan . RelOptUtil . toString ( input ) ) ; } ) ; }", "testMethod": "testAggregate2 ( ) { final org . apache . calcite . tools . RelBuilder builder = org . apache . calcite . tools . RelBuilder . create ( org . apache . calcite . test . RelBuilderTest . config ( ) . build ( ) ) ; org . apache . calcite . rel . RelNode root = builder . scan ( \"EMP\" ) . aggregate ( builder . groupKey ( builder . field ( 1 ) , builder . call ( SqlStdOperatorTable . PLUS , builder . field ( 4 ) , builder . field ( 3 ) ) , builder . field ( 1 ) ) , builder . countStar ( \"C\" ) , builder . sum ( builder . call ( SqlStdOperatorTable . PLUS , builder . field ( 3 ) , builder . literal ( 1 ) ) ) . as ( \"S\" ) ) . build ( ) ; final java . lang . String expected = \"\" + ( ( \"LogicalAggregate(group=[{1,<sp>8}],<sp>C=[COUNT()],<sp>S=[SUM($9)])\\n\" + \"<sp>LogicalProject(EMPNO=[$0],<sp>ENAME=[$1],<sp>JOB=[$2],<sp>MGR=[$3],<sp>HIREDATE=[$4],<sp>SAL=[$5],<sp>COMM=[$6],<sp>DEPTNO=[$7],<sp>$f8=[+($4,<sp>$3)],<sp>$f9=[+($3,<sp>1)])\\n\" ) + \"<sp>LogicalTableScan(table=[[scott,<sp>EMP]])\\n\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( root , org . apache . calcite . test . Matchers . hasTree ( expected ) )", "total": "testAggregate2 ( ) { final org . apache . calcite . tools . RelBuilder builder = org . apache . calcite . tools . RelBuilder . create ( org . apache . calcite . test . RelBuilderTest . config ( ) . build ( ) ) ; org . apache . calcite . rel . RelNode root = builder . scan ( \"EMP\" ) . aggregate ( builder . groupKey ( builder . field ( 1 ) , builder . call ( SqlStdOperatorTable . PLUS , builder . field ( 4 ) , builder . field ( 3 ) ) , builder . field ( 1 ) ) , builder . countStar ( \"C\" ) , builder . sum ( builder . call ( SqlStdOperatorTable . PLUS , builder . field ( 3 ) , builder . literal ( 1 ) ) ) . as ( \"S\" ) ) . build ( ) ; final java . lang . String expected = \"\" + ( ( \"LogicalAggregate(group=[{1,<sp>8}],<sp>C=[COUNT()],<sp>S=[SUM($9)])\\n\" + \"<sp>LogicalProject(EMPNO=[$0],<sp>ENAME=[$1],<sp>JOB=[$2],<sp>MGR=[$3],<sp>HIREDATE=[$4],<sp>SAL=[$5],<sp>COMM=[$6],<sp>DEPTNO=[$7],<sp>$f8=[+($4,<sp>$3)],<sp>$f9=[+($3,<sp>1)])\\n\" ) + \"<sp>LogicalTableScan(table=[[scott,<sp>EMP]])\\n\" ) ; \"<AssertPlaceHolder>\" ; } hasTree ( java . lang . String ) { return org . apache . calcite . test . Matchers . compose ( org . hamcrest . core . Is . is ( value ) , ( input ) -> { return org . apache . calcite . util . Util . toLinux ( org . apache . calcite . plan . RelOptUtil . toString ( input ) ) ; } ) ; }", "answer": "org . junit . Assert . assertThat ( root , org . apache . calcite . test . Matchers . hasTree ( expected ) )"}
{"focal": "getStackLevel ( ) { return stackLevel ; }", "testMethod": "setStackLevel_zeroInteger_stackLevelIsSet ( ) { int zero = 0 ; chargingProfile . setStackLevel ( zero ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chargingProfile . getStackLevel ( ) , org . hamcrest . CoreMatchers . equalTo ( zero ) )", "total": "setStackLevel_zeroInteger_stackLevelIsSet ( ) { int zero = 0 ; chargingProfile . setStackLevel ( zero ) ; \"<AssertPlaceHolder>\" ; } getStackLevel ( ) { return stackLevel ; }", "answer": "org . junit . Assert . assertThat ( chargingProfile . getStackLevel ( ) , org . hamcrest . CoreMatchers . equalTo ( zero ) )"}
{"focal": "next ( ) { return enumeration . nextElement ( ) ; }", "testMethod": "testRemoteExecuteMaxRow ( ) { try ( java . sql . Connection remoteConnection = org . apache . calcite . jdbc . CalciteRemoteDriverTest . getRemoteConnection ( ) ) { java . sql . Statement statement = remoteConnection . createStatement ( ) ; statement . setMaxRows ( 2 ) ; java . sql . ResultSet resultSet = statement . executeQuery ( \"select<sp>*<sp>from<sp>\\\"hr\\\".\\\"emps\\\"\" ) ; int count = 0 ; while ( resultSet . next ( ) ) { ++ count ; } \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( count , org . hamcrest . CoreMatchers . equalTo ( 2 ) )", "total": "testRemoteExecuteMaxRow ( ) { try ( java . sql . Connection remoteConnection = org . apache . calcite . jdbc . CalciteRemoteDriverTest . getRemoteConnection ( ) ) { java . sql . Statement statement = remoteConnection . createStatement ( ) ; statement . setMaxRows ( 2 ) ; java . sql . ResultSet resultSet = statement . executeQuery ( \"select<sp>*<sp>from<sp>\\\"hr\\\".\\\"emps\\\"\" ) ; int count = 0 ; while ( resultSet . next ( ) ) { ++ count ; } \"<AssertPlaceHolder>\" ; } } next ( ) { return enumeration . nextElement ( ) ; }", "answer": "org . junit . Assert . assertThat ( count , org . hamcrest . CoreMatchers . equalTo ( 2 ) )"}
{"focal": "getStatistics ( org . synyx . urlaubsverwaltung . web . FilterPeriod ) { java . util . List < org . synyx . urlaubsverwaltung . person . Person > persons = getRelevantPersons ( ) ; return persons . stream ( ) . map ( ( person ) -> applicationForLeaveStatisticsBuilder . build ( person , period . getStartDate ( ) , period . getEndDate ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; }", "testMethod": "getStatisticsForDepartmentHead ( ) { org . synyx . urlaubsverwaltung . web . FilterPeriod filterPeriod = new org . synyx . urlaubsverwaltung . web . FilterPeriod ( java . util . Optional . ofNullable ( \"01.01.2018\" ) , java . util . Optional . ofNullable ( \"31.12.2018\" ) ) ; org . synyx . urlaubsverwaltung . person . Person person = new org . synyx . urlaubsverwaltung . person . Person ( ) ; person . setPermissions ( java . util . Collections . singletonList ( Role . DEPARTMENT_HEAD ) ) ; when ( sessionService . getSignedInUser ( ) ) . thenReturn ( person ) ; org . synyx . urlaubsverwaltung . person . Person departmentMember = new org . synyx . urlaubsverwaltung . person . Person ( ) ; when ( departmentService . getManagedMembersOfDepartmentHead ( person ) ) . thenReturn ( java . util . Collections . singletonList ( departmentMember ) ) ; when ( applicationForLeaveStatisticsBuilder . build ( person , filterPeriod . getStartDate ( ) , filterPeriod . getEndDate ( ) ) ) . thenReturn ( mock ( org . synyx . urlaubsverwaltung . statistics . web . ApplicationForLeaveStatistics . class ) ) ; java . util . List < org . synyx . urlaubsverwaltung . statistics . web . ApplicationForLeaveStatistics > statistics = sut . getStatistics ( filterPeriod ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( statistics . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "getStatisticsForDepartmentHead ( ) { org . synyx . urlaubsverwaltung . web . FilterPeriod filterPeriod = new org . synyx . urlaubsverwaltung . web . FilterPeriod ( java . util . Optional . ofNullable ( \"01.01.2018\" ) , java . util . Optional . ofNullable ( \"31.12.2018\" ) ) ; org . synyx . urlaubsverwaltung . person . Person person = new org . synyx . urlaubsverwaltung . person . Person ( ) ; person . setPermissions ( java . util . Collections . singletonList ( Role . DEPARTMENT_HEAD ) ) ; when ( sessionService . getSignedInUser ( ) ) . thenReturn ( person ) ; org . synyx . urlaubsverwaltung . person . Person departmentMember = new org . synyx . urlaubsverwaltung . person . Person ( ) ; when ( departmentService . getManagedMembersOfDepartmentHead ( person ) ) . thenReturn ( java . util . Collections . singletonList ( departmentMember ) ) ; when ( applicationForLeaveStatisticsBuilder . build ( person , filterPeriod . getStartDate ( ) , filterPeriod . getEndDate ( ) ) ) . thenReturn ( mock ( org . synyx . urlaubsverwaltung . statistics . web . ApplicationForLeaveStatistics . class ) ) ; java . util . List < org . synyx . urlaubsverwaltung . statistics . web . ApplicationForLeaveStatistics > statistics = sut . getStatistics ( filterPeriod ) ; \"<AssertPlaceHolder>\" ; } getStatistics ( org . synyx . urlaubsverwaltung . web . FilterPeriod ) { java . util . List < org . synyx . urlaubsverwaltung . person . Person > persons = getRelevantPersons ( ) ; return persons . stream ( ) . map ( ( person ) -> applicationForLeaveStatisticsBuilder . build ( person , period . getStartDate ( ) , period . getEndDate ( ) ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( statistics . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "equalsContent ( org . openmrs . PersonAttribute ) { boolean returnValue = true ; java . lang . String [ ] methods = new java . lang . String [ ] { \"getAttributeType\" , \"getValue\" , \"getVoided\" } ; java . lang . Class attributeClass = this . getClass ( ) ; for ( java . lang . String methodAttribute : methods ) { try { java . lang . reflect . Method method = attributeClass . getMethod ( methodAttribute ) ; java . lang . Object thisValue = method . invoke ( this ) ; java . lang . Object otherValue = method . invoke ( otherAttribute ) ; if ( otherValue != null ) { returnValue &= otherValue . equals ( thisValue ) ; } } catch ( java . lang . NoSuchMethodException e ) { org . openmrs . PersonAttribute . log . warn ( ( \"No<sp>such<sp>method<sp>for<sp>comparison<sp>\" + methodAttribute ) , e ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { org . openmrs . PersonAttribute . log . error ( \"Error<sp>while<sp>comparing<sp>attributes\" , e ) ; } } return returnValue ; }", "testMethod": "equalsContent_shouldReturnTrueIfAllFieldsOtherThanIdPersonAndPreferredAreEqual ( ) { org . openmrs . PersonName pn = new org . openmrs . PersonName ( 1 ) ; pn . setPrefix ( \"Count\" ) ; pn . setGivenName ( \"Adam\" ) ; pn . setMiddleName ( \"Alex\" ) ; pn . setFamilyNamePrefix ( \"family<sp>prefix\" ) ; pn . setFamilyName ( \"Jones\" ) ; pn . setFamilyName2 ( \"Howard\" ) ; pn . setFamilyNameSuffix ( \"Jr.\" ) ; pn . setDegree ( \"Dr.\" ) ; pn . setPreferred ( true ) ; pn . setPerson ( new org . openmrs . Person ( 999 ) ) ; org . openmrs . PersonName other = new org . openmrs . PersonName ( 2 ) ; other . setPrefix ( \"Count\" ) ; other . setGivenName ( \"Adam\" ) ; other . setMiddleName ( \"Alex\" ) ; other . setFamilyNamePrefix ( \"family<sp>prefix\" ) ; other . setFamilyName ( \"Jones\" ) ; other . setFamilyName2 ( \"Howard\" ) ; other . setFamilyNameSuffix ( \"Jr.\" ) ; other . setDegree ( \"Dr.\" ) ; other . setPreferred ( false ) ; other . setPerson ( new org . openmrs . Person ( 111 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pn . equalsContent ( other ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "equalsContent_shouldReturnTrueIfAllFieldsOtherThanIdPersonAndPreferredAreEqual ( ) { org . openmrs . PersonName pn = new org . openmrs . PersonName ( 1 ) ; pn . setPrefix ( \"Count\" ) ; pn . setGivenName ( \"Adam\" ) ; pn . setMiddleName ( \"Alex\" ) ; pn . setFamilyNamePrefix ( \"family<sp>prefix\" ) ; pn . setFamilyName ( \"Jones\" ) ; pn . setFamilyName2 ( \"Howard\" ) ; pn . setFamilyNameSuffix ( \"Jr.\" ) ; pn . setDegree ( \"Dr.\" ) ; pn . setPreferred ( true ) ; pn . setPerson ( new org . openmrs . Person ( 999 ) ) ; org . openmrs . PersonName other = new org . openmrs . PersonName ( 2 ) ; other . setPrefix ( \"Count\" ) ; other . setGivenName ( \"Adam\" ) ; other . setMiddleName ( \"Alex\" ) ; other . setFamilyNamePrefix ( \"family<sp>prefix\" ) ; other . setFamilyName ( \"Jones\" ) ; other . setFamilyName2 ( \"Howard\" ) ; other . setFamilyNameSuffix ( \"Jr.\" ) ; other . setDegree ( \"Dr.\" ) ; other . setPreferred ( false ) ; other . setPerson ( new org . openmrs . Person ( 111 ) ) ; \"<AssertPlaceHolder>\" ; } equalsContent ( org . openmrs . PersonAttribute ) { boolean returnValue = true ; java . lang . String [ ] methods = new java . lang . String [ ] { \"getAttributeType\" , \"getValue\" , \"getVoided\" } ; java . lang . Class attributeClass = this . getClass ( ) ; for ( java . lang . String methodAttribute : methods ) { try { java . lang . reflect . Method method = attributeClass . getMethod ( methodAttribute ) ; java . lang . Object thisValue = method . invoke ( this ) ; java . lang . Object otherValue = method . invoke ( otherAttribute ) ; if ( otherValue != null ) { returnValue &= otherValue . equals ( thisValue ) ; } } catch ( java . lang . NoSuchMethodException e ) { org . openmrs . PersonAttribute . log . warn ( ( \"No<sp>such<sp>method<sp>for<sp>comparison<sp>\" + methodAttribute ) , e ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { org . openmrs . PersonAttribute . log . error ( \"Error<sp>while<sp>comparing<sp>attributes\" , e ) ; } } return returnValue ; }", "answer": "org . junit . Assert . assertThat ( pn . equalsContent ( other ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "testMethod": "null_value ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = emit ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , null , \"B\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , null , \"B\" } } ) )", "total": "null_value ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = emit ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , null , \"B\" } } ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , null , \"B\" } } ) )"}
{"focal": "contains ( java . lang . Object ) { if ( o instanceof byte [ ] ) { return delegate . contains ( new org . springframework . data . redis . connection . util . ByteArrayWrapper ( ( ( byte [ ] ) ( o ) ) ) ) ; } return delegate . contains ( o ) ; }", "testMethod": "saveAndFindUnqualified ( ) { org . springframework . data . redis . repository . cdi . RepositoryConsumer repositoryConsumer = org . springframework . data . redis . repository . cdi . CdiExtensionIntegrationTests . container . select ( org . springframework . data . redis . repository . cdi . RepositoryConsumer . class ) . get ( ) ; repositoryConsumer . deleteAll ( ) ; org . springframework . data . redis . repository . cdi . Person person = new org . springframework . data . redis . repository . cdi . Person ( ) ; person . setName ( \"foo\" ) ; repositoryConsumer . getUnqualifiedRepo ( ) . save ( person ) ; java . util . List < org . springframework . data . redis . repository . cdi . Person > result = repositoryConsumer . getUnqualifiedRepo ( ) . findByName ( \"foo\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , contains ( person ) )", "total": "saveAndFindUnqualified ( ) { org . springframework . data . redis . repository . cdi . RepositoryConsumer repositoryConsumer = org . springframework . data . redis . repository . cdi . CdiExtensionIntegrationTests . container . select ( org . springframework . data . redis . repository . cdi . RepositoryConsumer . class ) . get ( ) ; repositoryConsumer . deleteAll ( ) ; org . springframework . data . redis . repository . cdi . Person person = new org . springframework . data . redis . repository . cdi . Person ( ) ; person . setName ( \"foo\" ) ; repositoryConsumer . getUnqualifiedRepo ( ) . save ( person ) ; java . util . List < org . springframework . data . redis . repository . cdi . Person > result = repositoryConsumer . getUnqualifiedRepo ( ) . findByName ( \"foo\" ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . Object ) { if ( o instanceof byte [ ] ) { return delegate . contains ( new org . springframework . data . redis . connection . util . ByteArrayWrapper ( ( ( byte [ ] ) ( o ) ) ) ) ; } return delegate . contains ( o ) ; }", "answer": "org . junit . Assert . assertThat ( result , contains ( person ) )"}
{"focal": "charAt ( int ) { return attributeName . charAt ( index ) ; }", "testMethod": "charAt ( ) { org . slim3 . datastore . AbstractAttributeMeta < org . slim3 . datastore . model . Hoge , java . lang . String > attrMeta = new org . slim3 . datastore . AbstractAttributeMeta < org . slim3 . datastore . model . Hoge , java . lang . String > ( meta , \"myString\" , \"myString\" , java . lang . String . class ) { } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( attrMeta . charAt ( 3 ) , org . hamcrest . CoreMatchers . is ( \"myString\" . charAt ( 3 ) ) )", "total": "charAt ( ) { org . slim3 . datastore . AbstractAttributeMeta < org . slim3 . datastore . model . Hoge , java . lang . String > attrMeta = new org . slim3 . datastore . AbstractAttributeMeta < org . slim3 . datastore . model . Hoge , java . lang . String > ( meta , \"myString\" , \"myString\" , java . lang . String . class ) { } ; \"<AssertPlaceHolder>\" ; } charAt ( int ) { return attributeName . charAt ( index ) ; }", "answer": "org . junit . Assert . assertThat ( attrMeta . charAt ( 3 ) , org . hamcrest . CoreMatchers . is ( \"myString\" . charAt ( 3 ) ) )"}
{"focal": "hasErrors ( ) { for ( org . modeshape . schematic . SchemaLibrary . Problem problem : problems ) { if ( ( problem . getType ( ) ) == ( SchemaLibrary . ProblemType . ERROR ) ) return true ; } return false ; }", "testMethod": "shouldProducePlanWhenFullTextSearchingColumnThatIsSearchable ( ) { schemata = schemataBuilder . addTable ( \"someTable\" , \"column1\" , \"column2\" , \"column3\" ) . makeSearchable ( \"someTable\" , \"column1\" ) . build ( ) ; query = builder . select ( \"column1\" , \"column4\" ) . from ( \"someTable\" ) . where ( ) . search ( \"someTable\" , \"column1\" , \"term1\" ) . end ( ) . query ( ) ; initQueryContext ( ) ; plan = planner . createPlan ( queryContext , query ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( problems . hasErrors ( ) , org . hamcrest . core . Is . is ( true ) )", "total": "shouldProducePlanWhenFullTextSearchingColumnThatIsSearchable ( ) { schemata = schemataBuilder . addTable ( \"someTable\" , \"column1\" , \"column2\" , \"column3\" ) . makeSearchable ( \"someTable\" , \"column1\" ) . build ( ) ; query = builder . select ( \"column1\" , \"column4\" ) . from ( \"someTable\" ) . where ( ) . search ( \"someTable\" , \"column1\" , \"term1\" ) . end ( ) . query ( ) ; initQueryContext ( ) ; plan = planner . createPlan ( queryContext , query ) ; \"<AssertPlaceHolder>\" ; } hasErrors ( ) { for ( org . modeshape . schematic . SchemaLibrary . Problem problem : problems ) { if ( ( problem . getType ( ) ) == ( SchemaLibrary . ProblemType . ERROR ) ) return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( problems . hasErrors ( ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "run ( ) { me . add ( new java . lang . Exception ( ) ) ; }", "testMethod": "test_with_one_RunnableAssert ( ) { com . googlecode . junittoolbox . MultithreadingTesterTest . CountingRunnableAssert ra1 = new com . googlecode . junittoolbox . MultithreadingTesterTest . CountingRunnableAssert ( ) ; new com . googlecode . junittoolbox . MultithreadingTester ( ) . numThreads ( 11 ) . numRoundsPerThread ( 13 ) . add ( ra1 ) . run ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ra1 . count . get ( ) , is ( ( 11 * 13 ) ) )", "total": "test_with_one_RunnableAssert ( ) { com . googlecode . junittoolbox . MultithreadingTesterTest . CountingRunnableAssert ra1 = new com . googlecode . junittoolbox . MultithreadingTesterTest . CountingRunnableAssert ( ) ; new com . googlecode . junittoolbox . MultithreadingTester ( ) . numThreads ( 11 ) . numRoundsPerThread ( 13 ) . add ( ra1 ) . run ( ) ; \"<AssertPlaceHolder>\" ; } run ( ) { me . add ( new java . lang . Exception ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( ra1 . count . get ( ) , is ( ( 11 * 13 ) ) )"}
{"focal": "getWeblogicOperatorImage ( ) { return weblogicOperatorImage ; }", "testMethod": "whenCreatedFromMapWithoutImage_hasEmptyString ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( values . getWeblogicOperatorImage ( ) , org . hamcrest . Matchers . equalTo ( \"\" ) )", "total": "whenCreatedFromMapWithoutImage_hasEmptyString ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( ) ) ; \"<AssertPlaceHolder>\" ; } getWeblogicOperatorImage ( ) { return weblogicOperatorImage ; }", "answer": "org . junit . Assert . assertThat ( values . getWeblogicOperatorImage ( ) , org . hamcrest . Matchers . equalTo ( \"\" ) )"}
{"focal": "getAge ( ) { return age ; }", "testMethod": "shouldSetPropertyValuePrimitive ( ) { com . fluentinterface . examples . Person built = aPerson ( ) . withAge ( 10 ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( built . getAge ( ) , org . hamcrest . CoreMatchers . is ( 10 ) )", "total": "shouldSetPropertyValuePrimitive ( ) { com . fluentinterface . examples . Person built = aPerson ( ) . withAge ( 10 ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getAge ( ) { return age ; }", "answer": "org . junit . Assert . assertThat ( built . getAge ( ) , org . hamcrest . CoreMatchers . is ( 10 ) )"}
{"focal": "ofNullable ( java . lang . Boolean ) { return value == null ? com . annimon . stream . OptionalBoolean . EMPTY : com . annimon . stream . OptionalBoolean . of ( value ) ; }", "testMethod": "testOfNullableWithAbsentValue ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . annimon . stream . OptionalBoolean . ofNullable ( null ) , isEmpty ( ) )", "total": "testOfNullableWithAbsentValue ( ) { \"<AssertPlaceHolder>\" ; } ofNullable ( java . lang . Boolean ) { return value == null ? com . annimon . stream . OptionalBoolean . EMPTY : com . annimon . stream . OptionalBoolean . of ( value ) ; }", "answer": "org . junit . Assert . assertThat ( com . annimon . stream . OptionalBoolean . ofNullable ( null ) , isEmpty ( ) )"}
{"focal": "getList ( ) { return list ; }", "testMethod": "testAddAll01 ( ) { org . terasoluna . gfw . common . message . ResultMessage msg1 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"foo\" , \"aa\" ) ; org . terasoluna . gfw . common . message . ResultMessage msg2 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"bar\" , \"bb\" ) ; org . terasoluna . gfw . common . message . ResultMessages messages = new org . terasoluna . gfw . common . message . ResultMessages ( ( ( org . terasoluna . gfw . common . message . ResultMessageType ) ( ERROR ) ) ) ; messages . addAll ( msg1 , msg2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( messages . getList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( msg1 , msg2 ) ) )", "total": "testAddAll01 ( ) { org . terasoluna . gfw . common . message . ResultMessage msg1 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"foo\" , \"aa\" ) ; org . terasoluna . gfw . common . message . ResultMessage msg2 = org . terasoluna . gfw . common . message . ResultMessage . fromCode ( \"bar\" , \"bb\" ) ; org . terasoluna . gfw . common . message . ResultMessages messages = new org . terasoluna . gfw . common . message . ResultMessages ( ( ( org . terasoluna . gfw . common . message . ResultMessageType ) ( ERROR ) ) ) ; messages . addAll ( msg1 , msg2 ) ; \"<AssertPlaceHolder>\" ; } getList ( ) { return list ; }", "answer": "org . junit . Assert . assertThat ( messages . getList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( msg1 , msg2 ) ) )"}
{"focal": "getEffectiveDomainCreatePermissions ( com . acciente . oacc . Resource ) { com . acciente . oacc . sql . internal . persister . SQLConnection connection = null ; __assertAuthenticated ( ) ; __assertResourceSpecified ( accessorResource ) ; try { connection = __getConnection ( ) ; accessorResource = __resolveResource ( connection , accessorResource ) ; __assertQueryAuthorization ( connection , accessorResource ) ; return __getEffectiveDomainCreatePermissions ( connection , accessorResource ) ; } finally { __closeConnection ( connection ) ; } }", "testMethod": "getEffectiveDomainCreatePermissions_emptyAsAuthenticated ( ) { final com . acciente . oacc . Resource accessorResource = generateUnauthenticatableResource ( ) ; generateResourceAndAuthenticate ( ) ; grantQueryPermission ( accessControlContext . getSessionResource ( ) , accessorResource ) ; java . util . Set < com . acciente . oacc . DomainCreatePermission > domainCreatePermissions = accessControlContext . getEffectiveDomainCreatePermissions ( accessorResource ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( domainCreatePermissions . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "getEffectiveDomainCreatePermissions_emptyAsAuthenticated ( ) { final com . acciente . oacc . Resource accessorResource = generateUnauthenticatableResource ( ) ; generateResourceAndAuthenticate ( ) ; grantQueryPermission ( accessControlContext . getSessionResource ( ) , accessorResource ) ; java . util . Set < com . acciente . oacc . DomainCreatePermission > domainCreatePermissions = accessControlContext . getEffectiveDomainCreatePermissions ( accessorResource ) ; \"<AssertPlaceHolder>\" ; } getEffectiveDomainCreatePermissions ( com . acciente . oacc . Resource ) { com . acciente . oacc . sql . internal . persister . SQLConnection connection = null ; __assertAuthenticated ( ) ; __assertResourceSpecified ( accessorResource ) ; try { connection = __getConnection ( ) ; accessorResource = __resolveResource ( connection , accessorResource ) ; __assertQueryAuthorization ( connection , accessorResource ) ; return __getEffectiveDomainCreatePermissions ( connection , accessorResource ) ; } finally { __closeConnection ( connection ) ; } }", "answer": "org . junit . Assert . assertThat ( domainCreatePermissions . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "property ( com . asakusafw . directio . hive . serde . PropertyDescriptor ) { this . properties . add ( descriptor ) ; return this ; }", "testMethod": "of_url ( ) { com . asakusafw . utils . gradle . BasicProject project = project ( ) . with ( com . asakusafw . utils . gradle . PropertyConfigurator . of ( com . asakusafw . utils . gradle . PropertyConfiguratorTest . resource ( \"a\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( project . property ( \"a\" ) , is ( \"1\" ) )", "total": "of_url ( ) { com . asakusafw . utils . gradle . BasicProject project = project ( ) . with ( com . asakusafw . utils . gradle . PropertyConfigurator . of ( com . asakusafw . utils . gradle . PropertyConfiguratorTest . resource ( \"a\" ) ) ) ; \"<AssertPlaceHolder>\" ; } property ( com . asakusafw . directio . hive . serde . PropertyDescriptor ) { this . properties . add ( descriptor ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( project . property ( \"a\" ) , is ( \"1\" ) )"}
{"focal": "mdcMap ( java . lang . String [ ] ) { java . util . Map < java . lang . String , java . lang . Object > result = new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ; java . util . List < java . lang . String > exclusionList ; if ( exclusions == null ) { exclusionList = java . util . Arrays . asList ( new java . lang . String [ 0 ] ) ; } else { exclusionList = java . util . Arrays . asList ( exclusions ) ; } for ( java . util . Map . Entry < java . lang . String , java . lang . String > t : org . slf4j . MDC . getCopyOfContextMap ( ) . entrySet ( ) ) { if ( ! ( exclusionList . contains ( t . getKey ( ) ) ) ) { result . put ( t . getKey ( ) , t . getValue ( ) ) ; } } return result ; }", "testMethod": "testExclusionStrangeSeq ( ) { com . sap . hcp . cf . logback . converter . ContextPropsConverter cpc = new com . sap . hcp . cf . logback . converter . ContextPropsConverter ( ) ; cpc . setOptionList ( asList ( com . sap . hcp . cf . logback . converter . STRANGE_SEQ ) ) ; cpc . start ( ) ; org . slf4j . MDC . clear ( ) ; org . slf4j . MDC . put ( com . sap . hcp . cf . logback . converter . SOME_KEY , com . sap . hcp . cf . logback . converter . SOME_VALUE ) ; org . slf4j . MDC . put ( com . sap . hcp . cf . logback . converter . STRANGE_SEQ , com . sap . hcp . cf . logback . converter . STRANGE_SEQ ) ; java . util . Map < java . lang . String , java . lang . Object > actMap = mapFrom ( cpc . convert ( makeEvent ( com . sap . hcp . cf . logback . converter . TEST_MSG_NO_ARGS , com . sap . hcp . cf . logback . converter . NO_ARGS ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actMap , org . hamcrest . core . Is . is ( mdcMap ( asList ( com . sap . hcp . cf . logback . converter . STRANGE_SEQ ) ) ) )", "total": "testExclusionStrangeSeq ( ) { com . sap . hcp . cf . logback . converter . ContextPropsConverter cpc = new com . sap . hcp . cf . logback . converter . ContextPropsConverter ( ) ; cpc . setOptionList ( asList ( com . sap . hcp . cf . logback . converter . STRANGE_SEQ ) ) ; cpc . start ( ) ; org . slf4j . MDC . clear ( ) ; org . slf4j . MDC . put ( com . sap . hcp . cf . logback . converter . SOME_KEY , com . sap . hcp . cf . logback . converter . SOME_VALUE ) ; org . slf4j . MDC . put ( com . sap . hcp . cf . logback . converter . STRANGE_SEQ , com . sap . hcp . cf . logback . converter . STRANGE_SEQ ) ; java . util . Map < java . lang . String , java . lang . Object > actMap = mapFrom ( cpc . convert ( makeEvent ( com . sap . hcp . cf . logback . converter . TEST_MSG_NO_ARGS , com . sap . hcp . cf . logback . converter . NO_ARGS ) ) ) ; \"<AssertPlaceHolder>\" ; } mdcMap ( java . lang . String [ ] ) { java . util . Map < java . lang . String , java . lang . Object > result = new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ; java . util . List < java . lang . String > exclusionList ; if ( exclusions == null ) { exclusionList = java . util . Arrays . asList ( new java . lang . String [ 0 ] ) ; } else { exclusionList = java . util . Arrays . asList ( exclusions ) ; } for ( java . util . Map . Entry < java . lang . String , java . lang . String > t : org . slf4j . MDC . getCopyOfContextMap ( ) . entrySet ( ) ) { if ( ! ( exclusionList . contains ( t . getKey ( ) ) ) ) { result . put ( t . getKey ( ) , t . getValue ( ) ) ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( actMap , org . hamcrest . core . Is . is ( mdcMap ( asList ( com . sap . hcp . cf . logback . converter . STRANGE_SEQ ) ) ) )"}
{"focal": "toCLIStyleString ( ) { return toString ( '=' ) ; }", "testMethod": "testFromDeploymentName_String_byteArr ( ) { java . lang . String name = \"wildfly-ejb-in-war.war\" ; byte [ ] hash = org . jboss . as . controller . HashUtil . hexStringToByteArray ( \"48d7b49e084860769d5ce03dc2223466aa46be3a\" ) ; org . jboss . as . controller . PathAddress address = org . jboss . as . controller . PathAddress . pathAddress ( org . jboss . as . controller . PathElement . pathElement ( \"deployment\" , \"wildfly-ejb-in-war.war\" ) ) ; org . jboss . as . repository . ContentReference result = org . jboss . as . server . deployment . ModelContentReference . fromDeploymentName ( name , hash ) ; org . jboss . as . repository . ContentReference expResult = new org . jboss . as . repository . ContentReference ( address . toCLIStyleString ( ) , \"48d7b49e084860769d5ce03dc2223466aa46be3a\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expResult ) )", "total": "testFromDeploymentName_String_byteArr ( ) { java . lang . String name = \"wildfly-ejb-in-war.war\" ; byte [ ] hash = org . jboss . as . controller . HashUtil . hexStringToByteArray ( \"48d7b49e084860769d5ce03dc2223466aa46be3a\" ) ; org . jboss . as . controller . PathAddress address = org . jboss . as . controller . PathAddress . pathAddress ( org . jboss . as . controller . PathElement . pathElement ( \"deployment\" , \"wildfly-ejb-in-war.war\" ) ) ; org . jboss . as . repository . ContentReference result = org . jboss . as . server . deployment . ModelContentReference . fromDeploymentName ( name , hash ) ; org . jboss . as . repository . ContentReference expResult = new org . jboss . as . repository . ContentReference ( address . toCLIStyleString ( ) , \"48d7b49e084860769d5ce03dc2223466aa46be3a\" ) ; \"<AssertPlaceHolder>\" ; } toCLIStyleString ( ) { return toString ( '=' ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expResult ) )"}
{"focal": "getRows ( ) { return rows ; }", "testMethod": "byComplexKeys ( ) { java . util . List < int [ ] > keysToGet = new java . util . Vector < int [ ] > ( ) ; keysToGet . add ( new int [ ] { 2011 , 10 , 15 } ) ; keysToGet . add ( new int [ ] { 2013 , 12 , 17 } ) ; org . lightcouch . ViewResult < java . lang . Integer [ ] , java . lang . Integer , org . lightcouch . tests . Foo > fooRows = org . lightcouch . tests . ViewsTest . dbClient . view ( \"example/by_date\" ) . keys ( keysToGet ) . group ( true ) . queryView ( org . lightcouch . tests . Integer [ ] . class , org . lightcouch . tests . Integer . class , org . lightcouch . tests . Foo . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fooRows . getRows ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "byComplexKeys ( ) { java . util . List < int [ ] > keysToGet = new java . util . Vector < int [ ] > ( ) ; keysToGet . add ( new int [ ] { 2011 , 10 , 15 } ) ; keysToGet . add ( new int [ ] { 2013 , 12 , 17 } ) ; org . lightcouch . ViewResult < java . lang . Integer [ ] , java . lang . Integer , org . lightcouch . tests . Foo > fooRows = org . lightcouch . tests . ViewsTest . dbClient . view ( \"example/by_date\" ) . keys ( keysToGet ) . group ( true ) . queryView ( org . lightcouch . tests . Integer [ ] . class , org . lightcouch . tests . Integer . class , org . lightcouch . tests . Foo . class ) ; \"<AssertPlaceHolder>\" ; } getRows ( ) { return rows ; }", "answer": "org . junit . Assert . assertThat ( fooRows . getRows ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "apply ( T1 , T2 , T3 ) { return new com . m3 . scalaflavor4j . Tuple3 < T1 , T2 , T3 > ( _1 , _2 , _3 ) ; }", "testMethod": "foldLeft_A$Object ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . IndexedSeq . apply ( 3 , 4 , 2 , 0 , 5 , 1 ) ; java . lang . Integer result = seq . foldLeft ( 0 ) . apply ( new com . m3 . scalaflavor4j . FoldLeftF2 < java . lang . Integer , java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( java . lang . Integer z , java . lang . Integer i ) throws com . m3 . scalaflavor4j . Exception { return z + i ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 15 ) ) )", "total": "foldLeft_A$Object ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . IndexedSeq . apply ( 3 , 4 , 2 , 0 , 5 , 1 ) ; java . lang . Integer result = seq . foldLeft ( 0 ) . apply ( new com . m3 . scalaflavor4j . FoldLeftF2 < java . lang . Integer , java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( java . lang . Integer z , java . lang . Integer i ) throws com . m3 . scalaflavor4j . Exception { return z + i ; } } ) ; \"<AssertPlaceHolder>\" ; } apply ( T1 , T2 , T3 ) { return new com . m3 . scalaflavor4j . Tuple3 < T1 , T2 , T3 > ( _1 , _2 , _3 ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 15 ) ) )"}
{"focal": "run ( ) { answer = null ; printMessageWithDefaultAnswer ( ) ; java . util . Optional < java . lang . String > answer = processAnswer ( ) ; if ( ! ( answer . isPresent ( ) ) ) { return false ; } while ( ! ( validateAnswerAndShowErrors ( ) ) ) { answer = processAnswer ( ) ; if ( ! ( answer . isPresent ( ) ) ) { return false ; } } this . answer = answer . get ( ) ; return true ; }", "testMethod": "testExitAfterInvalidAnswer ( ) { mockBaseChoiceStep . setConsoleReader ( mockConsoleReader ( \"n\\nq\\n\" ) ) ; mockBaseChoiceStep . setPossibleChoices ( java . util . Arrays . asList ( \"one\" , \"two\" ) ) ; mockBaseChoiceStep . setValidAnswers ( java . util . Arrays . asList ( \"1\" , \"2\" ) ) ; mockBaseChoiceStep . setAnswerRequired ( true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mockBaseChoiceStep . run ( ) , is ( false ) )", "total": "testExitAfterInvalidAnswer ( ) { mockBaseChoiceStep . setConsoleReader ( mockConsoleReader ( \"n\\nq\\n\" ) ) ; mockBaseChoiceStep . setPossibleChoices ( java . util . Arrays . asList ( \"one\" , \"two\" ) ) ; mockBaseChoiceStep . setValidAnswers ( java . util . Arrays . asList ( \"1\" , \"2\" ) ) ; mockBaseChoiceStep . setAnswerRequired ( true ) ; \"<AssertPlaceHolder>\" ; } run ( ) { answer = null ; printMessageWithDefaultAnswer ( ) ; java . util . Optional < java . lang . String > answer = processAnswer ( ) ; if ( ! ( answer . isPresent ( ) ) ) { return false ; } while ( ! ( validateAnswerAndShowErrors ( ) ) ) { answer = processAnswer ( ) ; if ( ! ( answer . isPresent ( ) ) ) { return false ; } } this . answer = answer . get ( ) ; return true ; }", "answer": "org . junit . Assert . assertThat ( mockBaseChoiceStep . run ( ) , is ( false ) )"}
{"focal": "getReference ( ) { return reference ; }", "testMethod": "whenExists ( ) { final org . estatio . module . index . fixtures . enums . Index_enum index_d = org . estatio . module . index . fixtures . enums . Index_enum . IStatFoi ; final org . estatio . module . index . dom . Index index = indexRepository . findByReference ( index_d . getReference ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( index . getReference ( ) , org . hamcrest . CoreMatchers . is ( index_d . getReference ( ) ) )", "total": "whenExists ( ) { final org . estatio . module . index . fixtures . enums . Index_enum index_d = org . estatio . module . index . fixtures . enums . Index_enum . IStatFoi ; final org . estatio . module . index . dom . Index index = indexRepository . findByReference ( index_d . getReference ( ) ) ; \"<AssertPlaceHolder>\" ; } getReference ( ) { return reference ; }", "answer": "org . junit . Assert . assertThat ( index . getReference ( ) , org . hamcrest . CoreMatchers . is ( index_d . getReference ( ) ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldOptionallyExcludeFields ( ) { java . lang . String expectedResult = \"{\\\"order\\\":<sp>{\\\"comments\\\":<sp>\\\"pack<sp>it<sp>nicely,<sp>please\\\"}}\" ; br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"guilherme<sp>silveira\" ) , 15.0 , \"pack<sp>it<sp>nicely,<sp>please\" ) ; serialization . from ( order ) . exclude ( \"price\" ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldOptionallyExcludeFields ( ) { java . lang . String expectedResult = \"{\\\"order\\\":<sp>{\\\"comments\\\":<sp>\\\"pack<sp>it<sp>nicely,<sp>please\\\"}}\" ; br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"guilherme<sp>silveira\" ) , 15.0 , \"pack<sp>it<sp>nicely,<sp>please\" ) ; serialization . from ( order ) . exclude ( \"price\" ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "getFetchPaths ( ) { return fetchPaths . keySet ( ) ; }", "testMethod": "getFetchPaths_when_multipleFetch_expect_preserveOrder ( ) { io . ebeaninternal . server . querydefn . OrmQueryDetail detail = new io . ebeaninternal . server . querydefn . OrmQueryDetail ( ) ; detail . select ( \"foo\" ) ; detail . fetch ( \"customer\" , null , null ) ; detail . fetch ( \"details\" , null , null ) ; \"<AssertPlaceHolder>\" . containsExactly ( \"customer\" , \"details\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( detail . getFetchPaths ( ) )", "total": "getFetchPaths_when_multipleFetch_expect_preserveOrder ( ) { io . ebeaninternal . server . querydefn . OrmQueryDetail detail = new io . ebeaninternal . server . querydefn . OrmQueryDetail ( ) ; detail . select ( \"foo\" ) ; detail . fetch ( \"customer\" , null , null ) ; detail . fetch ( \"details\" , null , null ) ; \"<AssertPlaceHolder>\" . containsExactly ( \"customer\" , \"details\" ) ; } getFetchPaths ( ) { return fetchPaths . keySet ( ) ; }", "answer": "org . junit . Assert . assertThat ( detail . getFetchPaths ( ) )"}
{"focal": "peek ( ) { return this . get ( 0 ) ; }", "testMethod": "whenOfferThenPeekReturnFirstElement ( ) { list . offer ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . peek ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "whenOfferThenPeekReturnFirstElement ( ) { list . offer ( 0 ) ; \"<AssertPlaceHolder>\" ; } peek ( ) { return this . get ( 0 ) ; }", "answer": "org . junit . Assert . assertThat ( list . peek ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "getIotHubStatusCode ( int ) { com . microsoft . azure . sdk . iot . device . IotHubStatusCode iotHubStatus ; switch ( httpsStatus ) { case 200 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . OK ; break ; case 204 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . OK_EMPTY ; break ; case 400 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . BAD_FORMAT ; break ; case 401 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . UNAUTHORIZED ; break ; case 403 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . TOO_MANY_DEVICES ; break ; case 404 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . HUB_OR_DEVICE_ID_NOT_FOUND ; break ; case 412 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . PRECONDITION_FAILED ; break ; case 413 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . REQUEST_ENTITY_TOO_LARGE ; break ; case 429 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . THROTTLED ; break ; case 500 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . INTERNAL_SERVER_ERROR ; break ; case 503 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . SERVER_BUSY ; break ; default : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . ERROR ; } return iotHubStatus ; }", "testMethod": "getIotHubStatusCodeMapsOtherStatusCodeToError ( ) { final int httpsStatus = - 1 ; com . microsoft . azure . sdk . iot . device . IotHubStatusCode testStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . getIotHubStatusCode ( httpsStatus ) ; final com . microsoft . azure . sdk . iot . device . IotHubStatusCode expectedStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . ERROR ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testStatus , org . hamcrest . CoreMatchers . is ( expectedStatus ) )", "total": "getIotHubStatusCodeMapsOtherStatusCodeToError ( ) { final int httpsStatus = - 1 ; com . microsoft . azure . sdk . iot . device . IotHubStatusCode testStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . getIotHubStatusCode ( httpsStatus ) ; final com . microsoft . azure . sdk . iot . device . IotHubStatusCode expectedStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . ERROR ; \"<AssertPlaceHolder>\" ; } getIotHubStatusCode ( int ) { com . microsoft . azure . sdk . iot . device . IotHubStatusCode iotHubStatus ; switch ( httpsStatus ) { case 200 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . OK ; break ; case 204 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . OK_EMPTY ; break ; case 400 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . BAD_FORMAT ; break ; case 401 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . UNAUTHORIZED ; break ; case 403 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . TOO_MANY_DEVICES ; break ; case 404 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . HUB_OR_DEVICE_ID_NOT_FOUND ; break ; case 412 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . PRECONDITION_FAILED ; break ; case 413 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . REQUEST_ENTITY_TOO_LARGE ; break ; case 429 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . THROTTLED ; break ; case 500 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . INTERNAL_SERVER_ERROR ; break ; case 503 : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . SERVER_BUSY ; break ; default : iotHubStatus = com . microsoft . azure . sdk . iot . device . IotHubStatusCode . ERROR ; } return iotHubStatus ; }", "answer": "org . junit . Assert . assertThat ( testStatus , org . hamcrest . CoreMatchers . is ( expectedStatus ) )"}
{"focal": "isSortAscending ( ) { return this . sortAscending ; }", "testMethod": "shouldGetSortAscending ( ) { boolean sortAscending = ! ( this . state . isSortAscending ( ) ) ; this . state . setSortAscending ( sortAscending ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . adapter . isSortAscending ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( sortAscending ) ) )", "total": "shouldGetSortAscending ( ) { boolean sortAscending = ! ( this . state . isSortAscending ( ) ) ; this . state . setSortAscending ( sortAscending ) ; \"<AssertPlaceHolder>\" ; } isSortAscending ( ) { return this . sortAscending ; }", "answer": "org . junit . Assert . assertThat ( this . adapter . isSortAscending ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( sortAscending ) ) )"}
{"focal": "getLoanRepaymentSchedule ( org . apache . struts . action . ActionMapping , org . apache . struts . action . ActionForm , javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse ) { org . mifos . accounts . loan . struts . actionforms . LoanAccountActionForm loanAccountActionForm = ( ( org . mifos . accounts . loan . struts . actionforms . LoanAccountActionForm ) ( form ) ) ; org . mifos . security . util . UserContext userContext = getUserContext ( request ) ; java . lang . Integer loanId = java . lang . Integer . valueOf ( request . getParameter ( org . mifos . accounts . loan . struts . action . LoanAccountAction . ACCOUNT_ID ) ) ; java . util . Locale locale = userContext . getPreferredLocale ( ) ; java . util . Date viewDate = loanAccountActionForm . getScheduleViewDateValue ( locale ) ; org . mifos . accounts . loan . business . LoanBO loan = getLoan ( loanId ) ; org . mifos . accounts . loan . struts . action . LoanAccountAction . setSessionAtributeForGLIM ( request , loan ) ; loan . updateDetails ( userContext ) ; org . mifos . platform . validations . Errors errors = loanBusinessService . computeExtraInterest ( loan , viewDate ) ; if ( errors . hasErrors ( ) ) { loanAccountActionForm . resetScheduleViewDate ( ) ; } org . mifos . accounts . loan . business . service . OriginalScheduleInfoDto originalSchedule = this . loanServiceFacade . retrieveOriginalLoanSchedule ( loanId ) ; java . lang . String memberAccountIdParam = request . getParameter ( \"memberAccountId\" ) ; if ( org . apache . commons . lang . StringUtils . isNotBlank ( memberAccountIdParam ) ) { java . lang . Integer memberId = java . lang . Integer . valueOf ( memberAccountIdParam ) ; org . mifos . accounts . loan . business . LoanBO member = loan . findMemberById ( memberId ) ; if ( member != null ) { org . mifos . framework . util . helpers . SessionUtils . setAttribute ( CustomerConstants . CUSTOMER_NAME , member . getCustomer ( ) . getDisplayName ( ) , request ) ; org . mifos . framework . util . helpers . SessionUtils . setAttribute ( CustomerConstants . GLOBAL_CUST_NUM , member . getCustomer ( ) . getGlobalCustNum ( ) , request ) ; } } org . mifos . framework . util . helpers . SessionUtils . setAttribute ( Constants . BUSINESS_KEY , loan , request ) ; org . mifos . framework . util . helpers . SessionUtils . setAttribute ( Constants . ORIGINAL_SCHEDULE_AVAILABLE , originalSchedule . hasOriginalInstallments ( ) , request ) ; org . mifos . framework . util . helpers . SessionUtils . setAttribute ( Constants . VIEW_DATE , viewDate , request ) ; java . lang . String forward = ( errors . hasErrors ( ) ) ? ActionForwards . getLoanRepaymentScheduleFailure . toString ( ) : ActionForwards . getLoanRepaymentSchedule . toString ( ) ; addErrors ( request , getActionErrors ( errors ) ) ; return mapping . findForward ( forward ) ; }", "testMethod": "getLoanRepaymentScheduleShouldValidateViewDate ( ) { org . apache . struts . action . ActionForward getLoanScheduleFailure = new org . apache . struts . action . ActionForward ( \"getLoanRepaymentScheduleFailure\" ) ; java . sql . Date extraInterestDate = org . mifos . framework . TestUtils . getSqlDate ( 10 , 7 , 2010 ) ; org . mifos . platform . validations . Errors errors = new org . mifos . platform . validations . Errors ( ) ; errors . addError ( LoanConstants . CANNOT_VIEW_REPAYMENT_SCHEDULE , new java . lang . String [ ] { extraInterestDate . toString ( ) } ) ; when ( loanBusinessService . computeExtraInterest ( loanBO , extraInterestDate ) ) . thenReturn ( errors ) ; when ( form . getScheduleViewDateValue ( Locale . US ) ) . thenReturn ( extraInterestDate ) ; when ( request . getParameter ( \"accountId\" ) ) . thenReturn ( \"1\" ) ; when ( mapping . findForward ( \"getLoanRepaymentScheduleFailure\" ) ) . thenReturn ( getLoanScheduleFailure ) ; when ( loanServiceFacade . retrieveOriginalLoanSchedule ( org . mockito . Matchers . < java . lang . Integer > any ( ) ) ) . thenReturn ( new org . mifos . accounts . loan . business . service . OriginalScheduleInfoDto ( \"100\" , new java . util . Date ( ) , java . util . Collections . < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > emptyList ( ) ) ) ; org . apache . struts . action . ActionForward forward = loanAccountAction . getLoanRepaymentSchedule ( mapping , form , request , response ) ; \"<AssertPlaceHolder>\" ; verify ( form ) . resetScheduleViewDate ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( forward , org . hamcrest . CoreMatchers . is ( getLoanScheduleFailure ) )", "total": "getLoanRepaymentScheduleShouldValidateViewDate ( ) { org . apache . struts . action . ActionForward getLoanScheduleFailure = new org . apache . struts . action . ActionForward ( \"getLoanRepaymentScheduleFailure\" ) ; java . sql . Date extraInterestDate = org . mifos . framework . TestUtils . getSqlDate ( 10 , 7 , 2010 ) ; org . mifos . platform . validations . Errors errors = new org . mifos . platform . validations . Errors ( ) ; errors . addError ( LoanConstants . CANNOT_VIEW_REPAYMENT_SCHEDULE , new java . lang . String [ ] { extraInterestDate . toString ( ) } ) ; when ( loanBusinessService . computeExtraInterest ( loanBO , extraInterestDate ) ) . thenReturn ( errors ) ; when ( form . getScheduleViewDateValue ( Locale . US ) ) . thenReturn ( extraInterestDate ) ; when ( request . getParameter ( \"accountId\" ) ) . thenReturn ( \"1\" ) ; when ( mapping . findForward ( \"getLoanRepaymentScheduleFailure\" ) ) . thenReturn ( getLoanScheduleFailure ) ; when ( loanServiceFacade . retrieveOriginalLoanSchedule ( org . mockito . Matchers . < java . lang . Integer > any ( ) ) ) . thenReturn ( new org . mifos . accounts . loan . business . service . OriginalScheduleInfoDto ( \"100\" , new java . util . Date ( ) , java . util . Collections . < org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment > emptyList ( ) ) ) ; org . apache . struts . action . ActionForward forward = loanAccountAction . getLoanRepaymentSchedule ( mapping , form , request , response ) ; \"<AssertPlaceHolder>\" ; verify ( form ) . resetScheduleViewDate ( ) ; } getLoanRepaymentSchedule ( org . apache . struts . action . ActionMapping , org . apache . struts . action . ActionForm , javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse ) { org . mifos . accounts . loan . struts . actionforms . LoanAccountActionForm loanAccountActionForm = ( ( org . mifos . accounts . loan . struts . actionforms . LoanAccountActionForm ) ( form ) ) ; org . mifos . security . util . UserContext userContext = getUserContext ( request ) ; java . lang . Integer loanId = java . lang . Integer . valueOf ( request . getParameter ( org . mifos . accounts . loan . struts . action . LoanAccountAction . ACCOUNT_ID ) ) ; java . util . Locale locale = userContext . getPreferredLocale ( ) ; java . util . Date viewDate = loanAccountActionForm . getScheduleViewDateValue ( locale ) ; org . mifos . accounts . loan . business . LoanBO loan = getLoan ( loanId ) ; org . mifos . accounts . loan . struts . action . LoanAccountAction . setSessionAtributeForGLIM ( request , loan ) ; loan . updateDetails ( userContext ) ; org . mifos . platform . validations . Errors errors = loanBusinessService . computeExtraInterest ( loan , viewDate ) ; if ( errors . hasErrors ( ) ) { loanAccountActionForm . resetScheduleViewDate ( ) ; } org . mifos . accounts . loan . business . service . OriginalScheduleInfoDto originalSchedule = this . loanServiceFacade . retrieveOriginalLoanSchedule ( loanId ) ; java . lang . String memberAccountIdParam = request . getParameter ( \"memberAccountId\" ) ; if ( org . apache . commons . lang . StringUtils . isNotBlank ( memberAccountIdParam ) ) { java . lang . Integer memberId = java . lang . Integer . valueOf ( memberAccountIdParam ) ; org . mifos . accounts . loan . business . LoanBO member = loan . findMemberById ( memberId ) ; if ( member != null ) { org . mifos . framework . util . helpers . SessionUtils . setAttribute ( CustomerConstants . CUSTOMER_NAME , member . getCustomer ( ) . getDisplayName ( ) , request ) ; org . mifos . framework . util . helpers . SessionUtils . setAttribute ( CustomerConstants . GLOBAL_CUST_NUM , member . getCustomer ( ) . getGlobalCustNum ( ) , request ) ; } } org . mifos . framework . util . helpers . SessionUtils . setAttribute ( Constants . BUSINESS_KEY , loan , request ) ; org . mifos . framework . util . helpers . SessionUtils . setAttribute ( Constants . ORIGINAL_SCHEDULE_AVAILABLE , originalSchedule . hasOriginalInstallments ( ) , request ) ; org . mifos . framework . util . helpers . SessionUtils . setAttribute ( Constants . VIEW_DATE , viewDate , request ) ; java . lang . String forward = ( errors . hasErrors ( ) ) ? ActionForwards . getLoanRepaymentScheduleFailure . toString ( ) : ActionForwards . getLoanRepaymentSchedule . toString ( ) ; addErrors ( request , getActionErrors ( errors ) ) ; return mapping . findForward ( forward ) ; }", "answer": "org . junit . Assert . assertThat ( forward , org . hamcrest . CoreMatchers . is ( getLoanScheduleFailure ) )"}
{"focal": "isTestMethod ( org . eclipse . jdt . core . IJavaElement ) { if ( ! ( element instanceof org . eclipse . jdt . core . IMethod ) ) return false ; org . eclipse . jdt . core . IMethod method = ( ( org . eclipse . jdt . core . IMethod ) ( element ) ) ; if ( ! ( method . getReturnType ( ) . equals ( \"V\" ) ) ) return false ; int flags = method . getFlags ( ) ; if ( ( ! ( org . eclipse . jdt . core . Flags . isPublic ( flags ) ) ) || ( org . eclipse . jdt . core . Flags . isStatic ( flags ) ) ) return false ; if ( method . getElementName ( ) . startsWith ( \"test\" ) ) return true ; return junit . extensions . eclipse . quick . JavaElements . hasTestAnnotationOnMethod ( method ) ; }", "testMethod": "recognition_junit4_test_method ( ) { org . eclipse . jdt . core . IMethod element = methodBuilder . junit4_method ( ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( junit . extensions . eclipse . quick . JavaElements . isTestMethod ( element ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "recognition_junit4_test_method ( ) { org . eclipse . jdt . core . IMethod element = methodBuilder . junit4_method ( ) . build ( ) ; \"<AssertPlaceHolder>\" ; } isTestMethod ( org . eclipse . jdt . core . IJavaElement ) { if ( ! ( element instanceof org . eclipse . jdt . core . IMethod ) ) return false ; org . eclipse . jdt . core . IMethod method = ( ( org . eclipse . jdt . core . IMethod ) ( element ) ) ; if ( ! ( method . getReturnType ( ) . equals ( \"V\" ) ) ) return false ; int flags = method . getFlags ( ) ; if ( ( ! ( org . eclipse . jdt . core . Flags . isPublic ( flags ) ) ) || ( org . eclipse . jdt . core . Flags . isStatic ( flags ) ) ) return false ; if ( method . getElementName ( ) . startsWith ( \"test\" ) ) return true ; return junit . extensions . eclipse . quick . JavaElements . hasTestAnnotationOnMethod ( method ) ; }", "answer": "org . junit . Assert . assertThat ( junit . extensions . eclipse . quick . JavaElements . isTestMethod ( element ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getClusters ( ) { doReturn ( com . google . common . collect . Sets . newHashSet ( \"hoge\" , \"bar\" ) ) . when ( dataStoreJedis ) . smembers ( anyString ( ) ) ; org . junit . Assert . assertThat ( service . getClusters ( ) , org . hamcrest . Matchers . contains ( \"hoge\" , \"bar\" ) ) ; }", "testMethod": "getClusters ( ) { doReturn ( com . google . common . collect . Sets . newHashSet ( \"hoge\" , \"bar\" ) ) . when ( dataStoreJedis ) . smembers ( anyString ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( service . getClusters ( ) , org . hamcrest . Matchers . contains ( \"hoge\" , \"bar\" ) )", "total": "getClusters ( ) { doReturn ( com . google . common . collect . Sets . newHashSet ( \"hoge\" , \"bar\" ) ) . when ( dataStoreJedis ) . smembers ( anyString ( ) ) ; \"<AssertPlaceHolder>\" ; } getClusters ( ) { doReturn ( com . google . common . collect . Sets . newHashSet ( \"hoge\" , \"bar\" ) ) . when ( dataStoreJedis ) . smembers ( anyString ( ) ) ; org . junit . Assert . assertThat ( service . getClusters ( ) , org . hamcrest . Matchers . contains ( \"hoge\" , \"bar\" ) ) ; }", "answer": "org . junit . Assert . assertThat ( service . getClusters ( ) , org . hamcrest . Matchers . contains ( \"hoge\" , \"bar\" ) )"}
{"focal": "is ( T ) { return new com . oracle . bedrock . predicate . Is < T > ( new com . oracle . bedrock . predicate . EqualTo < T > ( value ) ) ; }", "testMethod": "shouldCopyNonStandardSystemProperties ( ) { int count = 0 ; java . lang . String propertyName = \"com.oracle.bedrock.custom.property.\" + count ; java . lang . String propertyValue = \"hello<sp>world\" ; while ( ( java . lang . System . getProperty ( propertyName ) ) != null ) { count ++ ; propertyName = \"com.oracle.bedrock.custom.property.\" + count ; } java . lang . System . setProperty ( propertyName , propertyValue ) ; java . util . Properties expected = new java . util . Properties ( ) ; java . util . Properties systemProperties = java . lang . System . getProperties ( ) ; for ( java . lang . String name : systemProperties . stringPropertyNames ( ) ) { if ( ! ( PropertiesBuilder . STANDARD_SYSTEM_PROPERTIES . contains ( name ) ) ) { expected . put ( name , systemProperties . get ( name ) ) ; } } com . oracle . bedrock . runtime . PropertiesBuilder builder = com . oracle . bedrock . runtime . PropertiesBuilder . fromCurrentNonStandardSystemProperties ( ) ; java . util . Properties properties = builder . realize ( ) ; \"<AssertPlaceHolder>\" ; java . lang . System . getProperties ( ) . remove ( propertyName ) ; }", "assertLine": "org . junit . Assert . assertThat ( properties , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldCopyNonStandardSystemProperties ( ) { int count = 0 ; java . lang . String propertyName = \"com.oracle.bedrock.custom.property.\" + count ; java . lang . String propertyValue = \"hello<sp>world\" ; while ( ( java . lang . System . getProperty ( propertyName ) ) != null ) { count ++ ; propertyName = \"com.oracle.bedrock.custom.property.\" + count ; } java . lang . System . setProperty ( propertyName , propertyValue ) ; java . util . Properties expected = new java . util . Properties ( ) ; java . util . Properties systemProperties = java . lang . System . getProperties ( ) ; for ( java . lang . String name : systemProperties . stringPropertyNames ( ) ) { if ( ! ( PropertiesBuilder . STANDARD_SYSTEM_PROPERTIES . contains ( name ) ) ) { expected . put ( name , systemProperties . get ( name ) ) ; } } com . oracle . bedrock . runtime . PropertiesBuilder builder = com . oracle . bedrock . runtime . PropertiesBuilder . fromCurrentNonStandardSystemProperties ( ) ; java . util . Properties properties = builder . realize ( ) ; \"<AssertPlaceHolder>\" ; java . lang . System . getProperties ( ) . remove ( propertyName ) ; } is ( T ) { return new com . oracle . bedrock . predicate . Is < T > ( new com . oracle . bedrock . predicate . EqualTo < T > ( value ) ) ; }", "answer": "org . junit . Assert . assertThat ( properties , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getValue ( ) { java . lang . String value = cookies . get ( name ) ; if ( value != null ) { return fromString ( value ) ; } else { return null ; } }", "testMethod": "testContainsBound ( ) { org . tessell . model . dsl . Binder b = new org . tessell . model . dsl . Binder ( ) ; org . tessell . gwt . user . client . ui . StubCheckBox c = new org . tessell . gwt . user . client . ui . StubCheckBox ( ) ; org . tessell . tests . model . properties . BooleanProperty s = p . contains ( \"s\" ) ; b . bind ( s ) . to ( c ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( c . getValue ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testContainsBound ( ) { org . tessell . model . dsl . Binder b = new org . tessell . model . dsl . Binder ( ) ; org . tessell . gwt . user . client . ui . StubCheckBox c = new org . tessell . gwt . user . client . ui . StubCheckBox ( ) ; org . tessell . tests . model . properties . BooleanProperty s = p . contains ( \"s\" ) ; b . bind ( s ) . to ( c ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { java . lang . String value = cookies . get ( name ) ; if ( value != null ) { return fromString ( value ) ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( c . getValue ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "atomic ( ) { if ( ( depth ) < 0 ) throw new java . lang . IllegalArgumentException ( \"no<sp>depth<sp>specified,<sp>use<sp>.depth(int)\" ) ; java . util . List < org . openscience . cdk . hash . AtomEncoder > encoders = new java . util . ArrayList < org . openscience . cdk . hash . AtomEncoder > ( ) ; for ( org . openscience . cdk . hash . AtomEncoder encoder : encoderSet ) { encoders . add ( encoder ) ; } encoders . addAll ( this . customEncoders ) ; boolean suppress = ( suppression ) != ( org . openscience . cdk . hash . AtomSuppression . unsuppressed ( ) ) ; org . openscience . cdk . hash . AtomEncoder encoder = new org . openscience . cdk . hash . ConjugatedAtomEncoder ( encoders ) ; org . openscience . cdk . hash . SeedGenerator seeds = new org . openscience . cdk . hash . SeedGenerator ( encoder , suppression ) ; org . openscience . cdk . hash . AbstractAtomHashGenerator simple = ( suppress ) ? new org . openscience . cdk . hash . SuppressedAtomHashGenerator ( seeds , new org . openscience . cdk . hash . Xorshift ( ) , makeStereoEncoderFactory ( ) , suppression , depth ) : new org . openscience . cdk . hash . BasicAtomHashGenerator ( seeds , new org . openscience . cdk . hash . Xorshift ( ) , makeStereoEncoderFactory ( ) , depth ) ; if ( ( equivSetFinder ) != null ) { return new org . openscience . cdk . hash . PerturbedAtomHashGenerator ( seeds , simple , new org . openscience . cdk . hash . Xorshift ( ) , makeStereoEncoderFactory ( ) , equivSetFinder , suppression ) ; } else { return simple ; } }", "testMethod": "testDepth ( ) { org . openscience . cdk . hash . AtomHashGenerator generator = new org . openscience . cdk . hash . HashGeneratorMaker ( ) . depth ( 5 ) . elemental ( ) . atomic ( ) ; java . lang . reflect . Field depthField = generator . getClass ( ) . getDeclaredField ( \"depth\" ) ; depthField . setAccessible ( true ) ; int value = depthField . getInt ( generator ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . is ( 5 ) )", "total": "testDepth ( ) { org . openscience . cdk . hash . AtomHashGenerator generator = new org . openscience . cdk . hash . HashGeneratorMaker ( ) . depth ( 5 ) . elemental ( ) . atomic ( ) ; java . lang . reflect . Field depthField = generator . getClass ( ) . getDeclaredField ( \"depth\" ) ; depthField . setAccessible ( true ) ; int value = depthField . getInt ( generator ) ; \"<AssertPlaceHolder>\" ; } atomic ( ) { if ( ( depth ) < 0 ) throw new java . lang . IllegalArgumentException ( \"no<sp>depth<sp>specified,<sp>use<sp>.depth(int)\" ) ; java . util . List < org . openscience . cdk . hash . AtomEncoder > encoders = new java . util . ArrayList < org . openscience . cdk . hash . AtomEncoder > ( ) ; for ( org . openscience . cdk . hash . AtomEncoder encoder : encoderSet ) { encoders . add ( encoder ) ; } encoders . addAll ( this . customEncoders ) ; boolean suppress = ( suppression ) != ( org . openscience . cdk . hash . AtomSuppression . unsuppressed ( ) ) ; org . openscience . cdk . hash . AtomEncoder encoder = new org . openscience . cdk . hash . ConjugatedAtomEncoder ( encoders ) ; org . openscience . cdk . hash . SeedGenerator seeds = new org . openscience . cdk . hash . SeedGenerator ( encoder , suppression ) ; org . openscience . cdk . hash . AbstractAtomHashGenerator simple = ( suppress ) ? new org . openscience . cdk . hash . SuppressedAtomHashGenerator ( seeds , new org . openscience . cdk . hash . Xorshift ( ) , makeStereoEncoderFactory ( ) , suppression , depth ) : new org . openscience . cdk . hash . BasicAtomHashGenerator ( seeds , new org . openscience . cdk . hash . Xorshift ( ) , makeStereoEncoderFactory ( ) , depth ) ; if ( ( equivSetFinder ) != null ) { return new org . openscience . cdk . hash . PerturbedAtomHashGenerator ( seeds , simple , new org . openscience . cdk . hash . Xorshift ( ) , makeStereoEncoderFactory ( ) , equivSetFinder , suppression ) ; } else { return simple ; } }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . is ( 5 ) )"}
{"focal": "contains ( java . lang . String ) { return ( id != null ) && ( super . contains ( id ) ) ; }", "testMethod": "testGetLinkedProjects ( ) { final java . util . concurrent . ExecutorService service = java . util . concurrent . Executors . newSingleThreadExecutor ( ) ; org . eclipse . sw360 . components . db . Project project = handler . getProjectById ( \"R1B\" 5 , user ) ; final java . util . concurrent . Future < org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ProjectLink > > completionFuture = service . submit ( ( ) -> handler . getLinkedProjects ( project , true , user ) ) ; service . shutdown ( ) ; service . awaitTermination ( 10 , TimeUnit . SECONDS ) ; final org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ProjectLink > linkedProjects = completionFuture . get ( ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR1A = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1A\" , \"vendor\" , \"component1\" , \"R1B\" 2 , \"R1B\" 7 , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1A\" ) . setComponentType ( ComponentType . OSS ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR1B = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1B\" , \"vendor\" , \"component1\" , \"releaseB\" , \"R1B\" 1 , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1B\" ) . setComponentType ( ComponentType . OSS ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR2A = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1B\" 4 , \"vendor\" , \"component2\" , \"R1B\" 2 , \"R1B\" 9 , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1B\" 4 ) . setComponentType ( ComponentType . COTS ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR2B = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1B\" 6 , \"vendor\" , \"component2\" , \"releaseB\" , \"vendor<sp>component2<sp>releaseB\" , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1B\" 6 ) . setComponentType ( ComponentType . COTS ) ; org . eclipse . sw360 . components . db . ProjectLink link3 = new org . eclipse . sw360 . components . db . ProjectLink ( \"P3\" , \"R1B\" 3 ) . setRelation ( ProjectRelationship . REFERRED ) . setNodeId ( \"P3\" ) . setParentNodeId ( \"component1\" 0 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 2 ) . setLinkedReleases ( org . eclipse . sw360 . components . db . Arrays . asList ( releaseLinkR2A , releaseLinkR2B ) ) . setSubprojects ( org . eclipse . sw360 . components . db . Collections . emptyList ( ) ) ; org . eclipse . sw360 . components . db . ProjectLink link4 = new org . eclipse . sw360 . components . db . ProjectLink ( \"P4\" , \"project4\" ) . setRelation ( ProjectRelationship . CONTAINED ) . setNodeId ( \"P4\" ) . setParentNodeId ( \"component1\" 0 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 2 ) . setSubprojects ( org . eclipse . sw360 . components . db . Collections . emptyList ( ) ) ; org . eclipse . sw360 . components . db . ProjectLink link2 = new org . eclipse . sw360 . components . db . ProjectLink ( \"component1\" 0 , \"R1B\" 8 ) . setRelation ( ProjectRelationship . CONTAINED ) . setNodeId ( \"component1\" 0 ) . setParentNodeId ( \"R1B\" 5 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 1 ) . setLinkedReleases ( org . eclipse . sw360 . components . db . Arrays . asList ( releaseLinkR1A , releaseLinkR1B ) ) . setSubprojects ( org . eclipse . sw360 . components . db . Arrays . asList ( link3 , link4 ) ) ; org . eclipse . sw360 . components . db . ProjectLink link1 = new org . eclipse . sw360 . components . db . ProjectLink ( \"R1B\" 5 , \"R1B\" 0 ) . setRelation ( ProjectRelationship . UNKNOWN ) . setNodeId ( \"R1B\" 5 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 0 ) . setSubprojects ( org . eclipse . sw360 . components . db . Arrays . asList ( link2 ) ) ; stripRandomPartsOfNodeIds ( linkedProjects ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( linkedProjects , org . hamcrest . Matchers . contains ( link1 ) )", "total": "testGetLinkedProjects ( ) { final java . util . concurrent . ExecutorService service = java . util . concurrent . Executors . newSingleThreadExecutor ( ) ; org . eclipse . sw360 . components . db . Project project = handler . getProjectById ( \"R1B\" 5 , user ) ; final java . util . concurrent . Future < org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ProjectLink > > completionFuture = service . submit ( ( ) -> handler . getLinkedProjects ( project , true , user ) ) ; service . shutdown ( ) ; service . awaitTermination ( 10 , TimeUnit . SECONDS ) ; final org . eclipse . sw360 . components . db . List < org . eclipse . sw360 . components . db . ProjectLink > linkedProjects = completionFuture . get ( ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR1A = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1A\" , \"vendor\" , \"component1\" , \"R1B\" 2 , \"R1B\" 7 , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1A\" ) . setComponentType ( ComponentType . OSS ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR1B = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1B\" , \"vendor\" , \"component1\" , \"releaseB\" , \"R1B\" 1 , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1B\" ) . setComponentType ( ComponentType . OSS ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR2A = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1B\" 4 , \"vendor\" , \"component2\" , \"R1B\" 2 , \"R1B\" 9 , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1B\" 4 ) . setComponentType ( ComponentType . COTS ) ; org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink releaseLinkR2B = new org . eclipse . sw360 . datahandler . thrift . components . ReleaseLink ( \"R1B\" 6 , \"vendor\" , \"component2\" , \"releaseB\" , \"vendor<sp>component2<sp>releaseB\" , false ) . setReleaseRelationship ( ReleaseRelationship . REFERRED ) . setMainlineState ( MainlineState . MAINLINE ) . setNodeId ( \"R1B\" 6 ) . setComponentType ( ComponentType . COTS ) ; org . eclipse . sw360 . components . db . ProjectLink link3 = new org . eclipse . sw360 . components . db . ProjectLink ( \"P3\" , \"R1B\" 3 ) . setRelation ( ProjectRelationship . REFERRED ) . setNodeId ( \"P3\" ) . setParentNodeId ( \"component1\" 0 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 2 ) . setLinkedReleases ( org . eclipse . sw360 . components . db . Arrays . asList ( releaseLinkR2A , releaseLinkR2B ) ) . setSubprojects ( org . eclipse . sw360 . components . db . Collections . emptyList ( ) ) ; org . eclipse . sw360 . components . db . ProjectLink link4 = new org . eclipse . sw360 . components . db . ProjectLink ( \"P4\" , \"project4\" ) . setRelation ( ProjectRelationship . CONTAINED ) . setNodeId ( \"P4\" ) . setParentNodeId ( \"component1\" 0 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 2 ) . setSubprojects ( org . eclipse . sw360 . components . db . Collections . emptyList ( ) ) ; org . eclipse . sw360 . components . db . ProjectLink link2 = new org . eclipse . sw360 . components . db . ProjectLink ( \"component1\" 0 , \"R1B\" 8 ) . setRelation ( ProjectRelationship . CONTAINED ) . setNodeId ( \"component1\" 0 ) . setParentNodeId ( \"R1B\" 5 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 1 ) . setLinkedReleases ( org . eclipse . sw360 . components . db . Arrays . asList ( releaseLinkR1A , releaseLinkR1B ) ) . setSubprojects ( org . eclipse . sw360 . components . db . Arrays . asList ( link3 , link4 ) ) ; org . eclipse . sw360 . components . db . ProjectLink link1 = new org . eclipse . sw360 . components . db . ProjectLink ( \"R1B\" 5 , \"R1B\" 0 ) . setRelation ( ProjectRelationship . UNKNOWN ) . setNodeId ( \"R1B\" 5 ) . setProjectType ( ProjectType . CUSTOMER ) . setState ( ProjectState . ACTIVE ) . setTreeLevel ( 0 ) . setSubprojects ( org . eclipse . sw360 . components . db . Arrays . asList ( link2 ) ) ; stripRandomPartsOfNodeIds ( linkedProjects ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . String ) { return ( id != null ) && ( super . contains ( id ) ) ; }", "answer": "org . junit . Assert . assertThat ( linkedProjects , org . hamcrest . Matchers . contains ( link1 ) )"}
{"focal": "getMetric ( ) { return _metric ; }", "testMethod": "testEbgpDoesNotExportWithMEDSet ( ) { org . batfish . datamodel . BgpRoute bgpRoute = _baseBgpRouteBuilder . setMetric ( 1000 ) . build ( ) ; setUpPeers ( false ) ; org . batfish . datamodel . BgpRoute . Builder transformedBgpRoute = runTransformBgpRoutePreExport ( bgpRoute ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( transformedBgpRoute . getMetric ( ) , org . hamcrest . Matchers . equalTo ( 0L ) )", "total": "testEbgpDoesNotExportWithMEDSet ( ) { org . batfish . datamodel . BgpRoute bgpRoute = _baseBgpRouteBuilder . setMetric ( 1000 ) . build ( ) ; setUpPeers ( false ) ; org . batfish . datamodel . BgpRoute . Builder transformedBgpRoute = runTransformBgpRoutePreExport ( bgpRoute ) ; \"<AssertPlaceHolder>\" ; } getMetric ( ) { return _metric ; }", "answer": "org . junit . Assert . assertThat ( transformedBgpRoute . getMetric ( ) , org . hamcrest . Matchers . equalTo ( 0L ) )"}
{"focal": "getMessageKey ( ) { org . junit . Assert . assertThat ( validator . getMessageKey ( ) , org . hamcrest . CoreMatchers . is ( \"validator.maxlength\" ) ) ; }", "testMethod": "getMessageKey ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( validator . getMessageKey ( ) , org . hamcrest . CoreMatchers . is ( \"validator.maxlength\" ) )", "total": "getMessageKey ( ) { \"<AssertPlaceHolder>\" ; } getMessageKey ( ) { org . junit . Assert . assertThat ( validator . getMessageKey ( ) , org . hamcrest . CoreMatchers . is ( \"validator.maxlength\" ) ) ; }", "answer": "org . junit . Assert . assertThat ( validator . getMessageKey ( ) , org . hamcrest . CoreMatchers . is ( \"validator.maxlength\" ) )"}
{"focal": "size ( ) { return hashMap . size ( ) ; }", "testMethod": "find_with_show_only_ended_does_not_show_if_not_enough_supports_but_minSupportDuration_time_has_not_ended ( ) { testHelper . create ( new fi . om . initiative . dao . TestHelper . InitiativeDraft ( userId ) . withState ( InitiativeState . ACCEPTED ) . withSupportCount ( 49 ) . isRunning ( fi . om . initiative . dao . InitiativeDaoSearchTest . day_before_yesterday , fi . om . initiative . dao . InitiativeDaoSearchTest . far_in_the_future ) ) ; testHelper . create ( new fi . om . initiative . dao . TestHelper . InitiativeDraft ( userId ) . withState ( InitiativeState . ACCEPTED ) . withSupportCount ( 50 ) . isRunning ( fi . om . initiative . dao . InitiativeDaoSearchTest . day_before_yesterday , fi . om . initiative . dao . InitiativeDaoSearchTest . far_in_the_future ) ) ; fi . om . initiative . dto . search . InitiativeSearch search = initiativeSearch ( ) ; search . setShow ( Show . ended ) ; fi . om . initiative . dto . InitiativeSettings . MinSupportCountSettings supportCountSettings = new fi . om . initiative . dto . InitiativeSettings . MinSupportCountSettings ( 50 , org . joda . time . Days . days ( 2 ) ) ; java . util . List < fi . om . initiative . dto . initiative . InitiativeInfo > result = initiativeDao . findInitiatives ( search , userId , supportCountSettings ) . list ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "find_with_show_only_ended_does_not_show_if_not_enough_supports_but_minSupportDuration_time_has_not_ended ( ) { testHelper . create ( new fi . om . initiative . dao . TestHelper . InitiativeDraft ( userId ) . withState ( InitiativeState . ACCEPTED ) . withSupportCount ( 49 ) . isRunning ( fi . om . initiative . dao . InitiativeDaoSearchTest . day_before_yesterday , fi . om . initiative . dao . InitiativeDaoSearchTest . far_in_the_future ) ) ; testHelper . create ( new fi . om . initiative . dao . TestHelper . InitiativeDraft ( userId ) . withState ( InitiativeState . ACCEPTED ) . withSupportCount ( 50 ) . isRunning ( fi . om . initiative . dao . InitiativeDaoSearchTest . day_before_yesterday , fi . om . initiative . dao . InitiativeDaoSearchTest . far_in_the_future ) ) ; fi . om . initiative . dto . search . InitiativeSearch search = initiativeSearch ( ) ; search . setShow ( Show . ended ) ; fi . om . initiative . dto . InitiativeSettings . MinSupportCountSettings supportCountSettings = new fi . om . initiative . dto . InitiativeSettings . MinSupportCountSettings ( 50 , org . joda . time . Days . days ( 2 ) ) ; java . util . List < fi . om . initiative . dto . initiative . InitiativeInfo > result = initiativeDao . findInitiatives ( search , userId , supportCountSettings ) . list ; \"<AssertPlaceHolder>\" ; } size ( ) { return hashMap . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "testCount ( ) { org . junit . tests . running . classes . RunWithTest . log += \"count\" ; return 0 ; }", "testMethod": "classesWithSuiteMethodsAreFiltered ( ) { int testCount = org . junit . runner . Request . method ( org . junit . tests . manipulation . SingleMethodTest . HasSuiteMethod . class , \"a\" ) . getRunner ( ) . getDescription ( ) . testCount ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testCount , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "classesWithSuiteMethodsAreFiltered ( ) { int testCount = org . junit . runner . Request . method ( org . junit . tests . manipulation . SingleMethodTest . HasSuiteMethod . class , \"a\" ) . getRunner ( ) . getDescription ( ) . testCount ( ) ; \"<AssertPlaceHolder>\" ; } testCount ( ) { org . junit . tests . running . classes . RunWithTest . log += \"count\" ; return 0 ; }", "answer": "org . junit . Assert . assertThat ( testCount , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "build ( org . xwiki . crypto . pkix . params . CertifiedPublicKey , org . xwiki . crypto . pkix . CertificateProvider ) { if ( certificate == null ) { return null ; } java . util . Deque < org . xwiki . crypto . pkix . params . CertifiedPublicKey > result = new java . util . ArrayDeque < org . xwiki . crypto . pkix . params . CertifiedPublicKey > ( ) ; build ( result , certificate , provider ) ; return result ; }", "testMethod": "testValidV1CertificatePath ( ) { java . util . Collection < org . bouncycastle . cert . X509CertificateHolder > certs = new java . util . ArrayList < org . bouncycastle . cert . X509CertificateHolder > ( ) ; certs . add ( org . xwiki . crypto . pkix . internal . BcUtils . getX509CertificateHolder ( v1CaCert ) ) ; org . bouncycastle . util . CollectionStore store = new org . bouncycastle . util . CollectionStore ( certs ) ; org . xwiki . crypto . pkix . CertificateProvider provider = mocker . getInstance ( org . xwiki . crypto . pkix . CertificateProvider . class , \"BCStoreX509\" ) ; ( ( org . xwiki . crypto . pkix . internal . BcStoreX509CertificateProvider ) ( provider ) ) . setStore ( store ) ; java . util . Collection < org . xwiki . crypto . pkix . params . CertifiedPublicKey > chain = builder . build ( v1Cert , provider ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chain , org . hamcrest . Matchers . contains ( v1CaCert , v1Cert ) )", "total": "testValidV1CertificatePath ( ) { java . util . Collection < org . bouncycastle . cert . X509CertificateHolder > certs = new java . util . ArrayList < org . bouncycastle . cert . X509CertificateHolder > ( ) ; certs . add ( org . xwiki . crypto . pkix . internal . BcUtils . getX509CertificateHolder ( v1CaCert ) ) ; org . bouncycastle . util . CollectionStore store = new org . bouncycastle . util . CollectionStore ( certs ) ; org . xwiki . crypto . pkix . CertificateProvider provider = mocker . getInstance ( org . xwiki . crypto . pkix . CertificateProvider . class , \"BCStoreX509\" ) ; ( ( org . xwiki . crypto . pkix . internal . BcStoreX509CertificateProvider ) ( provider ) ) . setStore ( store ) ; java . util . Collection < org . xwiki . crypto . pkix . params . CertifiedPublicKey > chain = builder . build ( v1Cert , provider ) ; \"<AssertPlaceHolder>\" ; } build ( org . xwiki . crypto . pkix . params . CertifiedPublicKey , org . xwiki . crypto . pkix . CertificateProvider ) { if ( certificate == null ) { return null ; } java . util . Deque < org . xwiki . crypto . pkix . params . CertifiedPublicKey > result = new java . util . ArrayDeque < org . xwiki . crypto . pkix . params . CertifiedPublicKey > ( ) ; build ( result , certificate , provider ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( chain , org . hamcrest . Matchers . contains ( v1CaCert , v1Cert ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testSetAttributeMapInvalid ( ) { org . codice . ddf . security . claims . cas . CasClaimsHandler handler = new org . codice . ddf . security . claims . cas . CasClaimsHandler ( ) ; java . util . List < java . lang . String > attributeMapEntries = java . util . Arrays . asList ( \"\" , \"colon:delimiter\" , \"key=value\" ) ; handler . setAttributeMap ( attributeMapEntries ) ; java . util . Map < java . lang . String , java . lang . String > attributeMap = handler . getAttributeMap ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( attributeMap . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testSetAttributeMapInvalid ( ) { org . codice . ddf . security . claims . cas . CasClaimsHandler handler = new org . codice . ddf . security . claims . cas . CasClaimsHandler ( ) ; java . util . List < java . lang . String > attributeMapEntries = java . util . Arrays . asList ( \"\" , \"colon:delimiter\" , \"key=value\" ) ; handler . setAttributeMap ( attributeMapEntries ) ; java . util . Map < java . lang . String , java . lang . String > attributeMap = handler . getAttributeMap ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( attributeMap . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getSelectedCell ( ) { java . lang . String elemClass = driver . findElement ( org . openqa . selenium . By . cssSelector ( \".sheet-selection\" ) ) . getAttribute ( \"class\" ) ; int rowStart = elemClass . indexOf ( \"row\" ) ; if ( rowStart == ( - 1 ) ) { return \"A1\" ; } int k = rowStart + ( \"row\" . length ( ) ) ; java . lang . String rowNumber = \"\" ; while ( k < ( elemClass . length ( ) ) ) { char digit = elemClass . charAt ( k ) ; if ( digit == '<sp>' ) { break ; } rowNumber += elemClass . charAt ( k ) ; k ++ ; } int colStart = elemClass . indexOf ( \"col\" ) ; k = colStart + ( \"col\" . length ( ) ) ; java . lang . String colNumberStr = \"\" ; while ( k < ( elemClass . length ( ) ) ) { char digit = elemClass . charAt ( k ) ; if ( digit == '<sp>' ) { break ; } colNumberStr += elemClass . charAt ( k ) ; k ++ ; } int colNumber = java . lang . Integer . parseInt ( colNumberStr ) ; int dividend = colNumber ; java . lang . String columnName = \"\" ; int modulo ; while ( dividend > 0 ) { modulo = ( dividend - 1 ) % 26 ; columnName = ( ( char ) ( 65 + modulo ) ) + columnName ; dividend = ( dividend - modulo ) / 26 ; } return columnName + rowNumber ; }", "testMethod": "shouldNotChangeCellWhenDoubleClickEditingAndArrowUpKeyIsPressed ( ) { final com . vaadin . addon . spreadsheet . elements . SheetCellElement b2 = spreadSheet . getCellAt ( \"B2\" ) ; b2 . setValue ( \"123\" ) ; sheetController . selectCell ( \"A1\" ) ; sheetController . doubleClickCell ( \"B2\" ) ; new org . openqa . selenium . interactions . Actions ( getDriver ( ) ) . sendKeys ( Keys . ARROW_UP ) . build ( ) . perform ( ) ; java . lang . String selectedCell = sheetController . getSelectedCell ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( selectedCell , org . hamcrest . CoreMatchers . is ( \"B2\" ) )", "total": "shouldNotChangeCellWhenDoubleClickEditingAndArrowUpKeyIsPressed ( ) { final com . vaadin . addon . spreadsheet . elements . SheetCellElement b2 = spreadSheet . getCellAt ( \"B2\" ) ; b2 . setValue ( \"123\" ) ; sheetController . selectCell ( \"A1\" ) ; sheetController . doubleClickCell ( \"B2\" ) ; new org . openqa . selenium . interactions . Actions ( getDriver ( ) ) . sendKeys ( Keys . ARROW_UP ) . build ( ) . perform ( ) ; java . lang . String selectedCell = sheetController . getSelectedCell ( ) ; \"<AssertPlaceHolder>\" ; } getSelectedCell ( ) { java . lang . String elemClass = driver . findElement ( org . openqa . selenium . By . cssSelector ( \".sheet-selection\" ) ) . getAttribute ( \"class\" ) ; int rowStart = elemClass . indexOf ( \"row\" ) ; if ( rowStart == ( - 1 ) ) { return \"A1\" ; } int k = rowStart + ( \"row\" . length ( ) ) ; java . lang . String rowNumber = \"\" ; while ( k < ( elemClass . length ( ) ) ) { char digit = elemClass . charAt ( k ) ; if ( digit == '<sp>' ) { break ; } rowNumber += elemClass . charAt ( k ) ; k ++ ; } int colStart = elemClass . indexOf ( \"col\" ) ; k = colStart + ( \"col\" . length ( ) ) ; java . lang . String colNumberStr = \"\" ; while ( k < ( elemClass . length ( ) ) ) { char digit = elemClass . charAt ( k ) ; if ( digit == '<sp>' ) { break ; } colNumberStr += elemClass . charAt ( k ) ; k ++ ; } int colNumber = java . lang . Integer . parseInt ( colNumberStr ) ; int dividend = colNumber ; java . lang . String columnName = \"\" ; int modulo ; while ( dividend > 0 ) { modulo = ( dividend - 1 ) % 26 ; columnName = ( ( char ) ( 65 + modulo ) ) + columnName ; dividend = ( dividend - modulo ) / 26 ; } return columnName + rowNumber ; }", "answer": "org . junit . Assert . assertThat ( selectedCell , org . hamcrest . CoreMatchers . is ( \"B2\" ) )"}
{"focal": "getTenantId ( ) { return tenantId ; }", "testMethod": "getDecisionDefinitionWithAuthenticatedTenant ( ) { identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyDecisionDefinitionCmdsTenantCheckTest . TENANT_ONE ) ) ; org . camunda . bpm . engine . repository . DecisionDefinition definition = repositoryService . getDecisionDefinition ( decisionDefinitionId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( definition . getTenantId ( ) , org . hamcrest . CoreMatchers . is ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyDecisionDefinitionCmdsTenantCheckTest . TENANT_ONE ) )", "total": "getDecisionDefinitionWithAuthenticatedTenant ( ) { identityService . setAuthentication ( \"user\" , null , java . util . Arrays . asList ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyDecisionDefinitionCmdsTenantCheckTest . TENANT_ONE ) ) ; org . camunda . bpm . engine . repository . DecisionDefinition definition = repositoryService . getDecisionDefinition ( decisionDefinitionId ) ; \"<AssertPlaceHolder>\" ; } getTenantId ( ) { return tenantId ; }", "answer": "org . junit . Assert . assertThat ( definition . getTenantId ( ) , org . hamcrest . CoreMatchers . is ( org . camunda . bpm . engine . test . api . multitenancy . tenantcheck . MultiTenancyDecisionDefinitionCmdsTenantCheckTest . TENANT_ONE ) )"}
{"focal": "getEmail ( ) { return email ; }", "testMethod": "lookup_abuse_contact ( ) { final net . ripe . db . whois . common . rpsl . RpslObject ABUSE_CONTACT_ROLE = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( ( \"role:<sp>Abuse<sp>Contact\\n\" + \"abuse-mailbox:<sp>abuse@test.net\\n\" 6 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 7 ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject ABUSE_CONTACT_ORGANISATION = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( ( ( ( ( ( ( \"organisation:<sp>ORG-RN1-TEST\\n\" + \"193.0.0.1\" 0 ) + \"org-type:<sp>OTHER\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 3 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 0 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 5 ) + \"193.0.0.1\" 1 ) + \"mnt-by:<sp>OWNER-MNT\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 7 ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject ABUSE_CONTACT_INETNUM = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( ( ( ( ( ( ( ( \"abuse-mailbox:<sp>abuse@test.net\\n\" 2 + \"193.0.0.1\" 2 ) + \"descr:<sp>some<sp>description\\n\" ) + \"org:<sp>ORG-RN1-TEST\\n\" ) + \"country:<sp>NL\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 4 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 9 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 1 ) + \"mnt-by:<sp>OWNER-MNT\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 7 ) ) ) ; databaseHelper . addObjects ( ABUSE_CONTACT_ROLE , ABUSE_CONTACT_ORGANISATION , ABUSE_CONTACT_INETNUM ) ; resetIpTrees ( ) ; final net . ripe . db . whois . api . rest . domain . AbuseContact abuseContact = restClient . request ( ) . lookupAbuseContact ( \"193.0.0.1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( abuseContact . getEmail ( ) , org . hamcrest . Matchers . is ( \"abuse-mailbox:<sp>abuse@test.net\\n\" 8 ) )", "total": "lookup_abuse_contact ( ) { final net . ripe . db . whois . common . rpsl . RpslObject ABUSE_CONTACT_ROLE = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( ( \"role:<sp>Abuse<sp>Contact\\n\" + \"abuse-mailbox:<sp>abuse@test.net\\n\" 6 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 7 ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject ABUSE_CONTACT_ORGANISATION = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( ( ( ( ( ( ( \"organisation:<sp>ORG-RN1-TEST\\n\" + \"193.0.0.1\" 0 ) + \"org-type:<sp>OTHER\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 3 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 0 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 5 ) + \"193.0.0.1\" 1 ) + \"mnt-by:<sp>OWNER-MNT\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 7 ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject ABUSE_CONTACT_INETNUM = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( ( ( ( ( ( ( ( \"abuse-mailbox:<sp>abuse@test.net\\n\" 2 + \"193.0.0.1\" 2 ) + \"descr:<sp>some<sp>description\\n\" ) + \"org:<sp>ORG-RN1-TEST\\n\" ) + \"country:<sp>NL\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 4 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 9 ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 1 ) + \"mnt-by:<sp>OWNER-MNT\\n\" ) + \"abuse-mailbox:<sp>abuse@test.net\\n\" 7 ) ) ) ; databaseHelper . addObjects ( ABUSE_CONTACT_ROLE , ABUSE_CONTACT_ORGANISATION , ABUSE_CONTACT_INETNUM ) ; resetIpTrees ( ) ; final net . ripe . db . whois . api . rest . domain . AbuseContact abuseContact = restClient . request ( ) . lookupAbuseContact ( \"193.0.0.1\" ) ; \"<AssertPlaceHolder>\" ; } getEmail ( ) { return email ; }", "answer": "org . junit . Assert . assertThat ( abuseContact . getEmail ( ) , org . hamcrest . Matchers . is ( \"abuse-mailbox:<sp>abuse@test.net\\n\" 8 ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "createAPredefinedClassificationWithAPositionWithoutAnyValues ( ) { com . silverpeas . pdc . model . PdcClassification classification = com . silverpeas . pdc . model . PdcClassification . aPredefinedPdcClassificationForComponentInstance ( com . silverpeas . pdc . web . COMPONENT_INSTANCE_ID ) . forNode ( \"2000\" ) . withPosition ( new com . silverpeas . pdc . model . PdcPosition ( ) ) ; com . sun . jersey . api . client . ClientResponse response = post ( theWebEntityOf ( classification ) , at ( ( ( COMPONENT_DEFAULT_CLASSIFICATION_PATH ) + \"?nodeId=2000\" ) ) ) ; int receivedStatus = response . getStatus ( ) ; int badRequest = Status . BAD_REQUEST . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( receivedStatus , is ( badRequest ) )", "total": "createAPredefinedClassificationWithAPositionWithoutAnyValues ( ) { com . silverpeas . pdc . model . PdcClassification classification = com . silverpeas . pdc . model . PdcClassification . aPredefinedPdcClassificationForComponentInstance ( com . silverpeas . pdc . web . COMPONENT_INSTANCE_ID ) . forNode ( \"2000\" ) . withPosition ( new com . silverpeas . pdc . model . PdcPosition ( ) ) ; com . sun . jersey . api . client . ClientResponse response = post ( theWebEntityOf ( classification ) , at ( ( ( COMPONENT_DEFAULT_CLASSIFICATION_PATH ) + \"?nodeId=2000\" ) ) ) ; int receivedStatus = response . getStatus ( ) ; int badRequest = Status . BAD_REQUEST . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( receivedStatus , is ( badRequest ) )"}
{"focal": "createMoney ( java . lang . String ) { return new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , amount ) ; }", "testMethod": "oneWithdrawalThenOneDepositWithExistingBalanceBeforeInterval ( ) { org . mifos . accounts . savings . interest . EndOfDayDetail september6thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september6th ) . withWithdrawalsOf ( \"500\" ) . build ( ) ; org . mifos . accounts . savings . interest . EndOfDayDetail september13thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september13th ) . withDespoitsOf ( \"550\" ) . build ( ) ; interestCalculationPeriodDetail = withBalanceOnAug31stToSeptember30thCalculationPeriod ( ) . containing ( september6thDetails , september13thDetails ) . build ( ) ; org . mifos . framework . util . helpers . Money minimumBalancePrincipal = calculationStrategy . calculatePrincipal ( interestCalculationPeriodDetail ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( minimumBalancePrincipal , org . hamcrest . CoreMatchers . is ( org . mifos . framework . TestUtils . createMoney ( \"500\" ) ) )", "total": "oneWithdrawalThenOneDepositWithExistingBalanceBeforeInterval ( ) { org . mifos . accounts . savings . interest . EndOfDayDetail september6thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september6th ) . withWithdrawalsOf ( \"500\" ) . build ( ) ; org . mifos . accounts . savings . interest . EndOfDayDetail september13thDetails = new org . mifos . accounts . savings . interest . EndOfDayBuilder ( ) . on ( september13th ) . withDespoitsOf ( \"550\" ) . build ( ) ; interestCalculationPeriodDetail = withBalanceOnAug31stToSeptember30thCalculationPeriod ( ) . containing ( september6thDetails , september13thDetails ) . build ( ) ; org . mifos . framework . util . helpers . Money minimumBalancePrincipal = calculationStrategy . calculatePrincipal ( interestCalculationPeriodDetail ) ; \"<AssertPlaceHolder>\" ; } createMoney ( java . lang . String ) { return new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , amount ) ; }", "answer": "org . junit . Assert . assertThat ( minimumBalancePrincipal , org . hamcrest . CoreMatchers . is ( org . mifos . framework . TestUtils . createMoney ( \"500\" ) ) )"}
{"focal": "getId ( ) { return _id ; }", "testMethod": "testAddProfile ( ) { when ( entityTypeFactory . extractEntityType ( SystemConstants . DEFAULT_PROFILE_TYPE_CODE , org . entando . entando . aps . system . services . userprofile . model . UserProfile . class , configItemName , this . entityTypeDom , userProfileManager . getName ( ) , this . entityDom ) ) . thenReturn ( this . createFakeProfile ( SystemConstants . DEFAULT_PROFILE_TYPE_CODE ) ) ; org . entando . entando . aps . system . services . userprofile . model . IUserProfile userProfile = userProfileManager . getDefaultProfileType ( ) ; java . lang . String name = \"Jack_Bower\" ; com . agiletec . aps . system . common . entity . model . attribute . MonoTextAttribute attribute = ( ( com . agiletec . aps . system . common . entity . model . attribute . MonoTextAttribute ) ( userProfile . getAttribute ( \"Name\" ) ) ) ; attribute . setText ( name ) ; this . userProfileManager . addProfile ( name , userProfile ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( userProfileDAO , org . mockito . Mockito . times ( 1 ) ) . addEntity ( userProfile ) ; org . mockito . Mockito . verify ( notifyManager , org . mockito . Mockito . times ( 1 ) ) . publishEvent ( org . mockito . Mockito . any ( org . entando . entando . aps . system . services . userprofile . event . ProfileChangedEvent . class ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( userProfile . getId ( ) , org . hamcrest . CoreMatchers . is ( name ) )", "total": "testAddProfile ( ) { when ( entityTypeFactory . extractEntityType ( SystemConstants . DEFAULT_PROFILE_TYPE_CODE , org . entando . entando . aps . system . services . userprofile . model . UserProfile . class , configItemName , this . entityTypeDom , userProfileManager . getName ( ) , this . entityDom ) ) . thenReturn ( this . createFakeProfile ( SystemConstants . DEFAULT_PROFILE_TYPE_CODE ) ) ; org . entando . entando . aps . system . services . userprofile . model . IUserProfile userProfile = userProfileManager . getDefaultProfileType ( ) ; java . lang . String name = \"Jack_Bower\" ; com . agiletec . aps . system . common . entity . model . attribute . MonoTextAttribute attribute = ( ( com . agiletec . aps . system . common . entity . model . attribute . MonoTextAttribute ) ( userProfile . getAttribute ( \"Name\" ) ) ) ; attribute . setText ( name ) ; this . userProfileManager . addProfile ( name , userProfile ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( userProfileDAO , org . mockito . Mockito . times ( 1 ) ) . addEntity ( userProfile ) ; org . mockito . Mockito . verify ( notifyManager , org . mockito . Mockito . times ( 1 ) ) . publishEvent ( org . mockito . Mockito . any ( org . entando . entando . aps . system . services . userprofile . event . ProfileChangedEvent . class ) ) ; } getId ( ) { return _id ; }", "answer": "org . junit . Assert . assertThat ( userProfile . getId ( ) , org . hamcrest . CoreMatchers . is ( name ) )"}
{"focal": "size ( ) { return elements . size ( ) ; }", "testMethod": "givenUsersExist_whenFindingUserWithAgeLessThan50AndGreateThan20_thenUsersAreFound ( ) { com . baeldung . model . User user = new com . baeldung . model . User ( ) ; user . setName ( \"Eric\" ) ; user . setAge ( 45 ) ; mongoTemplate . insert ( user ) ; user = new com . baeldung . model . User ( ) ; user . setName ( \"Antony\" ) ; user . setAge ( 55 ) ; mongoTemplate . insert ( user ) ; org . springframework . data . mongodb . core . query . Query query = new org . springframework . data . mongodb . core . query . Query ( ) ; query . addCriteria ( org . springframework . data . mongodb . core . query . Criteria . where ( \"age\" ) . lt ( 50 ) . gt ( 20 ) ) ; java . util . List < com . baeldung . model . User > users = mongoTemplate . find ( query , com . baeldung . model . User . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( users . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "givenUsersExist_whenFindingUserWithAgeLessThan50AndGreateThan20_thenUsersAreFound ( ) { com . baeldung . model . User user = new com . baeldung . model . User ( ) ; user . setName ( \"Eric\" ) ; user . setAge ( 45 ) ; mongoTemplate . insert ( user ) ; user = new com . baeldung . model . User ( ) ; user . setName ( \"Antony\" ) ; user . setAge ( 55 ) ; mongoTemplate . insert ( user ) ; org . springframework . data . mongodb . core . query . Query query = new org . springframework . data . mongodb . core . query . Query ( ) ; query . addCriteria ( org . springframework . data . mongodb . core . query . Criteria . where ( \"age\" ) . lt ( 50 ) . gt ( 20 ) ) ; java . util . List < com . baeldung . model . User > users = mongoTemplate . find ( query , com . baeldung . model . User . class ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elements . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( users . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "shouldResourceBeIncluded ( java . lang . Module , java . net . URL , java . lang . String , java . util . Map ) { boolean include = true ; for ( org . openmrs . module . ModuleConditionalResource conditionalResource : module . getConditionalResources ( ) ) { if ( fileUrl . getPath ( ) . matches ( ( ( \".*\" + ( conditionalResource . getPath ( ) ) ) + \"$\" ) ) ) { include = false ; if ( org . apache . commons . lang3 . StringUtils . isNotBlank ( conditionalResource . getOpenmrsPlatformVersion ( ) ) ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( openmrsVersion , conditionalResource . getOpenmrsPlatformVersion ( ) ) ; if ( ! include ) { return false ; } } if ( ( conditionalResource . getModules ( ) ) != null ) { for ( org . openmrs . module . ModuleConditionalResource . ModuleAndVersion conditionalModuleResource : conditionalResource . getModules ( ) ) { if ( \"!\" . equals ( conditionalModuleResource . getVersion ( ) ) ) { include = ! ( org . openmrs . module . ModuleFactory . isModuleStarted ( conditionalModuleResource . getModuleId ( ) ) ) ; if ( ! include ) { return false ; } } else { java . lang . String moduleVersion = startedRelatedModules . get ( conditionalModuleResource . getModuleId ( ) ) ; if ( moduleVersion != null ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( moduleVersion , conditionalModuleResource . getVersion ( ) ) ; if ( ! include ) { return false ; } } } } } } } return include ; }", "testMethod": "shouldResourceBeIncluded_shouldReturnFalseIfFileMatchesAndModuleVersionDoesNotMatch ( ) { org . openmrs . module . ModuleConditionalResource resource = new org . openmrs . module . ModuleConditionalResource ( ) ; resource . setPath ( \"lib/mockmodule-api-1.10.jar\" ) ; org . openmrs . module . ModuleConditionalResource . ModuleAndVersion module = new org . openmrs . module . ModuleConditionalResource . ModuleAndVersion ( ) ; module . setModuleId ( \"module\" ) ; module . setVersion ( \"1.0-2.0\" ) ; resource . getModules ( ) . add ( module ) ; mockModule . getConditionalResources ( ) . add ( resource ) ; mockModules . put ( \"module\" , \"3.0\" ) ; boolean result = org . openmrs . module . ModuleClassLoader . shouldResourceBeIncluded ( mockModule , java . net . URI . create ( \"file://module/mockmodule/lib/mockmodule-api-1.10.jar\" ) . toURL ( ) , \"1.10.0-SNAPSHOT\" , mockModules ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )", "total": "shouldResourceBeIncluded_shouldReturnFalseIfFileMatchesAndModuleVersionDoesNotMatch ( ) { org . openmrs . module . ModuleConditionalResource resource = new org . openmrs . module . ModuleConditionalResource ( ) ; resource . setPath ( \"lib/mockmodule-api-1.10.jar\" ) ; org . openmrs . module . ModuleConditionalResource . ModuleAndVersion module = new org . openmrs . module . ModuleConditionalResource . ModuleAndVersion ( ) ; module . setModuleId ( \"module\" ) ; module . setVersion ( \"1.0-2.0\" ) ; resource . getModules ( ) . add ( module ) ; mockModule . getConditionalResources ( ) . add ( resource ) ; mockModules . put ( \"module\" , \"3.0\" ) ; boolean result = org . openmrs . module . ModuleClassLoader . shouldResourceBeIncluded ( mockModule , java . net . URI . create ( \"file://module/mockmodule/lib/mockmodule-api-1.10.jar\" ) . toURL ( ) , \"1.10.0-SNAPSHOT\" , mockModules ) ; \"<AssertPlaceHolder>\" ; } shouldResourceBeIncluded ( java . lang . Module , java . net . URL , java . lang . String , java . util . Map ) { boolean include = true ; for ( org . openmrs . module . ModuleConditionalResource conditionalResource : module . getConditionalResources ( ) ) { if ( fileUrl . getPath ( ) . matches ( ( ( \".*\" + ( conditionalResource . getPath ( ) ) ) + \"$\" ) ) ) { include = false ; if ( org . apache . commons . lang3 . StringUtils . isNotBlank ( conditionalResource . getOpenmrsPlatformVersion ( ) ) ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( openmrsVersion , conditionalResource . getOpenmrsPlatformVersion ( ) ) ; if ( ! include ) { return false ; } } if ( ( conditionalResource . getModules ( ) ) != null ) { for ( org . openmrs . module . ModuleConditionalResource . ModuleAndVersion conditionalModuleResource : conditionalResource . getModules ( ) ) { if ( \"!\" . equals ( conditionalModuleResource . getVersion ( ) ) ) { include = ! ( org . openmrs . module . ModuleFactory . isModuleStarted ( conditionalModuleResource . getModuleId ( ) ) ) ; if ( ! include ) { return false ; } } else { java . lang . String moduleVersion = startedRelatedModules . get ( conditionalModuleResource . getModuleId ( ) ) ; if ( moduleVersion != null ) { include = org . openmrs . module . ModuleUtil . matchRequiredVersions ( moduleVersion , conditionalModuleResource . getVersion ( ) ) ; if ( ! include ) { return false ; } } } } } } } return include ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "queryForList ( com . github . vanroy . springdata . jest . SearchQuery , java . lang . Class ) { return queryForPage ( query , clazz ) . getContent ( ) ; }", "testMethod": "shouldDeleteGivenCriteriaQuery ( ) { java . lang . String documentId = java . lang . String . valueOf ( java . util . concurrent . ThreadLocalRandom . current ( ) . nextLong ( ) ) . substring ( 1 , 6 ) ; com . github . vanroy . springdata . jest . SampleEntity sampleEntity = com . github . vanroy . springdata . jest . SampleEntity . builder ( ) . id ( documentId ) . message ( \"test<sp>message\" ) . version ( java . lang . System . currentTimeMillis ( ) ) . build ( ) ; com . github . vanroy . springdata . jest . IndexQuery indexQuery = getIndexQuery ( sampleEntity ) ; elasticsearchTemplate . index ( indexQuery ) ; elasticsearchTemplate . refresh ( com . github . vanroy . springdata . jest . SampleEntity . class ) ; com . github . vanroy . springdata . jest . CriteriaQuery criteriaQuery = new com . github . vanroy . springdata . jest . CriteriaQuery ( new com . github . vanroy . springdata . jest . Criteria ( \"message\" ) . contains ( \"test\" ) ) ; elasticsearchTemplate . delete ( criteriaQuery , com . github . vanroy . springdata . jest . SampleEntity . class ) ; elasticsearchTemplate . refresh ( com . github . vanroy . springdata . jest . SampleEntity . class ) ; com . github . vanroy . springdata . jest . StringQuery stringQuery = new com . github . vanroy . springdata . jest . StringQuery ( matchAllQuery ( ) . toString ( ) ) ; com . github . vanroy . springdata . jest . List < com . github . vanroy . springdata . jest . SampleEntity > sampleEntities = elasticsearchTemplate . queryForList ( stringQuery , com . github . vanroy . springdata . jest . SampleEntity . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sampleEntities . size ( ) , is ( 0 ) )", "total": "shouldDeleteGivenCriteriaQuery ( ) { java . lang . String documentId = java . lang . String . valueOf ( java . util . concurrent . ThreadLocalRandom . current ( ) . nextLong ( ) ) . substring ( 1 , 6 ) ; com . github . vanroy . springdata . jest . SampleEntity sampleEntity = com . github . vanroy . springdata . jest . SampleEntity . builder ( ) . id ( documentId ) . message ( \"test<sp>message\" ) . version ( java . lang . System . currentTimeMillis ( ) ) . build ( ) ; com . github . vanroy . springdata . jest . IndexQuery indexQuery = getIndexQuery ( sampleEntity ) ; elasticsearchTemplate . index ( indexQuery ) ; elasticsearchTemplate . refresh ( com . github . vanroy . springdata . jest . SampleEntity . class ) ; com . github . vanroy . springdata . jest . CriteriaQuery criteriaQuery = new com . github . vanroy . springdata . jest . CriteriaQuery ( new com . github . vanroy . springdata . jest . Criteria ( \"message\" ) . contains ( \"test\" ) ) ; elasticsearchTemplate . delete ( criteriaQuery , com . github . vanroy . springdata . jest . SampleEntity . class ) ; elasticsearchTemplate . refresh ( com . github . vanroy . springdata . jest . SampleEntity . class ) ; com . github . vanroy . springdata . jest . StringQuery stringQuery = new com . github . vanroy . springdata . jest . StringQuery ( matchAllQuery ( ) . toString ( ) ) ; com . github . vanroy . springdata . jest . List < com . github . vanroy . springdata . jest . SampleEntity > sampleEntities = elasticsearchTemplate . queryForList ( stringQuery , com . github . vanroy . springdata . jest . SampleEntity . class ) ; \"<AssertPlaceHolder>\" ; } queryForList ( com . github . vanroy . springdata . jest . SearchQuery , java . lang . Class ) { return queryForPage ( query , clazz ) . getContent ( ) ; }", "answer": "org . junit . Assert . assertThat ( sampleEntities . size ( ) , is ( 0 ) )"}
{"focal": "hasPermission ( org . bukkit . command . CommandSender , me . gnat008 . perworldinventory . permission . PermissionNode ) { if ( node == null ) return true ; if ( ( ! ( sender instanceof org . bukkit . entity . Player ) ) || ( ! ( usingPermissionsPlugin ) ) ) return node . getDefaultPermission ( ) . evaluate ( sender ) ; org . bukkit . entity . Player player = ( ( org . bukkit . entity . Player ) ( sender ) ) ; return player . hasPermission ( node . getNode ( ) ) ; }", "testMethod": "shouldGrantToNonOpPlayer ( ) { me . gnat008 . perworldinventory . permission . PermissionNode node = TestPermissions . HELP ; org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; boolean result = permissionManager . hasPermission ( player , node ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldGrantToNonOpPlayer ( ) { me . gnat008 . perworldinventory . permission . PermissionNode node = TestPermissions . HELP ; org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; boolean result = permissionManager . hasPermission ( player , node ) ; \"<AssertPlaceHolder>\" ; } hasPermission ( org . bukkit . command . CommandSender , me . gnat008 . perworldinventory . permission . PermissionNode ) { if ( node == null ) return true ; if ( ( ! ( sender instanceof org . bukkit . entity . Player ) ) || ( ! ( usingPermissionsPlugin ) ) ) return node . getDefaultPermission ( ) . evaluate ( sender ) ; org . bukkit . entity . Player player = ( ( org . bukkit . entity . Player ) ( sender ) ) ; return player . hasPermission ( node . getNode ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "setExceptionMappings ( java . util . LinkedHashMap ) { this . exceptionMappings = exceptionMappings ; }", "testMethod": "testResolveExceptionCode_systemexception_not_exists_code ( ) { java . util . LinkedHashMap < java . lang . String , java . lang . String > exceptionMappings = new java . util . LinkedHashMap < java . lang . String , java . lang . String > ( ) ; exceptionMappings . put ( \"SystemException\" , \"sys001\" ) ; testTarget . setExceptionMappings ( exceptionMappings ) ; java . lang . String actualExceptionCode = testTarget . resolveExceptionCode ( new org . terasoluna . gfw . common . exception . SystemException ( null , \"testmessage001\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualExceptionCode , org . hamcrest . CoreMatchers . is ( \"sys001\" ) )", "total": "testResolveExceptionCode_systemexception_not_exists_code ( ) { java . util . LinkedHashMap < java . lang . String , java . lang . String > exceptionMappings = new java . util . LinkedHashMap < java . lang . String , java . lang . String > ( ) ; exceptionMappings . put ( \"SystemException\" , \"sys001\" ) ; testTarget . setExceptionMappings ( exceptionMappings ) ; java . lang . String actualExceptionCode = testTarget . resolveExceptionCode ( new org . terasoluna . gfw . common . exception . SystemException ( null , \"testmessage001\" ) ) ; \"<AssertPlaceHolder>\" ; } setExceptionMappings ( java . util . LinkedHashMap ) { this . exceptionMappings = exceptionMappings ; }", "answer": "org . junit . Assert . assertThat ( actualExceptionCode , org . hamcrest . CoreMatchers . is ( \"sys001\" ) )"}
{"focal": "compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "testMethod": "flattenAfterPipe ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , FlattenArray ( ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo<sp>|<sp>[]\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "flattenAfterPipe ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , FlattenArray ( ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo<sp>|<sp>[]\" ) ; \"<AssertPlaceHolder>\" ; } compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "isEmpty_A$ ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > target = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; boolean actual = target . isEmpty ( ) ; boolean expected = true ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isEmpty_A$ ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > target = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; boolean actual = target . isEmpty ( ) ; boolean expected = true ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "getName ( ) { return java . util . Optional . ofNullable ( name ) ; }", "testMethod": "dumpActual_file ( ) { java . io . File file = new java . io . File ( folder . getRoot ( ) , \"testing\" ) ; com . asakusafw . testdriver . MockDataModelSink sink = new com . asakusafw . testdriver . MockDataModelSink ( ) ; com . asakusafw . testdriver . MockFlowDriverOutput < org . apache . hadoop . io . Text > mock = com . asakusafw . testdriver . MockFlowDriverOutput . text ( getClass ( ) , new com . asakusafw . testdriver . MockTestDataToolProvider ( ) { @ com . asakusafw . testdriver . Override public com . asakusafw . testdriver . core . DataModelSinkFactory getDataModelSinkFactory ( java . net . URI uri ) { \"<AssertPlaceHolder>\" ; return new com . asakusafw . testdriver . core . DataModelSinkFactory ( ) { @ com . asakusafw . testdriver . Override public < T > com . asakusafw . testdriver . core . DataModelSink createSink ( com . asakusafw . testdriver . core . DataModelDefinition < T > definition , com . asakusafw . testdriver . core . TestContext context ) { return sink ; } } ; } } ) ; mock . dumpActual ( file ) ; checkInstance ( mock . getResultSink ( ) , sink ) ; }", "assertLine": "org . junit . Assert . assertThat ( new java . io . File ( uri ) . getName ( ) , is ( file . getName ( ) ) )", "total": "dumpActual_file ( ) { java . io . File file = new java . io . File ( folder . getRoot ( ) , \"testing\" ) ; com . asakusafw . testdriver . MockDataModelSink sink = new com . asakusafw . testdriver . MockDataModelSink ( ) ; com . asakusafw . testdriver . MockFlowDriverOutput < org . apache . hadoop . io . Text > mock = com . asakusafw . testdriver . MockFlowDriverOutput . text ( getClass ( ) , new com . asakusafw . testdriver . MockTestDataToolProvider ( ) { @ com . asakusafw . testdriver . Override public com . asakusafw . testdriver . core . DataModelSinkFactory getDataModelSinkFactory ( java . net . URI uri ) { \"<AssertPlaceHolder>\" ; return new com . asakusafw . testdriver . core . DataModelSinkFactory ( ) { @ com . asakusafw . testdriver . Override public < T > com . asakusafw . testdriver . core . DataModelSink createSink ( com . asakusafw . testdriver . core . DataModelDefinition < T > definition , com . asakusafw . testdriver . core . TestContext context ) { return sink ; } } ; } } ) ; mock . dumpActual ( file ) ; checkInstance ( mock . getResultSink ( ) , sink ) ; } getName ( ) { return java . util . Optional . ofNullable ( name ) ; }", "answer": "org . junit . Assert . assertThat ( new java . io . File ( uri ) . getName ( ) , is ( file . getName ( ) ) )"}
{"focal": "aCollectionWithSize ( int ) { return new org . hamcrest . TypeSafeMatcher < java . util . Collection > ( ) { @ com . eviware . soapui . utils . Override public boolean matchesSafely ( java . util . Collection collection ) { return ( collection != null ) && ( ( collection . size ( ) ) == size ) ; } @ com . eviware . soapui . utils . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( ( ( \"a<sp>collection<sp>with<sp>\" + size ) + \"<sp>elements\" ) ) ; } } ; }", "testMethod": "canRemoveScriptFromEditor ( ) { removeInputPanel ( \"Input<sp>panel<sp>2\" ) ; java . util . List < java . lang . String > javaScripts = editor . getJavaScripts ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( javaScripts , org . hamcrest . core . Is . is ( aCollectionWithSize ( 1 ) ) )", "total": "canRemoveScriptFromEditor ( ) { removeInputPanel ( \"Input<sp>panel<sp>2\" ) ; java . util . List < java . lang . String > javaScripts = editor . getJavaScripts ( ) ; \"<AssertPlaceHolder>\" ; } aCollectionWithSize ( int ) { return new org . hamcrest . TypeSafeMatcher < java . util . Collection > ( ) { @ com . eviware . soapui . utils . Override public boolean matchesSafely ( java . util . Collection collection ) { return ( collection != null ) && ( ( collection . size ( ) ) == size ) ; } @ com . eviware . soapui . utils . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( ( ( \"a<sp>collection<sp>with<sp>\" + size ) + \"<sp>elements\" ) ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( javaScripts , org . hamcrest . core . Is . is ( aCollectionWithSize ( 1 ) ) )"}
{"focal": "getRating ( ) { return rating ; }", "testMethod": "whenUpdateView_thenViewShouldReflectChanges ( ) { attribute . updateView ( view , newRating , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( view . getRating ( ) , org . hamcrest . CoreMatchers . equalTo ( ( ( float ) ( newRating ) ) ) )", "total": "whenUpdateView_thenViewShouldReflectChanges ( ) { attribute . updateView ( view , newRating , null ) ; \"<AssertPlaceHolder>\" ; } getRating ( ) { return rating ; }", "answer": "org . junit . Assert . assertThat ( view . getRating ( ) , org . hamcrest . CoreMatchers . equalTo ( ( ( float ) ( newRating ) ) ) )"}
{"focal": "isStrict ( ) { return strict ; }", "testMethod": "strictParameterIsMaintainedIfNotSpecified ( ) { params . setStrict ( true ) ; params . overrideStrict ( new com . github . timm . cucumber . options . RuntimeOptions ( \"--glue<sp>somewhere,somewhere.else\" ) . isStrict ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( params . isStrict ( ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "strictParameterIsMaintainedIfNotSpecified ( ) { params . setStrict ( true ) ; params . overrideStrict ( new com . github . timm . cucumber . options . RuntimeOptions ( \"--glue<sp>somewhere,somewhere.else\" ) . isStrict ( ) ) ; \"<AssertPlaceHolder>\" ; } isStrict ( ) { return strict ; }", "answer": "org . junit . Assert . assertThat ( params . isStrict ( ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "getPageSize ( ) { return this . pageSize ; }", "testMethod": "shouldGetPageSizeIfSpecified ( ) { this . uiPagedData . setPageSize ( 12 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . uiPagedData . getPageSize ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 12 ) ) )", "total": "shouldGetPageSizeIfSpecified ( ) { this . uiPagedData . setPageSize ( 12 ) ; \"<AssertPlaceHolder>\" ; } getPageSize ( ) { return this . pageSize ; }", "answer": "org . junit . Assert . assertThat ( this . uiPagedData . getPageSize ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 12 ) ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "input ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"Hello,<sp>world!\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"Hello,<sp>world!\" } } ) )", "total": "input ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"Hello,<sp>world!\" } } ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"Hello,<sp>world!\" } } ) )"}
{"focal": "evaluate ( org . apache . hadoop . hive . serde2 . io . HiveDecimalWritable ) { if ( ( ( i == null ) || ( ! ( i . isShort ( ) ) ) ) || ( ! ( i . isShort ( ) ) ) ) { return null ; } else { shortWritable . set ( i . shortValue ( ) ) ; return shortWritable ; } }", "testMethod": "evaluate_UnionAndTagArguments_MatchesTag ( ) { when ( unionOI . getObjectInspectors ( ) ) . thenReturn ( com . google . common . collect . ImmutableList . < org . apache . hadoop . hive . serde2 . objectinspector . ObjectInspector > of ( PrimitiveObjectInspectorFactory . writableStringObjectInspector , PrimitiveObjectInspectorFactory . writableLongObjectInspector ) ) ; when ( tagOI . getWritableConstantValue ( ) ) . thenReturn ( new org . apache . hadoop . io . IntWritable ( 0 ) ) ; when ( deferredObject . get ( ) ) . thenReturn ( value ) ; when ( unionOI . getTag ( value ) ) . thenReturn ( ( ( byte ) ( 0 ) ) ) ; when ( unionOI . getField ( value ) ) . thenReturn ( \"foo\" ) ; underTest . initialize ( new org . apache . hadoop . hive . serde2 . objectinspector . ObjectInspector [ ] { unionOI , tagOI } ) ; java . lang . Object result = underTest . evaluate ( new org . apache . hadoop . hive . ql . udf . generic . GenericUDF . DeferredObject [ ] { deferredObject } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( ( ( java . lang . Object ) ( \"foo\" ) ) ) )", "total": "evaluate_UnionAndTagArguments_MatchesTag ( ) { when ( unionOI . getObjectInspectors ( ) ) . thenReturn ( com . google . common . collect . ImmutableList . < org . apache . hadoop . hive . serde2 . objectinspector . ObjectInspector > of ( PrimitiveObjectInspectorFactory . writableStringObjectInspector , PrimitiveObjectInspectorFactory . writableLongObjectInspector ) ) ; when ( tagOI . getWritableConstantValue ( ) ) . thenReturn ( new org . apache . hadoop . io . IntWritable ( 0 ) ) ; when ( deferredObject . get ( ) ) . thenReturn ( value ) ; when ( unionOI . getTag ( value ) ) . thenReturn ( ( ( byte ) ( 0 ) ) ) ; when ( unionOI . getField ( value ) ) . thenReturn ( \"foo\" ) ; underTest . initialize ( new org . apache . hadoop . hive . serde2 . objectinspector . ObjectInspector [ ] { unionOI , tagOI } ) ; java . lang . Object result = underTest . evaluate ( new org . apache . hadoop . hive . ql . udf . generic . GenericUDF . DeferredObject [ ] { deferredObject } ) ; \"<AssertPlaceHolder>\" ; } evaluate ( org . apache . hadoop . hive . serde2 . io . HiveDecimalWritable ) { if ( ( ( i == null ) || ( ! ( i . isShort ( ) ) ) ) || ( ! ( i . isShort ( ) ) ) ) { return null ; } else { shortWritable . set ( i . shortValue ( ) ) ; return shortWritable ; } }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( ( ( java . lang . Object ) ( \"foo\" ) ) ) )"}
{"focal": "dimensionsForPages ( float , float ) { return new com . exigeninsurance . x4j . analytic . xlsx . transform . pdf . DocumentPageDimensionsMatcher ( expectedWidth , expectedHeight ) ; }", "testMethod": "pageStretchingWithMargins ( ) { renderer = createRenderer ( 10 , 10 ) ; renderer . setLeftHorizontalMargin ( 1 ) ; renderer . setRightHorizontalMargin ( 1 ) ; renderer . scalePageSizeTo ( 10 ) ; renderer . renderCurrentPage ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( document , com . exigeninsurance . x4j . analytic . xlsx . transform . pdf . DocumentPageDimensionsMatcher . dimensionsForPages ( 12 , 12 ) )", "total": "pageStretchingWithMargins ( ) { renderer = createRenderer ( 10 , 10 ) ; renderer . setLeftHorizontalMargin ( 1 ) ; renderer . setRightHorizontalMargin ( 1 ) ; renderer . scalePageSizeTo ( 10 ) ; renderer . renderCurrentPage ( ) ; \"<AssertPlaceHolder>\" ; } dimensionsForPages ( float , float ) { return new com . exigeninsurance . x4j . analytic . xlsx . transform . pdf . DocumentPageDimensionsMatcher ( expectedWidth , expectedHeight ) ; }", "answer": "org . junit . Assert . assertThat ( document , com . exigeninsurance . x4j . analytic . xlsx . transform . pdf . DocumentPageDimensionsMatcher . dimensionsForPages ( 12 , 12 ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "getProfileWithNavigationForUser ( ) { final java . util . List < org . bonitasoft . engine . profile . Profile > profiles = getProfileAPI ( ) . getProfilesWithNavigationForUser ( user1 . getId ( ) , 0 , 10 , ProfileCriterion . NAME_ASC ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . extracting ( \"name\" ) . containsExactlyInAnyOrder ( \"Administrator\" , \"User\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( profiles )", "total": "getProfileWithNavigationForUser ( ) { final java . util . List < org . bonitasoft . engine . profile . Profile > profiles = getProfileAPI ( ) . getProfilesWithNavigationForUser ( user1 . getId ( ) , 0 , 10 , ProfileCriterion . NAME_ASC ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . extracting ( \"name\" ) . containsExactlyInAnyOrder ( \"Administrator\" , \"User\" ) ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( profiles )"}
{"focal": "validate ( com . spotify . helios . common . descriptors . Job ) { final java . util . Set < java . lang . String > errors = com . google . common . collect . Sets . newHashSet ( ) ; errors . addAll ( validateJobId ( job ) ) ; errors . addAll ( validateJobImage ( job . getImage ( ) ) ) ; errors . addAll ( validateJobHostName ( job . getHostname ( ) ) ) ; final java . util . Set < java . lang . Integer > externalPorts = com . google . common . collect . Sets . newHashSet ( ) ; for ( final com . spotify . helios . common . descriptors . PortMapping mapping : job . getPorts ( ) . values ( ) ) { final java . lang . Integer externalMappedPort = mapping . getExternalPort ( ) ; if ( ( externalPorts . contains ( externalMappedPort ) ) && ( externalMappedPort != null ) ) { errors . add ( java . lang . String . format ( \"/a\" 9 , externalMappedPort ) ) ; } externalPorts . add ( externalMappedPort ) ; } for ( final Map . Entry < java . lang . String , com . spotify . helios . common . descriptors . PortMapping > entry : job . getPorts ( ) . entrySet ( ) ) { final java . lang . String name = entry . getKey ( ) ; final com . spotify . helios . common . descriptors . PortMapping mapping = entry . getValue ( ) ; if ( ! ( com . spotify . helios . common . JobValidator . PORT_MAPPING_PROTO_PATTERN . matcher ( mapping . getProtocol ( ) ) . matches ( ) ) ) { errors . add ( java . lang . String . format ( \"/a\" 6 , mapping . getProtocol ( ) ) ) ; } if ( ! ( legalPort ( mapping . getInternalPort ( ) ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>internal<sp>port:<sp>%d\" , mapping . getInternalPort ( ) ) ) ; } if ( ( ( mapping . getExternalPort ( ) ) != null ) && ( ! ( legalPort ( mapping . getExternalPort ( ) ) ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>external<sp>port:<sp>%d\" , mapping . getExternalPort ( ) ) ) ; } if ( ! ( com . spotify . helios . common . JobValidator . PORT_MAPPING_NAME_PATTERN . matcher ( name ) . matches ( ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>port<sp>mapping<sp>endpoint<sp>name:<sp>%s\" , name ) ) ; } } for ( final com . spotify . helios . common . descriptors . ServiceEndpoint registration : job . getRegistration ( ) . keySet ( ) ) { final com . spotify . helios . common . descriptors . ServicePorts servicePorts = job . getRegistration ( ) . get ( registration ) ; if ( ( servicePorts == null ) || ( ( servicePorts . getPorts ( ) ) == null ) ) { errors . add ( java . lang . String . format ( \"/a\" 3 , registration . getName ( ) ) ) ; continue ; } for ( final java . lang . String portName : servicePorts . getPorts ( ) . keySet ( ) ) { if ( ! ( job . getPorts ( ) . containsKey ( portName ) ) ) { errors . add ( java . lang . String . format ( \"/a\" 4 , registration , portName ) ) ; } if ( ! ( com . spotify . helios . common . JobValidator . REGISTRATION_NAME_PATTERN . matcher ( registration . getName ( ) ) . matches ( ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>service<sp>registration<sp>name:<sp>%s\" , registration . getName ( ) ) ) ; } } } for ( final Map . Entry < java . lang . String , java . lang . String > entry : job . getVolumes ( ) . entrySet ( ) ) { final java . lang . String path = entry . getKey ( ) ; final java . lang . String source = entry . getValue ( ) ; if ( ! ( path . startsWith ( \"/a\" 8 ) ) ) { errors . add ( ( \"Volume<sp>path<sp>is<sp>not<sp>absolute:<sp>\" + path ) ) ; continue ; } if ( ( source . contains ( \"/a\" 8 ) ) && ( ! ( source . startsWith ( \"/a\" 8 ) ) ) ) { errors . add ( ( \"/a\" 1 + source ) ) ; continue ; } final java . lang . String [ ] parts = path . split ( \"/a\" 0 , 3 ) ; if ( ( ( ( path . isEmpty ( ) ) || ( path . equals ( \"/a\" 8 ) ) ) || ( ( parts . length ) > 2 ) ) || ( ( ( parts . length ) > 1 ) && ( parts [ 1 ] . isEmpty ( ) ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>volume<sp>path:<sp>%s\" , path ) ) ; } } final java . util . Date expiry = job . getExpires ( ) ; final java . util . Date now = new java . util . Date ( ) ; if ( ( expiry != null ) && ( expiry . before ( now ) ) ) { errors", "testMethod": "testImageNameWithManyNameComponents ( ) { final com . spotify . helios . common . descriptors . Job job = com . spotify . helios . common . JobValidatorTest . VALID_JOB . toBuilder ( ) . setImage ( \"b.gcr.io/cloudsql-docker/and/more/components/gce-proxy:1.05\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( validator . validate ( job ) , org . hamcrest . core . Is . is ( org . hamcrest . Matchers . empty ( ) ) )", "total": "testImageNameWithManyNameComponents ( ) { final com . spotify . helios . common . descriptors . Job job = com . spotify . helios . common . JobValidatorTest . VALID_JOB . toBuilder ( ) . setImage ( \"b.gcr.io/cloudsql-docker/and/more/components/gce-proxy:1.05\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } validate ( com . spotify . helios . common . descriptors . Job ) { final java . util . Set < java . lang . String > errors = com . google . common . collect . Sets . newHashSet ( ) ; errors . addAll ( validateJobId ( job ) ) ; errors . addAll ( validateJobImage ( job . getImage ( ) ) ) ; errors . addAll ( validateJobHostName ( job . getHostname ( ) ) ) ; final java . util . Set < java . lang . Integer > externalPorts = com . google . common . collect . Sets . newHashSet ( ) ; for ( final com . spotify . helios . common . descriptors . PortMapping mapping : job . getPorts ( ) . values ( ) ) { final java . lang . Integer externalMappedPort = mapping . getExternalPort ( ) ; if ( ( externalPorts . contains ( externalMappedPort ) ) && ( externalMappedPort != null ) ) { errors . add ( java . lang . String . format ( \"/a\" 9 , externalMappedPort ) ) ; } externalPorts . add ( externalMappedPort ) ; } for ( final Map . Entry < java . lang . String , com . spotify . helios . common . descriptors . PortMapping > entry : job . getPorts ( ) . entrySet ( ) ) { final java . lang . String name = entry . getKey ( ) ; final com . spotify . helios . common . descriptors . PortMapping mapping = entry . getValue ( ) ; if ( ! ( com . spotify . helios . common . JobValidator . PORT_MAPPING_PROTO_PATTERN . matcher ( mapping . getProtocol ( ) ) . matches ( ) ) ) { errors . add ( java . lang . String . format ( \"/a\" 6 , mapping . getProtocol ( ) ) ) ; } if ( ! ( legalPort ( mapping . getInternalPort ( ) ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>internal<sp>port:<sp>%d\" , mapping . getInternalPort ( ) ) ) ; } if ( ( ( mapping . getExternalPort ( ) ) != null ) && ( ! ( legalPort ( mapping . getExternalPort ( ) ) ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>external<sp>port:<sp>%d\" , mapping . getExternalPort ( ) ) ) ; } if ( ! ( com . spotify . helios . common . JobValidator . PORT_MAPPING_NAME_PATTERN . matcher ( name ) . matches ( ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>port<sp>mapping<sp>endpoint<sp>name:<sp>%s\" , name ) ) ; } } for ( final com . spotify . helios . common . descriptors . ServiceEndpoint registration : job . getRegistration ( ) . keySet ( ) ) { final com . spotify . helios . common . descriptors . ServicePorts servicePorts = job . getRegistration ( ) . get ( registration ) ; if ( ( servicePorts == null ) || ( ( servicePorts . getPorts ( ) ) == null ) ) { errors . add ( java . lang . String . format ( \"/a\" 3 , registration . getName ( ) ) ) ; continue ; } for ( final java . lang . String portName : servicePorts . getPorts ( ) . keySet ( ) ) { if ( ! ( job . getPorts ( ) . containsKey ( portName ) ) ) { errors . add ( java . lang . String . format ( \"/a\" 4 , registration , portName ) ) ; } if ( ! ( com . spotify . helios . common . JobValidator . REGISTRATION_NAME_PATTERN . matcher ( registration . getName ( ) ) . matches ( ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>service<sp>registration<sp>name:<sp>%s\" , registration . getName ( ) ) ) ; } } } for ( final Map . Entry < java . lang . String , java . lang . String > entry : job . getVolumes ( ) . entrySet ( ) ) { final java . lang . String path = entry . getKey ( ) ; final java . lang . String source = entry . getValue ( ) ; if ( ! ( path . startsWith ( \"/a\" 8 ) ) ) { errors . add ( ( \"Volume<sp>path<sp>is<sp>not<sp>absolute:<sp>\" + path ) ) ; continue ; } if ( ( source . contains ( \"/a\" 8 ) ) && ( ! ( source . startsWith ( \"/a\" 8 ) ) ) ) { errors . add ( ( \"/a\" 1 + source ) ) ; continue ; } final java . lang . String [ ] parts = path . split ( \"/a\" 0 , 3 ) ; if ( ( ( ( path . isEmpty ( ) ) || ( path . equals ( \"/a\" 8 ) ) ) || ( ( parts . length ) > 2 ) ) || ( ( ( parts . length ) > 1 ) && ( parts [ 1 ] . isEmpty ( ) ) ) ) { errors . add ( java . lang . String . format ( \"Invalid<sp>volume<sp>path:<sp>%s\" , path ) ) ; } } final java . util . Date expiry = job . getExpires ( ) ; final java . util . Date now = new java . util . Date ( ) ; if ( ( expiry != null ) && ( expiry . before ( now ) ) ) { errors", "answer": "org . junit . Assert . assertThat ( validator . validate ( job ) , org . hamcrest . core . Is . is ( org . hamcrest . Matchers . empty ( ) ) )"}
{"focal": "throttledUntil ( java . lang . Object , javax . servlet . http . HttpServletRequest ) { if ( alwaysThrottle ( request ) ) return java . time . Instant . MAX ; if ( shouldBypassThrottling ( request ) ) return java . time . Instant . MIN ; return internalThrottledUntil ( bucket , request ) ; }", "testMethod": "requestsAlwaysThrottledWhenAlwaysThrottleParamIsPresent ( ) { org . wikidata . query . rdf . blazegraph . throttling . ThrottlerUnitTest . ThrottlerImpl throttler = new org . wikidata . query . rdf . blazegraph . throttling . ThrottlerUnitTest . ThrottlerImpl ( cache ) ; org . springframework . mock . web . MockHttpServletRequest request = org . wikidata . query . rdf . blazegraph . throttling . ThrottlingTestUtils . createRequest ( \"UA1\" , \"1.2.3.4\" ) ; request . addParameter ( \"throttleMeParam\" , \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( throttler . throttledUntil ( new java . lang . Object ( ) , request ) , org . hamcrest . Matchers . equalTo ( Instant . MAX ) )", "total": "requestsAlwaysThrottledWhenAlwaysThrottleParamIsPresent ( ) { org . wikidata . query . rdf . blazegraph . throttling . ThrottlerUnitTest . ThrottlerImpl throttler = new org . wikidata . query . rdf . blazegraph . throttling . ThrottlerUnitTest . ThrottlerImpl ( cache ) ; org . springframework . mock . web . MockHttpServletRequest request = org . wikidata . query . rdf . blazegraph . throttling . ThrottlingTestUtils . createRequest ( \"UA1\" , \"1.2.3.4\" ) ; request . addParameter ( \"throttleMeParam\" , \"\" ) ; \"<AssertPlaceHolder>\" ; } throttledUntil ( java . lang . Object , javax . servlet . http . HttpServletRequest ) { if ( alwaysThrottle ( request ) ) return java . time . Instant . MAX ; if ( shouldBypassThrottling ( request ) ) return java . time . Instant . MIN ; return internalThrottledUntil ( bucket , request ) ; }", "answer": "org . junit . Assert . assertThat ( throttler . throttledUntil ( new java . lang . Object ( ) , request ) , org . hamcrest . Matchers . equalTo ( Instant . MAX ) )"}
{"focal": "listHosts ( java . lang . String ) { return listHosts ( com . google . common . collect . ImmutableMultimap . of ( \"namePattern\" , namePattern ) ) ; }", "testMethod": "listHostsFilterByNamePattern ( ) { final java . util . List < java . lang . String > hosts = com . google . common . collect . ImmutableList . of ( \"foo1\" , \"foo2\" , \"foo3\" ) ; mockResponse ( \"GET\" , org . hamcrest . Matchers . allOf ( com . spotify . helios . client . HeliosClientTest . hasPath ( \"/hosts/\" ) , com . spotify . helios . client . HeliosClientTest . containsQuery ( \"namePattern=foo\" ) ) , com . spotify . helios . client . HeliosClientTest . response ( \"GET\" , 200 , hosts ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( client . listHosts ( \"foo\" ) . get ( ) , org . hamcrest . Matchers . equalTo ( hosts ) )", "total": "listHostsFilterByNamePattern ( ) { final java . util . List < java . lang . String > hosts = com . google . common . collect . ImmutableList . of ( \"foo1\" , \"foo2\" , \"foo3\" ) ; mockResponse ( \"GET\" , org . hamcrest . Matchers . allOf ( com . spotify . helios . client . HeliosClientTest . hasPath ( \"/hosts/\" ) , com . spotify . helios . client . HeliosClientTest . containsQuery ( \"namePattern=foo\" ) ) , com . spotify . helios . client . HeliosClientTest . response ( \"GET\" , 200 , hosts ) ) ; \"<AssertPlaceHolder>\" ; } listHosts ( java . lang . String ) { return listHosts ( com . google . common . collect . ImmutableMultimap . of ( \"namePattern\" , namePattern ) ) ; }", "answer": "org . junit . Assert . assertThat ( client . listHosts ( \"foo\" ) . get ( ) , org . hamcrest . Matchers . equalTo ( hosts ) )"}
{"focal": "validate ( ) { return true ; }", "testMethod": "validate_statusIsSet_returnTrue ( ) { confirmation . setStatus ( UnlockStatus . Unlocked ) ; boolean isValid = confirmation . validate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( true ) )", "total": "validate_statusIsSet_returnTrue ( ) { confirmation . setStatus ( UnlockStatus . Unlocked ) ; boolean isValid = confirmation . validate ( ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { return true ; }", "answer": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "toByteArray ( ) { return buffer . toByteArray ( ) ; }", "testMethod": "shouldHandleObjectIdAnnotation ( ) { org . jongo . marshall . jackson . configuration . Mapping build = new org . jongo . marshall . jackson . configuration . Mapping . Builder ( ) . build ( ) ; com . fasterxml . jackson . databind . ObjectReader reader = build . getReader ( org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoObjectId . class ) ; com . mongodb . DBObject oid = new com . mongodb . BasicDBObject ( \"$oid\" , \"53a499be60b2a2248d956875\" ) ; com . mongodb . BasicDBObject dbObject = new com . mongodb . BasicDBObject ( \"id\" , oid ) ; org . jongo . bson . BsonDocument document = org . jongo . bson . Bson . createDocument ( dbObject ) ; org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoObjectId testObj = reader . readValue ( document . toByteArray ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testObj . id , org . hamcrest . CoreMatchers . equalTo ( \"53a499be60b2a2248d956875\" ) )", "total": "shouldHandleObjectIdAnnotation ( ) { org . jongo . marshall . jackson . configuration . Mapping build = new org . jongo . marshall . jackson . configuration . Mapping . Builder ( ) . build ( ) ; com . fasterxml . jackson . databind . ObjectReader reader = build . getReader ( org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoObjectId . class ) ; com . mongodb . DBObject oid = new com . mongodb . BasicDBObject ( \"$oid\" , \"53a499be60b2a2248d956875\" ) ; com . mongodb . BasicDBObject dbObject = new com . mongodb . BasicDBObject ( \"id\" , oid ) ; org . jongo . bson . BsonDocument document = org . jongo . bson . Bson . createDocument ( dbObject ) ; org . jongo . marshall . jackson . oid . AnnotationsTest . WithMongoObjectId testObj = reader . readValue ( document . toByteArray ( ) ) ; \"<AssertPlaceHolder>\" ; } toByteArray ( ) { return buffer . toByteArray ( ) ; }", "answer": "org . junit . Assert . assertThat ( testObj . id , org . hamcrest . CoreMatchers . equalTo ( \"53a499be60b2a2248d956875\" ) )"}
{"focal": "getAttribute ( java . lang . String ) { return attributeMap . get ( name ) ; }", "testMethod": "copyBRForExcludeEmptyString ( ) { org . slim3 . util . BeanUtilTest . SrcBR src = new org . slim3 . util . BeanUtilTest . SrcBR ( ) ; src . aaa = \"\" ; org . slim3 . tester . MockServletContext servletContext = new org . slim3 . tester . MockServletContext ( ) ; org . slim3 . tester . MockHttpServletRequest dest = new org . slim3 . tester . MockHttpServletRequest ( servletContext ) ; dest . setAttribute ( \"aaa\" , \"111\" ) ; org . slim3 . util . BeanUtil . copy ( src , dest , new org . slim3 . util . CopyOptions ( ) . excludeEmptyString ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( ( java . lang . String ) ( dest . getAttribute ( \"aaa\" ) ) ) , org . hamcrest . CoreMatchers . is ( \"111\" ) )", "total": "copyBRForExcludeEmptyString ( ) { org . slim3 . util . BeanUtilTest . SrcBR src = new org . slim3 . util . BeanUtilTest . SrcBR ( ) ; src . aaa = \"\" ; org . slim3 . tester . MockServletContext servletContext = new org . slim3 . tester . MockServletContext ( ) ; org . slim3 . tester . MockHttpServletRequest dest = new org . slim3 . tester . MockHttpServletRequest ( servletContext ) ; dest . setAttribute ( \"aaa\" , \"111\" ) ; org . slim3 . util . BeanUtil . copy ( src , dest , new org . slim3 . util . CopyOptions ( ) . excludeEmptyString ( ) ) ; \"<AssertPlaceHolder>\" ; } getAttribute ( java . lang . String ) { return attributeMap . get ( name ) ; }", "answer": "org . junit . Assert . assertThat ( ( ( java . lang . String ) ( dest . getAttribute ( \"aaa\" ) ) ) , org . hamcrest . CoreMatchers . is ( \"111\" ) )"}
{"focal": "isExpired ( net . ripe . db . whois . common . DateTimeProvider ) { final org . joda . time . LocalDateTime notAfter = new org . joda . time . LocalDateTime ( certificate . getNotAfter ( ) ) ; return notAfter . isBefore ( dateTimeProvider . getCurrentDateTime ( ) ) ; }", "testMethod": "isExpired ( ) { final net . ripe . db . whois . update . keycert . PgpPublicKeyWrapper subject = net . ripe . db . whois . update . keycert . PgpPublicKeyWrapper . parse ( net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"certif:<sp>=XcVO\\n\" 6 + ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 1 + \"owner:<sp>Expired<sp><expired@ripe.net>\\n\" ) + \"fingerpr:<sp>610A<sp>2457<sp>2BA3<sp>A575<sp>5F85<sp>4DD8<sp>5E62<sp>6C72<sp>C88C<sp>A438\\n\" ) + \"certif:<sp>-----BEGIN<sp>PGP<sp>PUBLIC<sp>KEY<sp>BLOCK-----\\n\" ) + \"certif:<sp>=XcVO\\n\" 7 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" ) + \"certif:<sp>=XcVO\\n\" 2 ) + \"certif:<sp>=XcVO\\n\" 1 ) + \"certif:<sp>=XcVO\\n\" 5 ) + \"certif:<sp>yoRJqGii/1Z47FuudeJp1axQs1JER3OJ64IHuLblFIT7oS+YWBLopc1JABEBAAG0\\n\" ) + \"certif:<sp>=XcVO\\n\" 3 ) + \"certif:<sp>=XcVO\\n\" 8 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 3 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 4 ) + \"certif:<sp>=XcVO\\n\" 9 ) + \"certif:<sp>vHVECSOB0q32CN/wSrvVzL6hP8RuO0gwwVQH1V8KCYiY6kDEk33Qb4f1bTo+Wbi6\\n\" ) + \"certif:<sp>9yFvn1OvLh3/idb3U1qSq2+Y6Snl/kvgoVJQuS9x1NePtCYL2kheTAGiswg6CxTF\\n\" ) + \"certif:<sp>=XcVO\\n\" 4 ) + \"certif:<sp>gAAKCRBeYmxyyIykON13BACeqmXZNe9H/SK2AMiFLIx2Zfyw/P0cKabn3Iaan7iF\\n\" ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 0 ) + \"certif:<sp>=XcVO\\n\" 0 ) + \"certif:<sp>xw==\\n\" ) + \"certif:<sp>=XcVO\\n\" ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 2 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 5 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 6 ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( subject . isExpired ( dateTimeProvider ) , org . hamcrest . Matchers . is ( true ) )", "total": "isExpired ( ) { final net . ripe . db . whois . update . keycert . PgpPublicKeyWrapper subject = net . ripe . db . whois . update . keycert . PgpPublicKeyWrapper . parse ( net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"certif:<sp>=XcVO\\n\" 6 + ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 1 + \"owner:<sp>Expired<sp><expired@ripe.net>\\n\" ) + \"fingerpr:<sp>610A<sp>2457<sp>2BA3<sp>A575<sp>5F85<sp>4DD8<sp>5E62<sp>6C72<sp>C88C<sp>A438\\n\" ) + \"certif:<sp>-----BEGIN<sp>PGP<sp>PUBLIC<sp>KEY<sp>BLOCK-----\\n\" ) + \"certif:<sp>=XcVO\\n\" 7 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" ) + \"certif:<sp>=XcVO\\n\" 2 ) + \"certif:<sp>=XcVO\\n\" 1 ) + \"certif:<sp>=XcVO\\n\" 5 ) + \"certif:<sp>yoRJqGii/1Z47FuudeJp1axQs1JER3OJ64IHuLblFIT7oS+YWBLopc1JABEBAAG0\\n\" ) + \"certif:<sp>=XcVO\\n\" 3 ) + \"certif:<sp>=XcVO\\n\" 8 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 3 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 4 ) + \"certif:<sp>=XcVO\\n\" 9 ) + \"certif:<sp>vHVECSOB0q32CN/wSrvVzL6hP8RuO0gwwVQH1V8KCYiY6kDEk33Qb4f1bTo+Wbi6\\n\" ) + \"certif:<sp>9yFvn1OvLh3/idb3U1qSq2+Y6Snl/kvgoVJQuS9x1NePtCYL2kheTAGiswg6CxTF\\n\" ) + \"certif:<sp>=XcVO\\n\" 4 ) + \"certif:<sp>gAAKCRBeYmxyyIykON13BACeqmXZNe9H/SK2AMiFLIx2Zfyw/P0cKabn3Iaan7iF\\n\" ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 0 ) + \"certif:<sp>=XcVO\\n\" 0 ) + \"certif:<sp>xw==\\n\" ) + \"certif:<sp>=XcVO\\n\" ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 2 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 5 ) + \"certif:<sp>Comment:<sp>GPGTools<sp>-<sp>http://gpgtools.org\\n\" 6 ) ) ) ) ; \"<AssertPlaceHolder>\" ; } isExpired ( net . ripe . db . whois . common . DateTimeProvider ) { final org . joda . time . LocalDateTime notAfter = new org . joda . time . LocalDateTime ( certificate . getNotAfter ( ) ) ; return notAfter . isBefore ( dateTimeProvider . getCurrentDateTime ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( subject . isExpired ( dateTimeProvider ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getMDCValue ( javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse ) { org . springframework . security . core . Authentication authentication = org . springframework . security . core . context . SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication != null ) { java . lang . Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof org . springframework . security . core . userdetails . UserDetails ) { return ( ( org . springframework . security . core . userdetails . UserDetails ) ( principal ) ) . getUsername ( ) ; } return principal . toString ( ) ; } return null ; }", "testMethod": "testGetMDCValuePrincipalStringValue ( ) { org . terasoluna . gfw . security . web . logging . UserIdMDCPutFilter mdcPutFilter = new org . terasoluna . gfw . security . web . logging . UserIdMDCPutFilter ( ) ; java . lang . String userName = \"terasoluna@nttd.co.jp\" ; securityContext = mock ( org . springframework . security . core . context . SecurityContext . class ) ; authentication = mock ( org . springframework . security . core . Authentication . class ) ; when ( authentication . getPrincipal ( ) ) . thenReturn ( userName ) ; when ( securityContext . getAuthentication ( ) ) . thenReturn ( authentication ) ; org . springframework . security . core . context . SecurityContextHolder . setContext ( securityContext ) ; java . lang . String mdcValueStr = mdcPutFilter . getMDCValue ( request , response ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mdcValueStr , org . hamcrest . CoreMatchers . is ( userName ) )", "total": "testGetMDCValuePrincipalStringValue ( ) { org . terasoluna . gfw . security . web . logging . UserIdMDCPutFilter mdcPutFilter = new org . terasoluna . gfw . security . web . logging . UserIdMDCPutFilter ( ) ; java . lang . String userName = \"terasoluna@nttd.co.jp\" ; securityContext = mock ( org . springframework . security . core . context . SecurityContext . class ) ; authentication = mock ( org . springframework . security . core . Authentication . class ) ; when ( authentication . getPrincipal ( ) ) . thenReturn ( userName ) ; when ( securityContext . getAuthentication ( ) ) . thenReturn ( authentication ) ; org . springframework . security . core . context . SecurityContextHolder . setContext ( securityContext ) ; java . lang . String mdcValueStr = mdcPutFilter . getMDCValue ( request , response ) ; \"<AssertPlaceHolder>\" ; } getMDCValue ( javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse ) { org . springframework . security . core . Authentication authentication = org . springframework . security . core . context . SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication != null ) { java . lang . Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof org . springframework . security . core . userdetails . UserDetails ) { return ( ( org . springframework . security . core . userdetails . UserDetails ) ( principal ) ) . getUsername ( ) ; } return principal . toString ( ) ; } return null ; }", "answer": "org . junit . Assert . assertThat ( mdcValueStr , org . hamcrest . CoreMatchers . is ( userName ) )"}
{"focal": "restore ( boolean , java . nio . file . PathMatcher ) { org . apache . commons . lang . Validate . notNull ( filter , \"invalid<sp>null<sp>path<sp>filter\" ) ; if ( ( restored ) == null ) { this . restored = false ; if ( filter . matches ( path ) ) { this . restored = handleRestore ( required , filter ) ; } else { this . restored = handleRestoreWhenFilterNotMatching ( required ) ; } } return restored ; }", "testMethod": "restoreWithFilterFailsWhenFileIsNotSoftLinkAndNotMatching ( ) { entry = new org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImpl ( mockContext , com . google . common . collect . ImmutableMap . of ( MigrationEntryImpl . METADATA_NAME , org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImplTest . ENTRY_NAME , MigrationEntryImpl . METADATA_SOFTLINK , true ) ) ; \"<AssertPlaceHolder>\" ; verify ( mockPathUtils , never ( ) ) . getChecksumFor ( any ( java . nio . file . Path . class ) ) ; verifyReportHasMatchingError ( report , \"does<sp>not<sp>match<sp>filter\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( entry . restore ( true , ( p ) -> false ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "restoreWithFilterFailsWhenFileIsNotSoftLinkAndNotMatching ( ) { entry = new org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImpl ( mockContext , com . google . common . collect . ImmutableMap . of ( MigrationEntryImpl . METADATA_NAME , org . codice . ddf . configuration . migration . ImportMigrationExternalEntryImplTest . ENTRY_NAME , MigrationEntryImpl . METADATA_SOFTLINK , true ) ) ; \"<AssertPlaceHolder>\" ; verify ( mockPathUtils , never ( ) ) . getChecksumFor ( any ( java . nio . file . Path . class ) ) ; verifyReportHasMatchingError ( report , \"does<sp>not<sp>match<sp>filter\" ) ; } restore ( boolean , java . nio . file . PathMatcher ) { org . apache . commons . lang . Validate . notNull ( filter , \"invalid<sp>null<sp>path<sp>filter\" ) ; if ( ( restored ) == null ) { this . restored = false ; if ( filter . matches ( path ) ) { this . restored = handleRestore ( required , filter ) ; } else { this . restored = handleRestoreWhenFilterNotMatching ( required ) ; } } return restored ; }", "answer": "org . junit . Assert . assertThat ( entry . restore ( true , ( p ) -> false ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "exists ( java . nio . file . Path ) { return ( data . containsKey ( path ) ) || ( dirs . contains ( path ) ) ; }", "testMethod": "deleteRecursivelyIfExistsDeletesDirectory ( ) { java . nio . file . FileSystem vfs = com . google . common . jimfs . Jimfs . newFileSystem ( com . google . common . jimfs . Configuration . unix ( ) ) ; java . nio . file . Path fakeTmpDir = vfs . getPath ( \"/tmp/fake-tmp-dir\" ) ; java . nio . file . Path dirToDelete = fakeTmpDir . resolve ( \"delete-me\" ) ; java . nio . file . Path childDir = dirToDelete . resolve ( \"child-dir\" ) ; java . nio . file . Files . createDirectories ( childDir ) ; com . facebook . buck . io . file . MostFiles . deleteRecursivelyIfExists ( dirToDelete ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( java . nio . file . Files . exists ( dirToDelete ) , org . hamcrest . Matchers . is ( false ) )", "total": "deleteRecursivelyIfExistsDeletesDirectory ( ) { java . nio . file . FileSystem vfs = com . google . common . jimfs . Jimfs . newFileSystem ( com . google . common . jimfs . Configuration . unix ( ) ) ; java . nio . file . Path fakeTmpDir = vfs . getPath ( \"/tmp/fake-tmp-dir\" ) ; java . nio . file . Path dirToDelete = fakeTmpDir . resolve ( \"delete-me\" ) ; java . nio . file . Path childDir = dirToDelete . resolve ( \"child-dir\" ) ; java . nio . file . Files . createDirectories ( childDir ) ; com . facebook . buck . io . file . MostFiles . deleteRecursivelyIfExists ( dirToDelete ) ; \"<AssertPlaceHolder>\" ; } exists ( java . nio . file . Path ) { return ( data . containsKey ( path ) ) || ( dirs . contains ( path ) ) ; }", "answer": "org . junit . Assert . assertThat ( java . nio . file . Files . exists ( dirToDelete ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "testIsNotReadable ( ) { createFrenchSimpleAttachment ( ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK pk = new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( null , org . silverpeas . core . sharing . model . SimpleFileAccessControlTest . instanceId ) ; pk . setOldSilverpeasId ( 10 ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocument attachment = new org . silverpeas . core . contribution . attachment . model . SimpleDocument ( ) ; attachment . setPK ( pk ) ; attachment . setForeignId ( \"15\" ) ; org . silverpeas . core . sharing . security . ShareableAttachment resource = new org . silverpeas . core . sharing . security . ShareableAttachment ( \"965e985d-c711-47b3-a467-62779505965e985d-c711-47b3-a467-62779505\" , attachment ) ; org . silverpeas . core . sharing . model . SimpleFileAccessControl instance = new org . silverpeas . core . sharing . model . SimpleFileAccessControl ( ) ; boolean expResult = false ; boolean result = instance . isReadable ( resource ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( expResult ) )", "total": "testIsNotReadable ( ) { createFrenchSimpleAttachment ( ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK pk = new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( null , org . silverpeas . core . sharing . model . SimpleFileAccessControlTest . instanceId ) ; pk . setOldSilverpeasId ( 10 ) ; org . silverpeas . core . contribution . attachment . model . SimpleDocument attachment = new org . silverpeas . core . contribution . attachment . model . SimpleDocument ( ) ; attachment . setPK ( pk ) ; attachment . setForeignId ( \"15\" ) ; org . silverpeas . core . sharing . security . ShareableAttachment resource = new org . silverpeas . core . sharing . security . ShareableAttachment ( \"965e985d-c711-47b3-a467-62779505965e985d-c711-47b3-a467-62779505\" , attachment ) ; org . silverpeas . core . sharing . model . SimpleFileAccessControl instance = new org . silverpeas . core . sharing . model . SimpleFileAccessControl ( ) ; boolean expResult = false ; boolean result = instance . isReadable ( resource ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( expResult ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testInterfaceAddress ( ) { ipInterfaceAddressTlv . addInterfaceAddres ( ip4Address ) ; resultList = ipInterfaceAddressTlv . interfaceAddress ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultList . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testInterfaceAddress ( ) { ipInterfaceAddressTlv . addInterfaceAddres ( ip4Address ) ; resultList = ipInterfaceAddressTlv . interfaceAddress ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( resultList . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "spell ( java . lang . String ) { checkHandle ( ) ; checkWord ( \"word\" , word ) ; org . bridj . Pointer < java . lang . Byte > wordCString = toEncodedCString ( word ) ; int result = com . atlascopco . hunspell . HunspellLibrary . Hunspell_spell ( handle , wordCString ) ; return result != 0 ; }", "testMethod": "testSpellWithIncorrectWords ( ) { java . lang . String [ ] incorrectWords = new java . lang . String [ ] { \"wrods\" , \"flase\" , \"supercalifragilisticexpialidocious\" } ; for ( java . lang . String word : incorrectWords ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( word , unit . spell ( word ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testSpellWithIncorrectWords ( ) { java . lang . String [ ] incorrectWords = new java . lang . String [ ] { \"wrods\" , \"flase\" , \"supercalifragilisticexpialidocious\" } ; for ( java . lang . String word : incorrectWords ) { \"<AssertPlaceHolder>\" ; } } spell ( java . lang . String ) { checkHandle ( ) ; checkWord ( \"word\" , word ) ; org . bridj . Pointer < java . lang . Byte > wordCString = toEncodedCString ( word ) ; int result = com . atlascopco . hunspell . HunspellLibrary . Hunspell_spell ( handle , wordCString ) ; return result != 0 ; }", "answer": "org . junit . Assert . assertThat ( word , unit . spell ( word ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "readUTF ( ) { try { return com . asakusafw . runtime . io . util . DataIoUtils . readUTF ( this ) ; } catch ( java . io . IOException e ) { throw new java . lang . AssertionError ( e ) ; } }", "testMethod": "testWriteUTF_empty ( ) { java . io . RandomAccessFile file = file ( ) ; com . asakusafw . runtime . io . util . BufferedFileOutput buf = manage ( new com . asakusafw . runtime . io . util . BufferedFileOutput ( file , 100 ) ) ; buf . writeUTF ( \"\" ) ; buf . flush ( ) ; file . seek ( 0 ) ; \"<AssertPlaceHolder>\" ; eof ( file ) ; }", "assertLine": "org . junit . Assert . assertThat ( file . readUTF ( ) , is ( \"\" ) )", "total": "testWriteUTF_empty ( ) { java . io . RandomAccessFile file = file ( ) ; com . asakusafw . runtime . io . util . BufferedFileOutput buf = manage ( new com . asakusafw . runtime . io . util . BufferedFileOutput ( file , 100 ) ) ; buf . writeUTF ( \"\" ) ; buf . flush ( ) ; file . seek ( 0 ) ; \"<AssertPlaceHolder>\" ; eof ( file ) ; } readUTF ( ) { try { return com . asakusafw . runtime . io . util . DataIoUtils . readUTF ( this ) ; } catch ( java . io . IOException e ) { throw new java . lang . AssertionError ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( file . readUTF ( ) , is ( \"\" ) )"}
{"focal": "add_partitions_req ( org . apache . hadoop . hive . metastore . api . AddPartitionsRequest ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = checkWritePermissions ( request . getDbName ( ) ) ; for ( org . apache . hadoop . hive . metastore . api . Partition partition : request . getParts ( ) ) { mapping . checkWritePermissions ( partition . getDbName ( ) ) ; } org . apache . hadoop . hive . metastore . api . AddPartitionsResult result = mapping . getClient ( ) . add_partitions_req ( mapping . transformInboundAddPartitionsRequest ( request ) ) ; return mapping . transformOutboundAddPartitionsResult ( result ) ; }", "testMethod": "add_partitions_req ( ) { org . apache . hadoop . hive . metastore . api . Partition newPartition1 = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; newPartition1 . setDbName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; org . apache . hadoop . hive . metastore . api . Partition newPartition2 = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; newPartition2 . setDbName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > partitions = com . google . common . collect . Lists . newArrayList ( newPartition1 , newPartition2 ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsRequest request = new org . apache . hadoop . hive . metastore . api . AddPartitionsRequest ( ) ; request . setDbName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; request . setParts ( partitions ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsRequest inbound = new org . apache . hadoop . hive . metastore . api . AddPartitionsRequest ( ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsResult addPartitionResult = new org . apache . hadoop . hive . metastore . api . AddPartitionsResult ( ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsResult outbound = new org . apache . hadoop . hive . metastore . api . AddPartitionsResult ( ) ; when ( primaryMapping . transformInboundAddPartitionsRequest ( request ) ) . thenReturn ( inbound ) ; when ( primaryClient . add_partitions_req ( inbound ) ) . thenReturn ( addPartitionResult ) ; when ( primaryMapping . transformOutboundAddPartitionsResult ( addPartitionResult ) ) . thenReturn ( outbound ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsResult result = handler . add_partitions_req ( request ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping , times ( 3 ) ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )", "total": "add_partitions_req ( ) { org . apache . hadoop . hive . metastore . api . Partition newPartition1 = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; newPartition1 . setDbName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; org . apache . hadoop . hive . metastore . api . Partition newPartition2 = new org . apache . hadoop . hive . metastore . api . Partition ( ) ; newPartition2 . setDbName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > partitions = com . google . common . collect . Lists . newArrayList ( newPartition1 , newPartition2 ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsRequest request = new org . apache . hadoop . hive . metastore . api . AddPartitionsRequest ( ) ; request . setDbName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; request . setParts ( partitions ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsRequest inbound = new org . apache . hadoop . hive . metastore . api . AddPartitionsRequest ( ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsResult addPartitionResult = new org . apache . hadoop . hive . metastore . api . AddPartitionsResult ( ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsResult outbound = new org . apache . hadoop . hive . metastore . api . AddPartitionsResult ( ) ; when ( primaryMapping . transformInboundAddPartitionsRequest ( request ) ) . thenReturn ( inbound ) ; when ( primaryClient . add_partitions_req ( inbound ) ) . thenReturn ( addPartitionResult ) ; when ( primaryMapping . transformOutboundAddPartitionsResult ( addPartitionResult ) ) . thenReturn ( outbound ) ; org . apache . hadoop . hive . metastore . api . AddPartitionsResult result = handler . add_partitions_req ( request ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping , times ( 3 ) ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; } add_partitions_req ( org . apache . hadoop . hive . metastore . api . AddPartitionsRequest ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = checkWritePermissions ( request . getDbName ( ) ) ; for ( org . apache . hadoop . hive . metastore . api . Partition partition : request . getParts ( ) ) { mapping . checkWritePermissions ( partition . getDbName ( ) ) ; } org . apache . hadoop . hive . metastore . api . AddPartitionsResult result = mapping . getClient ( ) . add_partitions_req ( mapping . transformInboundAddPartitionsRequest ( request ) ) ; return mapping . transformOutboundAddPartitionsResult ( result ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )"}
{"focal": "formatAttributes ( ) { return component . formatAttributes ( ) ; }", "testMethod": "testCopyFormatAttributesWithOSAsString ( ) { org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor underTest = new org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor ( new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"os\" , \"darwin\" ) . build ( ) ) ; underTest . copyFormatAttributes ( asset ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( asset . formatAttributes ( ) . get ( \"os\" ) , org . hamcrest . Matchers . is ( \"darwin\" ) )", "total": "testCopyFormatAttributesWithOSAsString ( ) { org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor underTest = new org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor ( new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"os\" , \"darwin\" ) . build ( ) ) ; underTest . copyFormatAttributes ( asset ) ; \"<AssertPlaceHolder>\" ; } formatAttributes ( ) { return component . formatAttributes ( ) ; }", "answer": "org . junit . Assert . assertThat ( asset . formatAttributes ( ) . get ( \"os\" ) , org . hamcrest . Matchers . is ( \"darwin\" ) )"}
{"focal": "isDefined ( ) { return false ; }", "testMethod": "unapply_A$Tuple5 ( ) { java . lang . String _1 = \"foo\" ; java . lang . Integer _2 = 123 ; java . lang . Long _3 = 456L ; java . lang . Boolean _4 = true ; java . lang . Double _5 = 7.8 ; com . m3 . scalaflavor4j . Tuple5 < java . lang . String , java . lang . Integer , java . lang . Long , java . lang . Boolean , java . lang . Double > tuple = com . m3 . scalaflavor4j . Tuple5 . apply ( _1 , _2 , _3 , _4 , _5 ) ; com . m3 . scalaflavor4j . Option < com . m3 . scalaflavor4j . Tuple5 < java . lang . String , java . lang . Integer , java . lang . Long , java . lang . Boolean , java . lang . Double > > actual = com . m3 . scalaflavor4j . Tuple5 . unapply ( tuple ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . isDefined ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "unapply_A$Tuple5 ( ) { java . lang . String _1 = \"foo\" ; java . lang . Integer _2 = 123 ; java . lang . Long _3 = 456L ; java . lang . Boolean _4 = true ; java . lang . Double _5 = 7.8 ; com . m3 . scalaflavor4j . Tuple5 < java . lang . String , java . lang . Integer , java . lang . Long , java . lang . Boolean , java . lang . Double > tuple = com . m3 . scalaflavor4j . Tuple5 . apply ( _1 , _2 , _3 , _4 , _5 ) ; com . m3 . scalaflavor4j . Option < com . m3 . scalaflavor4j . Tuple5 < java . lang . String , java . lang . Integer , java . lang . Long , java . lang . Boolean , java . lang . Double > > actual = com . m3 . scalaflavor4j . Tuple5 . unapply ( tuple ) ; \"<AssertPlaceHolder>\" ; } isDefined ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( actual . isDefined ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getRunningFlows ( ) { java . util . Collection < org . drools . runtime . process . ProcessInstance > processInstances = getSessionForCurrentContext ( ) . getProcessInstances ( ) ; java . util . Collection < java . lang . Long > result = new java . util . HashSet < java . lang . Long > ( ) ; for ( org . drools . runtime . process . ProcessInstance p : processInstances ) { result . add ( p . getId ( ) ) ; } return result ; }", "testMethod": "testRegisterWorkflowTrigger_shouldRegisterTrigger ( ) { service . registerFlowTriggerEvent ( new org . openengsb . core . api . Event ( \"triggerEvent\" ) , \"ci\" ) ; service . processEvent ( new org . openengsb . core . api . Event ( ) ) ; service . processEvent ( new org . openengsb . core . api . Event ( \"triggerEvent\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( service . getRunningFlows ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testRegisterWorkflowTrigger_shouldRegisterTrigger ( ) { service . registerFlowTriggerEvent ( new org . openengsb . core . api . Event ( \"triggerEvent\" ) , \"ci\" ) ; service . processEvent ( new org . openengsb . core . api . Event ( ) ) ; service . processEvent ( new org . openengsb . core . api . Event ( \"triggerEvent\" ) ) ; \"<AssertPlaceHolder>\" ; } getRunningFlows ( ) { java . util . Collection < org . drools . runtime . process . ProcessInstance > processInstances = getSessionForCurrentContext ( ) . getProcessInstances ( ) ; java . util . Collection < java . lang . Long > result = new java . util . HashSet < java . lang . Long > ( ) ; for ( org . drools . runtime . process . ProcessInstance p : processInstances ) { result . add ( p . getId ( ) ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( service . getRunningFlows ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getEntries ( ) { com . airhacks . enhydrator . in . Row row = new com . airhacks . enhydrator . in . Row ( ) ; row . addColumn ( ( - 1 ) , \"a\" , \"java\" ) ; row . addColumn ( ( - 1 ) , \"b\" , \"tengah\" ) ; return row ; }", "testMethod": "columnList ( ) { java . lang . String expected = \"a,b\" ; java . lang . String columns = com . airhacks . enhydrator . out . JDBCSink . columnList ( getEntries ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( columns , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "columnList ( ) { java . lang . String expected = \"a,b\" ; java . lang . String columns = com . airhacks . enhydrator . out . JDBCSink . columnList ( getEntries ( ) ) ; \"<AssertPlaceHolder>\" ; } getEntries ( ) { com . airhacks . enhydrator . in . Row row = new com . airhacks . enhydrator . in . Row ( ) ; row . addColumn ( ( - 1 ) , \"a\" , \"java\" ) ; row . addColumn ( ( - 1 ) , \"b\" , \"tengah\" ) ; return row ; }", "answer": "org . junit . Assert . assertThat ( columns , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldReturnResultsWithScanAndScrollForSpecifiedFieldsForCriteriaQuery ( ) { java . util . List < org . springframework . data . elasticsearch . core . IndexQuery > entities = org . springframework . data . elasticsearch . core . ElasticsearchTemplateTests . createSampleEntitiesWithMessage ( \"Test<sp>message\" , 30 ) ; elasticsearchTemplate . bulkIndex ( entities ) ; elasticsearchTemplate . refresh ( org . springframework . data . elasticsearch . entities . SampleEntity . class ) ; org . springframework . data . elasticsearch . core . CriteriaQuery criteriaQuery = new org . springframework . data . elasticsearch . core . CriteriaQuery ( new org . springframework . data . elasticsearch . core . Criteria ( ) ) ; criteriaQuery . addIndices ( org . springframework . data . elasticsearch . core . ElasticsearchTemplateTests . INDEX_NAME ) ; criteriaQuery . addTypes ( org . springframework . data . elasticsearch . core . ElasticsearchTemplateTests . TYPE_NAME ) ; criteriaQuery . addFields ( \"message\" ) ; criteriaQuery . setPageable ( org . springframework . data . domain . PageRequest . of ( 0 , 10 ) ) ; org . springframework . data . domain . Page < org . springframework . data . elasticsearch . entities . SampleEntity > scroll = elasticsearchTemplate . startScroll ( 1000 , criteriaQuery , org . springframework . data . elasticsearch . entities . SampleEntity . class , searchResultMapper ) ; java . lang . String scrollId = ( ( org . springframework . data . elasticsearch . core . ScrolledPage < ? > ) ( scroll ) ) . getScrollId ( ) ; java . util . List < org . springframework . data . elasticsearch . entities . SampleEntity > sampleEntities = new java . util . ArrayList ( ) ; while ( scroll . hasContent ( ) ) { sampleEntities . addAll ( scroll . getContent ( ) ) ; scrollId = ( ( org . springframework . data . elasticsearch . core . ScrolledPage < ? > ) ( scroll ) ) . getScrollId ( ) ; scroll = elasticsearchTemplate . continueScroll ( scrollId , 1000 , org . springframework . data . elasticsearch . entities . SampleEntity . class , searchResultMapper ) ; } elasticsearchTemplate . clearScroll ( scrollId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sampleEntities . size ( ) , is ( equalTo ( 30 ) ) )", "total": "shouldReturnResultsWithScanAndScrollForSpecifiedFieldsForCriteriaQuery ( ) { java . util . List < org . springframework . data . elasticsearch . core . IndexQuery > entities = org . springframework . data . elasticsearch . core . ElasticsearchTemplateTests . createSampleEntitiesWithMessage ( \"Test<sp>message\" , 30 ) ; elasticsearchTemplate . bulkIndex ( entities ) ; elasticsearchTemplate . refresh ( org . springframework . data . elasticsearch . entities . SampleEntity . class ) ; org . springframework . data . elasticsearch . core . CriteriaQuery criteriaQuery = new org . springframework . data . elasticsearch . core . CriteriaQuery ( new org . springframework . data . elasticsearch . core . Criteria ( ) ) ; criteriaQuery . addIndices ( org . springframework . data . elasticsearch . core . ElasticsearchTemplateTests . INDEX_NAME ) ; criteriaQuery . addTypes ( org . springframework . data . elasticsearch . core . ElasticsearchTemplateTests . TYPE_NAME ) ; criteriaQuery . addFields ( \"message\" ) ; criteriaQuery . setPageable ( org . springframework . data . domain . PageRequest . of ( 0 , 10 ) ) ; org . springframework . data . domain . Page < org . springframework . data . elasticsearch . entities . SampleEntity > scroll = elasticsearchTemplate . startScroll ( 1000 , criteriaQuery , org . springframework . data . elasticsearch . entities . SampleEntity . class , searchResultMapper ) ; java . lang . String scrollId = ( ( org . springframework . data . elasticsearch . core . ScrolledPage < ? > ) ( scroll ) ) . getScrollId ( ) ; java . util . List < org . springframework . data . elasticsearch . entities . SampleEntity > sampleEntities = new java . util . ArrayList ( ) ; while ( scroll . hasContent ( ) ) { sampleEntities . addAll ( scroll . getContent ( ) ) ; scrollId = ( ( org . springframework . data . elasticsearch . core . ScrolledPage < ? > ) ( scroll ) ) . getScrollId ( ) ; scroll = elasticsearchTemplate . continueScroll ( scrollId , 1000 , org . springframework . data . elasticsearch . entities . SampleEntity . class , searchResultMapper ) ; } elasticsearchTemplate . clearScroll ( scrollId ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( sampleEntities . size ( ) , is ( equalTo ( 30 ) ) )"}
{"focal": "getAge ( ) { return age ; }", "testMethod": "testDefaultApplication ( ) { test . component3 . Person person = $ . getBean ( \"person\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( person . getAge ( ) , org . hamcrest . Matchers . is ( 12 ) )", "total": "testDefaultApplication ( ) { test . component3 . Person person = $ . getBean ( \"person\" ) ; \"<AssertPlaceHolder>\" ; } getAge ( ) { return age ; }", "answer": "org . junit . Assert . assertThat ( person . getAge ( ) , org . hamcrest . Matchers . is ( 12 ) )"}
{"focal": "isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "testMethod": "slice_A$int$int ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . Integer from = 1 ; java . lang . Integer until = 2 ; com . m3 . scalaflavor4j . Seq < java . lang . String > actual = nil . slice ( from , until ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "slice_A$int$int ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . Integer from = 1 ; java . lang . Integer until = 2 ; com . m3 . scalaflavor4j . Seq < java . lang . String > actual = nil . slice ( from , until ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( ( resource ) == null ) || ( ( resource . getResource ( ) ) == null ) ; }", "answer": "org . junit . Assert . assertThat ( actual . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "hasFurtherParams ( ) { return externalEntitiesIterator . hasNext ( ) ; }", "testMethod": "nullPayloadPosition ( ) { wsattacker . library . intelligentdos . helper . IterateModel iterateModel = wsattacker . library . intelligentdos . helper . IterateModel . custom ( ) . startAt ( 2 ) . stopAt ( 2 ) . build ( ) ; xmlAttributeCount . setNumberOfAttributesIterator ( iterateModel ) ; \"<AssertPlaceHolder>\" ; xmlAttributeCount . nextParam ( ) ; xmlAttributeCount . getTamperedRequest ( \"\" , null ) ; }", "assertLine": "org . junit . Assert . assertThat ( xmlAttributeCount . hasFurtherParams ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "nullPayloadPosition ( ) { wsattacker . library . intelligentdos . helper . IterateModel iterateModel = wsattacker . library . intelligentdos . helper . IterateModel . custom ( ) . startAt ( 2 ) . stopAt ( 2 ) . build ( ) ; xmlAttributeCount . setNumberOfAttributesIterator ( iterateModel ) ; \"<AssertPlaceHolder>\" ; xmlAttributeCount . nextParam ( ) ; xmlAttributeCount . getTamperedRequest ( \"\" , null ) ; } hasFurtherParams ( ) { return externalEntitiesIterator . hasNext ( ) ; }", "answer": "org . junit . Assert . assertThat ( xmlAttributeCount . hasFurtherParams ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "size ( ) { return java . lang . reflect . Array . getLength ( arrayObject ) ; }", "testMethod": "test_inValidStringAndCharacterCode ( ) { org . terasoluna . gfw . common . codelist . Customer c = new org . terasoluna . gfw . common . codelist . Customer ( ) ; c . gender = 'G' ; c . lang = \"FR\" ; java . util . Set < javax . validation . ConstraintViolation < org . terasoluna . gfw . common . codelist . Customer > > result = validator . validate ( c ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "test_inValidStringAndCharacterCode ( ) { org . terasoluna . gfw . common . codelist . Customer c = new org . terasoluna . gfw . common . codelist . Customer ( ) ; c . gender = 'G' ; c . lang = \"FR\" ; java . util . Set < javax . validation . ConstraintViolation < org . terasoluna . gfw . common . codelist . Customer > > result = validator . validate ( c ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return java . lang . reflect . Array . getLength ( arrayObject ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "equalTo ( java . lang . Object ) { whereClause . append ( \"<sp>=<sp>?<sp>\" ) ; parameters . add ( value ) ; return this ; }", "testMethod": "simpleTest ( ) { com . bedatadriven . rebar . sql . client . SqlDatabase db = com . bedatadriven . rebar . sql . server . TestUtil . openUniqueDb ( ) ; final com . bedatadriven . rebar . sql . client . util . SqlKeyValueTable table = new com . bedatadriven . rebar . sql . client . util . SqlKeyValueTable ( db , \"sync_regions\" , \"id\" , \"lastUpdate\" ) ; db . execute ( table . createTableIfNotExists ( ) , com . bedatadriven . rebar . async . NullCallback . forVoid ( ) ) ; table . put ( \"foo\" , \"bar\" ) ; table . get ( \"foo\" , new com . google . gwt . user . client . rpc . AsyncCallback < java . lang . String > ( ) { @ com . bedatadriven . rebar . sql . server . Override public void onSuccess ( java . lang . String result ) { \"<AssertPlaceHolder>\" ; } @ com . bedatadriven . rebar . sql . server . Override public void onFailure ( java . lang . Throwable caught ) { throw new java . lang . AssertionError ( caught ) ; } } ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( \"bar\" ) )", "total": "simpleTest ( ) { com . bedatadriven . rebar . sql . client . SqlDatabase db = com . bedatadriven . rebar . sql . server . TestUtil . openUniqueDb ( ) ; final com . bedatadriven . rebar . sql . client . util . SqlKeyValueTable table = new com . bedatadriven . rebar . sql . client . util . SqlKeyValueTable ( db , \"sync_regions\" , \"id\" , \"lastUpdate\" ) ; db . execute ( table . createTableIfNotExists ( ) , com . bedatadriven . rebar . async . NullCallback . forVoid ( ) ) ; table . put ( \"foo\" , \"bar\" ) ; table . get ( \"foo\" , new com . google . gwt . user . client . rpc . AsyncCallback < java . lang . String > ( ) { @ com . bedatadriven . rebar . sql . server . Override public void onSuccess ( java . lang . String result ) { \"<AssertPlaceHolder>\" ; } @ com . bedatadriven . rebar . sql . server . Override public void onFailure ( java . lang . Throwable caught ) { throw new java . lang . AssertionError ( caught ) ; } } ) ; } equalTo ( java . lang . Object ) { whereClause . append ( \"<sp>=<sp>?<sp>\" ) ; parameters . add ( value ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . equalTo ( \"bar\" ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldCountCustomMethodForEndingWith ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity . setId ( documentId ) ; sampleEntity . setType ( \"test\" ) ; sampleEntity . setRate ( 10 ) ; sampleEntity . setMessage ( \"foo\" ) ; repository . save ( sampleEntity ) ; documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId ) ; sampleEntity2 . setType ( \"test\" ) ; sampleEntity2 . setRate ( 10 ) ; sampleEntity2 . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity2 ) ; long count = repository . countByMessageEndingWith ( \"o\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )", "total": "shouldCountCustomMethodForEndingWith ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity . setId ( documentId ) ; sampleEntity . setType ( \"test\" ) ; sampleEntity . setRate ( 10 ) ; sampleEntity . setMessage ( \"foo\" ) ; repository . save ( sampleEntity ) ; documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId ) ; sampleEntity2 . setType ( \"test\" ) ; sampleEntity2 . setRate ( 10 ) ; sampleEntity2 . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity2 ) ; long count = repository . countByMessageEndingWith ( \"o\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )"}
{"focal": "creatingServers ( oracle . kubernetes . operator . helpers . DomainPresenceInfo ) { oracle . kubernetes . weblogic . domain . model . Domain dom = info . getDomain ( ) ; oracle . kubernetes . weblogic . domain . model . DomainSpec spec = dom . getSpec ( ) ; java . util . List < oracle . kubernetes . weblogic . domain . model . Cluster > clusters = spec . getClusters ( ) ; java . util . List < oracle . kubernetes . weblogic . domain . model . ManagedServer > servers = spec . getManagedServers ( ) ; for ( oracle . kubernetes . weblogic . domain . model . Cluster cluster : clusters ) { int replicaCount = dom . getReplicaCount ( cluster . getClusterName ( ) ) ; java . lang . String clusterServerStartPolicy = cluster . getServerStartPolicy ( ) ; oracle . kubernetes . operator . helpers . JobHelper . LOGGER . fine ( ( ( ( ( ( \"Start<sp>Policy:<sp>\" + clusterServerStartPolicy ) + \",<sp>replicaCount:<sp>\" ) + replicaCount ) + \"<sp>for<sp>cluster:<sp>\" ) + cluster ) ) ; if ( ( ( clusterServerStartPolicy == null ) || ( ! ( clusterServerStartPolicy . equals ( ConfigurationConstants . START_NEVER ) ) ) ) && ( replicaCount > 0 ) ) { return true ; } } java . lang . String domainServerStartPolicy = dom . getSpec ( ) . getServerStartPolicy ( ) ; if ( ( domainServerStartPolicy == null ) || ( ! ( domainServerStartPolicy . equals ( ConfigurationConstants . START_NEVER ) ) ) ) { return true ; } for ( oracle . kubernetes . weblogic . domain . model . ManagedServer server : servers ) { java . lang . String serverStartPolicy = server . getServerStartPolicy ( ) ; if ( ( serverStartPolicy == null ) || ( ! ( serverStartPolicy . equals ( ConfigurationConstants . START_NEVER ) ) ) ) { return true ; } } return false ; }", "testMethod": "creatingServers_false_when_no_domain_nor_cluster_replicas ( ) { oracle . kubernetes . operator . helpers . DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfo ( ) ; configureCluster ( domainPresenceInfo , \"cluster1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( oracle . kubernetes . operator . helpers . JobHelper . creatingServers ( domainPresenceInfo ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "creatingServers_false_when_no_domain_nor_cluster_replicas ( ) { oracle . kubernetes . operator . helpers . DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfo ( ) ; configureCluster ( domainPresenceInfo , \"cluster1\" ) ; \"<AssertPlaceHolder>\" ; } creatingServers ( oracle . kubernetes . operator . helpers . DomainPresenceInfo ) { oracle . kubernetes . weblogic . domain . model . Domain dom = info . getDomain ( ) ; oracle . kubernetes . weblogic . domain . model . DomainSpec spec = dom . getSpec ( ) ; java . util . List < oracle . kubernetes . weblogic . domain . model . Cluster > clusters = spec . getClusters ( ) ; java . util . List < oracle . kubernetes . weblogic . domain . model . ManagedServer > servers = spec . getManagedServers ( ) ; for ( oracle . kubernetes . weblogic . domain . model . Cluster cluster : clusters ) { int replicaCount = dom . getReplicaCount ( cluster . getClusterName ( ) ) ; java . lang . String clusterServerStartPolicy = cluster . getServerStartPolicy ( ) ; oracle . kubernetes . operator . helpers . JobHelper . LOGGER . fine ( ( ( ( ( ( \"Start<sp>Policy:<sp>\" + clusterServerStartPolicy ) + \",<sp>replicaCount:<sp>\" ) + replicaCount ) + \"<sp>for<sp>cluster:<sp>\" ) + cluster ) ) ; if ( ( ( clusterServerStartPolicy == null ) || ( ! ( clusterServerStartPolicy . equals ( ConfigurationConstants . START_NEVER ) ) ) ) && ( replicaCount > 0 ) ) { return true ; } } java . lang . String domainServerStartPolicy = dom . getSpec ( ) . getServerStartPolicy ( ) ; if ( ( domainServerStartPolicy == null ) || ( ! ( domainServerStartPolicy . equals ( ConfigurationConstants . START_NEVER ) ) ) ) { return true ; } for ( oracle . kubernetes . weblogic . domain . model . ManagedServer server : servers ) { java . lang . String serverStartPolicy = server . getServerStartPolicy ( ) ; if ( ( serverStartPolicy == null ) || ( ! ( serverStartPolicy . equals ( ConfigurationConstants . START_NEVER ) ) ) ) { return true ; } } return false ; }", "answer": "org . junit . Assert . assertThat ( oracle . kubernetes . operator . helpers . JobHelper . creatingServers ( domainPresenceInfo ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "getProfileForUser ( ) { final java . util . List < org . bonitasoft . engine . profile . Profile > profiles = getProfileAPI ( ) . getProfilesForUser ( user1 . getId ( ) , 0 , 10 , ProfileCriterion . NAME_ASC ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . extracting ( \"name\" ) . contains ( \"Administrator\" , \"User\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( profiles )", "total": "getProfileForUser ( ) { final java . util . List < org . bonitasoft . engine . profile . Profile > profiles = getProfileAPI ( ) . getProfilesForUser ( user1 . getId ( ) , 0 , 10 , ProfileCriterion . NAME_ASC ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . extracting ( \"name\" ) . contains ( \"Administrator\" , \"User\" ) ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( profiles )"}
{"focal": "countByQuery ( ) { com . orientechnologies . orient . object . db . OObjectDatabaseTx db = dbf . db ( ) ; com . orientechnologies . orient . core . sql . query . OSQLSynchQuery < com . orientechnologies . orient . core . record . impl . ODocument > q = new com . orientechnologies . orient . core . sql . query . OSQLSynchQuery < com . orientechnologies . orient . core . record . impl . ODocument > ( \"select<sp>count(*)<sp>from<sp>Person\" ) ; java . util . List < com . orientechnologies . orient . core . record . impl . ODocument > results = db . query ( q ) ; assert ( results . size ( ) ) == 1 ; return results . get ( 0 ) . field ( \"count\" ) ; }", "testMethod": "test05DbShouldNotBeEmpty ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( service . countByQuery ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "test05DbShouldNotBeEmpty ( ) { \"<AssertPlaceHolder>\" ; } countByQuery ( ) { com . orientechnologies . orient . object . db . OObjectDatabaseTx db = dbf . db ( ) ; com . orientechnologies . orient . core . sql . query . OSQLSynchQuery < com . orientechnologies . orient . core . record . impl . ODocument > q = new com . orientechnologies . orient . core . sql . query . OSQLSynchQuery < com . orientechnologies . orient . core . record . impl . ODocument > ( \"select<sp>count(*)<sp>from<sp>Person\" ) ; java . util . List < com . orientechnologies . orient . core . record . impl . ODocument > results = db . query ( q ) ; assert ( results . size ( ) ) == 1 ; return results . get ( 0 ) . field ( \"count\" ) ; }", "answer": "org . junit . Assert . assertThat ( service . countByQuery ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "getFirstMonitorable ( io . pcp . parfait . dropwizard . MetricAdapter ) { return metricAdapter . getMonitorables ( ) . iterator ( ) . next ( ) ; }", "testMethod": "shouldUpdateMonitorToCurrentValueWhenUpdateMonitorsIsCalled ( ) { int newValue = ( io . pcp . parfait . dropwizard . metricadapters . GaugeAdapterTest . INITIAL_VALUE ) + 5 ; when ( gauge . getValue ( ) ) . thenReturn ( newValue ) ; gaugeAdapter . updateMonitorables ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( ( java . lang . Integer ) ( getFirstMonitorable ( gaugeAdapter ) . get ( ) ) ) , org . hamcrest . Matchers . is ( newValue ) )", "total": "shouldUpdateMonitorToCurrentValueWhenUpdateMonitorsIsCalled ( ) { int newValue = ( io . pcp . parfait . dropwizard . metricadapters . GaugeAdapterTest . INITIAL_VALUE ) + 5 ; when ( gauge . getValue ( ) ) . thenReturn ( newValue ) ; gaugeAdapter . updateMonitorables ( ) ; \"<AssertPlaceHolder>\" ; } getFirstMonitorable ( io . pcp . parfait . dropwizard . MetricAdapter ) { return metricAdapter . getMonitorables ( ) . iterator ( ) . next ( ) ; }", "answer": "org . junit . Assert . assertThat ( ( ( java . lang . Integer ) ( getFirstMonitorable ( gaugeAdapter ) . get ( ) ) ) , org . hamcrest . Matchers . is ( newValue ) )"}
{"focal": "split ( java . lang . String ) { java . util . List < java . lang . String > result = new java . util . ArrayList ( ) ; return com . openshift . internal . util . StringSplitter . split ( str , result ) ; }", "testMethod": "testSimpleDoubleSpaceManyParameters ( ) { java . util . List < java . lang . String > result = com . openshift . internal . util . StringSplitter . split ( \"parm1<sp>parm2<sp>parm3\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"parm1\" , \"parm2\" , \"parm3\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testSimpleDoubleSpaceManyParameters ( ) { java . util . List < java . lang . String > result = com . openshift . internal . util . StringSplitter . split ( \"parm1<sp>parm2<sp>parm3\" ) ; java . util . List < java . lang . String > expected = java . util . Arrays . asList ( \"parm1\" , \"parm2\" , \"parm3\" ) ; \"<AssertPlaceHolder>\" ; } split ( java . lang . String ) { java . util . List < java . lang . String > result = new java . util . ArrayList ( ) ; return com . openshift . internal . util . StringSplitter . split ( str , result ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "exists ( ) { return ( getId ( ) ) != null ; }", "testMethod": "convertANonODTDocument ( ) { java . io . File wrongDocument = getDocumentNamed ( org . silverpeas . core . contribution . converter . ODTConverterIT . WRONG_DOCUMENT_NAME ) ; \"<AssertPlaceHolder>\" ; converter . convert ( wrongDocument , inFormat ( pdf ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( wrongDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "convertANonODTDocument ( ) { java . io . File wrongDocument = getDocumentNamed ( org . silverpeas . core . contribution . converter . ODTConverterIT . WRONG_DOCUMENT_NAME ) ; \"<AssertPlaceHolder>\" ; converter . convert ( wrongDocument , inFormat ( pdf ) ) ; } exists ( ) { return ( getId ( ) ) != null ; }", "answer": "org . junit . Assert . assertThat ( wrongDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "size ( ) { return values . size ( ) ; }", "testMethod": "shouldReturnSizeOfZero ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( root . size ( ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "shouldReturnSizeOfZero ( ) { \"<AssertPlaceHolder>\" ; } size ( ) { return values . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( root . size ( ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "isVariableNameValid ( java . lang . String ) { return org . kie . dmn . feel . parser . feel11 . FEELParser . checkVariableName ( source ) . isEmpty ( ) ; }", "testMethod": "testVariableNameWithValidCharacters ( ) { java . lang . String var = \"?_873./-'+*valid\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . kie . dmn . feel . parser . feel11 . FEELParser . isVariableNameValid ( var ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testVariableNameWithValidCharacters ( ) { java . lang . String var = \"?_873./-'+*valid\" ; \"<AssertPlaceHolder>\" ; } isVariableNameValid ( java . lang . String ) { return org . kie . dmn . feel . parser . feel11 . FEELParser . checkVariableName ( source ) . isEmpty ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . kie . dmn . feel . parser . feel11 . FEELParser . isVariableNameValid ( var ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getContentType ( ) { return contentType ; }", "testMethod": "shouldReturnSameContentType ( ) { com . navercorp . volleyextensions . volleyer . http . ContentType contentType = com . navercorp . volleyextensions . volleyer . http . ContentType . CONTENT_TYPE_TEXT_JSON ; com . navercorp . volleyextensions . volleyer . multipart . Part part = new com . navercorp . volleyextensions . volleyer . multipart . FilePart ( com . navercorp . volleyextensions . volleyer . multipart . FilePartTest . name , com . navercorp . volleyextensions . volleyer . multipart . FilePartTest . file , contentType ) ; com . navercorp . volleyextensions . volleyer . http . ContentType returnContentType = part . getContentType ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( contentType , org . hamcrest . CoreMatchers . is ( returnContentType ) )", "total": "shouldReturnSameContentType ( ) { com . navercorp . volleyextensions . volleyer . http . ContentType contentType = com . navercorp . volleyextensions . volleyer . http . ContentType . CONTENT_TYPE_TEXT_JSON ; com . navercorp . volleyextensions . volleyer . multipart . Part part = new com . navercorp . volleyextensions . volleyer . multipart . FilePart ( com . navercorp . volleyextensions . volleyer . multipart . FilePartTest . name , com . navercorp . volleyextensions . volleyer . multipart . FilePartTest . file , contentType ) ; com . navercorp . volleyextensions . volleyer . http . ContentType returnContentType = part . getContentType ( ) ; \"<AssertPlaceHolder>\" ; } getContentType ( ) { return contentType ; }", "answer": "org . junit . Assert . assertThat ( contentType , org . hamcrest . CoreMatchers . is ( returnContentType ) )"}
{"focal": "set ( T ) { if ( ( insertedElement ) != null ) { insertedElement . set ( value ) ; } else { backingList . add ( listIndex , value ) ; insertedElement = new de . fxnn . util . ExistingListElement ( backingList , listIndex ) ; } }", "testMethod": "testSetFirstElement ( ) { java . util . List < java . lang . Integer > givenList = com . google . common . collect . Lists . newArrayList ( 1 , 2 , 3 ) ; de . fxnn . util . ListElement . firstElement ( givenList ) . set ( 42 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( givenList . get ( 0 ) , is ( 42 ) )", "total": "testSetFirstElement ( ) { java . util . List < java . lang . Integer > givenList = com . google . common . collect . Lists . newArrayList ( 1 , 2 , 3 ) ; de . fxnn . util . ListElement . firstElement ( givenList ) . set ( 42 ) ; \"<AssertPlaceHolder>\" ; } set ( T ) { if ( ( insertedElement ) != null ) { insertedElement . set ( value ) ; } else { backingList . add ( listIndex , value ) ; insertedElement = new de . fxnn . util . ExistingListElement ( backingList , listIndex ) ; } }", "answer": "org . junit . Assert . assertThat ( givenList . get ( 0 ) , is ( 42 ) )"}
{"focal": "getLabels ( ) { return com . google . common . base . Joiner . on ( \"\\n\" ) . skipNulls ( ) . join ( labels ) ; }", "testMethod": "twoOfThreeLabelsExists ( ) { java . util . Set < java . lang . String > localLabels = new java . util . HashSet ( asList ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . LOCALLY_TESTED , org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . MERGE ) ) ; java . util . List < org . jenkinsci . plugins . github . pullrequest . events . impl . GHLabel > remoteLabels = asList ( testLabel , reviewedLabel , mergeLabel ) ; java . util . Set < java . lang . String > remoteLabelSet = new java . util . HashSet ( asList ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . LOCALLY_TESTED , org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . REVIEWED , org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . MERGE ) ) ; commonExpectations ( localLabels ) ; when ( issue . getLabels ( ) ) . thenReturn ( remoteLabels ) ; when ( testLabel . getName ( ) ) . thenReturn ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . LOCALLY_TESTED ) ; when ( reviewedLabel . getName ( ) ) . thenReturn ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . REVIEWED ) ; when ( mergeLabel . getName ( ) ) . thenReturn ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . MERGE ) ; causeCreationExpectations ( ) ; org . jenkinsci . plugins . github . pullrequest . GitHubPRCause cause = new org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEvent ( labels , false ) . check ( newGitHubPRDecisionContext ( ) . withPrTrigger ( trigger ) . withLocalPR ( localPR ) . withRemotePR ( remotePr ) . withListener ( listener ) . build ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cause . getLabels ( ) , org . hamcrest . Matchers . equalTo ( remoteLabelSet ) )", "total": "twoOfThreeLabelsExists ( ) { java . util . Set < java . lang . String > localLabels = new java . util . HashSet ( asList ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . LOCALLY_TESTED , org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . MERGE ) ) ; java . util . List < org . jenkinsci . plugins . github . pullrequest . events . impl . GHLabel > remoteLabels = asList ( testLabel , reviewedLabel , mergeLabel ) ; java . util . Set < java . lang . String > remoteLabelSet = new java . util . HashSet ( asList ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . LOCALLY_TESTED , org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . REVIEWED , org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . MERGE ) ) ; commonExpectations ( localLabels ) ; when ( issue . getLabels ( ) ) . thenReturn ( remoteLabels ) ; when ( testLabel . getName ( ) ) . thenReturn ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . LOCALLY_TESTED ) ; when ( reviewedLabel . getName ( ) ) . thenReturn ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . REVIEWED ) ; when ( mergeLabel . getName ( ) ) . thenReturn ( org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEventTest . MERGE ) ; causeCreationExpectations ( ) ; org . jenkinsci . plugins . github . pullrequest . GitHubPRCause cause = new org . jenkinsci . plugins . github . pullrequest . events . impl . GitHubPRLabelExistsEvent ( labels , false ) . check ( newGitHubPRDecisionContext ( ) . withPrTrigger ( trigger ) . withLocalPR ( localPR ) . withRemotePR ( remotePr ) . withListener ( listener ) . build ( ) ) ; \"<AssertPlaceHolder>\" ; } getLabels ( ) { return com . google . common . base . Joiner . on ( \"\\n\" ) . skipNulls ( ) . join ( labels ) ; }", "answer": "org . junit . Assert . assertThat ( cause . getLabels ( ) , org . hamcrest . Matchers . equalTo ( remoteLabelSet ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectWithDifferentType ( ) { org . o3project . odenos . core . component . network . flow . basic . FlowAction obj = new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsObjectWithDifferentType ( ) { org . o3project . odenos . core . component . network . flow . basic . FlowAction obj = new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "next ( ) { item = delegate . next ( ) ; return item ; }", "testMethod": "sscanShouldRetrieveAllValuesInSetCorrectly ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { nativeConnection . sadd ( org . springframework . data . redis . connection . jedis . JedisClusterConnectionTests . KEY_1_BYTES , org . springframework . data . redis . connection . jedis . JedisConverters . toBytes ( java . lang . Integer . valueOf ( i ) ) ) ; } int count = 0 ; org . springframework . data . redis . core . Cursor < byte [ ] > cursor = clusterConnection . sScan ( org . springframework . data . redis . connection . jedis . JedisClusterConnectionTests . KEY_1_BYTES , ScanOptions . NONE ) ; while ( cursor . hasNext ( ) ) { count ++ ; cursor . next ( ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , is ( 30 ) )", "total": "sscanShouldRetrieveAllValuesInSetCorrectly ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { nativeConnection . sadd ( org . springframework . data . redis . connection . jedis . JedisClusterConnectionTests . KEY_1_BYTES , org . springframework . data . redis . connection . jedis . JedisConverters . toBytes ( java . lang . Integer . valueOf ( i ) ) ) ; } int count = 0 ; org . springframework . data . redis . core . Cursor < byte [ ] > cursor = clusterConnection . sScan ( org . springframework . data . redis . connection . jedis . JedisClusterConnectionTests . KEY_1_BYTES , ScanOptions . NONE ) ; while ( cursor . hasNext ( ) ) { count ++ ; cursor . next ( ) ; } \"<AssertPlaceHolder>\" ; } next ( ) { item = delegate . next ( ) ; return item ; }", "answer": "org . junit . Assert . assertThat ( count , is ( 30 ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "size_A$ ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . Integer actual = nil . size ( ) ; java . lang . Integer expected = 0 ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "size_A$ ( ) { com . m3 . scalaflavor4j . Nil < java . lang . String > nil = com . m3 . scalaflavor4j . Nil . < java . lang . String > apply ( ) ; java . lang . Integer actual = nil . size ( ) ; java . lang . Integer expected = 0 ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "isDirectory ( ) { return directory ; }", "testMethod": "createProvider ( ) { java . io . File path = folder . newFolder ( \"session\" ) ; org . junit . Assume . assumeTrue ( path . delete ( ) ) ; java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( SessionProfile . KEY_PROVIDER , com . asakusafw . windgate . file . session . FileSessionProvider . class . getName ( ) ) ; p . setProperty ( ( ( SessionProfile . KEY_PREFIX ) + ( com . asakusafw . windgate . file . session . FileSessionProvider . KEY_DIRECTORY ) ) , path . getPath ( ) ) ; com . asakusafw . windgate . core . session . SessionProfile profile = com . asakusafw . windgate . core . session . SessionProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; com . asakusafw . windgate . core . session . SessionProvider provider = profile . createProvider ( ) ; try ( com . asakusafw . windgate . core . session . SessionMirror session = provider . create ( \"hello\" ) ) { } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( path . isDirectory ( ) , is ( true ) )", "total": "createProvider ( ) { java . io . File path = folder . newFolder ( \"session\" ) ; org . junit . Assume . assumeTrue ( path . delete ( ) ) ; java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( SessionProfile . KEY_PROVIDER , com . asakusafw . windgate . file . session . FileSessionProvider . class . getName ( ) ) ; p . setProperty ( ( ( SessionProfile . KEY_PREFIX ) + ( com . asakusafw . windgate . file . session . FileSessionProvider . KEY_DIRECTORY ) ) , path . getPath ( ) ) ; com . asakusafw . windgate . core . session . SessionProfile profile = com . asakusafw . windgate . core . session . SessionProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; com . asakusafw . windgate . core . session . SessionProvider provider = profile . createProvider ( ) ; try ( com . asakusafw . windgate . core . session . SessionMirror session = provider . create ( \"hello\" ) ) { } \"<AssertPlaceHolder>\" ; } isDirectory ( ) { return directory ; }", "answer": "org . junit . Assert . assertThat ( path . isDirectory ( ) , is ( true ) )"}
{"focal": "items ( ) { return entries . values ( ) ; }", "testMethod": "testInterpolatedTypeDefaults ( ) { org . apache . beam . sdk . transforms . display . DisplayData data = org . apache . beam . sdk . transforms . display . DisplayData . from ( new org . apache . beam . sdk . transforms . display . HasDisplayData ( ) { @ org . apache . beam . sdk . transforms . display . Override public void populateDisplayData ( org . apache . beam . sdk . transforms . display . DisplayData . Builder builder ) { builder . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"integer\" , 123 ) , 123 ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Integer\" , java . lang . Integer . valueOf ( 123 ) ) , java . lang . Integer . valueOf ( 123 ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"long\" , 123L ) , 123L ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Long\" , java . lang . Long . valueOf ( 123 ) ) , java . lang . Long . valueOf ( 123 ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"float\" , 1.23F ) , 1.23F ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Float\" , java . lang . Float . valueOf ( 1.23F ) ) , java . lang . Float . valueOf ( 1.23F ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"double\" , 1.23 ) , 1.23 ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Double\" , java . lang . Double . valueOf ( 1.23 ) ) , java . lang . Double . valueOf ( 1.23 ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"boolean\" , true ) , true ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Boolean\" , Boolean . TRUE ) , Boolean . TRUE ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( data . items ( ) , org . hamcrest . Matchers . empty ( ) )", "total": "testInterpolatedTypeDefaults ( ) { org . apache . beam . sdk . transforms . display . DisplayData data = org . apache . beam . sdk . transforms . display . DisplayData . from ( new org . apache . beam . sdk . transforms . display . HasDisplayData ( ) { @ org . apache . beam . sdk . transforms . display . Override public void populateDisplayData ( org . apache . beam . sdk . transforms . display . DisplayData . Builder builder ) { builder . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"integer\" , 123 ) , 123 ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Integer\" , java . lang . Integer . valueOf ( 123 ) ) , java . lang . Integer . valueOf ( 123 ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"long\" , 123L ) , 123L ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Long\" , java . lang . Long . valueOf ( 123 ) ) , java . lang . Long . valueOf ( 123 ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"float\" , 1.23F ) , 1.23F ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Float\" , java . lang . Float . valueOf ( 1.23F ) ) , java . lang . Float . valueOf ( 1.23F ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"double\" , 1.23 ) , 1.23 ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Double\" , java . lang . Double . valueOf ( 1.23 ) ) , java . lang . Double . valueOf ( 1.23 ) ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"boolean\" , true ) , true ) . addIfNotDefault ( org . apache . beam . sdk . transforms . display . DisplayData . item ( \"Boolean\" , Boolean . TRUE ) , Boolean . TRUE ) ; } } ) ; \"<AssertPlaceHolder>\" ; } items ( ) { return entries . values ( ) ; }", "answer": "org . junit . Assert . assertThat ( data . items ( ) , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "readFromInputStream ( java . io . InputStream ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"inputStream\" , inputStream ) ; try { final java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( inputStream ) ; final E result = ( ( E ) ( ois . readObject ( ) ) ) ; ois . close ( ) ; return result ; } catch ( final java . lang . Exception e ) { throw org . openspotlight . common . util . Exceptions . logAndReturnNew ( e , org . openspotlight . common . exception . SLException . class ) ; } }", "testMethod": "shouldWriteAndReadStream ( ) { final java . lang . Double value = new java . lang . Double ( 1.0 ) ; final java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; org . openspotlight . common . util . Serialization . serializeToOutputStream ( value , baos ) ; final byte [ ] content = baos . toByteArray ( ) ; final java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( content ) ; final java . lang . Double readedValue = org . openspotlight . common . util . Serialization . readFromInputStream ( bais ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( readedValue , org . hamcrest . core . Is . is ( value ) )", "total": "shouldWriteAndReadStream ( ) { final java . lang . Double value = new java . lang . Double ( 1.0 ) ; final java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; org . openspotlight . common . util . Serialization . serializeToOutputStream ( value , baos ) ; final byte [ ] content = baos . toByteArray ( ) ; final java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( content ) ; final java . lang . Double readedValue = org . openspotlight . common . util . Serialization . readFromInputStream ( bais ) ; \"<AssertPlaceHolder>\" ; } readFromInputStream ( java . io . InputStream ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"inputStream\" , inputStream ) ; try { final java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( inputStream ) ; final E result = ( ( E ) ( ois . readObject ( ) ) ) ; ois . close ( ) ; return result ; } catch ( final java . lang . Exception e ) { throw org . openspotlight . common . util . Exceptions . logAndReturnNew ( e , org . openspotlight . common . exception . SLException . class ) ; } }", "answer": "org . junit . Assert . assertThat ( readedValue , org . hamcrest . core . Is . is ( value ) )"}
{"focal": "getMouse ( ) { return mouse ; }", "testMethod": "shouldNotInstantiateIfLastTerm ( ) { final ognl . TypeConverter typeConverter = mock ( ognl . TypeConverter . class ) ; final br . com . caelum . vraptor . http . ognl . ReflectionBasedNullHandlerTest . House house = new br . com . caelum . vraptor . http . ognl . ReflectionBasedNullHandlerTest . House ( ) ; final br . com . caelum . vraptor . http . ognl . Mouse tom = new br . com . caelum . vraptor . http . ognl . Mouse ( ) ; java . lang . reflect . Method method = br . com . caelum . vraptor . http . ognl . ReflectionBasedNullHandlerTest . House . class . getDeclaredMethod ( \"setMouse\" , br . com . caelum . vraptor . http . ognl . Mouse . class ) ; when ( typeConverter . convertValue ( context , house , method , \"mouse\" , \"22\" , br . com . caelum . vraptor . http . ognl . Mouse . class ) ) . thenReturn ( tom ) ; ognl . Ognl . setTypeConverter ( context , typeConverter ) ; ognl . Ognl . setValue ( \"mouse\" , context , house , \"22\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( house . getMouse ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( tom ) ) )", "total": "shouldNotInstantiateIfLastTerm ( ) { final ognl . TypeConverter typeConverter = mock ( ognl . TypeConverter . class ) ; final br . com . caelum . vraptor . http . ognl . ReflectionBasedNullHandlerTest . House house = new br . com . caelum . vraptor . http . ognl . ReflectionBasedNullHandlerTest . House ( ) ; final br . com . caelum . vraptor . http . ognl . Mouse tom = new br . com . caelum . vraptor . http . ognl . Mouse ( ) ; java . lang . reflect . Method method = br . com . caelum . vraptor . http . ognl . ReflectionBasedNullHandlerTest . House . class . getDeclaredMethod ( \"setMouse\" , br . com . caelum . vraptor . http . ognl . Mouse . class ) ; when ( typeConverter . convertValue ( context , house , method , \"mouse\" , \"22\" , br . com . caelum . vraptor . http . ognl . Mouse . class ) ) . thenReturn ( tom ) ; ognl . Ognl . setTypeConverter ( context , typeConverter ) ; ognl . Ognl . setValue ( \"mouse\" , context , house , \"22\" ) ; \"<AssertPlaceHolder>\" ; } getMouse ( ) { return mouse ; }", "answer": "org . junit . Assert . assertThat ( house . getMouse ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( tom ) ) )"}
{"focal": "getChanges ( ) { return changes ; }", "testMethod": "testNoChanges ( ) { java . lang . String drl1 = \"package<sp>org.drools\\n\" + ( ( ( \"rule<sp>R1<sp>when\\n\" + \"<sp>$m<sp>:<sp>Message(<sp>message<sp>==<sp>\\\"Hello<sp>World\\\"<sp>)\\n\" ) + \"then\\n\" ) + \"end\\n\" ) ; java . lang . String drl2 = \"package<sp>org.drools\\n\" + ( ( ( \"rule<sp>R2<sp>when\\n\" + \"<sp>$m<sp>:<sp>Message(<sp>message<sp>==<sp>\\\"Hello<sp>World\\\"<sp>)\\n\" ) + \"then\\n\" ) + \"end\\n\" ) ; org . drools . compiler . kie . builder . impl . InternalKieModule kieJar1 = createKieJar ( drl1 , drl2 ) ; org . drools . compiler . kie . builder . impl . InternalKieModule kieJar2 = createKieJar ( drl1 , drl2 ) ; org . drools . compiler . kie . util . KieJarChangeSet changes = org . drools . compiler . kie . util . ChangeSetBuilder . build ( kieJar1 , kieJar2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( changes . getChanges ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "testNoChanges ( ) { java . lang . String drl1 = \"package<sp>org.drools\\n\" + ( ( ( \"rule<sp>R1<sp>when\\n\" + \"<sp>$m<sp>:<sp>Message(<sp>message<sp>==<sp>\\\"Hello<sp>World\\\"<sp>)\\n\" ) + \"then\\n\" ) + \"end\\n\" ) ; java . lang . String drl2 = \"package<sp>org.drools\\n\" + ( ( ( \"rule<sp>R2<sp>when\\n\" + \"<sp>$m<sp>:<sp>Message(<sp>message<sp>==<sp>\\\"Hello<sp>World\\\"<sp>)\\n\" ) + \"then\\n\" ) + \"end\\n\" ) ; org . drools . compiler . kie . builder . impl . InternalKieModule kieJar1 = createKieJar ( drl1 , drl2 ) ; org . drools . compiler . kie . builder . impl . InternalKieModule kieJar2 = createKieJar ( drl1 , drl2 ) ; org . drools . compiler . kie . util . KieJarChangeSet changes = org . drools . compiler . kie . util . ChangeSetBuilder . build ( kieJar1 , kieJar2 ) ; \"<AssertPlaceHolder>\" ; } getChanges ( ) { return changes ; }", "answer": "org . junit . Assert . assertThat ( changes . getChanges ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "next ( ) { return ( index ) < ( org . modeshape . schematic . internal . document . IndexSequence . MAXIMUM_KEY_COUNT ) ? org . modeshape . schematic . internal . document . IndexSequence . INDEX_VALUES [ ( ( index ) ++ ) ] : java . lang . String . valueOf ( ( ( index ) ++ ) ) ; }", "testMethod": "shouldCreateIteratorOverValuesWhenSuppliedIteratorOfUnknownObjects ( ) { java . util . List < java . lang . String > values = new java . util . ArrayList < java . lang . String > ( ) ; for ( int i = 0 ; i != 10 ; ++ i ) values . add ( ( \"\" + i ) ) ; java . util . Iterator < java . math . BigDecimal > iter = factory . create ( values . iterator ( ) ) ; java . util . Iterator < java . lang . String > valueIter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( iter . next ( ) , org . hamcrest . core . Is . is ( factory . create ( valueIter . next ( ) ) ) )", "total": "shouldCreateIteratorOverValuesWhenSuppliedIteratorOfUnknownObjects ( ) { java . util . List < java . lang . String > values = new java . util . ArrayList < java . lang . String > ( ) ; for ( int i = 0 ; i != 10 ; ++ i ) values . add ( ( \"\" + i ) ) ; java . util . Iterator < java . math . BigDecimal > iter = factory . create ( values . iterator ( ) ) ; java . util . Iterator < java . lang . String > valueIter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { \"<AssertPlaceHolder>\" ; } } next ( ) { return ( index ) < ( org . modeshape . schematic . internal . document . IndexSequence . MAXIMUM_KEY_COUNT ) ? org . modeshape . schematic . internal . document . IndexSequence . INDEX_VALUES [ ( ( index ) ++ ) ] : java . lang . String . valueOf ( ( ( index ) ++ ) ) ; }", "answer": "org . junit . Assert . assertThat ( iter . next ( ) , org . hamcrest . core . Is . is ( factory . create ( valueIter . next ( ) ) ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldReturnCountForGivenCriteriaQuery ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = org . springframework . data . elasticsearch . entities . SampleEntity . builder ( ) . id ( documentId ) . message ( \"some<sp>message\" ) . version ( java . lang . System . currentTimeMillis ( ) ) . build ( ) ; org . springframework . data . elasticsearch . core . IndexQuery indexQuery = getIndexQuery ( sampleEntity ) ; elasticsearchTemplate . index ( indexQuery ) ; elasticsearchTemplate . refresh ( org . springframework . data . elasticsearch . entities . SampleEntity . class ) ; org . springframework . data . elasticsearch . core . CriteriaQuery criteriaQuery = new org . springframework . data . elasticsearch . core . CriteriaQuery ( new org . springframework . data . elasticsearch . core . Criteria ( ) ) ; long count = elasticsearchTemplate . count ( criteriaQuery , org . springframework . data . elasticsearch . entities . SampleEntity . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )", "total": "shouldReturnCountForGivenCriteriaQuery ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = org . springframework . data . elasticsearch . entities . SampleEntity . builder ( ) . id ( documentId ) . message ( \"some<sp>message\" ) . version ( java . lang . System . currentTimeMillis ( ) ) . build ( ) ; org . springframework . data . elasticsearch . core . IndexQuery indexQuery = getIndexQuery ( sampleEntity ) ; elasticsearchTemplate . index ( indexQuery ) ; elasticsearchTemplate . refresh ( org . springframework . data . elasticsearch . entities . SampleEntity . class ) ; org . springframework . data . elasticsearch . core . CriteriaQuery criteriaQuery = new org . springframework . data . elasticsearch . core . CriteriaQuery ( new org . springframework . data . elasticsearch . core . Criteria ( ) ) ; long count = elasticsearchTemplate . count ( criteriaQuery , org . springframework . data . elasticsearch . entities . SampleEntity . class ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )"}
{"focal": "get ( ) { return synchronous ( newGet ( ) . setURI ( uri ) ) ; }", "testMethod": "testGetNextMessageIdReusesIdAfterExchangeLifetime ( ) { int exchangeLifetime = 100 ; org . eclipse . californium . core . network . config . NetworkConfig config = org . eclipse . californium . core . network . config . NetworkConfig . createStandardWithoutFile ( ) . setInt ( NetworkConfig . Keys . EXCHANGE_LIFETIME , exchangeLifetime ) ; final org . eclipse . californium . core . network . MapBasedMessageIdTracker tracker = new org . eclipse . californium . core . network . MapBasedMessageIdTracker ( 0 , config ) ; int firstMid = tracker . getNextMessageId ( ) ; for ( int i = 1 ; i < ( org . eclipse . californium . core . network . MessageIdTracker . TOTAL_NO_OF_MIDS ) ; i ++ ) { tracker . getNextMessageId ( ) ; } exchangeLifetime += exchangeLifetime > > 1 ; final java . util . concurrent . atomic . AtomicInteger mid = new java . util . concurrent . atomic . AtomicInteger ( ( - 1 ) ) ; org . eclipse . californium . TestTools . waitForCondition ( exchangeLifetime , 10 , TimeUnit . MILLISECONDS , new org . eclipse . californium . CheckCondition ( ) { @ org . eclipse . californium . core . network . Override public boolean isFulFilled ( ) throws org . eclipse . californium . core . network . IllegalStateException { mid . set ( tracker . getNextMessageId ( ) ) ; return 0 <= ( mid . get ( ) ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mid . get ( ) , org . hamcrest . CoreMatchers . is ( firstMid ) )", "total": "testGetNextMessageIdReusesIdAfterExchangeLifetime ( ) { int exchangeLifetime = 100 ; org . eclipse . californium . core . network . config . NetworkConfig config = org . eclipse . californium . core . network . config . NetworkConfig . createStandardWithoutFile ( ) . setInt ( NetworkConfig . Keys . EXCHANGE_LIFETIME , exchangeLifetime ) ; final org . eclipse . californium . core . network . MapBasedMessageIdTracker tracker = new org . eclipse . californium . core . network . MapBasedMessageIdTracker ( 0 , config ) ; int firstMid = tracker . getNextMessageId ( ) ; for ( int i = 1 ; i < ( org . eclipse . californium . core . network . MessageIdTracker . TOTAL_NO_OF_MIDS ) ; i ++ ) { tracker . getNextMessageId ( ) ; } exchangeLifetime += exchangeLifetime > > 1 ; final java . util . concurrent . atomic . AtomicInteger mid = new java . util . concurrent . atomic . AtomicInteger ( ( - 1 ) ) ; org . eclipse . californium . TestTools . waitForCondition ( exchangeLifetime , 10 , TimeUnit . MILLISECONDS , new org . eclipse . californium . CheckCondition ( ) { @ org . eclipse . californium . core . network . Override public boolean isFulFilled ( ) throws org . eclipse . californium . core . network . IllegalStateException { mid . set ( tracker . getNextMessageId ( ) ) ; return 0 <= ( mid . get ( ) ) ; } } ) ; \"<AssertPlaceHolder>\" ; } get ( ) { return synchronous ( newGet ( ) . setURI ( uri ) ) ; }", "answer": "org . junit . Assert . assertThat ( mid . get ( ) , org . hamcrest . CoreMatchers . is ( firstMid ) )"}
{"focal": "nullValue ( ) { return new org . eclipse . che . ide . ext . java . jdi . server . expression . ReadOnlyValue ( null ) ; }", "testMethod": "objectShouldNotBeEqualsWhenObjectIsNull ( ) { boolean isEquals = debuggerVariable . equals ( org . hamcrest . CoreMatchers . nullValue ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isEquals , org . hamcrest . CoreMatchers . is ( false ) )", "total": "objectShouldNotBeEqualsWhenObjectIsNull ( ) { boolean isEquals = debuggerVariable . equals ( org . hamcrest . CoreMatchers . nullValue ( ) ) ; \"<AssertPlaceHolder>\" ; } nullValue ( ) { return new org . eclipse . che . ide . ext . java . jdi . server . expression . ReadOnlyValue ( null ) ; }", "answer": "org . junit . Assert . assertThat ( isEquals , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getText ( ) { return stb . getText ( ) ; }", "testMethod": "testShouldIssueMouseUpEvents ( ) { driver . get ( pages . javascriptPage ) ; driver . findElement ( org . openqa . selenium . By . id ( \"mouseup\" ) ) . click ( ) ; org . openqa . selenium . WebElement result = driver . findElement ( org . openqa . selenium . By . id ( \"result\" ) ) ; wait . until ( org . openqa . selenium . WaitingConditions . elementTextToEqual ( result , \"mouse<sp>up\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . getText ( ) , org . hamcrest . Matchers . equalTo ( \"mouse<sp>up\" ) )", "total": "testShouldIssueMouseUpEvents ( ) { driver . get ( pages . javascriptPage ) ; driver . findElement ( org . openqa . selenium . By . id ( \"mouseup\" ) ) . click ( ) ; org . openqa . selenium . WebElement result = driver . findElement ( org . openqa . selenium . By . id ( \"result\" ) ) ; wait . until ( org . openqa . selenium . WaitingConditions . elementTextToEqual ( result , \"mouse<sp>up\" ) ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { return stb . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . getText ( ) , org . hamcrest . Matchers . equalTo ( \"mouse<sp>up\" ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectSuccess ( ) { org . o3project . odenos . core . component . network . flow . basic . FlowAction obj = new org . o3project . odenos . core . component . network . flow . basic . FlowAction ( ) { @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean validate ( ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public java . lang . String getType ( ) { return \"Type\" ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean readValue ( org . msgpack . type . Value value ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public org . o3project . odenos . core . component . network . flow . basic . FlowAction clone ( ) { return this ; } } ; org . o3project . odenos . core . component . network . flow . basic . FlowAction target = new org . o3project . odenos . core . component . network . flow . basic . FlowAction ( ) { @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean validate ( ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public java . lang . String getType ( ) { return \"Type\" ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean readValue ( org . msgpack . type . Value value ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public org . o3project . odenos . core . component . network . flow . basic . FlowAction clone ( ) { return this ; } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testEqualsObjectSuccess ( ) { org . o3project . odenos . core . component . network . flow . basic . FlowAction obj = new org . o3project . odenos . core . component . network . flow . basic . FlowAction ( ) { @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean validate ( ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public java . lang . String getType ( ) { return \"Type\" ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean readValue ( org . msgpack . type . Value value ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public org . o3project . odenos . core . component . network . flow . basic . FlowAction clone ( ) { return this ; } } ; org . o3project . odenos . core . component . network . flow . basic . FlowAction target = new org . o3project . odenos . core . component . network . flow . basic . FlowAction ( ) { @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean validate ( ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public java . lang . String getType ( ) { return \"Type\" ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public boolean readValue ( org . msgpack . type . Value value ) { return false ; } @ org . o3project . odenos . core . component . network . flow . basic . Override public org . o3project . odenos . core . component . network . flow . basic . FlowAction clone ( ) { return this ; } } ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "validate ( ) { return true ; }", "testMethod": "validate_statusIsSet_returnTrue ( ) { confirmation . setStatus ( ClearCacheStatus . Accepted ) ; boolean isValid = confirmation . validate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( true ) )", "total": "validate_statusIsSet_returnTrue ( ) { confirmation . setStatus ( ClearCacheStatus . Accepted ) ; boolean isValid = confirmation . validate ( ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { return true ; }", "answer": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "numericallyThenLexicographically ( ) { return ( o1 , o2 ) -> { if ( ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o1 ) ) && ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o2 ) ) ) { return uk . gov . pay . adminusers . utils . Comparators . usingNumericComparator ( ) . compare ( o1 , o2 ) ; } else if ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o1 ) ) { return - 1 ; } else if ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o2 ) ) { return 1 ; } else { return o1 . compareTo ( o2 ) ; } } ; }", "testMethod": "shouldOrderGatewayAccountsIdsNumericallyThenLexicographically ( ) { java . util . List < java . lang . String > result = java . util . stream . Stream . of ( \"1aaa\" , \"1\" , \"6\" , \"cde\" , \"4\" , \"bbb23\" , \"10\" , \"5\" ) . sorted ( numericallyThenLexicographically ( ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( \"1\" , \"4\" , \"5\" , \"6\" , \"10\" , \"1aaa\" , \"bbb23\" , \"cde\" ) ) )", "total": "shouldOrderGatewayAccountsIdsNumericallyThenLexicographically ( ) { java . util . List < java . lang . String > result = java . util . stream . Stream . of ( \"1aaa\" , \"1\" , \"6\" , \"cde\" , \"4\" , \"bbb23\" , \"10\" , \"5\" ) . sorted ( numericallyThenLexicographically ( ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; } numericallyThenLexicographically ( ) { return ( o1 , o2 ) -> { if ( ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o1 ) ) && ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o2 ) ) ) { return uk . gov . pay . adminusers . utils . Comparators . usingNumericComparator ( ) . compare ( o1 , o2 ) ; } else if ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o1 ) ) { return - 1 ; } else if ( org . apache . commons . lang3 . math . NumberUtils . isDigits ( o2 ) ) { return 1 ; } else { return o1 . compareTo ( o2 ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( \"1\" , \"4\" , \"5\" , \"6\" , \"10\" , \"1aaa\" , \"bbb23\" , \"cde\" ) ) )"}
{"focal": "format ( long ) { java . lang . String num = java . lang . String . valueOf ( java . lang . Math . abs ( amount ) ) ; char zero = this . zeroDigit ; java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; if ( amount < 0 ) { sb . append ( this . minusSign ) ; } for ( int i = 0 , n = num . length ( ) ; i < n ; i ++ ) { char c = num . charAt ( i ) ; if ( zero != '0' ) { c = ( ( char ) ( ( c + zero ) - '0' ) ) ; } sb . append ( c ) ; } return sb . toString ( ) ; }", "testMethod": "dayPeriods ( ) { net . time4j . format . expert . ChronoFormatter < net . time4j . PlainTimestamp > cf2 = net . time4j . format . expert . ChronoFormatter . ofPattern ( \"yyyy-MM-dd<sp>h:mm<sp>B\" , PatternType . CLDR , Locale . ENGLISH , net . time4j . PlainTimestamp . axis ( ) ) ; java . time . LocalDateTime ldt = java . time . LocalDateTime . now ( ) ; net . time4j . PlainTimestamp tsp = net . time4j . PlainTimestamp . from ( ldt ) ; java . lang . String expected = cf2 . format ( tsp ) ; System . out . println ( expected ) ; net . time4j . format . expert . ChronoFormatter < java . time . LocalDateTime > cf1 = net . time4j . format . expert . ChronoFormatter . ofPattern ( \"yyyy-MM-dd<sp>h:mm<sp>B\" , PatternType . CLDR , Locale . ENGLISH , net . time4j . PlainTimestamp . threeten ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cf1 . format ( ldt ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "dayPeriods ( ) { net . time4j . format . expert . ChronoFormatter < net . time4j . PlainTimestamp > cf2 = net . time4j . format . expert . ChronoFormatter . ofPattern ( \"yyyy-MM-dd<sp>h:mm<sp>B\" , PatternType . CLDR , Locale . ENGLISH , net . time4j . PlainTimestamp . axis ( ) ) ; java . time . LocalDateTime ldt = java . time . LocalDateTime . now ( ) ; net . time4j . PlainTimestamp tsp = net . time4j . PlainTimestamp . from ( ldt ) ; java . lang . String expected = cf2 . format ( tsp ) ; System . out . println ( expected ) ; net . time4j . format . expert . ChronoFormatter < java . time . LocalDateTime > cf1 = net . time4j . format . expert . ChronoFormatter . ofPattern ( \"yyyy-MM-dd<sp>h:mm<sp>B\" , PatternType . CLDR , Locale . ENGLISH , net . time4j . PlainTimestamp . threeten ( ) ) ; \"<AssertPlaceHolder>\" ; } format ( long ) { java . lang . String num = java . lang . String . valueOf ( java . lang . Math . abs ( amount ) ) ; char zero = this . zeroDigit ; java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; if ( amount < 0 ) { sb . append ( this . minusSign ) ; } for ( int i = 0 , n = num . length ( ) ; i < n ; i ++ ) { char c = num . charAt ( i ) ; if ( zero != '0' ) { c = ( ( char ) ( ( c + zero ) - '0' ) ) ; } sb . append ( c ) ; } return sb . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( cf1 . format ( ldt ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "asString ( java . io . InputStream ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; org . slim3 . controller . upload . Streams . copy ( pStream , baos , true ) ; return baos . toString ( ) ; }", "testMethod": "asString ( ) { tester . request . setAttribute ( \"aaa\" , \"1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( controller . asString ( \"aaa\" ) , org . hamcrest . CoreMatchers . is ( \"1\" ) )", "total": "asString ( ) { tester . request . setAttribute ( \"aaa\" , \"1\" ) ; \"<AssertPlaceHolder>\" ; } asString ( java . io . InputStream ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; org . slim3 . controller . upload . Streams . copy ( pStream , baos , true ) ; return baos . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( controller . asString ( \"aaa\" ) , org . hamcrest . CoreMatchers . is ( \"1\" ) )"}
{"focal": "toBase2SuffixedString ( long ) { if ( ( n > 0 ) && ( ( java . lang . Long . bitCount ( n ) ) == 1 ) ) { int i = ( java . lang . Long . numberOfTrailingZeros ( java . lang . Math . abs ( n ) ) ) / 10 ; return ( n > > ( i * 10 ) ) + ( org . terracotta . offheapstore . util . DebuggingUtils . BASE_2_SUFFIXES [ i ] ) ; } else { int i = ( 63 - ( java . lang . Long . numberOfLeadingZeros ( n ) ) ) / 10 ; long factor = 1L << ( i * 10 ) ; long leading = n / factor ; long decimalFactor = factor / 10 ; if ( decimalFactor == 0 ) { return leading + ( org . terracotta . offheapstore . util . DebuggingUtils . BASE_2_SUFFIXES [ i ] ) ; } else { long decimal = ( n - ( leading * factor ) ) / ( factor / 10 ) ; return ( ( leading + \".\" ) + decimal ) + ( org . terracotta . offheapstore . util . DebuggingUtils . BASE_2_SUFFIXES [ i ] ) ; } } }", "testMethod": "testPowerOfTwoBase2Conversions ( ) { long size = 1L ; for ( java . lang . String suffix : new java . lang . String [ ] { \"\" , \"K\" , \"M\" , \"G\" , \"T\" , \"P\" , \"E\" } ) { for ( long value = 1 ; value < 1024 ; value <<= 1 , size <<= 1 ) { if ( size < 0 ) { break ; } \"<AssertPlaceHolder>\" ; } } }", "assertLine": "org . junit . Assert . assertThat ( org . terracotta . offheapstore . util . DebuggingUtils . toBase2SuffixedString ( size ) , org . hamcrest . core . Is . is ( ( value + suffix ) ) )", "total": "testPowerOfTwoBase2Conversions ( ) { long size = 1L ; for ( java . lang . String suffix : new java . lang . String [ ] { \"\" , \"K\" , \"M\" , \"G\" , \"T\" , \"P\" , \"E\" } ) { for ( long value = 1 ; value < 1024 ; value <<= 1 , size <<= 1 ) { if ( size < 0 ) { break ; } \"<AssertPlaceHolder>\" ; } } } toBase2SuffixedString ( long ) { if ( ( n > 0 ) && ( ( java . lang . Long . bitCount ( n ) ) == 1 ) ) { int i = ( java . lang . Long . numberOfTrailingZeros ( java . lang . Math . abs ( n ) ) ) / 10 ; return ( n > > ( i * 10 ) ) + ( org . terracotta . offheapstore . util . DebuggingUtils . BASE_2_SUFFIXES [ i ] ) ; } else { int i = ( 63 - ( java . lang . Long . numberOfLeadingZeros ( n ) ) ) / 10 ; long factor = 1L << ( i * 10 ) ; long leading = n / factor ; long decimalFactor = factor / 10 ; if ( decimalFactor == 0 ) { return leading + ( org . terracotta . offheapstore . util . DebuggingUtils . BASE_2_SUFFIXES [ i ] ) ; } else { long decimal = ( n - ( leading * factor ) ) / ( factor / 10 ) ; return ( ( leading + \".\" ) + decimal ) + ( org . terracotta . offheapstore . util . DebuggingUtils . BASE_2_SUFFIXES [ i ] ) ; } } }", "answer": "org . junit . Assert . assertThat ( org . terracotta . offheapstore . util . DebuggingUtils . toBase2SuffixedString ( size ) , org . hamcrest . core . Is . is ( ( value + suffix ) ) )"}
{"focal": "getValue ( ) { if ( ( value ) != null ) { if ( isLabeledDateType ( ) ) { return ch . puzzle . itc . mobiliar . business . deploy . entity . CustomFilter . convertDateToString ( getDateValue ( ) ) ; } return value . toString ( ) ; } else { return null ; } }", "testMethod": "shouldReturnPropertyValueIfPropertyValueIsNotNull ( ) { java . lang . String propertyValue = \"test\" ; java . lang . String defaultValue = \"default\" ; java . lang . String context = \"mik\" 0 ; ch . puzzle . itc . mobiliar . business . property . entity . ResourceEditProperty resourceEditProperty = new ch . puzzle . itc . mobiliar . business . property . entity . ResourceEditProperty ( \"technicalKey\" , \"displayName\" , propertyValue , \"exampleValue\" , defaultValue , \"propertyComment\" , true , true , false , null , true , \"validationLogic\" , \"mik\" , null , null , null , \"propContName\" , \"typeContName\" , null , null , null , null , null , null , null , null , null , null , null , null , null ) ; dto = new ch . mobi . itc . mobiliar . rest . dtos . PropertyDTO ( resourceEditProperty , context ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dto . getValue ( ) , org . hamcrest . CoreMatchers . is ( propertyValue ) )", "total": "shouldReturnPropertyValueIfPropertyValueIsNotNull ( ) { java . lang . String propertyValue = \"test\" ; java . lang . String defaultValue = \"default\" ; java . lang . String context = \"mik\" 0 ; ch . puzzle . itc . mobiliar . business . property . entity . ResourceEditProperty resourceEditProperty = new ch . puzzle . itc . mobiliar . business . property . entity . ResourceEditProperty ( \"technicalKey\" , \"displayName\" , propertyValue , \"exampleValue\" , defaultValue , \"propertyComment\" , true , true , false , null , true , \"validationLogic\" , \"mik\" , null , null , null , \"propContName\" , \"typeContName\" , null , null , null , null , null , null , null , null , null , null , null , null , null ) ; dto = new ch . mobi . itc . mobiliar . rest . dtos . PropertyDTO ( resourceEditProperty , context ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { if ( ( value ) != null ) { if ( isLabeledDateType ( ) ) { return ch . puzzle . itc . mobiliar . business . deploy . entity . CustomFilter . convertDateToString ( getDateValue ( ) ) ; } return value . toString ( ) ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( dto . getValue ( ) , org . hamcrest . CoreMatchers . is ( propertyValue ) )"}
{"focal": "get ( ) { return delegate . get ( ) ; }", "testMethod": "testJobSubmissionUnderSameJobId ( ) { submitJob ( ) ; runningJobsRegistry . setJobRunning ( jobId ) ; resultFuture . completeExceptionally ( new org . apache . flink . runtime . jobmaster . JobNotFinishedException ( jobId ) ) ; final java . util . concurrent . CompletableFuture < org . apache . flink . runtime . messages . Acknowledge > submissionFuture = dispatcherGateway . submitJob ( jobGraph , org . apache . flink . runtime . dispatcher . DispatcherResourceCleanupTest . timeout ) ; try { submissionFuture . get ( 10L , TimeUnit . MILLISECONDS ) ; org . junit . Assert . fail ( ( \"The<sp>job<sp>submission<sp>future<sp>should<sp>not<sp>complete<sp>until<sp>the<sp>previous<sp>JobManager<sp>\" + \"termination<sp>future<sp>has<sp>been<sp>completed.\" ) ) ; } catch ( java . util . concurrent . TimeoutException ignored ) { } finally { terminationFuture . complete ( null ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( submissionFuture . get ( ) , org . hamcrest . Matchers . equalTo ( org . apache . flink . runtime . messages . Acknowledge . get ( ) ) )", "total": "testJobSubmissionUnderSameJobId ( ) { submitJob ( ) ; runningJobsRegistry . setJobRunning ( jobId ) ; resultFuture . completeExceptionally ( new org . apache . flink . runtime . jobmaster . JobNotFinishedException ( jobId ) ) ; final java . util . concurrent . CompletableFuture < org . apache . flink . runtime . messages . Acknowledge > submissionFuture = dispatcherGateway . submitJob ( jobGraph , org . apache . flink . runtime . dispatcher . DispatcherResourceCleanupTest . timeout ) ; try { submissionFuture . get ( 10L , TimeUnit . MILLISECONDS ) ; org . junit . Assert . fail ( ( \"The<sp>job<sp>submission<sp>future<sp>should<sp>not<sp>complete<sp>until<sp>the<sp>previous<sp>JobManager<sp>\" + \"termination<sp>future<sp>has<sp>been<sp>completed.\" ) ) ; } catch ( java . util . concurrent . TimeoutException ignored ) { } finally { terminationFuture . complete ( null ) ; } \"<AssertPlaceHolder>\" ; } get ( ) { return delegate . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( submissionFuture . get ( ) , org . hamcrest . Matchers . equalTo ( org . apache . flink . runtime . messages . Acknowledge . get ( ) ) )"}
{"focal": "countCrossingsBetweenLayers ( org . eclipse . elk . alg . layered . graph . LNode [ ] , org . eclipse . elk . alg . layered . graph . LNode [ ] ) { java . util . List < org . eclipse . elk . alg . layered . graph . LPort > ports = initPortPositionsCounterClockwise ( leftLayerNodes , rightLayerNodes ) ; indexTree = new org . eclipse . elk . alg . layered . p3order . counting . BinaryIndexedTree ( ports . size ( ) ) ; return countCrossingsOnPorts ( ports ) ; }", "testMethod": "countCrossingsBetweenLayers_crossWithExtraEdgeInBetween ( ) { getCrossWithExtraEdgeInBetweenGraph ( ) ; counter = new org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter ( new int [ getNumPorts ( order ( ) ) ] ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( counter . countCrossingsBetweenLayers ( order ( ) [ 0 ] , order ( ) [ 1 ] ) , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "countCrossingsBetweenLayers_crossWithExtraEdgeInBetween ( ) { getCrossWithExtraEdgeInBetweenGraph ( ) ; counter = new org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter ( new int [ getNumPorts ( order ( ) ) ] ) ; \"<AssertPlaceHolder>\" ; } countCrossingsBetweenLayers ( org . eclipse . elk . alg . layered . graph . LNode [ ] , org . eclipse . elk . alg . layered . graph . LNode [ ] ) { java . util . List < org . eclipse . elk . alg . layered . graph . LPort > ports = initPortPositionsCounterClockwise ( leftLayerNodes , rightLayerNodes ) ; indexTree = new org . eclipse . elk . alg . layered . p3order . counting . BinaryIndexedTree ( ports . size ( ) ) ; return countCrossingsOnPorts ( ports ) ; }", "answer": "org . junit . Assert . assertThat ( counter . countCrossingsBetweenLayers ( order ( ) [ 0 ] , order ( ) [ 1 ] ) , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "hasErrors ( ) { runCodes ( ) ; return ( numErrors ) > 0 ; }", "testMethod": "testHasErrorsWhenNoneRecorded ( ) { final org . codice . ddf . configuration . migration . MigrationReportImpl report = new org . codice . ddf . configuration . migration . MigrationReportImpl ( org . codice . ddf . migration . MigrationOperation . IMPORT , java . util . Optional . empty ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( report . hasErrors ( ) , org . hamcrest . Matchers . equalTo ( false ) )", "total": "testHasErrorsWhenNoneRecorded ( ) { final org . codice . ddf . configuration . migration . MigrationReportImpl report = new org . codice . ddf . configuration . migration . MigrationReportImpl ( org . codice . ddf . migration . MigrationOperation . IMPORT , java . util . Optional . empty ( ) ) ; \"<AssertPlaceHolder>\" ; } hasErrors ( ) { runCodes ( ) ; return ( numErrors ) > 0 ; }", "answer": "org . junit . Assert . assertThat ( report . hasErrors ( ) , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "save ( com . baeldung . infra . event . BaseEvent ) { return eventRepo . save ( convert ( event ) ) . getId ( ) ; }", "testMethod": "whenSavingRawEvent_thenCanBeRetrieved ( ) { final java . util . UUID correlationId = java . util . UUID . randomUUID ( ) ; final com . baeldung . infra . persistence . event . RawEvent rawEvent = new com . baeldung . infra . persistence . event . RawEvent ( correlationId , org . apache . commons . lang3 . RandomStringUtils . randomAlphabetic ( 12 ) , com . baeldung . store . events . LeadCreated . class . getCanonicalName ( ) ) ; rawEventRepo . save ( rawEvent ) ; final com . baeldung . infra . persistence . event . RawEvent savedEvent = rawEventRepo . findAllByCorrelationId ( correlationId ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( savedEvent , org . hamcrest . Matchers . equalTo ( rawEvent ) )", "total": "whenSavingRawEvent_thenCanBeRetrieved ( ) { final java . util . UUID correlationId = java . util . UUID . randomUUID ( ) ; final com . baeldung . infra . persistence . event . RawEvent rawEvent = new com . baeldung . infra . persistence . event . RawEvent ( correlationId , org . apache . commons . lang3 . RandomStringUtils . randomAlphabetic ( 12 ) , com . baeldung . store . events . LeadCreated . class . getCanonicalName ( ) ) ; rawEventRepo . save ( rawEvent ) ; final com . baeldung . infra . persistence . event . RawEvent savedEvent = rawEventRepo . findAllByCorrelationId ( correlationId ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; } save ( com . baeldung . infra . event . BaseEvent ) { return eventRepo . save ( convert ( event ) ) . getId ( ) ; }", "answer": "org . junit . Assert . assertThat ( savedEvent , org . hamcrest . Matchers . equalTo ( rawEvent ) )"}
{"focal": "getStep ( ) { return step ; }", "testMethod": "shouldStoreStepDefinition ( ) { uut = com . github . bmsantos . core . cola . story . processor . MethodDetails . build ( com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . TYPE , com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . STEP , method , null , null ) ; final java . lang . String result = uut . getStep ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( ( ( ( com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . TYPE ) + \"<sp>\" ) + ( com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . STEP ) ) ) )", "total": "shouldStoreStepDefinition ( ) { uut = com . github . bmsantos . core . cola . story . processor . MethodDetails . build ( com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . TYPE , com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . STEP , method , null , null ) ; final java . lang . String result = uut . getStep ( ) ; \"<AssertPlaceHolder>\" ; } getStep ( ) { return step ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( ( ( ( com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . TYPE ) + \"<sp>\" ) + ( com . github . bmsantos . core . cola . story . processor . MethodDetailsTest . STEP ) ) ) )"}
{"focal": "getSingleScenariosFromFeature ( java . lang . String , java . lang . String , java . util . List ) { java . lang . String escapedFeatureContent = featureContent . replace ( \"\\\\n\" , \"\\\\\\\\n\" ) ; gherkin . ast . GherkinDocument gherkinDocument = getGherkinDocumentFromFeatureFileContent ( escapedFeatureContent ) ; gherkin . ast . Feature feature = gherkinDocument . getFeature ( ) ; java . lang . String featureName = ( ( feature . getKeyword ( ) ) + \":<sp>\" ) + ( feature . getName ( ) ) ; java . lang . String featureLanguage = feature . getLanguage ( ) ; java . lang . String featureDescription = feature . getDescription ( ) ; java . util . List < java . lang . String > featureTags = gherkinToCucableConverter . convertGherkinTagsToCucableTags ( feature . getTags ( ) ) ; java . util . ArrayList < com . trivago . vo . SingleScenario > singleScenarioFeatures = new java . util . ArrayList ( ) ; java . util . List < com . trivago . vo . Step > backgroundSteps = new java . util . ArrayList ( ) ; java . util . List < gherkin . ast . ScenarioDefinition > scenarioDefinitions = feature . getChildren ( ) ; for ( gherkin . ast . ScenarioDefinition scenarioDefinition : scenarioDefinitions ) { java . lang . String scenarioName = ( ( scenarioDefinition . getKeyword ( ) ) + \":<sp>\" ) + ( scenarioDefinition . getName ( ) ) ; java . lang . String scenarioDescription = scenarioDefinition . getDescription ( ) ; if ( scenarioDefinition instanceof gherkin . ast . Background ) { gherkin . ast . Background background = ( ( gherkin . ast . Background ) ( scenarioDefinition ) ) ; backgroundSteps = gherkinToCucableConverter . convertGherkinStepsToCucableSteps ( background . getSteps ( ) ) ; continue ; } if ( scenarioDefinition instanceof gherkin . ast . Scenario ) { gherkin . ast . Scenario scenario = ( ( gherkin . ast . Scenario ) ( scenarioDefinition ) ) ; if ( ( ( scenarioLineNumbers == null ) || ( scenarioLineNumbers . isEmpty ( ) ) ) || ( scenarioLineNumbers . contains ( scenario . getLocation ( ) . getLine ( ) ) ) ) { com . trivago . vo . SingleScenario singleScenario = new com . trivago . vo . SingleScenario ( featureName , featureFilePath , featureLanguage , featureDescription , scenarioName , scenarioDescription , featureTags , backgroundSteps ) ; addGherkinScenarioInformationToSingleScenario ( scenario , singleScenario ) ; if ( scenarioShouldBeIncluded ( singleScenario . getScenarioTags ( ) , singleScenario . getFeatureTags ( ) ) ) { singleScenarioFeatures . add ( singleScenario ) ; } } continue ; } if ( scenarioDefinition instanceof gherkin . ast . ScenarioOutline ) { gherkin . ast . ScenarioOutline scenarioOutline = ( ( gherkin . ast . ScenarioOutline ) ( scenarioDefinition ) ) ; if ( ( ( scenarioLineNumbers == null ) || ( scenarioLineNumbers . isEmpty ( ) ) ) || ( scenarioLineNumbers . contains ( scenarioOutline . getLocation ( ) . getLine ( ) ) ) ) { java . util . List < com . trivago . vo . SingleScenario > outlineScenarios = getSingleScenariosFromOutline ( scenarioOutline , featureName , featureFilePath , featureLanguage , featureDescription , featureTags , backgroundSteps ) ; for ( com . trivago . vo . SingleScenario singleScenario : outlineScenarios ) { if ( scenarioShouldBeIncluded ( singleScenario . getScenarioTags ( ) , singleScenario . getFeatureTags ( ) , singleScenario . getExampleTags ( ) ) ) { singleScenarioFeatures . add ( singleScenario ) ; } } } } } return singleScenarioFeatures ; }", "testMethod": "validFeatureTwoIncludeTagsTest ( ) { java . lang . String featureContent = getTwoScenariosWithTags ( ) ; when ( propertyManager . getIncludeScenarioTags ( ) ) . thenReturn ( \"@tag1<sp>or<sp>@tag3\" ) ; java . util . List < com . trivago . vo . SingleScenario > singleScenariosFromFeature = gherkinDocumentParser . getSingleScenariosFromFeature ( featureContent , \"\" , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( singleScenariosFromFeature . size ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "validFeatureTwoIncludeTagsTest ( ) { java . lang . String featureContent = getTwoScenariosWithTags ( ) ; when ( propertyManager . getIncludeScenarioTags ( ) ) . thenReturn ( \"@tag1<sp>or<sp>@tag3\" ) ; java . util . List < com . trivago . vo . SingleScenario > singleScenariosFromFeature = gherkinDocumentParser . getSingleScenariosFromFeature ( featureContent , \"\" , null ) ; \"<AssertPlaceHolder>\" ; } getSingleScenariosFromFeature ( java . lang . String , java . lang . String , java . util . List ) { java . lang . String escapedFeatureContent = featureContent . replace ( \"\\\\n\" , \"\\\\\\\\n\" ) ; gherkin . ast . GherkinDocument gherkinDocument = getGherkinDocumentFromFeatureFileContent ( escapedFeatureContent ) ; gherkin . ast . Feature feature = gherkinDocument . getFeature ( ) ; java . lang . String featureName = ( ( feature . getKeyword ( ) ) + \":<sp>\" ) + ( feature . getName ( ) ) ; java . lang . String featureLanguage = feature . getLanguage ( ) ; java . lang . String featureDescription = feature . getDescription ( ) ; java . util . List < java . lang . String > featureTags = gherkinToCucableConverter . convertGherkinTagsToCucableTags ( feature . getTags ( ) ) ; java . util . ArrayList < com . trivago . vo . SingleScenario > singleScenarioFeatures = new java . util . ArrayList ( ) ; java . util . List < com . trivago . vo . Step > backgroundSteps = new java . util . ArrayList ( ) ; java . util . List < gherkin . ast . ScenarioDefinition > scenarioDefinitions = feature . getChildren ( ) ; for ( gherkin . ast . ScenarioDefinition scenarioDefinition : scenarioDefinitions ) { java . lang . String scenarioName = ( ( scenarioDefinition . getKeyword ( ) ) + \":<sp>\" ) + ( scenarioDefinition . getName ( ) ) ; java . lang . String scenarioDescription = scenarioDefinition . getDescription ( ) ; if ( scenarioDefinition instanceof gherkin . ast . Background ) { gherkin . ast . Background background = ( ( gherkin . ast . Background ) ( scenarioDefinition ) ) ; backgroundSteps = gherkinToCucableConverter . convertGherkinStepsToCucableSteps ( background . getSteps ( ) ) ; continue ; } if ( scenarioDefinition instanceof gherkin . ast . Scenario ) { gherkin . ast . Scenario scenario = ( ( gherkin . ast . Scenario ) ( scenarioDefinition ) ) ; if ( ( ( scenarioLineNumbers == null ) || ( scenarioLineNumbers . isEmpty ( ) ) ) || ( scenarioLineNumbers . contains ( scenario . getLocation ( ) . getLine ( ) ) ) ) { com . trivago . vo . SingleScenario singleScenario = new com . trivago . vo . SingleScenario ( featureName , featureFilePath , featureLanguage , featureDescription , scenarioName , scenarioDescription , featureTags , backgroundSteps ) ; addGherkinScenarioInformationToSingleScenario ( scenario , singleScenario ) ; if ( scenarioShouldBeIncluded ( singleScenario . getScenarioTags ( ) , singleScenario . getFeatureTags ( ) ) ) { singleScenarioFeatures . add ( singleScenario ) ; } } continue ; } if ( scenarioDefinition instanceof gherkin . ast . ScenarioOutline ) { gherkin . ast . ScenarioOutline scenarioOutline = ( ( gherkin . ast . ScenarioOutline ) ( scenarioDefinition ) ) ; if ( ( ( scenarioLineNumbers == null ) || ( scenarioLineNumbers . isEmpty ( ) ) ) || ( scenarioLineNumbers . contains ( scenarioOutline . getLocation ( ) . getLine ( ) ) ) ) { java . util . List < com . trivago . vo . SingleScenario > outlineScenarios = getSingleScenariosFromOutline ( scenarioOutline , featureName , featureFilePath , featureLanguage , featureDescription , featureTags , backgroundSteps ) ; for ( com . trivago . vo . SingleScenario singleScenario : outlineScenarios ) { if ( scenarioShouldBeIncluded ( singleScenario . getScenarioTags ( ) , singleScenario . getFeatureTags ( ) , singleScenario . getExampleTags ( ) ) ) { singleScenarioFeatures . add ( singleScenario ) ; } } } } } return singleScenarioFeatures ; }", "answer": "org . junit . Assert . assertThat ( singleScenariosFromFeature . size ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "getCurieMap ( ) { return curieUtil . getCurieMap ( ) ; }", "testMethod": "getMap ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( util . getCurieMap ( ) , org . hamcrest . CoreMatchers . is ( map ) )", "total": "getMap ( ) { \"<AssertPlaceHolder>\" ; } getCurieMap ( ) { return curieUtil . getCurieMap ( ) ; }", "answer": "org . junit . Assert . assertThat ( util . getCurieMap ( ) , org . hamcrest . CoreMatchers . is ( map ) )"}
{"focal": "asList ( ) { return java . util . Collections . unmodifiableList ( this . stateHolders ) ; }", "testMethod": "shouldGetAsList ( ) { this . stateHolders . add ( this . stateHolder ) ; this . stateHolders . add ( this . partialStateHolder ) ; java . util . List < javax . faces . component . StateHolder > asList = this . stateHolders . asList ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( asList , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( java . util . Arrays . asList ( this . stateHolder , this . partialStateHolder ) ) ) )", "total": "shouldGetAsList ( ) { this . stateHolders . add ( this . stateHolder ) ; this . stateHolders . add ( this . partialStateHolder ) ; java . util . List < javax . faces . component . StateHolder > asList = this . stateHolders . asList ( ) ; \"<AssertPlaceHolder>\" ; } asList ( ) { return java . util . Collections . unmodifiableList ( this . stateHolders ) ; }", "answer": "org . junit . Assert . assertThat ( asList , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( java . util . Arrays . asList ( this . stateHolder , this . partialStateHolder ) ) ) )"}
{"focal": "getIssueSelector ( ) { hudson . plugins . jira . selector . AbstractIssueSelector uis = this . issueSelector ; if ( uis == null ) uis = new hudson . plugins . jira . selector . DefaultIssueSelector ( ) ; return this . issueSelector = uis ; }", "testMethod": "setIssueSelectorPersists ( ) { final hudson . plugins . jira . JiraEnvironmentVariableBuilder builder = new hudson . plugins . jira . JiraEnvironmentVariableBuilder ( issueSelector ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( builder . getIssueSelector ( ) , is ( issueSelector ) )", "total": "setIssueSelectorPersists ( ) { final hudson . plugins . jira . JiraEnvironmentVariableBuilder builder = new hudson . plugins . jira . JiraEnvironmentVariableBuilder ( issueSelector ) ; \"<AssertPlaceHolder>\" ; } getIssueSelector ( ) { hudson . plugins . jira . selector . AbstractIssueSelector uis = this . issueSelector ; if ( uis == null ) uis = new hudson . plugins . jira . selector . DefaultIssueSelector ( ) ; return this . issueSelector = uis ; }", "answer": "org . junit . Assert . assertThat ( builder . getIssueSelector ( ) , is ( issueSelector ) )"}
{"focal": "toString ( ) { return com . google . common . base . MoreObjects . toStringHelper ( this ) . add ( \"id\" , id ) . add ( \"value\" , value ) . toString ( ) ; }", "testMethod": "testDiscreteToString ( ) { org . onosproject . net . resource . ResourceId resource = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . resource . ResourceIdTest . D1 , org . onosproject . net . resource . ResourceIdTest . P1 ) . id ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resource . toString ( ) , org . hamcrest . Matchers . is ( java . util . Arrays . asList ( org . onosproject . net . resource . ResourceIdTest . D1 , org . onosproject . net . resource . ResourceIdTest . P1 ) . toString ( ) ) )", "total": "testDiscreteToString ( ) { org . onosproject . net . resource . ResourceId resource = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . resource . ResourceIdTest . D1 , org . onosproject . net . resource . ResourceIdTest . P1 ) . id ( ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return com . google . common . base . MoreObjects . toStringHelper ( this ) . add ( \"id\" , id ) . add ( \"value\" , value ) . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( resource . toString ( ) , org . hamcrest . Matchers . is ( java . util . Arrays . asList ( org . onosproject . net . resource . ResourceIdTest . D1 , org . onosproject . net . resource . ResourceIdTest . P1 ) . toString ( ) ) )"}
{"focal": "createInteractionTypePredicate ( org . eol . globi . data . ImportLogger ) { return ( java . util . Map < java . lang . String , java . lang . String > l ) -> { java . lang . String interactionTypeId = l . get ( INTERACTION_TYPE_ID ) ; boolean hasValidId = false ; if ( ( org . apache . commons . lang3 . StringUtils . isBlank ( interactionTypeId ) ) && ( logger != null ) ) { logger . warn ( null , \"missing<sp>interactionTypeId\" ) ; } else { hasValidId = ( org . eol . globi . domain . InteractType . typeOf ( interactionTypeId ) ) != null ; if ( ( ! hasValidId ) && ( logger != null ) ) { logger . warn ( null , ( ( \"found<sp>unsupported<sp>interactionTypeId<sp>[\" + interactionTypeId ) + \"]\" ) ) ; } } return hasValidId ; } ; }", "testMethod": "interactionTypePredicateMissing ( ) { java . util . function . Predicate < java . util . Map < java . lang . String , java . lang . String > > interactionTypePredicate = org . eol . globi . data . InteractionListenerImpl . createInteractionTypePredicate ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interactionTypePredicate . test ( new java . util . HashMap < java . lang . String , java . lang . String > ( ) ) , org . hamcrest . core . Is . is ( false ) )", "total": "interactionTypePredicateMissing ( ) { java . util . function . Predicate < java . util . Map < java . lang . String , java . lang . String > > interactionTypePredicate = org . eol . globi . data . InteractionListenerImpl . createInteractionTypePredicate ( null ) ; \"<AssertPlaceHolder>\" ; } createInteractionTypePredicate ( org . eol . globi . data . ImportLogger ) { return ( java . util . Map < java . lang . String , java . lang . String > l ) -> { java . lang . String interactionTypeId = l . get ( INTERACTION_TYPE_ID ) ; boolean hasValidId = false ; if ( ( org . apache . commons . lang3 . StringUtils . isBlank ( interactionTypeId ) ) && ( logger != null ) ) { logger . warn ( null , \"missing<sp>interactionTypeId\" ) ; } else { hasValidId = ( org . eol . globi . domain . InteractType . typeOf ( interactionTypeId ) ) != null ; if ( ( ! hasValidId ) && ( logger != null ) ) { logger . warn ( null , ( ( \"found<sp>unsupported<sp>interactionTypeId<sp>[\" + interactionTypeId ) + \"]\" ) ) ; } } return hasValidId ; } ; }", "answer": "org . junit . Assert . assertThat ( interactionTypePredicate . test ( new java . util . HashMap < java . lang . String , java . lang . String > ( ) ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "filtrate ( java . util . List ) { return new com . github . bmsantos . core . cola . filters . FilterProcessor ( features ) ; }", "testMethod": "shouldFilterFeaturesWithSkipTagAndSingleScenario ( ) { final com . github . bmsantos . core . cola . formatter . FeatureDetails feature = test . utils . TestUtils . loadFeatures ( \"com.github.bmsantos.core.cola.filters.TagFilterTest$SkipFeatureWithSingleScenarioClass\" ) . get ( 0 ) ; final boolean result = uut . filtrate ( feature ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )", "total": "shouldFilterFeaturesWithSkipTagAndSingleScenario ( ) { final com . github . bmsantos . core . cola . formatter . FeatureDetails feature = test . utils . TestUtils . loadFeatures ( \"com.github.bmsantos.core.cola.filters.TagFilterTest$SkipFeatureWithSingleScenarioClass\" ) . get ( 0 ) ; final boolean result = uut . filtrate ( feature ) ; \"<AssertPlaceHolder>\" ; } filtrate ( java . util . List ) { return new com . github . bmsantos . core . cola . filters . FilterProcessor ( features ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "zouGeenMeldingMoetenGevenWantEenOuderInBericht ( ) { nl . bzk . brp . model . objecttype . logisch . Relatie relatieBericht = mock ( nl . bzk . brp . model . objecttype . bericht . RelatieBericht . class ) ; nl . bzk . brp . model . objecttype . logisch . Relatie relatieModel = mock ( nl . bzk . brp . model . objecttype . operationeel . RelatieModel . class ) ; java . util . Set < nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht > betrokkenheidBerichten = new java . util . HashSet < nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht > ( ) ; betrokkenheidBerichten . add ( new nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht ( ) ) ; doReturn ( betrokkenheidBerichten ) . when ( relatieBericht ) . getOuderBetrokkenheden ( ) ; java . util . List < nl . bzk . brp . model . validatie . Melding > meldingen = brby0134 . executeer ( relatieModel , relatieBericht , null ) ; \"<AssertPlaceHolder>\" ; verify ( persoonRepository , never ( ) ) . findByBurgerservicenummer ( isA ( nl . bzk . brp . model . attribuuttype . Burgerservicenummer . class ) ) ; verify ( relatieRepository , never ( ) ) . isVerwant ( anyInt ( ) , anyInt ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( meldingen . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "zouGeenMeldingMoetenGevenWantEenOuderInBericht ( ) { nl . bzk . brp . model . objecttype . logisch . Relatie relatieBericht = mock ( nl . bzk . brp . model . objecttype . bericht . RelatieBericht . class ) ; nl . bzk . brp . model . objecttype . logisch . Relatie relatieModel = mock ( nl . bzk . brp . model . objecttype . operationeel . RelatieModel . class ) ; java . util . Set < nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht > betrokkenheidBerichten = new java . util . HashSet < nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht > ( ) ; betrokkenheidBerichten . add ( new nl . bzk . brp . model . objecttype . bericht . BetrokkenheidBericht ( ) ) ; doReturn ( betrokkenheidBerichten ) . when ( relatieBericht ) . getOuderBetrokkenheden ( ) ; java . util . List < nl . bzk . brp . model . validatie . Melding > meldingen = brby0134 . executeer ( relatieModel , relatieBericht , null ) ; \"<AssertPlaceHolder>\" ; verify ( persoonRepository , never ( ) ) . findByBurgerservicenummer ( isA ( nl . bzk . brp . model . attribuuttype . Burgerservicenummer . class ) ) ; verify ( relatieRepository , never ( ) ) . isVerwant ( anyInt ( ) , anyInt ( ) ) ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( meldingen . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "br ( java . lang . String ) { if ( org . slim3 . util . StringUtil . isEmpty ( input ) ) { return \"\" ; } return input . replaceAll ( \"\\r\\n\" , org . slim3 . jsp . Functions . BR ) . replaceAll ( \"\\r\" , org . slim3 . jsp . Functions . BR ) . replaceAll ( \"\\n\" , org . slim3 . jsp . Functions . BR ) ; }", "testMethod": "brForNull ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . slim3 . jsp . Functions . br ( null ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "brForNull ( ) { \"<AssertPlaceHolder>\" ; } br ( java . lang . String ) { if ( org . slim3 . util . StringUtil . isEmpty ( input ) ) { return \"\" ; } return input . replaceAll ( \"\\r\\n\" , org . slim3 . jsp . Functions . BR ) . replaceAll ( \"\\r\" , org . slim3 . jsp . Functions . BR ) . replaceAll ( \"\\n\" , org . slim3 . jsp . Functions . BR ) ; }", "answer": "org . junit . Assert . assertThat ( org . slim3 . jsp . Functions . br ( null ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "getRows ( ) { return this . rows ; }", "testMethod": "shouldApplyDerivedMaxResultsToQuery ( ) { when ( metadataMock . getDomainType ( ) ) . thenReturn ( ( ( java . lang . Class ) ( org . springframework . data . keyvalue . Person . class ) ) ) ; when ( metadataMock . getReturnedDomainClass ( any ( java . lang . reflect . Method . class ) ) ) . thenReturn ( ( ( java . lang . Class ) ( org . springframework . data . keyvalue . Person . class ) ) ) ; org . springframework . data . repository . query . QueryMethod qm = new org . springframework . data . repository . query . QueryMethod ( org . springframework . data . keyvalue . repository . query . KeyValuePartTreeQueryUnitTests . Repo . class . getMethod ( \"findTop3By\" ) , metadataMock , projectionFactoryMock ) ; org . springframework . data . keyvalue . repository . query . KeyValuePartTreeQuery partTreeQuery = new org . springframework . data . keyvalue . repository . query . KeyValuePartTreeQuery ( qm , org . springframework . data . repository . query . QueryMethodEvaluationContextProvider . DEFAULT , kvOpsMock , org . springframework . data . keyvalue . repository . query . SpelQueryCreator . class ) ; org . springframework . data . keyvalue . core . query . KeyValueQuery < ? > query = partTreeQuery . prepareQuery ( new java . lang . Object [ ] { } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . getRows ( ) , is ( 3 ) )", "total": "shouldApplyDerivedMaxResultsToQuery ( ) { when ( metadataMock . getDomainType ( ) ) . thenReturn ( ( ( java . lang . Class ) ( org . springframework . data . keyvalue . Person . class ) ) ) ; when ( metadataMock . getReturnedDomainClass ( any ( java . lang . reflect . Method . class ) ) ) . thenReturn ( ( ( java . lang . Class ) ( org . springframework . data . keyvalue . Person . class ) ) ) ; org . springframework . data . repository . query . QueryMethod qm = new org . springframework . data . repository . query . QueryMethod ( org . springframework . data . keyvalue . repository . query . KeyValuePartTreeQueryUnitTests . Repo . class . getMethod ( \"findTop3By\" ) , metadataMock , projectionFactoryMock ) ; org . springframework . data . keyvalue . repository . query . KeyValuePartTreeQuery partTreeQuery = new org . springframework . data . keyvalue . repository . query . KeyValuePartTreeQuery ( qm , org . springframework . data . repository . query . QueryMethodEvaluationContextProvider . DEFAULT , kvOpsMock , org . springframework . data . keyvalue . repository . query . SpelQueryCreator . class ) ; org . springframework . data . keyvalue . core . query . KeyValueQuery < ? > query = partTreeQuery . prepareQuery ( new java . lang . Object [ ] { } ) ; \"<AssertPlaceHolder>\" ; } getRows ( ) { return this . rows ; }", "answer": "org . junit . Assert . assertThat ( query . getRows ( ) , is ( 3 ) )"}
{"focal": "sameAs ( java . lang . CharSequence ) { return new org . robobinding . widget . edittext . CharSequenceMatcher ( value ) ; }", "testMethod": "whenUpdateView_thenViewShouldReflectChanges ( ) { java . lang . String newText = org . apache . commons . lang3 . RandomStringUtils . randomAlphanumeric ( 5 ) ; attribute . updateView ( view , newText , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( view . getText ( ) , org . robobinding . widget . edittext . CharSequenceMatcher . sameAs ( newText ) )", "total": "whenUpdateView_thenViewShouldReflectChanges ( ) { java . lang . String newText = org . apache . commons . lang3 . RandomStringUtils . randomAlphanumeric ( 5 ) ; attribute . updateView ( view , newText , null ) ; \"<AssertPlaceHolder>\" ; } sameAs ( java . lang . CharSequence ) { return new org . robobinding . widget . edittext . CharSequenceMatcher ( value ) ; }", "answer": "org . junit . Assert . assertThat ( view . getText ( ) , org . robobinding . widget . edittext . CharSequenceMatcher . sameAs ( newText ) )"}
{"focal": "toString ( ) { com . oracle . bedrock . table . Cell . Separator cellSeparator = optionsByType . get ( Cell . Separator . class ) ; java . util . ArrayList < java . lang . Integer > cellWidths = new java . util . ArrayList ( ) ; for ( com . oracle . bedrock . table . Row row : this ) { int rowWidth = row . width ( ) ; while ( ( cellWidths . size ( ) ) < rowWidth ) { cellWidths . add ( 0 ) ; } int i = 0 ; for ( com . oracle . bedrock . table . Cell cell : row ) { int currentWidth = cellWidths . get ( i ) ; com . oracle . bedrock . table . Cell . Width width = cell . getOptions ( ) . getOrDefault ( Cell . Width . class , row . getOptions ( ) . getOrDefault ( Cell . Width . class , this . getOptions ( ) . get ( Cell . Width . class ) ) ) ; int cellWidth ; if ( width . isAutoDetect ( ) ) { cellWidth = cell . width ( ) ; if ( cell . containsNull ( ) ) { com . oracle . bedrock . table . Cell . DisplayNull displayNull = cell . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , row . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , this . getOptions ( ) . get ( Cell . DisplayNull . class ) ) ) ; cellWidth = java . lang . Math . max ( cellWidth , displayNull . getValue ( ) . length ( ) ) ; } } else { cellWidth = width . getCharacters ( ) ; } if ( cellWidth > currentWidth ) { cellWidths . set ( i , cellWidth ) ; } i ++ ; } } com . oracle . bedrock . table . Row . Comparator comparator = optionsByType . get ( Row . Comparator . class ) ; com . oracle . bedrock . table . Row [ ] orderedRows = new com . oracle . bedrock . table . Row [ rows . size ( ) ] ; rows . toArray ( orderedRows ) ; if ( comparator != null ) { java . util . Arrays . sort ( orderedRows , comparator ) ; } java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; for ( int rowIndex = 0 ; rowIndex < ( orderedRows . length ) ; rowIndex ++ ) { com . oracle . bedrock . table . Row row = orderedRows [ rowIndex ] ; if ( rowIndex > 0 ) { builder . append ( \"\\n\" ) ; } int line = 0 ; int rowHeight ; do { rowHeight = 0 ; int rowWidth = row . width ( ) ; for ( int cellIndex = 0 ; cellIndex < rowWidth ; cellIndex ++ ) { com . oracle . bedrock . table . Cell cell = row . getCell ( cellIndex ) ; com . oracle . bedrock . table . Cell . Justification justification = cell . getOptions ( ) . getOrDefault ( Cell . Justification . class , row . getOptions ( ) . getOrDefault ( Cell . Justification . class , this . getOptions ( ) . get ( Cell . Justification . class ) ) ) ; int cellHeight = cell . height ( ) ; rowHeight = ( cellHeight > rowHeight ) ? cellHeight : rowHeight ; java . lang . String justifiedContent ; if ( ( cell . isEmpty ( ) ) || ( line >= cellHeight ) ) { if ( cellIndex > 0 ) { builder . append ( \"<sp>\" ) ; builder . append ( cellSeparator . getSeparator ( ) ) ; builder . append ( \"<sp>\" ) ; } justifiedContent = justification . format ( \"\" , cellWidths . get ( cellIndex ) ) ; } else { if ( cellIndex > 0 ) { builder . append ( \"<sp>\" ) ; builder . append ( cellSeparator . getSeparator ( ) ) ; builder . append ( \"<sp>\" ) ; } java . lang . String content = cell . getLine ( line ) ; if ( content == null ) { com . oracle . bedrock . table . Cell . DisplayNull displayNull = cell . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , row . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , this . getOptions ( ) . get ( Cell . DisplayNull . class ) ) ) ; content = displayNull . getValue ( ) ; } justifiedContent = justification . format ( content , cellWidths . get ( cellIndex ) ) ; } if ( cellIndex == ( rowWidth - 1 ) ) { justifiedContent = trimTrailingWhiteSpace ( justifiedContent ) ; } builder . append ( justifiedContent ) ; } line ++ ; if ( line < rowHeight ) { builder . append ( \"\\n\" ) ; } } while ( line < rowHeight ) ; } return builder . toString ( ) ; }", "testMethod": "shouldProduceSingleCellTable ( ) { com . oracle . bedrock . table . Table table = new com . oracle . bedrock . table . Table ( ) ; table . addRow ( \"Hello<sp>World\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( table . toString ( ) , org . hamcrest . core . Is . is ( \"Hello<sp>World\" ) )", "total": "shouldProduceSingleCellTable ( ) { com . oracle . bedrock . table . Table table = new com . oracle . bedrock . table . Table ( ) ; table . addRow ( \"Hello<sp>World\" ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { com . oracle . bedrock . table . Cell . Separator cellSeparator = optionsByType . get ( Cell . Separator . class ) ; java . util . ArrayList < java . lang . Integer > cellWidths = new java . util . ArrayList ( ) ; for ( com . oracle . bedrock . table . Row row : this ) { int rowWidth = row . width ( ) ; while ( ( cellWidths . size ( ) ) < rowWidth ) { cellWidths . add ( 0 ) ; } int i = 0 ; for ( com . oracle . bedrock . table . Cell cell : row ) { int currentWidth = cellWidths . get ( i ) ; com . oracle . bedrock . table . Cell . Width width = cell . getOptions ( ) . getOrDefault ( Cell . Width . class , row . getOptions ( ) . getOrDefault ( Cell . Width . class , this . getOptions ( ) . get ( Cell . Width . class ) ) ) ; int cellWidth ; if ( width . isAutoDetect ( ) ) { cellWidth = cell . width ( ) ; if ( cell . containsNull ( ) ) { com . oracle . bedrock . table . Cell . DisplayNull displayNull = cell . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , row . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , this . getOptions ( ) . get ( Cell . DisplayNull . class ) ) ) ; cellWidth = java . lang . Math . max ( cellWidth , displayNull . getValue ( ) . length ( ) ) ; } } else { cellWidth = width . getCharacters ( ) ; } if ( cellWidth > currentWidth ) { cellWidths . set ( i , cellWidth ) ; } i ++ ; } } com . oracle . bedrock . table . Row . Comparator comparator = optionsByType . get ( Row . Comparator . class ) ; com . oracle . bedrock . table . Row [ ] orderedRows = new com . oracle . bedrock . table . Row [ rows . size ( ) ] ; rows . toArray ( orderedRows ) ; if ( comparator != null ) { java . util . Arrays . sort ( orderedRows , comparator ) ; } java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; for ( int rowIndex = 0 ; rowIndex < ( orderedRows . length ) ; rowIndex ++ ) { com . oracle . bedrock . table . Row row = orderedRows [ rowIndex ] ; if ( rowIndex > 0 ) { builder . append ( \"\\n\" ) ; } int line = 0 ; int rowHeight ; do { rowHeight = 0 ; int rowWidth = row . width ( ) ; for ( int cellIndex = 0 ; cellIndex < rowWidth ; cellIndex ++ ) { com . oracle . bedrock . table . Cell cell = row . getCell ( cellIndex ) ; com . oracle . bedrock . table . Cell . Justification justification = cell . getOptions ( ) . getOrDefault ( Cell . Justification . class , row . getOptions ( ) . getOrDefault ( Cell . Justification . class , this . getOptions ( ) . get ( Cell . Justification . class ) ) ) ; int cellHeight = cell . height ( ) ; rowHeight = ( cellHeight > rowHeight ) ? cellHeight : rowHeight ; java . lang . String justifiedContent ; if ( ( cell . isEmpty ( ) ) || ( line >= cellHeight ) ) { if ( cellIndex > 0 ) { builder . append ( \"<sp>\" ) ; builder . append ( cellSeparator . getSeparator ( ) ) ; builder . append ( \"<sp>\" ) ; } justifiedContent = justification . format ( \"\" , cellWidths . get ( cellIndex ) ) ; } else { if ( cellIndex > 0 ) { builder . append ( \"<sp>\" ) ; builder . append ( cellSeparator . getSeparator ( ) ) ; builder . append ( \"<sp>\" ) ; } java . lang . String content = cell . getLine ( line ) ; if ( content == null ) { com . oracle . bedrock . table . Cell . DisplayNull displayNull = cell . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , row . getOptions ( ) . getOrDefault ( Cell . DisplayNull . class , this . getOptions ( ) . get ( Cell . DisplayNull . class ) ) ) ; content = displayNull . getValue ( ) ; } justifiedContent = justification . format ( content , cellWidths . get ( cellIndex ) ) ; } if ( cellIndex == ( rowWidth - 1 ) ) { justifiedContent = trimTrailingWhiteSpace ( justifiedContent ) ; } builder . append ( justifiedContent ) ; } line ++ ; if ( line < rowHeight ) { builder . append ( \"\\n\" ) ; } } while ( line < rowHeight ) ; } return builder . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( table . toString ( ) , org . hamcrest . core . Is . is ( \"Hello<sp>World\" ) )"}
{"focal": "hasSameFieldsAs ( T ) { return new org . mockito . ArgumentMatcher < T > ( ) { @ org . ei . drishti . util . Override public boolean matches ( java . lang . Object o ) { return org . apache . commons . lang . builder . EqualsBuilder . reflectionEquals ( other , o ) ; } @ org . ei . drishti . util . Override public void describeTo ( org . hamcrest . Description description ) { description . appendValue ( other ) ; } } ; }", "testMethod": "shouldFindChildByCaseId ( ) { org . ei . drishti . domain . Child child = new org . ei . drishti . domain . Child ( \"CASE-1\" , \"MOTHER-CASE-1\" , \"bcg\" , \"3\" , \"male\" ) . withAnm ( \"ANM<sp>ID<sp>1\" ) ; allChildren . add ( child ) ; org . ei . drishti . domain . Child childFromDB = allChildren . findByCaseId ( \"CASE-1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( childFromDB , hasSameFieldsAs ( child ) )", "total": "shouldFindChildByCaseId ( ) { org . ei . drishti . domain . Child child = new org . ei . drishti . domain . Child ( \"CASE-1\" , \"MOTHER-CASE-1\" , \"bcg\" , \"3\" , \"male\" ) . withAnm ( \"ANM<sp>ID<sp>1\" ) ; allChildren . add ( child ) ; org . ei . drishti . domain . Child childFromDB = allChildren . findByCaseId ( \"CASE-1\" ) ; \"<AssertPlaceHolder>\" ; } hasSameFieldsAs ( T ) { return new org . mockito . ArgumentMatcher < T > ( ) { @ org . ei . drishti . util . Override public boolean matches ( java . lang . Object o ) { return org . apache . commons . lang . builder . EqualsBuilder . reflectionEquals ( other , o ) ; } @ org . ei . drishti . util . Override public void describeTo ( org . hamcrest . Description description ) { description . appendValue ( other ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( childFromDB , hasSameFieldsAs ( child ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . GroupRenameEvent event = new com . github . seratch . jslack . api . model . event . GroupRenameEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"group_rename\\\"}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . GroupRenameEvent event = new com . github . seratch . jslack . api . model . event . GroupRenameEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"group_rename\\\"}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "restore ( org . codice . ddf . util . function . BiThrowingConsumer ) { org . apache . commons . lang . Validate . notNull ( consumer , \"invalid<sp>null<sp>consumer\" ) ; if ( ( restored ) == null ) { this . restored = false ; java . util . Optional < java . io . InputStream > is = java . util . Optional . empty ( ) ; try { is = getInputStream ( true ) ; final java . util . Optional < java . io . InputStream > fis = is ; this . restored = getReport ( ) . wasIOSuccessful ( ( ) -> consumer . accept ( getReport ( ) , fis ) ) ; } catch ( java . io . IOException e ) { getReport ( ) . record ( new org . codice . ddf . migration . MigrationException ( Messages . IMPORT_PATH_COPY_ERROR , path , context . getPathUtils ( ) . getDDFHome ( ) , e ) ) ; } finally { is . ifPresent ( org . apache . commons . io . IOUtils :: closeQuietly ) ; } } return restored ; }", "testMethod": "restoreWhenRequiredEntryWasNotImported ( ) { final org . codice . ddf . configuration . migration . ImportMigrationEntryImpl entry = new org . codice . ddf . configuration . migration . ImportMigrationEntryImpl ( mockContext , org . codice . ddf . configuration . migration . ImportMigrationEntryImplTest . ENTRY_NAME , true ) ; when ( mockContext . getInputStreamFor ( org . mockito . Mockito . same ( entry ) , org . mockito . Mockito . anyBoolean ( ) ) ) . thenReturn ( null ) ; \"<AssertPlaceHolder>\" ; verifyReportHasMatchingError ( report , \"was<sp>not<sp>exported\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( entry . restore ( true ) , org . hamcrest . Matchers . equalTo ( false ) )", "total": "restoreWhenRequiredEntryWasNotImported ( ) { final org . codice . ddf . configuration . migration . ImportMigrationEntryImpl entry = new org . codice . ddf . configuration . migration . ImportMigrationEntryImpl ( mockContext , org . codice . ddf . configuration . migration . ImportMigrationEntryImplTest . ENTRY_NAME , true ) ; when ( mockContext . getInputStreamFor ( org . mockito . Mockito . same ( entry ) , org . mockito . Mockito . anyBoolean ( ) ) ) . thenReturn ( null ) ; \"<AssertPlaceHolder>\" ; verifyReportHasMatchingError ( report , \"was<sp>not<sp>exported\" ) ; } restore ( org . codice . ddf . util . function . BiThrowingConsumer ) { org . apache . commons . lang . Validate . notNull ( consumer , \"invalid<sp>null<sp>consumer\" ) ; if ( ( restored ) == null ) { this . restored = false ; java . util . Optional < java . io . InputStream > is = java . util . Optional . empty ( ) ; try { is = getInputStream ( true ) ; final java . util . Optional < java . io . InputStream > fis = is ; this . restored = getReport ( ) . wasIOSuccessful ( ( ) -> consumer . accept ( getReport ( ) , fis ) ) ; } catch ( java . io . IOException e ) { getReport ( ) . record ( new org . codice . ddf . migration . MigrationException ( Messages . IMPORT_PATH_COPY_ERROR , path , context . getPathUtils ( ) . getDDFHome ( ) , e ) ) ; } finally { is . ifPresent ( org . apache . commons . io . IOUtils :: closeQuietly ) ; } } return restored ; }", "answer": "org . junit . Assert . assertThat ( entry . restore ( true ) , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEquals ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPopMpls obj = target ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testEquals ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPopMpls obj = target ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "sizeOf ( java . sql . ResultSet ) { int tableCount = 0 ; while ( rs . next ( ) ) { tableCount ++ ; } return tableCount ; }", "testMethod": "getNoTablesFilteredByEmptySetOfTypes ( ) { final java . sql . ResultSet rs = metaData . getTables ( null , null , null , new java . lang . String [ 0 ] ) ; int tableCount = sizeOf ( rs ) ; \"<AssertPlaceHolder>\" . isEqualTo ( 0 ) ; }", "assertLine": "org . junit . Assert . assertThat ( tableCount )", "total": "getNoTablesFilteredByEmptySetOfTypes ( ) { final java . sql . ResultSet rs = metaData . getTables ( null , null , null , new java . lang . String [ 0 ] ) ; int tableCount = sizeOf ( rs ) ; \"<AssertPlaceHolder>\" . isEqualTo ( 0 ) ; } sizeOf ( java . sql . ResultSet ) { int tableCount = 0 ; while ( rs . next ( ) ) { tableCount ++ ; } return tableCount ; }", "answer": "org . junit . Assert . assertThat ( tableCount )"}
{"focal": "build ( java . nio . file . Path , java . lang . String , com . spotify . docker . client . ProgressHandler , com . spotify . docker . client . BuildParam [ ] ) { return build ( directory , name , null , handler , params ) ; }", "testMethod": "testBuildImageIdPathToDockerFile ( ) { final java . nio . file . Path dockerDirectory = com . spotify . docker . client . DefaultDockerClientTest . getResource ( \"dockerDirectory\" ) ; final java . util . concurrent . atomic . AtomicReference < java . lang . String > imageIdFromMessage = new java . util . concurrent . atomic . AtomicReference ( ) ; final java . lang . String returnedImageId = sut . build ( dockerDirectory , \"test\" , \"innerDir/innerDockerfile\" , ( message ) -> { final java . lang . String imageId = message . buildImageId ( ) ; if ( imageId != null ) { imageIdFromMessage . set ( imageId ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( returnedImageId , org . hamcrest . Matchers . is ( imageIdFromMessage . get ( ) ) )", "total": "testBuildImageIdPathToDockerFile ( ) { final java . nio . file . Path dockerDirectory = com . spotify . docker . client . DefaultDockerClientTest . getResource ( \"dockerDirectory\" ) ; final java . util . concurrent . atomic . AtomicReference < java . lang . String > imageIdFromMessage = new java . util . concurrent . atomic . AtomicReference ( ) ; final java . lang . String returnedImageId = sut . build ( dockerDirectory , \"test\" , \"innerDir/innerDockerfile\" , ( message ) -> { final java . lang . String imageId = message . buildImageId ( ) ; if ( imageId != null ) { imageIdFromMessage . set ( imageId ) ; } } ) ; \"<AssertPlaceHolder>\" ; } build ( java . nio . file . Path , java . lang . String , com . spotify . docker . client . ProgressHandler , com . spotify . docker . client . BuildParam [ ] ) { return build ( directory , name , null , handler , params ) ; }", "answer": "org . junit . Assert . assertThat ( returnedImageId , org . hamcrest . Matchers . is ( imageIdFromMessage . get ( ) ) )"}
{"focal": "validateEmail ( java . lang . String ) { if ( ( fr . xephi . authme . util . Utils . isEmailEmpty ( email ) ) || ( ! ( fr . xephi . authme . util . StringUtils . isInsideString ( '@' , email ) ) ) ) { return false ; } final java . lang . String emailDomain = email . split ( \"@\" ) [ 1 ] ; return validateWhitelistAndBlacklist ( emailDomain , EmailSettings . DOMAIN_WHITELIST , EmailSettings . DOMAIN_BLACKLIST ) ; }", "testMethod": "shouldAcceptEmailWithEmptyLists ( ) { given ( settings . getProperty ( EmailSettings . DOMAIN_WHITELIST ) ) . willReturn ( java . util . Collections . emptyList ( ) ) ; given ( settings . getProperty ( EmailSettings . DOMAIN_BLACKLIST ) ) . willReturn ( java . util . Collections . emptyList ( ) ) ; boolean result = validationService . validateEmail ( \"test@example.org\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldAcceptEmailWithEmptyLists ( ) { given ( settings . getProperty ( EmailSettings . DOMAIN_WHITELIST ) ) . willReturn ( java . util . Collections . emptyList ( ) ) ; given ( settings . getProperty ( EmailSettings . DOMAIN_BLACKLIST ) ) . willReturn ( java . util . Collections . emptyList ( ) ) ; boolean result = validationService . validateEmail ( \"test@example.org\" ) ; \"<AssertPlaceHolder>\" ; } validateEmail ( java . lang . String ) { if ( ( fr . xephi . authme . util . Utils . isEmailEmpty ( email ) ) || ( ! ( fr . xephi . authme . util . StringUtils . isInsideString ( '@' , email ) ) ) ) { return false ; } final java . lang . String emailDomain = email . split ( \"@\" ) [ 1 ] ; return validateWhitelistAndBlacklist ( emailDomain , EmailSettings . DOMAIN_WHITELIST , EmailSettings . DOMAIN_BLACKLIST ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "startsWith ( com . m3 . scalaflavor4j . Seq , int ) { return false ; }", "testMethod": "startsWith_A$Seq$int_true ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > that = com . m3 . scalaflavor4j . Seq . apply ( 2 , 3 ) ; int offset = 1 ; boolean actual = seq . startsWith ( that , offset ) ; boolean expected = true ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "startsWith_A$Seq$int_true ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > that = com . m3 . scalaflavor4j . Seq . apply ( 2 , 3 ) ; int offset = 1 ; boolean actual = seq . startsWith ( that , offset ) ; boolean expected = true ; \"<AssertPlaceHolder>\" ; } startsWith ( com . m3 . scalaflavor4j . Seq , int ) { return false ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "getStyleForMetacard ( ddf . catalog . data . Metacard ) { for ( org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntry mapEntry : styleMap ) { if ( mapEntry . metacardMatch ( metacard ) ) { return mapEntry . getStyleUrl ( ) ; } } return \"\" ; }", "testMethod": "testGetStyleForMetacardBySourceId ( ) { ddf . catalog . data . Metacard metacard = new org . codice . ddf . spatial . kml . transformer . MockMetacard ( null , null ) ; org . codice . ddf . spatial . kml . transformer . KmlStyleMap mapper = new org . codice . ddf . spatial . kml . transformer . KmlStyleMap ( ) ; mapper . addMapEntry ( new org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntryImpl ( ddf . catalog . data . Metacard . SOURCE_ID , MockMetacard . DEFAULT_SOURCE_ID , org . codice . ddf . spatial . kml . transformer . KmlStyleMapTest . DEFAULT_STYLE_URL ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mapper . getStyleForMetacard ( metacard ) , org . hamcrest . Matchers . is ( org . codice . ddf . spatial . kml . transformer . KmlStyleMapTest . DEFAULT_STYLE_URL ) )", "total": "testGetStyleForMetacardBySourceId ( ) { ddf . catalog . data . Metacard metacard = new org . codice . ddf . spatial . kml . transformer . MockMetacard ( null , null ) ; org . codice . ddf . spatial . kml . transformer . KmlStyleMap mapper = new org . codice . ddf . spatial . kml . transformer . KmlStyleMap ( ) ; mapper . addMapEntry ( new org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntryImpl ( ddf . catalog . data . Metacard . SOURCE_ID , MockMetacard . DEFAULT_SOURCE_ID , org . codice . ddf . spatial . kml . transformer . KmlStyleMapTest . DEFAULT_STYLE_URL ) ) ; \"<AssertPlaceHolder>\" ; } getStyleForMetacard ( ddf . catalog . data . Metacard ) { for ( org . codice . ddf . spatial . kml . transformer . KmlStyleMapEntry mapEntry : styleMap ) { if ( mapEntry . metacardMatch ( metacard ) ) { return mapEntry . getStyleUrl ( ) ; } } return \"\" ; }", "answer": "org . junit . Assert . assertThat ( mapper . getStyleForMetacard ( metacard ) , org . hamcrest . Matchers . is ( org . codice . ddf . spatial . kml . transformer . KmlStyleMapTest . DEFAULT_STYLE_URL ) )"}
{"focal": "delist ( ) { if ( ! ( isEnlisted ( ) ) ) { return false ; } org . mule . runtime . core . privileged . transaction . XaTransaction transaction = getTransaction ( ) ; synchronized ( this ) { if ( isEnlisted ( ) ) { boolean wasAbleToDelist = transaction . delistResource ( enlistedXAResource , javax . transaction . xa . XAResource . TMSUCCESS ) ; if ( wasAbleToDelist ) { enlistedXAResource = null ; } } return ! ( isEnlisted ( ) ) ; } }", "testMethod": "delist ( ) { enlist ( ) ; \"<AssertPlaceHolder>\" ; verify ( transaction ) . delistResource ( xaResource , javax . transaction . xa . XAResource . TMSUCCESS ) ; }", "assertLine": "org . junit . Assert . assertThat ( resource . delist ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "delist ( ) { enlist ( ) ; \"<AssertPlaceHolder>\" ; verify ( transaction ) . delistResource ( xaResource , javax . transaction . xa . XAResource . TMSUCCESS ) ; } delist ( ) { if ( ! ( isEnlisted ( ) ) ) { return false ; } org . mule . runtime . core . privileged . transaction . XaTransaction transaction = getTransaction ( ) ; synchronized ( this ) { if ( isEnlisted ( ) ) { boolean wasAbleToDelist = transaction . delistResource ( enlistedXAResource , javax . transaction . xa . XAResource . TMSUCCESS ) ; if ( wasAbleToDelist ) { enlistedXAResource = null ; } } return ! ( isEnlisted ( ) ) ; } }", "answer": "org . junit . Assert . assertThat ( resource . delist ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "simplifyBooleanExpr ( org . batfish . z3 . expr . BooleanExpr ) { return expr . accept ( new org . batfish . z3 . expr . visitors . Simplifier ( ) ) ; }", "testMethod": "testSimplifyOr1 ( ) { org . batfish . z3 . expr . BooleanExpr p1 = newAtom ( ) ; org . batfish . z3 . expr . OrExpr or = new org . batfish . z3 . expr . OrExpr ( of ( p1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . batfish . z3 . expr . visitors . Simplifier . simplifyBooleanExpr ( or ) , org . hamcrest . Matchers . equalTo ( p1 ) )", "total": "testSimplifyOr1 ( ) { org . batfish . z3 . expr . BooleanExpr p1 = newAtom ( ) ; org . batfish . z3 . expr . OrExpr or = new org . batfish . z3 . expr . OrExpr ( of ( p1 ) ) ; \"<AssertPlaceHolder>\" ; } simplifyBooleanExpr ( org . batfish . z3 . expr . BooleanExpr ) { return expr . accept ( new org . batfish . z3 . expr . visitors . Simplifier ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( org . batfish . z3 . expr . visitors . Simplifier . simplifyBooleanExpr ( or ) , org . hamcrest . Matchers . equalTo ( p1 ) )"}
{"focal": "getTags ( ) { hudson . util . ArgumentListBuilder args = new hudson . util . ArgumentListBuilder ( \"show-ref\" , \"--tags\" , \"-d\" ) ; java . lang . String result ; try { result = launchCommandIn ( args , workspace ) ; } catch ( hudson . plugins . git . GitException ge ) { if ( isPeeledRef || ( ! ( tagMap . containsKey ( tagName ) ) ) ) { tagMap . put ( tagName , org . eclipse . jgit . lib . ObjectId . fromString ( sha1String ) ) ; } } java . util . Set < hudson . plugins . git . GitObject > tags = new java . util . HashSet ( tagMap . size ( ) ) ; for ( Map . Entry < java . lang . String , org . eclipse . jgit . lib . ObjectId > entry : tagMap . entrySet ( ) ) { tags . add ( new hudson . plugins . git . GitObject ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return tags ; }", "testMethod": "testGetTags_OneTag ( ) { org . eclipse . jgit . lib . ObjectId commitOne = commitOneFile ( ) ; java . lang . String tagName = \"tag-one\" ; gitClient . tag ( tagName , ( \"Comment<sp>for<sp>annotated<sp>\" + tagName ) ) ; hudson . plugins . git . GitObject expectedTag = new hudson . plugins . git . GitObject ( tagName , commitOne ) ; java . util . Set < hudson . plugins . git . GitObject > result = gitClient . getTags ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , contains ( expectedTag ) )", "total": "testGetTags_OneTag ( ) { org . eclipse . jgit . lib . ObjectId commitOne = commitOneFile ( ) ; java . lang . String tagName = \"tag-one\" ; gitClient . tag ( tagName , ( \"Comment<sp>for<sp>annotated<sp>\" + tagName ) ) ; hudson . plugins . git . GitObject expectedTag = new hudson . plugins . git . GitObject ( tagName , commitOne ) ; java . util . Set < hudson . plugins . git . GitObject > result = gitClient . getTags ( ) ; \"<AssertPlaceHolder>\" ; } getTags ( ) { hudson . util . ArgumentListBuilder args = new hudson . util . ArgumentListBuilder ( \"show-ref\" , \"--tags\" , \"-d\" ) ; java . lang . String result ; try { result = launchCommandIn ( args , workspace ) ; } catch ( hudson . plugins . git . GitException ge ) { if ( isPeeledRef || ( ! ( tagMap . containsKey ( tagName ) ) ) ) { tagMap . put ( tagName , org . eclipse . jgit . lib . ObjectId . fromString ( sha1String ) ) ; } } java . util . Set < hudson . plugins . git . GitObject > tags = new java . util . HashSet ( tagMap . size ( ) ) ; for ( Map . Entry < java . lang . String , org . eclipse . jgit . lib . ObjectId > entry : tagMap . entrySet ( ) ) { tags . add ( new hudson . plugins . git . GitObject ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return tags ; }", "answer": "org . junit . Assert . assertThat ( result , contains ( expectedTag ) )"}
{"focal": "isS3ServerSideEncryption ( ) { return s3ServerSideEncryption ; }", "testMethod": "noS3ServerSideEncryption ( ) { copierOptions . put ( com . hotels . bdp . circustrain . s3mapreducecpcopier . S3MapReduceCpOptionsParser . S3_SERVER_SIDE_ENCRYPTION , false ) ; com . hotels . bdp . circustrain . s3mapreducecp . S3MapReduceCpOptions options = parser . parse ( copierOptions ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( options . isS3ServerSideEncryption ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "noS3ServerSideEncryption ( ) { copierOptions . put ( com . hotels . bdp . circustrain . s3mapreducecpcopier . S3MapReduceCpOptionsParser . S3_SERVER_SIDE_ENCRYPTION , false ) ; com . hotels . bdp . circustrain . s3mapreducecp . S3MapReduceCpOptions options = parser . parse ( copierOptions ) ; \"<AssertPlaceHolder>\" ; } isS3ServerSideEncryption ( ) { return s3ServerSideEncryption ; }", "answer": "org . junit . Assert . assertThat ( options . isS3ServerSideEncryption ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "detect ( int ) { for ( org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . common . Shutdown shutdown : org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . common . Shutdown . values ( ) ) { if ( timeout == ( shutdown . getTimeout ( ) ) ) { return shutdown ; } } return null ; }", "testMethod": "contentShouldBeDetected ( ) { for ( java . lang . Shutdown shutdown : java . lang . Shutdown . values ( ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( shutdown , org . hamcrest . CoreMatchers . is ( java . lang . Shutdown . detect ( shutdown . toString ( ) ) ) )", "total": "contentShouldBeDetected ( ) { for ( java . lang . Shutdown shutdown : java . lang . Shutdown . values ( ) ) { \"<AssertPlaceHolder>\" ; } } detect ( int ) { for ( org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . common . Shutdown shutdown : org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . common . Shutdown . values ( ) ) { if ( timeout == ( shutdown . getTimeout ( ) ) ) { return shutdown ; } } return null ; }", "answer": "org . junit . Assert . assertThat ( shutdown , org . hamcrest . CoreMatchers . is ( java . lang . Shutdown . detect ( shutdown . toString ( ) ) ) )"}
{"focal": "getValue ( ) { return propertyValueModel . getValue ( ) ; }", "testMethod": "whenObserveChangesOnTheView_thenValueModelShouldReceiveTheChangeFromView ( ) { int index = org . robobinding . util . RandomValues . anyIndex ( arrayAdapter . getCount ( ) ) ; org . robobinding . property . ValueModel < java . lang . Integer > valueModel = org . robobinding . viewattribute . ValueModelUtils . create ( ) ; attribute . observeChangesOnTheView ( viewAddOn , valueModel , view ) ; view . setSelection ( index ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( valueModel . getValue ( ) , org . hamcrest . CoreMatchers . is ( index ) )", "total": "whenObserveChangesOnTheView_thenValueModelShouldReceiveTheChangeFromView ( ) { int index = org . robobinding . util . RandomValues . anyIndex ( arrayAdapter . getCount ( ) ) ; org . robobinding . property . ValueModel < java . lang . Integer > valueModel = org . robobinding . viewattribute . ValueModelUtils . create ( ) ; attribute . observeChangesOnTheView ( viewAddOn , valueModel , view ) ; view . setSelection ( index ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return propertyValueModel . getValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( valueModel . getValue ( ) , org . hamcrest . CoreMatchers . is ( index ) )"}
{"focal": "size ( ) { return whiteList . size ( ) ; }", "testMethod": "panopticOperationsHandlerGetAllDatabasesByPatternException ( ) { java . lang . String pattern = \"pattern\" ; when ( primaryDatabaseClient . get_databases ( pattern ) ) . thenThrow ( new org . apache . thrift . TException ( ) ) ; com . hotels . bdp . waggledance . mapping . service . PanopticOperationHandler handler = service . getPanopticOperationHandler ( ) ; java . util . List < java . lang . String > result = handler . getAllDatabases ( pattern ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "panopticOperationsHandlerGetAllDatabasesByPatternException ( ) { java . lang . String pattern = \"pattern\" ; when ( primaryDatabaseClient . get_databases ( pattern ) ) . thenThrow ( new org . apache . thrift . TException ( ) ) ; com . hotels . bdp . waggledance . mapping . service . PanopticOperationHandler handler = service . getPanopticOperationHandler ( ) ; java . util . List < java . lang . String > result = handler . getAllDatabases ( pattern ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return whiteList . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "testMethod": "multiple_columns ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = emit ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" , \"C\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" , \"C\" } } ) )", "total": "multiple_columns ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = emit ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" , \"C\" } } ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" , \"C\" } } ) )"}
{"focal": "hasWildcards ( ) { return hasWildcards ; }", "testMethod": "testWithEscapedCharactersOnly ( ) { org . mule . runtime . core . api . util . WildcardAttributeEvaluator wildcardAttributeEvaluator = new org . mule . runtime . core . api . util . WildcardAttributeEvaluator ( \"\\\\*\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( wildcardAttributeEvaluator . hasWildcards ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "testWithEscapedCharactersOnly ( ) { org . mule . runtime . core . api . util . WildcardAttributeEvaluator wildcardAttributeEvaluator = new org . mule . runtime . core . api . util . WildcardAttributeEvaluator ( \"\\\\*\" ) ; \"<AssertPlaceHolder>\" ; } hasWildcards ( ) { return hasWildcards ; }", "answer": "org . junit . Assert . assertThat ( wildcardAttributeEvaluator . hasWildcards ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "compareTo ( org . codice . ddf . migration . MigrationEntry ) { if ( me == ( this ) ) { return 0 ; } final int c = super . compareTo ( me ) ; if ( c != 0 ) { return c ; } final org . codice . ddf . configuration . migration . ImportMigrationJavaPropertyReferencedEntryImpl ime = ( ( org . codice . ddf . configuration . migration . ImportMigrationJavaPropertyReferencedEntryImpl ) ( me ) ) ; return propertiesPath . compareTo ( ime . getPropertiesPath ( ) ) ; }", "testMethod": "testCompareToWhenEquals ( ) { final org . codice . ddf . configuration . migration . ImportMigrationPropertyReferencedEntryImpl entry2 = org . mockito . Mockito . mock ( org . codice . ddf . configuration . migration . ImportMigrationPropertyReferencedEntryImpl . class , org . mockito . Mockito . withSettings ( ) . useConstructor ( context , metadata ) . defaultAnswer ( Answers . CALLS_REAL_METHODS ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( entry . compareTo ( entry2 ) , org . hamcrest . Matchers . equalTo ( 0 ) )", "total": "testCompareToWhenEquals ( ) { final org . codice . ddf . configuration . migration . ImportMigrationPropertyReferencedEntryImpl entry2 = org . mockito . Mockito . mock ( org . codice . ddf . configuration . migration . ImportMigrationPropertyReferencedEntryImpl . class , org . mockito . Mockito . withSettings ( ) . useConstructor ( context , metadata ) . defaultAnswer ( Answers . CALLS_REAL_METHODS ) ) ; \"<AssertPlaceHolder>\" ; } compareTo ( org . codice . ddf . migration . MigrationEntry ) { if ( me == ( this ) ) { return 0 ; } final int c = super . compareTo ( me ) ; if ( c != 0 ) { return c ; } final org . codice . ddf . configuration . migration . ImportMigrationJavaPropertyReferencedEntryImpl ime = ( ( org . codice . ddf . configuration . migration . ImportMigrationJavaPropertyReferencedEntryImpl ) ( me ) ) ; return propertiesPath . compareTo ( ime . getPropertiesPath ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( entry . compareTo ( entry2 ) , org . hamcrest . Matchers . equalTo ( 0 ) )"}
{"focal": "getRuleKey ( java . lang . String ) { try { return getBuildValue ( key ) . map ( RuleKey :: new ) ; } catch ( java . lang . IllegalArgumentException ignored ) { return java . util . Optional . empty ( ) ; } }", "testMethod": "whenMetadataInvalidRuleKeyThenGetRuleKeyReturnsAbsent ( ) { com . facebook . buck . io . filesystem . ProjectFilesystem projectFilesystem = new com . facebook . buck . io . filesystem . impl . FakeProjectFilesystem ( ) ; projectFilesystem . writeContentsToPath ( \"Not<sp>A<sp>Valid<sp>Rule<sp>Key\" , java . nio . file . Paths . get ( \"buck-out/bin/foo/bar/.baz/metadata/build\" , BuildInfo . MetadataKey . RULE_KEY ) ) ; com . facebook . buck . core . model . BuildTarget buildTarget = com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//foo/bar:baz\" ) ; com . facebook . buck . core . build . engine . buildinfo . DefaultOnDiskBuildInfo onDiskBuildInfo = new com . facebook . buck . core . build . engine . buildinfo . DefaultOnDiskBuildInfo ( buildTarget , projectFilesystem , new com . facebook . buck . core . build . engine . buildinfo . FilesystemBuildInfoStore ( projectFilesystem ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( onDiskBuildInfo . getRuleKey ( BuildInfo . MetadataKey . RULE_KEY ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . empty ( ) ) )", "total": "whenMetadataInvalidRuleKeyThenGetRuleKeyReturnsAbsent ( ) { com . facebook . buck . io . filesystem . ProjectFilesystem projectFilesystem = new com . facebook . buck . io . filesystem . impl . FakeProjectFilesystem ( ) ; projectFilesystem . writeContentsToPath ( \"Not<sp>A<sp>Valid<sp>Rule<sp>Key\" , java . nio . file . Paths . get ( \"buck-out/bin/foo/bar/.baz/metadata/build\" , BuildInfo . MetadataKey . RULE_KEY ) ) ; com . facebook . buck . core . model . BuildTarget buildTarget = com . facebook . buck . core . model . BuildTargetFactory . newInstance ( \"//foo/bar:baz\" ) ; com . facebook . buck . core . build . engine . buildinfo . DefaultOnDiskBuildInfo onDiskBuildInfo = new com . facebook . buck . core . build . engine . buildinfo . DefaultOnDiskBuildInfo ( buildTarget , projectFilesystem , new com . facebook . buck . core . build . engine . buildinfo . FilesystemBuildInfoStore ( projectFilesystem ) ) ; \"<AssertPlaceHolder>\" ; } getRuleKey ( java . lang . String ) { try { return getBuildValue ( key ) . map ( RuleKey :: new ) ; } catch ( java . lang . IllegalArgumentException ignored ) { return java . util . Optional . empty ( ) ; } }", "answer": "org . junit . Assert . assertThat ( onDiskBuildInfo . getRuleKey ( BuildInfo . MetadataKey . RULE_KEY ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . empty ( ) ) )"}
{"focal": "build ( ) { if ( ( this . clientBehaviors ) != null ) { return new org . odata4j . cxf . consumer . ODataCxfConsumer ( this . formatType , this . serviceRootUri , this . clientBehaviors ) ; } else { return new org . odata4j . cxf . consumer . ODataCxfConsumer ( this . formatType , this . serviceRootUri ) ; } }", "testMethod": "loadCxfImplByDefaultIfJerseyImplIsNotAvailable ( ) { useTestClassLoader ( org . odata4j . test . integration . consumer . JERSEY_CONSUMER_CLASSNAME ) ; org . odata4j . consumer . ODataConsumer consumer = org . odata4j . consumer . ODataConsumers . newBuilder ( \"foo\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( consumer , org . hamcrest . Matchers . is ( org . odata4j . cxf . consumer . ODataCxfConsumer . class ) )", "total": "loadCxfImplByDefaultIfJerseyImplIsNotAvailable ( ) { useTestClassLoader ( org . odata4j . test . integration . consumer . JERSEY_CONSUMER_CLASSNAME ) ; org . odata4j . consumer . ODataConsumer consumer = org . odata4j . consumer . ODataConsumers . newBuilder ( \"foo\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } build ( ) { if ( ( this . clientBehaviors ) != null ) { return new org . odata4j . cxf . consumer . ODataCxfConsumer ( this . formatType , this . serviceRootUri , this . clientBehaviors ) ; } else { return new org . odata4j . cxf . consumer . ODataCxfConsumer ( this . formatType , this . serviceRootUri ) ; } }", "answer": "org . junit . Assert . assertThat ( consumer , org . hamcrest . Matchers . is ( org . odata4j . cxf . consumer . ODataCxfConsumer . class ) )"}
{"focal": "cronTime ( ) { java . lang . String [ ] cronSplit = cronTime . split ( \"\\\\+\" ) ; java . lang . String time = ( ( cronSplit [ 2 ] ) + \":\" ) + ( cronSplit [ 1 ] ) ; return time ; }", "testMethod": "testUpdateCronTime ( ) { dataUsage . updateCronTime ( org . codice . ddf . resourcemanagement . usage . DataUsageTest . TIME ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . codice . ddf . resourcemanagement . usage . DataUsageTest . TIME , org . hamcrest . core . Is . is ( dataUsage . cronTime ( ) ) )", "total": "testUpdateCronTime ( ) { dataUsage . updateCronTime ( org . codice . ddf . resourcemanagement . usage . DataUsageTest . TIME ) ; \"<AssertPlaceHolder>\" ; } cronTime ( ) { java . lang . String [ ] cronSplit = cronTime . split ( \"\\\\+\" ) ; java . lang . String time = ( ( cronSplit [ 2 ] ) + \":\" ) + ( cronSplit [ 1 ] ) ; return time ; }", "answer": "org . junit . Assert . assertThat ( org . codice . ddf . resourcemanagement . usage . DataUsageTest . TIME , org . hamcrest . core . Is . is ( dataUsage . cronTime ( ) ) )"}
{"focal": "getReachabilityParameters ( ) { org . batfish . datamodel . PathConstraints pathConstraints = getPathConstraints ( ) ; return org . batfish . question . ReachabilityParameters . builder ( ) . setActions ( com . google . common . collect . ImmutableSortedSet . copyOf ( org . batfish . question . ReachabilityParameters . filterDispositions ( getActions ( ) . getDispositions ( ) ) ) ) . setDestinationIpSpaceSpecifier ( getDestinationIpSpaceSpecifier ( ) ) . setFinalNodesSpecifier ( pathConstraints . getEndLocation ( ) ) . setForbiddenTransitNodesSpecifier ( pathConstraints . getForbiddenLocations ( ) ) . setHeaderSpace ( getHeaderSpace ( ) ) . setIgnoreFilters ( getIgnoreFilters ( ) ) . setInvertSearch ( getInvertSearch ( ) ) . setRequiredTransitNodesSpecifier ( pathConstraints . getTransitLocations ( ) ) . setSourceLocationSpecifier ( pathConstraints . getStartLocation ( ) ) . setSourceIpSpaceSpecifier ( getSourceIpSpaceSpecifier ( ) ) . setSpecialize ( true ) . build ( ) ; }", "testMethod": "testInvertSearch ( ) { org . batfish . question . specifiers . SpecifiersReachabilityQuestion q = org . batfish . question . specifiers . SpecifiersReachabilityQuestion . builder ( ) . setInvertSearch ( true ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( q . getReachabilityParameters ( ) . getInvertSearch ( ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "testInvertSearch ( ) { org . batfish . question . specifiers . SpecifiersReachabilityQuestion q = org . batfish . question . specifiers . SpecifiersReachabilityQuestion . builder ( ) . setInvertSearch ( true ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getReachabilityParameters ( ) { org . batfish . datamodel . PathConstraints pathConstraints = getPathConstraints ( ) ; return org . batfish . question . ReachabilityParameters . builder ( ) . setActions ( com . google . common . collect . ImmutableSortedSet . copyOf ( org . batfish . question . ReachabilityParameters . filterDispositions ( getActions ( ) . getDispositions ( ) ) ) ) . setDestinationIpSpaceSpecifier ( getDestinationIpSpaceSpecifier ( ) ) . setFinalNodesSpecifier ( pathConstraints . getEndLocation ( ) ) . setForbiddenTransitNodesSpecifier ( pathConstraints . getForbiddenLocations ( ) ) . setHeaderSpace ( getHeaderSpace ( ) ) . setIgnoreFilters ( getIgnoreFilters ( ) ) . setInvertSearch ( getInvertSearch ( ) ) . setRequiredTransitNodesSpecifier ( pathConstraints . getTransitLocations ( ) ) . setSourceLocationSpecifier ( pathConstraints . getStartLocation ( ) ) . setSourceIpSpaceSpecifier ( getSourceIpSpaceSpecifier ( ) ) . setSpecialize ( true ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( q . getReachabilityParameters ( ) . getInvertSearch ( ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "getNeoNode ( ) { java . lang . Iterable < org . neo4j . graphdb . Node > allNodes = org . neo4j . tooling . GlobalGraphOperations . at ( graphDb ) . getAllNodes ( ) ; for ( org . neo4j . graphdb . Node node : allNodes ) { if ( \"Thomas<sp>Anderson\" . equals ( node . getProperty ( \"name\" ) ) ) { return node ; } } return null ; }", "testMethod": "neo_node_should_be_returned ( ) { com . lordofthejars . nosqlunit . demo . neo4j . MatrixManager matrixManager = new com . lordofthejars . nosqlunit . demo . neo4j . MatrixManager ( graphDatabaseService ) ; org . neo4j . graphdb . Node neo = matrixManager . getNeoNode ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( ( java . lang . String ) ( neo . getProperty ( \"name\" ) ) ) , org . hamcrest . CoreMatchers . is ( \"Thomas<sp>Anderson\" ) )", "total": "neo_node_should_be_returned ( ) { com . lordofthejars . nosqlunit . demo . neo4j . MatrixManager matrixManager = new com . lordofthejars . nosqlunit . demo . neo4j . MatrixManager ( graphDatabaseService ) ; org . neo4j . graphdb . Node neo = matrixManager . getNeoNode ( ) ; \"<AssertPlaceHolder>\" ; } getNeoNode ( ) { java . lang . Iterable < org . neo4j . graphdb . Node > allNodes = org . neo4j . tooling . GlobalGraphOperations . at ( graphDb ) . getAllNodes ( ) ; for ( org . neo4j . graphdb . Node node : allNodes ) { if ( \"Thomas<sp>Anderson\" . equals ( node . getProperty ( \"name\" ) ) ) { return node ; } } return null ; }", "answer": "org . junit . Assert . assertThat ( ( ( java . lang . String ) ( neo . getProperty ( \"name\" ) ) ) , org . hamcrest . CoreMatchers . is ( \"Thomas<sp>Anderson\" ) )"}
{"focal": "getField ( java . lang . Class , java . lang . String ) { java . lang . reflect . Field field ; try { field = clazz . getDeclaredField ( name ) ; } catch ( final java . lang . NoSuchFieldException e ) { throw new java . lang . IllegalArgumentException ( e ) ; } field . setAccessible ( true ) ; return field ; }", "testMethod": "zetAantalAdministratieveHandelingenPerKeerProperty ( ) { final java . lang . Integer handelingenPerKeer = ( ( java . lang . Integer ) ( org . springframework . test . util . ReflectionTestUtils . getField ( administratieveHandelingPublicatieService , \"aantalAdministratieveHandelingenPerKeer\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( handelingenPerKeer , org . hamcrest . core . Is . is ( 10 ) )", "total": "zetAantalAdministratieveHandelingenPerKeerProperty ( ) { final java . lang . Integer handelingenPerKeer = ( ( java . lang . Integer ) ( org . springframework . test . util . ReflectionTestUtils . getField ( administratieveHandelingPublicatieService , \"aantalAdministratieveHandelingenPerKeer\" ) ) ) ; \"<AssertPlaceHolder>\" ; } getField ( java . lang . Class , java . lang . String ) { java . lang . reflect . Field field ; try { field = clazz . getDeclaredField ( name ) ; } catch ( final java . lang . NoSuchFieldException e ) { throw new java . lang . IllegalArgumentException ( e ) ; } field . setAccessible ( true ) ; return field ; }", "answer": "org . junit . Assert . assertThat ( handelingenPerKeer , org . hamcrest . core . Is . is ( 10 ) )"}
{"focal": "build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "testMethod": "more_report ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withOnMoreInput ( ErrorAction . REPORT ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" , \"E\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) )", "total": "more_report ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withOnMoreInput ( ErrorAction . REPORT ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" , \"E\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) ; \"<AssertPlaceHolder>\" ; } build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" } , new java . lang . String [ ] { \"F\" , \"G\" } } ) )"}
{"focal": "monitor ( boolean , boolean , boolean ) { return new com . gemserk . componentsengine . input . ButtonMonitorTest . MonitorMatcher ( isPressed , isReleased , isHolded ) ; }", "testMethod": "keepReleased ( ) { monitor . down = false ; monitor . update ( ) ; monitor . down = true ; monitor . update ( ) ; monitor . down = true ; monitor . update ( ) ; monitor . down = false ; monitor . update ( ) ; monitor . down = false ; monitor . update ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( monitor , com . gemserk . componentsengine . input . ButtonMonitorTest . MonitorMatcher . monitor ( false , false , false ) )", "total": "keepReleased ( ) { monitor . down = false ; monitor . update ( ) ; monitor . down = true ; monitor . update ( ) ; monitor . down = true ; monitor . update ( ) ; monitor . down = false ; monitor . update ( ) ; monitor . down = false ; monitor . update ( ) ; \"<AssertPlaceHolder>\" ; } monitor ( boolean , boolean , boolean ) { return new com . gemserk . componentsengine . input . ButtonMonitorTest . MonitorMatcher ( isPressed , isReleased , isHolded ) ; }", "answer": "org . junit . Assert . assertThat ( monitor , com . gemserk . componentsengine . input . ButtonMonitorTest . MonitorMatcher . monitor ( false , false , false ) )"}
{"focal": "contains ( E [ ] ) { return org . hamcrest . Matchers . Matchers . contains ( items ) ; }", "testMethod": "escape_cr_eof ( ) { java . util . List < java . lang . String > results = com . asakusafw . runtime . io . text . tabular . LineCursorTest . parse ( '\\\\' , false , \"Hello\\\\\\r\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , contains ( \"Hello\\\\\\r\" ) )", "total": "escape_cr_eof ( ) { java . util . List < java . lang . String > results = com . asakusafw . runtime . io . text . tabular . LineCursorTest . parse ( '\\\\' , false , \"Hello\\\\\\r\" ) ; \"<AssertPlaceHolder>\" ; } contains ( E [ ] ) { return org . hamcrest . Matchers . Matchers . contains ( items ) ; }", "answer": "org . junit . Assert . assertThat ( results , contains ( \"Hello\\\\\\r\" ) )"}
{"focal": "isEmpty ( ) { return new com . annimon . stream . test . hamcrest . StreamMatcher . IsEmptyMatcher ( ) ; }", "testMethod": "testIsEmptyOnNullValue ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( null , com . annimon . stream . test . hamcrest . StreamMatcher . isEmpty ( ) )", "total": "testIsEmptyOnNullValue ( ) { \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return new com . annimon . stream . test . hamcrest . StreamMatcher . IsEmptyMatcher ( ) ; }", "answer": "org . junit . Assert . assertThat ( null , com . annimon . stream . test . hamcrest . StreamMatcher . isEmpty ( ) )"}
{"focal": "hasSize ( org . hamcrest . Matcher ) { return new org . batfish . datamodel . matchers . RowsMatchersImpl . HasSize ( subMatcher ) ; }", "testMethod": "testIdenticalAclsCombine ( ) { _aclb . setLines ( com . google . common . collect . ImmutableList . of ( rejectingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) , acceptingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; _aclb2 . setLines ( com . google . common . collect . ImmutableList . of ( rejectingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) , acceptingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; java . util . List < org . batfish . datamodel . answers . AclSpecs > aclSpecs = getAclSpecs ( com . google . common . collect . ImmutableSet . of ( \"c1\" , \"c2\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( aclSpecs , org . hamcrest . Matchers . hasSize ( 1 ) )", "total": "testIdenticalAclsCombine ( ) { _aclb . setLines ( com . google . common . collect . ImmutableList . of ( rejectingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) , acceptingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; _aclb2 . setLines ( com . google . common . collect . ImmutableList . of ( rejectingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) , acceptingHeaderSpace ( org . batfish . datamodel . HeaderSpace . builder ( ) . setSrcIps ( org . batfish . datamodel . Prefix . parse ( \"1.0.0.0/24\" ) . toIpSpace ( ) ) . build ( ) ) ) ) . build ( ) ; java . util . List < org . batfish . datamodel . answers . AclSpecs > aclSpecs = getAclSpecs ( com . google . common . collect . ImmutableSet . of ( \"c1\" , \"c2\" ) ) ; \"<AssertPlaceHolder>\" ; } hasSize ( org . hamcrest . Matcher ) { return new org . batfish . datamodel . matchers . RowsMatchersImpl . HasSize ( subMatcher ) ; }", "answer": "org . junit . Assert . assertThat ( aclSpecs , org . hamcrest . Matchers . hasSize ( 1 ) )"}
{"focal": "evaluateCommand ( org . jenkinsci . plugins . postbuildscript . model . ScriptFile , org . jenkinsci . plugins . postbuildscript . service . Command ) { if ( workspaceIsNull ( ) ) { return false ; } hudson . FilePath filePath = new org . jenkinsci . plugins . postbuildscript . service . ScriptFilePath ( workspace ) . resolve ( command . getScriptPath ( ) ) ; org . jenkinsci . plugins . postbuildscript . service . LoadScriptContentCallable callable = new org . jenkinsci . plugins . postbuildscript . service . LoadScriptContentCallable ( ) ; java . lang . String scriptContent = new org . jenkinsci . plugins . postbuildscript . service . Content ( callable ) . resolve ( filePath ) ; org . jenkinsci . plugins . postbuildscript . model . Script script = new org . jenkinsci . plugins . postbuildscript . model . Script ( scriptFile . getResults ( ) , scriptContent ) ; script . setSandboxed ( scriptFile . isSandboxed ( ) ) ; return evaluateScript ( script , command . getParameters ( ) ) ; }", "testMethod": "doesNotExecuteScriptFileIfWorkspaceIsNull ( ) { org . jenkinsci . plugins . postbuildscript . service . GroovyScriptPreparer groovyScriptPreparer = new org . jenkinsci . plugins . postbuildscript . service . GroovyScriptPreparer ( logger , null , executorFactory ) ; boolean evaluated = groovyScriptPreparer . evaluateCommand ( scriptFile , new org . jenkinsci . plugins . postbuildscript . service . Command ( file . getName ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( evaluated , org . hamcrest . CoreMatchers . is ( false ) )", "total": "doesNotExecuteScriptFileIfWorkspaceIsNull ( ) { org . jenkinsci . plugins . postbuildscript . service . GroovyScriptPreparer groovyScriptPreparer = new org . jenkinsci . plugins . postbuildscript . service . GroovyScriptPreparer ( logger , null , executorFactory ) ; boolean evaluated = groovyScriptPreparer . evaluateCommand ( scriptFile , new org . jenkinsci . plugins . postbuildscript . service . Command ( file . getName ( ) ) ) ; \"<AssertPlaceHolder>\" ; } evaluateCommand ( org . jenkinsci . plugins . postbuildscript . model . ScriptFile , org . jenkinsci . plugins . postbuildscript . service . Command ) { if ( workspaceIsNull ( ) ) { return false ; } hudson . FilePath filePath = new org . jenkinsci . plugins . postbuildscript . service . ScriptFilePath ( workspace ) . resolve ( command . getScriptPath ( ) ) ; org . jenkinsci . plugins . postbuildscript . service . LoadScriptContentCallable callable = new org . jenkinsci . plugins . postbuildscript . service . LoadScriptContentCallable ( ) ; java . lang . String scriptContent = new org . jenkinsci . plugins . postbuildscript . service . Content ( callable ) . resolve ( filePath ) ; org . jenkinsci . plugins . postbuildscript . model . Script script = new org . jenkinsci . plugins . postbuildscript . model . Script ( scriptFile . getResults ( ) , scriptContent ) ; script . setSandboxed ( scriptFile . isSandboxed ( ) ) ; return evaluateScript ( script , command . getParameters ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( evaluated , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "containsAny ( java . util . Set ) { return ! ( com . google . common . collect . Sets . intersection ( this . values ( ) , other ) . isEmpty ( ) ) ; }", "testMethod": "testContainsWithEmpty ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) , org . onosproject . net . PortNumber . portNumber ( 1 ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . EncodableDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sut . containsAny ( com . google . common . collect . ImmutableSet . of ( ) ) , org . hamcrest . Matchers . is ( false ) )", "total": "testContainsWithEmpty ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) , org . onosproject . net . PortNumber . portNumber ( 1 ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . EncodableDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; \"<AssertPlaceHolder>\" ; } containsAny ( java . util . Set ) { return ! ( com . google . common . collect . Sets . intersection ( this . values ( ) , other ) . isEmpty ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( sut . containsAny ( com . google . common . collect . ImmutableSet . of ( ) ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getParent ( ) { return parent ; }", "testMethod": "parentPropertyMustBeSetWhenAddingOrderLineToContainer ( ) { org . libreplan . business . orders . entities . OrderLineGroup orderLineGroup = org . libreplan . business . orders . entities . OrderLineGroup . create ( ) ; orderLineGroup . useSchedulingDataFor ( org . libreplan . business . test . planner . entities . TaskTest . mockOrderVersion ( ) ) ; org . libreplan . business . orders . entities . OrderLine orderLine = org . libreplan . business . orders . entities . OrderLine . create ( ) ; orderLineGroup . add ( orderLine ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( orderLine . getParent ( ) , org . hamcrest . CoreMatchers . equalTo ( orderLineGroup ) )", "total": "parentPropertyMustBeSetWhenAddingOrderLineToContainer ( ) { org . libreplan . business . orders . entities . OrderLineGroup orderLineGroup = org . libreplan . business . orders . entities . OrderLineGroup . create ( ) ; orderLineGroup . useSchedulingDataFor ( org . libreplan . business . test . planner . entities . TaskTest . mockOrderVersion ( ) ) ; org . libreplan . business . orders . entities . OrderLine orderLine = org . libreplan . business . orders . entities . OrderLine . create ( ) ; orderLineGroup . add ( orderLine ) ; \"<AssertPlaceHolder>\" ; } getParent ( ) { return parent ; }", "answer": "org . junit . Assert . assertThat ( orderLine . getParent ( ) , org . hamcrest . CoreMatchers . equalTo ( orderLineGroup ) )"}
{"focal": "create ( org . talend . components . kinesis . KinesisDatasetProperties ) { return org . talend . components . kinesis . runtime . KinesisClient . getProvider ( dataset ) . getKinesisClient ( ) ; }", "testMethod": "testConvertIntValueToTime ( ) { int conv = testConvertValue ( org . apache . avro . Schema . create ( Schema . Type . INT ) , 45862123 , TypeConverterProperties . TypeConverterOutputTypes . Time , \"\" , org . talend . components . processing . runtime . typeconverter . Integer . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( conv , org . hamcrest . Matchers . is ( 45862123 ) )", "total": "testConvertIntValueToTime ( ) { int conv = testConvertValue ( org . apache . avro . Schema . create ( Schema . Type . INT ) , 45862123 , TypeConverterProperties . TypeConverterOutputTypes . Time , \"\" , org . talend . components . processing . runtime . typeconverter . Integer . class ) ; \"<AssertPlaceHolder>\" ; } create ( org . talend . components . kinesis . KinesisDatasetProperties ) { return org . talend . components . kinesis . runtime . KinesisClient . getProvider ( dataset ) . getKinesisClient ( ) ; }", "answer": "org . junit . Assert . assertThat ( conv , org . hamcrest . Matchers . is ( 45862123 ) )"}
{"focal": "hashCode ( ) { return super . hashCode ( ) ; }", "testMethod": "testHashCode ( ) { final ddf . catalog . validation . impl . validator . EnumerationValidator validator1 = new ddf . catalog . validation . impl . validator . EnumerationValidator ( com . google . common . collect . Sets . newHashSet ( \"first\" , \"second\" ) , false ) ; final ddf . catalog . validation . impl . validator . EnumerationValidator validator2 = new ddf . catalog . validation . impl . validator . EnumerationValidator ( com . google . common . collect . Sets . newHashSet ( \"first\" , \"second\" ) , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( validator1 . hashCode ( ) , org . hamcrest . CoreMatchers . is ( validator2 . hashCode ( ) ) )", "total": "testHashCode ( ) { final ddf . catalog . validation . impl . validator . EnumerationValidator validator1 = new ddf . catalog . validation . impl . validator . EnumerationValidator ( com . google . common . collect . Sets . newHashSet ( \"first\" , \"second\" ) , false ) ; final ddf . catalog . validation . impl . validator . EnumerationValidator validator2 = new ddf . catalog . validation . impl . validator . EnumerationValidator ( com . google . common . collect . Sets . newHashSet ( \"first\" , \"second\" ) , false ) ; \"<AssertPlaceHolder>\" ; } hashCode ( ) { return super . hashCode ( ) ; }", "answer": "org . junit . Assert . assertThat ( validator1 . hashCode ( ) , org . hamcrest . CoreMatchers . is ( validator2 . hashCode ( ) ) )"}
{"focal": "withMetadataEnvelopedFrom ( uk . gov . justice . services . messaging . Envelope ) { return uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher . metadata ( ) . envelopedWith ( jsonEnvelope . metadata ( ) ) ; }", "testMethod": "shouldMatchAGivenMetadataWhereEnvelopedFromJsonEnvelope ( ) { final uk . gov . justice . services . messaging . Metadata testMetadata = defaultMetadataRandomIdWithName ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . EVENT_NAME ) . withCausation ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . ID , uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . CAUSATION_ID ) . build ( ) ; final uk . gov . justice . services . messaging . JsonEnvelope jsonEnvelope = envelope ( ) . with ( defaultMetadataWithName ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . COMMAND_ACTION ) ) . withPayloadOf ( \"Test\" , \"value\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testMetadata , uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher . withMetadataEnvelopedFrom ( jsonEnvelope ) )", "total": "shouldMatchAGivenMetadataWhereEnvelopedFromJsonEnvelope ( ) { final uk . gov . justice . services . messaging . Metadata testMetadata = defaultMetadataRandomIdWithName ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . EVENT_NAME ) . withCausation ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . ID , uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . CAUSATION_ID ) . build ( ) ; final uk . gov . justice . services . messaging . JsonEnvelope jsonEnvelope = envelope ( ) . with ( defaultMetadataWithName ( uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcherTest . COMMAND_ACTION ) ) . withPayloadOf ( \"Test\" , \"value\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } withMetadataEnvelopedFrom ( uk . gov . justice . services . messaging . Envelope ) { return uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher . metadata ( ) . envelopedWith ( jsonEnvelope . metadata ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( testMetadata , uk . gov . justice . services . test . utils . core . matchers . JsonEnvelopeMetadataMatcher . withMetadataEnvelopedFrom ( jsonEnvelope ) )"}
{"focal": "getBreakString ( ) { return breakString ; }", "testMethod": "testWithBreakString ( ) { final com . orangesignal . csv . CsvConfig cfg = new com . orangesignal . csv . CsvConfig ( ) ; cfg . withBreakString ( \"\\n\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cfg . getBreakString ( ) , org . hamcrest . core . Is . is ( \"\\n\" ) )", "total": "testWithBreakString ( ) { final com . orangesignal . csv . CsvConfig cfg = new com . orangesignal . csv . CsvConfig ( ) ; cfg . withBreakString ( \"\\n\" ) ; \"<AssertPlaceHolder>\" ; } getBreakString ( ) { return breakString ; }", "answer": "org . junit . Assert . assertThat ( cfg . getBreakString ( ) , org . hamcrest . core . Is . is ( \"\\n\" ) )"}
{"focal": "getAttribute ( java . lang . String ) { return commandProcessor . getString ( \"getAttribute\" , new java . lang . String [ ] { attributeLocator } ) ; }", "testMethod": "testCanGetValueFromOptionViaAttributeWhenAttributeIsEmptyString ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"optionEmptyValueSet\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( element . getAttribute ( \"value\" ) , org . hamcrest . Matchers . is ( \"\" ) )", "total": "testCanGetValueFromOptionViaAttributeWhenAttributeIsEmptyString ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"optionEmptyValueSet\" ) ) ; \"<AssertPlaceHolder>\" ; } getAttribute ( java . lang . String ) { return commandProcessor . getString ( \"getAttribute\" , new java . lang . String [ ] { attributeLocator } ) ; }", "answer": "org . junit . Assert . assertThat ( element . getAttribute ( \"value\" ) , org . hamcrest . Matchers . is ( \"\" ) )"}
{"focal": "getMessage ( ) { return message ; }", "testMethod": "testCheckAlgo ( ) { final org . uberfire . java . nio . fs . jgit . daemon . ssh . GitSSHService sshService = new org . uberfire . java . nio . fs . jgit . daemon . ssh . GitSSHService ( ) ; final java . io . File certDir = org . uberfire . java . nio . fs . jgit . daemon . ssh . GitSSHServiceTest . createTempDirectory ( ) ; try { sshService . setup ( certDir , null , \"10000\" , \"xxxx\" , mock ( org . eclipse . jgit . transport . resolver . ReceivePackFactory . class ) , mock ( JGitFileSystemProvider . RepositoryResolverImpl . class ) , executorService ) ; org . junit . Assert . fail ( \"has<sp>to<sp>fail\" ) ; } catch ( final java . lang . Exception ex ) { \"<AssertPlaceHolder>\" . contains ( \"'xxxx'\" ) ; } }", "assertLine": "org . junit . Assert . assertThat ( ex . getMessage ( ) )", "total": "testCheckAlgo ( ) { final org . uberfire . java . nio . fs . jgit . daemon . ssh . GitSSHService sshService = new org . uberfire . java . nio . fs . jgit . daemon . ssh . GitSSHService ( ) ; final java . io . File certDir = org . uberfire . java . nio . fs . jgit . daemon . ssh . GitSSHServiceTest . createTempDirectory ( ) ; try { sshService . setup ( certDir , null , \"10000\" , \"xxxx\" , mock ( org . eclipse . jgit . transport . resolver . ReceivePackFactory . class ) , mock ( JGitFileSystemProvider . RepositoryResolverImpl . class ) , executorService ) ; org . junit . Assert . fail ( \"has<sp>to<sp>fail\" ) ; } catch ( final java . lang . Exception ex ) { \"<AssertPlaceHolder>\" . contains ( \"'xxxx'\" ) ; } } getMessage ( ) { return message ; }", "answer": "org . junit . Assert . assertThat ( ex . getMessage ( ) )"}
{"focal": "isEnabled ( ) { java . lang . Object value = execute ( DriverCommand . IS_ELEMENT_ENABLED , com . google . common . collect . ImmutableMap . of ( \"id\" , id ) ) . getValue ( ) ; try { return ( ( java . lang . Boolean ) ( value ) ) ; } catch ( java . lang . ClassCastException ex ) { throw new org . openqa . selenium . WebDriverException ( ( \"Returned<sp>value<sp>cannot<sp>be<sp>converted<sp>to<sp>Boolean:<sp>\" + value ) , ex ) ; } }", "testMethod": "testShouldIndicateWhenATextAreaIsDisabled ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement textArea = driver . findElement ( org . openqa . selenium . By . xpath ( \"//textarea[@id='notWorkingArea']\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( textArea . isEnabled ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "testShouldIndicateWhenATextAreaIsDisabled ( ) { driver . get ( pages . formPage ) ; org . openqa . selenium . WebElement textArea = driver . findElement ( org . openqa . selenium . By . xpath ( \"//textarea[@id='notWorkingArea']\" ) ) ; \"<AssertPlaceHolder>\" ; } isEnabled ( ) { java . lang . Object value = execute ( DriverCommand . IS_ELEMENT_ENABLED , com . google . common . collect . ImmutableMap . of ( \"id\" , id ) ) . getValue ( ) ; try { return ( ( java . lang . Boolean ) ( value ) ) ; } catch ( java . lang . ClassCastException ex ) { throw new org . openqa . selenium . WebDriverException ( ( \"Returned<sp>value<sp>cannot<sp>be<sp>converted<sp>to<sp>Boolean:<sp>\" + value ) , ex ) ; } }", "answer": "org . junit . Assert . assertThat ( textArea . isEnabled ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "hasNext ( ) { return ( cursor ) != ( size ) ; }", "testMethod": "whenHasNextInEmptyArrayListThenResultFalse ( ) { vkaretko . MyArrayList list = new vkaretko . MyArrayList ( 2 ) ; java . util . Iterator itr = list . iterator ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( itr . hasNext ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "whenHasNextInEmptyArrayListThenResultFalse ( ) { vkaretko . MyArrayList list = new vkaretko . MyArrayList ( 2 ) ; java . util . Iterator itr = list . iterator ( ) ; \"<AssertPlaceHolder>\" ; } hasNext ( ) { return ( cursor ) != ( size ) ; }", "answer": "org . junit . Assert . assertThat ( itr . hasNext ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "run ( ) { org . apache . servicecomb . pack . alpha . server . discovery . consul . AlphaConsulAutoConfiguration . LOG . info ( \"Unregister<sp>Consul<sp>{}\" , consuleInstanceId ) ; consulClient . agentServiceDeregister ( consuleInstanceId ) ; }", "testMethod": "burnsAllTasksInQueue ( ) { runnables . offer ( ( ) -> messages . add ( \"hello\" ) ) ; runnables . offer ( ( ) -> messages . add ( \"world\" ) ) ; taskRunner . run ( ) ; await ( ) . atMost ( 500 , org . apache . servicecomb . pack . alpha . core . MILLISECONDS ) . until ( runnables :: isEmpty ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( messages , org . hamcrest . Matchers . contains ( \"hello\" , \"world\" ) )", "total": "burnsAllTasksInQueue ( ) { runnables . offer ( ( ) -> messages . add ( \"hello\" ) ) ; runnables . offer ( ( ) -> messages . add ( \"world\" ) ) ; taskRunner . run ( ) ; await ( ) . atMost ( 500 , org . apache . servicecomb . pack . alpha . core . MILLISECONDS ) . until ( runnables :: isEmpty ) ; \"<AssertPlaceHolder>\" ; } run ( ) { org . apache . servicecomb . pack . alpha . server . discovery . consul . AlphaConsulAutoConfiguration . LOG . info ( \"Unregister<sp>Consul<sp>{}\" , consuleInstanceId ) ; consulClient . agentServiceDeregister ( consuleInstanceId ) ; }", "answer": "org . junit . Assert . assertThat ( messages , org . hamcrest . Matchers . contains ( \"hello\" , \"world\" ) )"}
{"focal": "urlValidatorValueOf ( boolean ) { return isDisabledSecureConnection ? uk . gov . pay . api . validation . URLValidator . SECURITY_DISABLED : uk . gov . pay . api . validation . URLValidator . SECURITY_ENABLED ; }", "testMethod": "shouldReturnExpectedURLValidatorWhenDisabledSecureConnectionIsFalse ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uk . gov . pay . api . validation . URLValidator . urlValidatorValueOf ( false ) , org . hamcrest . core . Is . is ( uk . gov . pay . api . validation . URLValidator . SECURITY_ENABLED ) )", "total": "shouldReturnExpectedURLValidatorWhenDisabledSecureConnectionIsFalse ( ) { \"<AssertPlaceHolder>\" ; } urlValidatorValueOf ( boolean ) { return isDisabledSecureConnection ? uk . gov . pay . api . validation . URLValidator . SECURITY_DISABLED : uk . gov . pay . api . validation . URLValidator . SECURITY_ENABLED ; }", "answer": "org . junit . Assert . assertThat ( uk . gov . pay . api . validation . URLValidator . urlValidatorValueOf ( false ) , org . hamcrest . core . Is . is ( uk . gov . pay . api . validation . URLValidator . SECURITY_ENABLED ) )"}
{"focal": "addToClassPool ( javassist . ClassPool ) { javassist . CtClass ctClass ; if ( this . superclass . isPresent ( ) ) { ctClass = classPool . makeClass ( this . name , this . superclass . get ( ) ) ; } else { ctClass = classPool . makeClass ( this . name ) ; } ctClass . setModifiers ( this . modifier ) ; for ( java . lang . String annotation : annotations ) { javassist . bytecode . ClassFile classFile = ctClass . getClassFile ( ) ; javassist . bytecode . ConstPool constPool = classFile . getConstPool ( ) ; javassist . bytecode . AnnotationsAttribute attr = new javassist . bytecode . AnnotationsAttribute ( constPool , javassist . bytecode . AnnotationsAttribute . visibleTag ) ; javassist . bytecode . annotation . Annotation annot = new javassist . bytecode . annotation . Annotation ( annotation , constPool ) ; attr . setAnnotation ( annot ) ; ctClass . getClassFile2 ( ) . addAttribute ( attr ) ; } for ( javassist . CtClass interfaceCtClass : interfaces ) { ctClass . addInterface ( interfaceCtClass ) ; } return ctClass ; }", "testMethod": "testTwoClassesExcludeClassThatDoesNotExist ( ) { japicmp . cmp . JarArchiveComparatorOptions options = new japicmp . cmp . JarArchiveComparatorOptions ( ) ; options . getFilters ( ) . getExcludes ( ) . add ( new japicmp . filter . JavaDocLikeClassFilter ( \"japicmp.Test1\" ) ) ; java . util . List < japicmp . model . JApiClass > jApiClasses = japicmp . cmp . ClassesHelper . compareClasses ( options , new japicmp . cmp . ClassesHelper . ClassesGenerator ( ) { @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createOldClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Homer\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Marge\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createNewClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Homer\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Marge\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( jApiClasses . size ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "testTwoClassesExcludeClassThatDoesNotExist ( ) { japicmp . cmp . JarArchiveComparatorOptions options = new japicmp . cmp . JarArchiveComparatorOptions ( ) ; options . getFilters ( ) . getExcludes ( ) . add ( new japicmp . filter . JavaDocLikeClassFilter ( \"japicmp.Test1\" ) ) ; java . util . List < japicmp . model . JApiClass > jApiClasses = japicmp . cmp . ClassesHelper . compareClasses ( options , new japicmp . cmp . ClassesHelper . ClassesGenerator ( ) { @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createOldClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Homer\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Marge\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } @ japicmp . cmp . Override public java . util . List < javassist . CtClass > createNewClasses ( javassist . ClassPool classPool ) throws japicmp . cmp . Exception { javassist . CtClass ctClass1 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Homer\" ) . addToClassPool ( classPool ) ; javassist . CtClass ctClass2 = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Marge\" ) . addToClassPool ( classPool ) ; return java . util . Arrays . asList ( ctClass1 , ctClass2 ) ; } } ) ; \"<AssertPlaceHolder>\" ; } addToClassPool ( javassist . ClassPool ) { javassist . CtClass ctClass ; if ( this . superclass . isPresent ( ) ) { ctClass = classPool . makeClass ( this . name , this . superclass . get ( ) ) ; } else { ctClass = classPool . makeClass ( this . name ) ; } ctClass . setModifiers ( this . modifier ) ; for ( java . lang . String annotation : annotations ) { javassist . bytecode . ClassFile classFile = ctClass . getClassFile ( ) ; javassist . bytecode . ConstPool constPool = classFile . getConstPool ( ) ; javassist . bytecode . AnnotationsAttribute attr = new javassist . bytecode . AnnotationsAttribute ( constPool , javassist . bytecode . AnnotationsAttribute . visibleTag ) ; javassist . bytecode . annotation . Annotation annot = new javassist . bytecode . annotation . Annotation ( annotation , constPool ) ; attr . setAnnotation ( annot ) ; ctClass . getClassFile2 ( ) . addAttribute ( attr ) ; } for ( javassist . CtClass interfaceCtClass : interfaces ) { ctClass . addInterface ( interfaceCtClass ) ; } return ctClass ; }", "answer": "org . junit . Assert . assertThat ( jApiClasses . size ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "copy ( java . lang . String ) { input . sendKeys ( inputText ) ; org . jboss . arquillian . graphene . Graphene . guardHttp ( ok ) . click ( ) ; return output . getAttribute ( \"value\" ) ; }", "testMethod": "copy ( com . airhacks . IndexPage ) { java . lang . String expected = \"duke\" ; java . lang . String actual = page . copy ( expected ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "copy ( com . airhacks . IndexPage ) { java . lang . String expected = \"duke\" ; java . lang . String actual = page . copy ( expected ) ; \"<AssertPlaceHolder>\" ; } copy ( java . lang . String ) { input . sendKeys ( inputText ) ; org . jboss . arquillian . graphene . Graphene . guardHttp ( ok ) . click ( ) ; return output . getAttribute ( \"value\" ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getCurrentHour ( ) { return currentHour ; }", "testMethod": "whenUpdateView_thenViewShouldReflectChanges ( ) { int newCurrentHourValue = org . robobinding . util . RandomValues . integerBetween ( 1 , 23 ) ; attribute . updateView ( view , newCurrentHourValue , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( view . getCurrentHour ( ) , org . hamcrest . CoreMatchers . is ( newCurrentHourValue ) )", "total": "whenUpdateView_thenViewShouldReflectChanges ( ) { int newCurrentHourValue = org . robobinding . util . RandomValues . integerBetween ( 1 , 23 ) ; attribute . updateView ( view , newCurrentHourValue , null ) ; \"<AssertPlaceHolder>\" ; } getCurrentHour ( ) { return currentHour ; }", "answer": "org . junit . Assert . assertThat ( view . getCurrentHour ( ) , org . hamcrest . CoreMatchers . is ( newCurrentHourValue ) )"}
{"focal": "nowInSystemTime ( ) { org . junit . Assert . assertThat ( net . time4j . calendar . EthiopianTime . nowInSystemTime ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . SystemClock . inLocalView ( ) . now ( net . time4j . calendar . EthiopianTime . axis ( ) ) ) ) ; }", "testMethod": "nowInSystemTime ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . calendar . EthiopianTime . nowInSystemTime ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . SystemClock . inLocalView ( ) . now ( net . time4j . calendar . EthiopianTime . axis ( ) ) ) )", "total": "nowInSystemTime ( ) { \"<AssertPlaceHolder>\" ; } nowInSystemTime ( ) { org . junit . Assert . assertThat ( net . time4j . calendar . EthiopianTime . nowInSystemTime ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . SystemClock . inLocalView ( ) . now ( net . time4j . calendar . EthiopianTime . axis ( ) ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . calendar . EthiopianTime . nowInSystemTime ( ) , org . hamcrest . CoreMatchers . is ( net . time4j . SystemClock . inLocalView ( ) . now ( net . time4j . calendar . EthiopianTime . axis ( ) ) ) )"}
{"focal": "getFundName ( ) { return fundName ; }", "testMethod": "shouldUpdateFund ( ) { org . mifos . framework . hibernate . helper . StaticHibernateUtil . startTransaction ( ) ; fundDao . update ( fund , \"newFundName\" ) ; org . mifos . framework . hibernate . helper . StaticHibernateUtil . flushSession ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fund . getFundName ( ) , org . hamcrest . CoreMatchers . is ( \"newFundName\" ) )", "total": "shouldUpdateFund ( ) { org . mifos . framework . hibernate . helper . StaticHibernateUtil . startTransaction ( ) ; fundDao . update ( fund , \"newFundName\" ) ; org . mifos . framework . hibernate . helper . StaticHibernateUtil . flushSession ( ) ; \"<AssertPlaceHolder>\" ; } getFundName ( ) { return fundName ; }", "answer": "org . junit . Assert . assertThat ( fund . getFundName ( ) , org . hamcrest . CoreMatchers . is ( \"newFundName\" ) )"}
{"focal": "build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "testMethod": "skip_empty_field ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . withSkipEmptyInput ( true ) . build ( ) ) . withField ( self ( ) , field ( 3 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"A\" , \"\" , \"B\" , \"\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"A\" , \"B\" , \"\" } } ) )", "total": "skip_empty_field ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . withField ( self ( ) , field ( 2 ) . withSkipEmptyInput ( true ) . build ( ) ) . withField ( self ( ) , field ( 3 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"A\" , \"\" , \"B\" , \"\" } } ) ; \"<AssertPlaceHolder>\" ; } build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"\" , \"A\" , \"B\" , \"\" } } ) )"}
{"focal": "is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "testMethod": "rootOid_withNoVersion ( ) { org . apache . isis . core . metamodel . adapter . oid . RootOid oid = org . apache . isis . core . metamodel . adapter . oid . RootOid . create ( org . apache . isis . core . metamodel . spec . ObjectSpecId . of ( \"CUS\" ) , \"123\" ) ; final java . lang . String enString = oid . enString ( ) ; final org . apache . isis . core . metamodel . adapter . oid . RootOid deString = org . apache . isis . core . metamodel . adapter . oid . RootOid . deString ( enString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( deString , org . hamcrest . CoreMatchers . is ( oid ) )", "total": "rootOid_withNoVersion ( ) { org . apache . isis . core . metamodel . adapter . oid . RootOid oid = org . apache . isis . core . metamodel . adapter . oid . RootOid . create ( org . apache . isis . core . metamodel . spec . ObjectSpecId . of ( \"CUS\" ) , \"123\" ) ; final java . lang . String enString = oid . enString ( ) ; final org . apache . isis . core . metamodel . adapter . oid . RootOid deString = org . apache . isis . core . metamodel . adapter . oid . RootOid . deString ( enString ) ; \"<AssertPlaceHolder>\" ; } is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( deString , org . hamcrest . CoreMatchers . is ( oid ) )"}
{"focal": "size ( ) { return getMap ( ) . size ( ) ; }", "testMethod": "testTreeSet ( ) { final java . util . TreeSet < java . lang . String > set = new java . util . TreeSet < java . lang . String > ( new java . util . Comparator < java . lang . String > ( ) { @ de . metas . migration . scanner . impl . Override public int compare ( final java . lang . String o1 , final java . lang . String o2 ) { return o1 . substring ( 0 , 1 ) . compareTo ( o2 . substring ( 0 , 1 ) ) ; } } ) ; set . add ( \"String1\" ) ; set . add ( \"String2\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( set . size ( ) , org . hamcrest . Matchers . is ( 1 ) )", "total": "testTreeSet ( ) { final java . util . TreeSet < java . lang . String > set = new java . util . TreeSet < java . lang . String > ( new java . util . Comparator < java . lang . String > ( ) { @ de . metas . migration . scanner . impl . Override public int compare ( final java . lang . String o1 , final java . lang . String o2 ) { return o1 . substring ( 0 , 1 ) . compareTo ( o2 . substring ( 0 , 1 ) ) ; } } ) ; set . add ( \"String1\" ) ; set . add ( \"String2\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return getMap ( ) . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( set . size ( ) , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "handle ( org . apache . servicecomb . pack . alpha . core . TxEvent ) { if ( ( types . contains ( event . type ( ) ) ) && ( isGlobalTxAborted ( event ) ) ) { org . apache . servicecomb . pack . alpha . core . TxConsistentService . LOG . info ( \"Transaction<sp>event<sp>{}<sp>rejected,<sp>because<sp>its<sp>parent<sp>with<sp>globalTxId<sp>{}<sp>was<sp>already<sp>aborted\" , event . type ( ) , event . globalTxId ( ) ) ; return false ; } eventRepository . save ( event ) ; return true ; }", "testMethod": "skipTxStartedEvent_IfGlobalTxAlreadyFailed ( ) { java . lang . String localTxId1 = java . util . UUID . randomUUID ( ) . toString ( ) ; events . add ( newEvent ( org . apache . servicecomb . pack . alpha . core . TxStartedEvent ) ) ; events . add ( newEvent ( org . apache . servicecomb . pack . alpha . core . TxAbortedEvent ) ) ; org . apache . servicecomb . pack . alpha . core . TxEvent event = eventOf ( org . apache . servicecomb . pack . alpha . core . TxStartedEvent , localTxId1 ) ; consistentService . handle ( event ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( events . size ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "skipTxStartedEvent_IfGlobalTxAlreadyFailed ( ) { java . lang . String localTxId1 = java . util . UUID . randomUUID ( ) . toString ( ) ; events . add ( newEvent ( org . apache . servicecomb . pack . alpha . core . TxStartedEvent ) ) ; events . add ( newEvent ( org . apache . servicecomb . pack . alpha . core . TxAbortedEvent ) ) ; org . apache . servicecomb . pack . alpha . core . TxEvent event = eventOf ( org . apache . servicecomb . pack . alpha . core . TxStartedEvent , localTxId1 ) ; consistentService . handle ( event ) ; \"<AssertPlaceHolder>\" ; } handle ( org . apache . servicecomb . pack . alpha . core . TxEvent ) { if ( ( types . contains ( event . type ( ) ) ) && ( isGlobalTxAborted ( event ) ) ) { org . apache . servicecomb . pack . alpha . core . TxConsistentService . LOG . info ( \"Transaction<sp>event<sp>{}<sp>rejected,<sp>because<sp>its<sp>parent<sp>with<sp>globalTxId<sp>{}<sp>was<sp>already<sp>aborted\" , event . type ( ) , event . globalTxId ( ) ) ; return false ; } eventRepository . save ( event ) ; return true ; }", "answer": "org . junit . Assert . assertThat ( events . size ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "getCompleted ( java . util . concurrent . CompletionStage ) { java . util . concurrent . CompletableFuture < T > future = stage . toCompletableFuture ( ) ; com . spotify . futures . CompletableFutures . checkCompleted ( future ) ; return future . join ( ) ; }", "testMethod": "getCompleted_done ( ) { final java . util . concurrent . CompletionStage < java . lang . String > future = completedFuture ( \"hello\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . spotify . futures . CompletableFutures . getCompleted ( future ) , org . hamcrest . core . Is . is ( \"hello\" ) )", "total": "getCompleted_done ( ) { final java . util . concurrent . CompletionStage < java . lang . String > future = completedFuture ( \"hello\" ) ; \"<AssertPlaceHolder>\" ; } getCompleted ( java . util . concurrent . CompletionStage ) { java . util . concurrent . CompletableFuture < T > future = stage . toCompletableFuture ( ) ; com . spotify . futures . CompletableFutures . checkCompleted ( future ) ; return future . join ( ) ; }", "answer": "org . junit . Assert . assertThat ( com . spotify . futures . CompletableFutures . getCompleted ( future ) , org . hamcrest . core . Is . is ( \"hello\" ) )"}
{"focal": "databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "testMethod": "expected_table_and_database_table_with_same_content_should_be_equals ( ) { addTableWithData ( getDynamoDB ( ) , \"col1\" , \"name\" , \"Alex\" ) ; boolean isEquals = com . lordofthejars . nosqlunit . dynamodb . integration . WhenExpectedDataShouldBeCompared . dynamoOperation . databaseIs ( new java . io . ByteArrayInputStream ( \"{\\\"col1\\\":[{\\\"name\\\":\\\"Alex\\\"}]}\" . getBytes ( \"UTF-8\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isEquals , org . hamcrest . CoreMatchers . is ( true ) )", "total": "expected_table_and_database_table_with_same_content_should_be_equals ( ) { addTableWithData ( getDynamoDB ( ) , \"col1\" , \"name\" , \"Alex\" ) ; boolean isEquals = com . lordofthejars . nosqlunit . dynamodb . integration . WhenExpectedDataShouldBeCompared . dynamoOperation . databaseIs ( new java . io . ByteArrayInputStream ( \"{\\\"col1\\\":[{\\\"name\\\":\\\"Alex\\\"}]}\" . getBytes ( \"UTF-8\" ) ) ) ; \"<AssertPlaceHolder>\" ; } databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "answer": "org . junit . Assert . assertThat ( isEquals , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "get ( org . ops4j . pax . exam . acceptance . rest . api . RestRequest ) { try { io . restassured . response . Response res = io . restassured . RestAssured . given ( ) . auth ( ) . basic ( clientConfig . getUser ( ) , clientConfig . getPassword ( ) ) . headers ( r . getHeaders ( ) ) . body ( r . getBody ( ) ) . when ( ) . get ( r . getPath ( ) ) ; return new org . ops4j . pax . exam . acceptance . rest . restassured . RestClientImpl . RestResultImpl ( res , null , 0 ) ; } catch ( java . lang . Exception e ) { return new org . ops4j . pax . exam . acceptance . rest . restassured . RestClientImpl . RestResultImpl ( null , e , 0 ) ; } }", "testMethod": "invokeSingleTestMethod ( ) { org . junit . Assume . assumeTrue ( org . ops4j . pax . exam . regression . multi . RegressionConfiguration . isNativeContainer ( ) ) ; org . junit . Assume . assumeTrue ( org . ops4j . pax . exam . regression . multi . RegressionConfiguration . isEquinox ( ) ) ; org . junit . runner . JUnitCore junit = new org . junit . runner . JUnitCore ( ) ; java . lang . String method = \"getInjectedServices\" ; org . junit . runner . Request request = org . junit . runner . Request . method ( org . ops4j . pax . exam . regression . multi . inject . FilterTest . class , method ) ; org . junit . runner . Result result = junit . run ( request ) ; if ( ( result . getFailureCount ( ) ) > 0 ) { org . ops4j . pax . exam . regression . multi . inject . SingleMethodInvokerTest . LOG . error ( result . getFailures ( ) . get ( 0 ) . getTrace ( ) ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . getFailureCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "invokeSingleTestMethod ( ) { org . junit . Assume . assumeTrue ( org . ops4j . pax . exam . regression . multi . RegressionConfiguration . isNativeContainer ( ) ) ; org . junit . Assume . assumeTrue ( org . ops4j . pax . exam . regression . multi . RegressionConfiguration . isEquinox ( ) ) ; org . junit . runner . JUnitCore junit = new org . junit . runner . JUnitCore ( ) ; java . lang . String method = \"getInjectedServices\" ; org . junit . runner . Request request = org . junit . runner . Request . method ( org . ops4j . pax . exam . regression . multi . inject . FilterTest . class , method ) ; org . junit . runner . Result result = junit . run ( request ) ; if ( ( result . getFailureCount ( ) ) > 0 ) { org . ops4j . pax . exam . regression . multi . inject . SingleMethodInvokerTest . LOG . error ( result . getFailures ( ) . get ( 0 ) . getTrace ( ) ) ; } \"<AssertPlaceHolder>\" ; } get ( org . ops4j . pax . exam . acceptance . rest . api . RestRequest ) { try { io . restassured . response . Response res = io . restassured . RestAssured . given ( ) . auth ( ) . basic ( clientConfig . getUser ( ) , clientConfig . getPassword ( ) ) . headers ( r . getHeaders ( ) ) . body ( r . getBody ( ) ) . when ( ) . get ( r . getPath ( ) ) ; return new org . ops4j . pax . exam . acceptance . rest . restassured . RestClientImpl . RestResultImpl ( res , null , 0 ) ; } catch ( java . lang . Exception e ) { return new org . ops4j . pax . exam . acceptance . rest . restassured . RestClientImpl . RestResultImpl ( null , e , 0 ) ; } }", "answer": "org . junit . Assert . assertThat ( result . getFailureCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getUniqueResultFromQuery ( java . lang . String ) { return uniqueResult ( namedQuery ( name ) ) ; }", "testMethod": "itReturnsUniqueResultsFromQueries ( ) { when ( query . uniqueResult ( ) ) . thenReturn ( \"woo\" ) ; \"<AssertPlaceHolder>\" ; verify ( session ) . getNamedQuery ( \"query-name\" ) ; verify ( query ) . uniqueResult ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( dao . getUniqueResultFromQuery ( \"query-name\" ) , org . hamcrest . CoreMatchers . is ( \"woo\" ) )", "total": "itReturnsUniqueResultsFromQueries ( ) { when ( query . uniqueResult ( ) ) . thenReturn ( \"woo\" ) ; \"<AssertPlaceHolder>\" ; verify ( session ) . getNamedQuery ( \"query-name\" ) ; verify ( query ) . uniqueResult ( ) ; } getUniqueResultFromQuery ( java . lang . String ) { return uniqueResult ( namedQuery ( name ) ) ; }", "answer": "org . junit . Assert . assertThat ( dao . getUniqueResultFromQuery ( \"query-name\" ) , org . hamcrest . CoreMatchers . is ( \"woo\" ) )"}
{"focal": "contains ( java . lang . Object ) { return serviceMap . containsValue ( arg0 ) ; }", "testMethod": "testInitialContains ( ) { org . codice . ddf . platform . util . http . UnavailableUrls set = initSet ( 200 ) ; set . add ( \"hello\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( set . contains ( \"hello\" ) , org . hamcrest . Matchers . is ( true ) )", "total": "testInitialContains ( ) { org . codice . ddf . platform . util . http . UnavailableUrls set = initSet ( 200 ) ; set . add ( \"hello\" ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . Object ) { return serviceMap . containsValue ( arg0 ) ; }", "answer": "org . junit . Assert . assertThat ( set . contains ( \"hello\" ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "call ( ) { int exitCode = 0 ; try { scheduler ( ) . run ( ) ; } catch ( java . lang . Throwable t ) { log . error ( \"Caught<sp>throwable<sp>while<sp>processing<sp>data\" , t ) ; exitCode = 1 ; } return exitCode ; }", "testMethod": "testSuccessfulRunner ( ) { software . amazon . kinesis . multilang . MultiLangDaemon . MultiLangRunner runner = new software . amazon . kinesis . multilang . MultiLangDaemon . MultiLangRunner ( scheduler ) ; doNothing ( ) . when ( scheduler ) . run ( ) ; int exit = runner . call ( ) ; \"<AssertPlaceHolder>\" ; verify ( scheduler ) . run ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( exit , org . hamcrest . Matchers . equalTo ( 0 ) )", "total": "testSuccessfulRunner ( ) { software . amazon . kinesis . multilang . MultiLangDaemon . MultiLangRunner runner = new software . amazon . kinesis . multilang . MultiLangDaemon . MultiLangRunner ( scheduler ) ; doNothing ( ) . when ( scheduler ) . run ( ) ; int exit = runner . call ( ) ; \"<AssertPlaceHolder>\" ; verify ( scheduler ) . run ( ) ; } call ( ) { int exitCode = 0 ; try { scheduler ( ) . run ( ) ; } catch ( java . lang . Throwable t ) { log . error ( \"Caught<sp>throwable<sp>while<sp>processing<sp>data\" , t ) ; exitCode = 1 ; } return exitCode ; }", "answer": "org . junit . Assert . assertThat ( exit , org . hamcrest . Matchers . equalTo ( 0 ) )"}
{"focal": "search ( ca . uhn . fhir . rest . param . StringParam ) { final ca . uhn . fhir . jaxrs . server . example . List < ca . uhn . fhir . jaxrs . server . example . Patient > result = new ca . uhn . fhir . jaxrs . server . example . LinkedList < ca . uhn . fhir . jaxrs . server . example . Patient > ( ) ; for ( final ca . uhn . fhir . jaxrs . server . example . List < ca . uhn . fhir . jaxrs . server . example . Patient > patientIterator : ca . uhn . fhir . jaxrs . server . example . JaxRsPatientRestProviderDstu3 . patients . values ( ) ) { ca . uhn . fhir . jaxrs . server . example . Patient single = null ; for ( ca . uhn . fhir . jaxrs . server . example . Patient patient : patientIterator ) { if ( ( name == null ) || ( patient . getName ( ) . get ( 0 ) . getFamilyElement ( ) . getValueNotNull ( ) . equals ( name . getValueNotNull ( ) ) ) ) { single = patient ; } } if ( single != null ) { result . add ( single ) ; } } return result ; }", "testMethod": "testSearchWithIncludesStarRecurse ( ) { java . lang . String methodName = \"testSearchWithIncludes\" ; ca . uhn . fhir . jpa . dao . dstu3 . IIdType parentParentOrgId ; { ca . uhn . fhir . jpa . dao . dstu3 . Organization org = new ca . uhn . fhir . jpa . dao . dstu3 . Organization ( ) ; org . getNameElement ( ) . setValue ( ( methodName + \"_O1Parent\" ) ) ; parentParentOrgId = myOrganizationDao . create ( org , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } ca . uhn . fhir . jpa . dao . dstu3 . IIdType parentOrgId ; { ca . uhn . fhir . jpa . dao . dstu3 . Organization org = new ca . uhn . fhir . jpa . dao . dstu3 . Organization ( ) ; org . getNameElement ( ) . setValue ( ( methodName + \"_O1Parent\" ) ) ; org . setPartOf ( new ca . uhn . fhir . jpa . dao . dstu3 . Reference ( parentParentOrgId ) ) ; parentOrgId = myOrganizationDao . create ( org , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } ca . uhn . fhir . jpa . dao . dstu3 . IIdType orgId ; { ca . uhn . fhir . jpa . dao . dstu3 . Organization org = new ca . uhn . fhir . jpa . dao . dstu3 . Organization ( ) ; org . getNameElement ( ) . setValue ( ( methodName + \"_O1\" ) ) ; org . setPartOf ( new ca . uhn . fhir . jpa . dao . dstu3 . Reference ( parentOrgId ) ) ; orgId = myOrganizationDao . create ( org , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } ca . uhn . fhir . jpa . dao . dstu3 . IIdType patientId ; { ca . uhn . fhir . jpa . dao . dstu3 . Patient patient = new ca . uhn . fhir . jpa . dao . dstu3 . Patient ( ) ; patient . addIdentifier ( ) . setSystem ( \"urn:system\" ) . setValue ( \"001\" ) ; patient . addName ( ) . setFamily ( ( ( \"Tester_\" + methodName ) + \"_P1\" ) ) . addGiven ( \"Joe\" ) ; patient . getManagingOrganization ( ) . setReferenceElement ( orgId ) ; patientId = myPatientDao . create ( patient , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } { ca . uhn . fhir . jpa . searchparam . SearchParameterMap params = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; params . add ( Patient . SP_FAMILY , new ca . uhn . fhir . jpa . dao . dstu3 . StringParam ( ( ( \"Tester_\" + methodName ) + \"_P1\" ) ) ) ; params . addInclude ( new ca . uhn . fhir . model . api . Include ( \"*\" ) . asRecursive ( ) ) ; ca . uhn . fhir . jpa . dao . dstu3 . List < ca . uhn . fhir . jpa . dao . dstu3 . IIdType > resources = toUnqualifiedVersionlessIds ( myPatientDao . search ( params ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( resources , contains ( patientId , orgId , parentOrgId , parentParentOrgId ) )", "total": "testSearchWithIncludesStarRecurse ( ) { java . lang . String methodName = \"testSearchWithIncludes\" ; ca . uhn . fhir . jpa . dao . dstu3 . IIdType parentParentOrgId ; { ca . uhn . fhir . jpa . dao . dstu3 . Organization org = new ca . uhn . fhir . jpa . dao . dstu3 . Organization ( ) ; org . getNameElement ( ) . setValue ( ( methodName + \"_O1Parent\" ) ) ; parentParentOrgId = myOrganizationDao . create ( org , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } ca . uhn . fhir . jpa . dao . dstu3 . IIdType parentOrgId ; { ca . uhn . fhir . jpa . dao . dstu3 . Organization org = new ca . uhn . fhir . jpa . dao . dstu3 . Organization ( ) ; org . getNameElement ( ) . setValue ( ( methodName + \"_O1Parent\" ) ) ; org . setPartOf ( new ca . uhn . fhir . jpa . dao . dstu3 . Reference ( parentParentOrgId ) ) ; parentOrgId = myOrganizationDao . create ( org , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } ca . uhn . fhir . jpa . dao . dstu3 . IIdType orgId ; { ca . uhn . fhir . jpa . dao . dstu3 . Organization org = new ca . uhn . fhir . jpa . dao . dstu3 . Organization ( ) ; org . getNameElement ( ) . setValue ( ( methodName + \"_O1\" ) ) ; org . setPartOf ( new ca . uhn . fhir . jpa . dao . dstu3 . Reference ( parentOrgId ) ) ; orgId = myOrganizationDao . create ( org , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } ca . uhn . fhir . jpa . dao . dstu3 . IIdType patientId ; { ca . uhn . fhir . jpa . dao . dstu3 . Patient patient = new ca . uhn . fhir . jpa . dao . dstu3 . Patient ( ) ; patient . addIdentifier ( ) . setSystem ( \"urn:system\" ) . setValue ( \"001\" ) ; patient . addName ( ) . setFamily ( ( ( \"Tester_\" + methodName ) + \"_P1\" ) ) . addGiven ( \"Joe\" ) ; patient . getManagingOrganization ( ) . setReferenceElement ( orgId ) ; patientId = myPatientDao . create ( patient , mySrd ) . getId ( ) . toUnqualifiedVersionless ( ) ; } { ca . uhn . fhir . jpa . searchparam . SearchParameterMap params = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; params . add ( Patient . SP_FAMILY , new ca . uhn . fhir . jpa . dao . dstu3 . StringParam ( ( ( \"Tester_\" + methodName ) + \"_P1\" ) ) ) ; params . addInclude ( new ca . uhn . fhir . model . api . Include ( \"*\" ) . asRecursive ( ) ) ; ca . uhn . fhir . jpa . dao . dstu3 . List < ca . uhn . fhir . jpa . dao . dstu3 . IIdType > resources = toUnqualifiedVersionlessIds ( myPatientDao . search ( params ) ) ; \"<AssertPlaceHolder>\" ; } } search ( ca . uhn . fhir . rest . param . StringParam ) { final ca . uhn . fhir . jaxrs . server . example . List < ca . uhn . fhir . jaxrs . server . example . Patient > result = new ca . uhn . fhir . jaxrs . server . example . LinkedList < ca . uhn . fhir . jaxrs . server . example . Patient > ( ) ; for ( final ca . uhn . fhir . jaxrs . server . example . List < ca . uhn . fhir . jaxrs . server . example . Patient > patientIterator : ca . uhn . fhir . jaxrs . server . example . JaxRsPatientRestProviderDstu3 . patients . values ( ) ) { ca . uhn . fhir . jaxrs . server . example . Patient single = null ; for ( ca . uhn . fhir . jaxrs . server . example . Patient patient : patientIterator ) { if ( ( name == null ) || ( patient . getName ( ) . get ( 0 ) . getFamilyElement ( ) . getValueNotNull ( ) . equals ( name . getValueNotNull ( ) ) ) ) { single = patient ; } } if ( single != null ) { result . add ( single ) ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( resources , contains ( patientId , orgId , parentOrgId , parentParentOrgId ) )"}
{"focal": "determineRandomShardNumber ( com . google . common . base . Optional , int ) { com . google . common . base . Preconditions . checkArgument ( ( numShards > 0 ) ) ; com . google . common . base . Preconditions . checkNotNull ( optShardNumber ) ; if ( optShardNumber . isPresent ( ) ) { final int shardNumber = optShardNumber . get ( ) ; if ( ( shardNumber >= 0 ) && ( shardNumber < numShards ) ) { return optShardNumber . get ( ) ; } } return generator . nextInt ( numShards ) ; }", "testMethod": "testDetermineRandomShardNumber_AbsentShardNumber ( ) { int actualShardNumber = impl . determineRandomShardNumber ( com . google . common . base . Optional . < java . lang . Integer > absent ( ) , 3 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( ( actualShardNumber >= 0 ) && ( actualShardNumber < 3 ) ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testDetermineRandomShardNumber_AbsentShardNumber ( ) { int actualShardNumber = impl . determineRandomShardNumber ( com . google . common . base . Optional . < java . lang . Integer > absent ( ) , 3 ) ; \"<AssertPlaceHolder>\" ; } determineRandomShardNumber ( com . google . common . base . Optional , int ) { com . google . common . base . Preconditions . checkArgument ( ( numShards > 0 ) ) ; com . google . common . base . Preconditions . checkNotNull ( optShardNumber ) ; if ( optShardNumber . isPresent ( ) ) { final int shardNumber = optShardNumber . get ( ) ; if ( ( shardNumber >= 0 ) && ( shardNumber < numShards ) ) { return optShardNumber . get ( ) ; } } return generator . nextInt ( numShards ) ; }", "answer": "org . junit . Assert . assertThat ( ( ( actualShardNumber >= 0 ) && ( actualShardNumber < 3 ) ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getBalance ( ) { return balance ; }", "testMethod": "newAccountsShouldHaveZeroBalance ( ) { com . jayway . repository . AccountEntity account = accountRepository . save ( new com . jayway . repository . AccountEntity ( ) ) ; entityManager . flush ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( account . getBalance ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "newAccountsShouldHaveZeroBalance ( ) { com . jayway . repository . AccountEntity account = accountRepository . save ( new com . jayway . repository . AccountEntity ( ) ) ; entityManager . flush ( ) ; \"<AssertPlaceHolder>\" ; } getBalance ( ) { return balance ; }", "answer": "org . junit . Assert . assertThat ( account . getBalance ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "mkString ( ) { return mkString ( \"\" , \"\" , \"\" ) ; }", "testMethod": "mkString_A$ ( ) { com . m3 . scalaflavor4j . IndexedSeq < java . lang . Integer > seq = com . m3 . scalaflavor4j . IndexedSeq . apply ( 1 , 2 , 3 , 4 , 5 ) ; java . lang . String actual = seq . mkString ( ) ; java . lang . String expected = \"12345\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "mkString_A$ ( ) { com . m3 . scalaflavor4j . IndexedSeq < java . lang . Integer > seq = com . m3 . scalaflavor4j . IndexedSeq . apply ( 1 , 2 , 3 , 4 , 5 ) ; java . lang . String actual = seq . mkString ( ) ; java . lang . String expected = \"12345\" ; \"<AssertPlaceHolder>\" ; } mkString ( ) { return mkString ( \"\" , \"\" , \"\" ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "matches ( java . lang . Object ) { if ( ( candidate == null ) || ( ! ( candidate . getClass ( ) . equals ( java . lang . String . class ) ) ) ) { return false ; } java . lang . String haystack = shrinkWhitespace ( ( ( java . lang . String ) ( candidate ) ) ) ; for ( java . lang . String needle : strings ) { needle = shrinkWhitespace ( needle ) ; int index = haystack . indexOf ( needle ) ; if ( index == ( - 1 ) ) { return false ; } haystack = haystack . substring ( ( index + ( needle . length ( ) ) ) ) ; } return true ; }", "testMethod": "matchesWhenPublicFieldHasExpectedValue ( ) { com . lassekoskela . maven . buildevents . FieldMatcher < com . lassekoskela . maven . buildevents . FieldMatcherTest . WhateverObject > m = matcher ( com . lassekoskela . maven . buildevents . FieldMatcherTest . CORRECT_FIELD , com . lassekoskela . maven . buildevents . FieldMatcherTest . CORRECT_VALUE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( m . matches ( candidate ) , org . hamcrest . Matchers . is ( true ) )", "total": "matchesWhenPublicFieldHasExpectedValue ( ) { com . lassekoskela . maven . buildevents . FieldMatcher < com . lassekoskela . maven . buildevents . FieldMatcherTest . WhateverObject > m = matcher ( com . lassekoskela . maven . buildevents . FieldMatcherTest . CORRECT_FIELD , com . lassekoskela . maven . buildevents . FieldMatcherTest . CORRECT_VALUE ) ; \"<AssertPlaceHolder>\" ; } matches ( java . lang . Object ) { if ( ( candidate == null ) || ( ! ( candidate . getClass ( ) . equals ( java . lang . String . class ) ) ) ) { return false ; } java . lang . String haystack = shrinkWhitespace ( ( ( java . lang . String ) ( candidate ) ) ) ; for ( java . lang . String needle : strings ) { needle = shrinkWhitespace ( needle ) ; int index = haystack . indexOf ( needle ) ; if ( index == ( - 1 ) ) { return false ; } haystack = haystack . substring ( ( index + ( needle . length ( ) ) ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( m . matches ( candidate ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "exists ( ) { return ( getId ( ) ) != null ; }", "testMethod": "convertAnODTDocumentToRTF ( ) { final java . io . File convertedDocument = converter . convert ( document , inFormat ( rtf ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( convertedDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "convertAnODTDocumentToRTF ( ) { final java . io . File convertedDocument = converter . convert ( document , inFormat ( rtf ) ) ; \"<AssertPlaceHolder>\" ; } exists ( ) { return ( getId ( ) ) != null ; }", "answer": "org . junit . Assert . assertThat ( convertedDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "convertToUUIDString ( java . lang . String ) { if ( ( ( value == null ) || ( value . contains ( \"-\" ) ) ) || ( ( value . length ( ) ) != 32 ) ) { return value ; } java . lang . StringBuilder sb = new java . lang . StringBuilder ( value ) ; char dash = '-' ; sb . insert ( 8 , dash ) ; sb . insert ( 13 , dash ) ; sb . insert ( 18 , dash ) ; sb . insert ( 23 , dash ) ; return sb . toString ( ) ; }", "testMethod": "whenInputIsNotAtCorrectLengthShouldReturnInputValue ( ) { java . lang . String uuid = de . slackspace . openkeepass . util . StringUtils . convertToUUIDString ( \"abc\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uuid , org . hamcrest . CoreMatchers . is ( \"abc\" ) )", "total": "whenInputIsNotAtCorrectLengthShouldReturnInputValue ( ) { java . lang . String uuid = de . slackspace . openkeepass . util . StringUtils . convertToUUIDString ( \"abc\" ) ; \"<AssertPlaceHolder>\" ; } convertToUUIDString ( java . lang . String ) { if ( ( ( value == null ) || ( value . contains ( \"-\" ) ) ) || ( ( value . length ( ) ) != 32 ) ) { return value ; } java . lang . StringBuilder sb = new java . lang . StringBuilder ( value ) ; char dash = '-' ; sb . insert ( 8 , dash ) ; sb . insert ( 13 , dash ) ; sb . insert ( 18 , dash ) ; sb . insert ( 23 , dash ) ; return sb . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( uuid , org . hamcrest . CoreMatchers . is ( \"abc\" ) )"}
{"focal": "leavesIterator ( ) { return new com . pengyifan . commons . collections . tree . Tree . LeavesIterator ( getThis ( ) ) ; }", "testMethod": "testLeavesIterator ( ) { \"<AssertPlaceHolder>\" ; a . leavesIterator ( ) . remove ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( com . google . common . collect . Lists . newArrayList ( a . leavesIterator ( ) ) , org . hamcrest . CoreMatchers . is ( com . google . common . collect . Lists . newArrayList ( c , f , d , e ) ) )", "total": "testLeavesIterator ( ) { \"<AssertPlaceHolder>\" ; a . leavesIterator ( ) . remove ( ) ; } leavesIterator ( ) { return new com . pengyifan . commons . collections . tree . Tree . LeavesIterator ( getThis ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( com . google . common . collect . Lists . newArrayList ( a . leavesIterator ( ) ) , org . hamcrest . CoreMatchers . is ( com . google . common . collect . Lists . newArrayList ( c , f , d , e ) ) )"}
{"focal": "hasNext ( ) { return ( cursor ) != ( size ) ; }", "testMethod": "whenNextTwoTimesThenHasNextFalse ( ) { linkedSet . add ( 2 ) ; linkedSet . add ( 1 ) ; java . util . Iterator itr = linkedSet . iterator ( ) ; itr . next ( ) ; itr . next ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( itr . hasNext ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "whenNextTwoTimesThenHasNextFalse ( ) { linkedSet . add ( 2 ) ; linkedSet . add ( 1 ) ; java . util . Iterator itr = linkedSet . iterator ( ) ; itr . next ( ) ; itr . next ( ) ; \"<AssertPlaceHolder>\" ; } hasNext ( ) { return ( cursor ) != ( size ) ; }", "answer": "org . junit . Assert . assertThat ( itr . hasNext ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "deleteResource ( java . util . Properties ) { return true ; }", "testMethod": "deleteResource ( ) { com . hotels . plunger . Bucket sink = new com . hotels . plunger . Bucket ( com . hotels . plunger . BucketTest . FIELDS , pipe , flow ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sink . deleteResource ( new java . util . Properties ( ) ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "deleteResource ( ) { com . hotels . plunger . Bucket sink = new com . hotels . plunger . Bucket ( com . hotels . plunger . BucketTest . FIELDS , pipe , flow ) ; \"<AssertPlaceHolder>\" ; } deleteResource ( java . util . Properties ) { return true ; }", "answer": "org . junit . Assert . assertThat ( sink . deleteResource ( new java . util . Properties ( ) ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "get ( ) { try { return this . cm . get ( ) . getInstanceMap ( org . phenotips . vocabulary . Vocabulary . class ) ; } catch ( org . xwiki . component . manager . ComponentLookupException e ) { return java . util . Collections . emptyMap ( ) ; } }", "testMethod": "modulesAreSortedByPriority ( ) { this . moduleList . add ( this . mediumPriorityModule ) ; this . moduleList . add ( this . lowPriorityModule ) ; this . moduleList . add ( this . highPriorityModule ) ; java . util . List < org . phenotips . security . authorization . AuthorizationModule > expectedList = java . util . Arrays . asList ( this . highPriorityModule , this . mediumPriorityModule , this . lowPriorityModule ) ; java . util . List < org . phenotips . security . authorization . AuthorizationModule > actualList = this . mocker . getComponentUnderTest ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualList , org . hamcrest . Matchers . is ( expectedList ) )", "total": "modulesAreSortedByPriority ( ) { this . moduleList . add ( this . mediumPriorityModule ) ; this . moduleList . add ( this . lowPriorityModule ) ; this . moduleList . add ( this . highPriorityModule ) ; java . util . List < org . phenotips . security . authorization . AuthorizationModule > expectedList = java . util . Arrays . asList ( this . highPriorityModule , this . mediumPriorityModule , this . lowPriorityModule ) ; java . util . List < org . phenotips . security . authorization . AuthorizationModule > actualList = this . mocker . getComponentUnderTest ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; } get ( ) { try { return this . cm . get ( ) . getInstanceMap ( org . phenotips . vocabulary . Vocabulary . class ) ; } catch ( org . xwiki . component . manager . ComponentLookupException e ) { return java . util . Collections . emptyMap ( ) ; } }", "answer": "org . junit . Assert . assertThat ( actualList , org . hamcrest . Matchers . is ( expectedList ) )"}
{"focal": "is ( com . fundynamic . d2tm . game . entities . Entity ) { return ( com . fundynamic . d2tm . game . entities . NullEntity . INSTANCE . equals ( entity ) ) || ( entity instanceof com . fundynamic . d2tm . game . entities . NullEntity ) ; }", "testMethod": "getCenteredCoordinateOfEntity ( ) { int widthInPixels = 96 ; int heightInPixels = 96 ; com . fundynamic . d2tm . game . types . EntityData entityData = new com . fundynamic . d2tm . game . types . EntityData ( ) ; entityData . type = EntityType . STRUCTURE ; entityData . setWidth ( widthInPixels ) ; entityData . setHeight ( heightInPixels ) ; com . fundynamic . d2tm . math . Coordinate topLeftCoordinate = com . fundynamic . d2tm . math . Coordinate . create ( 160 , 224 ) ; com . fundynamic . d2tm . game . entities . Entity entity = new com . fundynamic . d2tm . game . entities . TestableEntity ( topLeftCoordinate , mock ( org . newdawn . slick . SpriteSheet . class ) , entityData , player , entityRepository ) . setName ( \"Refinery\" ) ; com . fundynamic . d2tm . math . Coordinate expectedCenteredCoordinate = com . fundynamic . d2tm . math . Coordinate . create ( ( ( topLeftCoordinate . getXAsInt ( ) ) + ( widthInPixels / 2 ) ) , ( ( topLeftCoordinate . getYAsInt ( ) ) + ( heightInPixels / 2 ) ) ) ; com . fundynamic . d2tm . math . Coordinate centeredCoordinateOfEntity = entity . getCenteredCoordinate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( centeredCoordinateOfEntity , org . hamcrest . core . Is . is ( expectedCenteredCoordinate ) )", "total": "getCenteredCoordinateOfEntity ( ) { int widthInPixels = 96 ; int heightInPixels = 96 ; com . fundynamic . d2tm . game . types . EntityData entityData = new com . fundynamic . d2tm . game . types . EntityData ( ) ; entityData . type = EntityType . STRUCTURE ; entityData . setWidth ( widthInPixels ) ; entityData . setHeight ( heightInPixels ) ; com . fundynamic . d2tm . math . Coordinate topLeftCoordinate = com . fundynamic . d2tm . math . Coordinate . create ( 160 , 224 ) ; com . fundynamic . d2tm . game . entities . Entity entity = new com . fundynamic . d2tm . game . entities . TestableEntity ( topLeftCoordinate , mock ( org . newdawn . slick . SpriteSheet . class ) , entityData , player , entityRepository ) . setName ( \"Refinery\" ) ; com . fundynamic . d2tm . math . Coordinate expectedCenteredCoordinate = com . fundynamic . d2tm . math . Coordinate . create ( ( ( topLeftCoordinate . getXAsInt ( ) ) + ( widthInPixels / 2 ) ) , ( ( topLeftCoordinate . getYAsInt ( ) ) + ( heightInPixels / 2 ) ) ) ; com . fundynamic . d2tm . math . Coordinate centeredCoordinateOfEntity = entity . getCenteredCoordinate ( ) ; \"<AssertPlaceHolder>\" ; } is ( com . fundynamic . d2tm . game . entities . Entity ) { return ( com . fundynamic . d2tm . game . entities . NullEntity . INSTANCE . equals ( entity ) ) || ( entity instanceof com . fundynamic . d2tm . game . entities . NullEntity ) ; }", "answer": "org . junit . Assert . assertThat ( centeredCoordinateOfEntity , org . hamcrest . core . Is . is ( expectedCenteredCoordinate ) )"}
{"focal": "countCrossingsBetweenLayers ( org . eclipse . elk . alg . layered . graph . LNode [ ] , org . eclipse . elk . alg . layered . graph . LNode [ ] ) { java . util . List < org . eclipse . elk . alg . layered . graph . LPort > ports = initPortPositionsCounterClockwise ( leftLayerNodes , rightLayerNodes ) ; indexTree = new org . eclipse . elk . alg . layered . p3order . counting . BinaryIndexedTree ( ports . size ( ) ) ; return countCrossingsOnPorts ( ports ) ; }", "testMethod": "countCrossingsBetweenLayers_fixedPortOrder ( ) { getFixedPortOrderGraph ( ) ; counter = new org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter ( new int [ getNumPorts ( order ( ) ) ] ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( counter . countCrossingsBetweenLayers ( order ( ) [ 0 ] , order ( ) [ 1 ] ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "countCrossingsBetweenLayers_fixedPortOrder ( ) { getFixedPortOrderGraph ( ) ; counter = new org . eclipse . elk . alg . layered . p3order . counting . CrossingsCounter ( new int [ getNumPorts ( order ( ) ) ] ) ; \"<AssertPlaceHolder>\" ; } countCrossingsBetweenLayers ( org . eclipse . elk . alg . layered . graph . LNode [ ] , org . eclipse . elk . alg . layered . graph . LNode [ ] ) { java . util . List < org . eclipse . elk . alg . layered . graph . LPort > ports = initPortPositionsCounterClockwise ( leftLayerNodes , rightLayerNodes ) ; indexTree = new org . eclipse . elk . alg . layered . p3order . counting . BinaryIndexedTree ( ports . size ( ) ) ; return countCrossingsOnPorts ( ports ) ; }", "answer": "org . junit . Assert . assertThat ( counter . countCrossingsBetweenLayers ( order ( ) [ 0 ] , order ( ) [ 1 ] ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "localeChain ( java . util . Locale ) { if ( Locale . ENGLISH . equals ( from ) ) { return java . util . Collections . singletonList ( Locale . ENGLISH ) ; } final java . util . Locale normalized = normalizeLocale ( from ) ; final java . util . List < java . util . Locale > chain = new java . util . ArrayList < java . util . Locale > ( 3 ) ; chain . add ( normalized ) ; if ( ( ! ( \"\" . equals ( normalized . getCountry ( ) ) ) ) && ( ! ( Locale . ENGLISH . getLanguage ( ) . equals ( normalized . getLanguage ( ) ) ) ) ) { chain . add ( new java . util . Locale ( normalized . getLanguage ( ) ) ) ; } chain . add ( Locale . ENGLISH ) ; return chain ; }", "testMethod": "testLocaleChainLanguageOnly ( ) { final java . util . List < java . util . Locale > chain = fakeValuesService . localeChain ( Locale . CHINESE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chain , contains ( Locale . CHINESE , Locale . ENGLISH ) )", "total": "testLocaleChainLanguageOnly ( ) { final java . util . List < java . util . Locale > chain = fakeValuesService . localeChain ( Locale . CHINESE ) ; \"<AssertPlaceHolder>\" ; } localeChain ( java . util . Locale ) { if ( Locale . ENGLISH . equals ( from ) ) { return java . util . Collections . singletonList ( Locale . ENGLISH ) ; } final java . util . Locale normalized = normalizeLocale ( from ) ; final java . util . List < java . util . Locale > chain = new java . util . ArrayList < java . util . Locale > ( 3 ) ; chain . add ( normalized ) ; if ( ( ! ( \"\" . equals ( normalized . getCountry ( ) ) ) ) && ( ! ( Locale . ENGLISH . getLanguage ( ) . equals ( normalized . getLanguage ( ) ) ) ) ) { chain . add ( new java . util . Locale ( normalized . getLanguage ( ) ) ) ; } chain . add ( Locale . ENGLISH ) ; return chain ; }", "answer": "org . junit . Assert . assertThat ( chain , contains ( Locale . CHINESE , Locale . ENGLISH ) )"}
{"focal": "count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "testMethod": "testQueryByTasksWithoutTenantId ( ) { org . camunda . bpm . engine . task . TaskQuery query = taskService . createTaskQuery ( ) . withoutTenantId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "testQueryByTasksWithoutTenantId ( ) { org . camunda . bpm . engine . task . TaskQuery query = taskService . createTaskQuery ( ) . withoutTenantId ( ) ; \"<AssertPlaceHolder>\" ; } count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "get ( ) { if ( ( registry ) == null ) { registry = createRegistry ( ) ; } return registry ; }", "testMethod": "assertItemRegistryIsThreadSafe ( ) { java . util . concurrent . atomic . AtomicInteger numberOfSuccessfulGetItemCalls = new java . util . concurrent . atomic . AtomicInteger ( 0 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { new java . lang . Thread ( ( ) -> { for ( int j = 0 ; j < 10 ; j ++ ) { try { itemRegistry . getItem ( org . eclipse . smarthome . core . items . ItemRegistryImplTest . ITEM_NAME ) ; numberOfSuccessfulGetItemCalls . incrementAndGet ( ) ; } catch ( e ) { } } } ) . start ( ) ; } waitFor ( ( ) -> ( numberOfSuccessfulGetItemCalls . get ( ) ) >= 100 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( numberOfSuccessfulGetItemCalls . get ( ) , org . hamcrest . CoreMatchers . is ( 100 ) )", "total": "assertItemRegistryIsThreadSafe ( ) { java . util . concurrent . atomic . AtomicInteger numberOfSuccessfulGetItemCalls = new java . util . concurrent . atomic . AtomicInteger ( 0 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { new java . lang . Thread ( ( ) -> { for ( int j = 0 ; j < 10 ; j ++ ) { try { itemRegistry . getItem ( org . eclipse . smarthome . core . items . ItemRegistryImplTest . ITEM_NAME ) ; numberOfSuccessfulGetItemCalls . incrementAndGet ( ) ; } catch ( e ) { } } } ) . start ( ) ; } waitFor ( ( ) -> ( numberOfSuccessfulGetItemCalls . get ( ) ) >= 100 ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( ( registry ) == null ) { registry = createRegistry ( ) ; } return registry ; }", "answer": "org . junit . Assert . assertThat ( numberOfSuccessfulGetItemCalls . get ( ) , org . hamcrest . CoreMatchers . is ( 100 ) )"}
{"focal": "getSheetName ( ) { return sheet . getName ( ) ; }", "testMethod": "shouldGetAndReturnNameOfTheSheet ( ) { when ( sheet . getName ( ) ) . thenReturn ( \"testing123\" ) ; java . lang . String name = rowSetMetaData . getSheetName ( ) ; \"<AssertPlaceHolder>\" ; verify ( sheet , times ( 1 ) ) . getName ( ) ; verifyNoMoreInteractions ( sheet ) ; }", "assertLine": "org . junit . Assert . assertThat ( name , org . hamcrest . Matchers . is ( \"testing123\" ) )", "total": "shouldGetAndReturnNameOfTheSheet ( ) { when ( sheet . getName ( ) ) . thenReturn ( \"testing123\" ) ; java . lang . String name = rowSetMetaData . getSheetName ( ) ; \"<AssertPlaceHolder>\" ; verify ( sheet , times ( 1 ) ) . getName ( ) ; verifyNoMoreInteractions ( sheet ) ; } getSheetName ( ) { return sheet . getName ( ) ; }", "answer": "org . junit . Assert . assertThat ( name , org . hamcrest . Matchers . is ( \"testing123\" ) )"}
{"focal": "size ( ) { return fieldErrors . size ( ) ; }", "testMethod": "shouldReturnPrincipalAndInterestDetailsForMatchingNumberOfInstallments_larger ( ) { org . mifos . clientportfolio . newloan . domain . LoanInterestCalculationDetails loanInterestCalculationDetails = new org . mifos . clientportfolio . newloan . domain . LoanInterestCalculationDetailsBuilder ( ) . withLoanAmount ( \"100.0\" ) . withGraceType ( GraceType . NONE ) . withGraceDurationOf ( 0 ) . withNumberOfInstallments ( 20 ) . withInterestFractionalRatePerInstallmentOf ( \"0.16\" ) . build ( ) ; java . util . List < org . mifos . accounts . loan . util . helpers . InstallmentPrincipalAndInterest > equalInstallments = principalWithInterestGenerator . generateEqualInstallments ( loanInterestCalculationDetails ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( equalInstallments . size ( ) , org . hamcrest . Matchers . is ( 20 ) )", "total": "shouldReturnPrincipalAndInterestDetailsForMatchingNumberOfInstallments_larger ( ) { org . mifos . clientportfolio . newloan . domain . LoanInterestCalculationDetails loanInterestCalculationDetails = new org . mifos . clientportfolio . newloan . domain . LoanInterestCalculationDetailsBuilder ( ) . withLoanAmount ( \"100.0\" ) . withGraceType ( GraceType . NONE ) . withGraceDurationOf ( 0 ) . withNumberOfInstallments ( 20 ) . withInterestFractionalRatePerInstallmentOf ( \"0.16\" ) . build ( ) ; java . util . List < org . mifos . accounts . loan . util . helpers . InstallmentPrincipalAndInterest > equalInstallments = principalWithInterestGenerator . generateEqualInstallments ( loanInterestCalculationDetails ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return fieldErrors . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( equalInstallments . size ( ) , org . hamcrest . Matchers . is ( 20 ) )"}
{"focal": "getList ( ) { return list ; }", "testMethod": "testAdd03 ( ) { org . terasoluna . gfw . common . message . ResultMessage msg1 = org . terasoluna . gfw . common . message . ResultMessage . fromText ( \"foo\" ) ; org . terasoluna . gfw . common . message . ResultMessage msg2 = org . terasoluna . gfw . common . message . ResultMessage . fromText ( \"bar\" ) ; org . terasoluna . gfw . common . message . ResultMessages messages = new org . terasoluna . gfw . common . message . ResultMessages ( ( ( org . terasoluna . gfw . common . message . ResultMessageType ) ( ERROR ) ) , msg1 ) ; messages . add ( msg2 ) ; \"<AssertPlaceHolder>\" ; System . out . println ( messages ) ; }", "assertLine": "org . junit . Assert . assertThat ( messages . getList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( msg1 , msg2 ) ) )", "total": "testAdd03 ( ) { org . terasoluna . gfw . common . message . ResultMessage msg1 = org . terasoluna . gfw . common . message . ResultMessage . fromText ( \"foo\" ) ; org . terasoluna . gfw . common . message . ResultMessage msg2 = org . terasoluna . gfw . common . message . ResultMessage . fromText ( \"bar\" ) ; org . terasoluna . gfw . common . message . ResultMessages messages = new org . terasoluna . gfw . common . message . ResultMessages ( ( ( org . terasoluna . gfw . common . message . ResultMessageType ) ( ERROR ) ) , msg1 ) ; messages . add ( msg2 ) ; \"<AssertPlaceHolder>\" ; System . out . println ( messages ) ; } getList ( ) { return list ; }", "answer": "org . junit . Assert . assertThat ( messages . getList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( msg1 , msg2 ) ) )"}
{"focal": "run ( ) { return runResult ( ) . get ( ) ; }", "testMethod": "exitValue ( ) { commandHandler = ( com . fizzed . blaze . ssh . SshCommand command ) -> { if ( command . line . equals ( \"hello\" ) ) { command . out . println ( \"Hello<sp>World!\" ) ; command . exit . onExit ( 0 ) ; } else { command . exit . onExit ( 1 ) ; } } ; com . fizzed . blaze . ssh . SshSession session = startAndConnect ( ) ; java . lang . Integer exitValue = new com . fizzed . blaze . ssh . impl . JschExec ( context , session ) . command ( \"hello\" ) . run ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( exitValue , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "exitValue ( ) { commandHandler = ( com . fizzed . blaze . ssh . SshCommand command ) -> { if ( command . line . equals ( \"hello\" ) ) { command . out . println ( \"Hello<sp>World!\" ) ; command . exit . onExit ( 0 ) ; } else { command . exit . onExit ( 1 ) ; } } ; com . fizzed . blaze . ssh . SshSession session = startAndConnect ( ) ; java . lang . Integer exitValue = new com . fizzed . blaze . ssh . impl . JschExec ( context , session ) . command ( \"hello\" ) . run ( ) ; \"<AssertPlaceHolder>\" ; } run ( ) { return runResult ( ) . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( exitValue , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getGraphDb ( ) { if ( ( graphDb ) == null ) { graphDb = new org . neo4j . test . TestGraphDatabaseFactory ( ) . newImpermanentDatabase ( ) ; } return graphDb ; }", "testMethod": "importHechingers ( ) { java . lang . String [ ] datasetsUsingHechingerFormat = new java . lang . String [ ] { \"thieltges2011\" , \"preston2012\" , \"zander2011\" , \"mouritsen2011\" } ; int studyCount = 0 ; for ( java . lang . String dataset : datasetsUsingHechingerFormat ) { try { org . eol . globi . data . StudyImporterForRegistry importer = createImporter ( ) ; importer . importData ( ( \"globalbioticinteractions/\" + dataset ) ) ; java . util . List < org . eol . globi . domain . StudyNode > allStudies = org . eol . globi . util . NodeUtil . findAllStudies ( getGraphDb ( ) ) ; \"<AssertPlaceHolder>\" ; studyCount += 1 ; } catch ( java . lang . Exception e ) { throw new java . lang . Exception ( ( ( \"failed<sp>to<sp>import<sp>[\" + dataset ) + \"]\" ) , e ) ; } } }", "assertLine": "org . junit . Assert . assertThat ( allStudies . size ( ) , org . hamcrest . core . Is . is ( ( studyCount + 1 ) ) )", "total": "importHechingers ( ) { java . lang . String [ ] datasetsUsingHechingerFormat = new java . lang . String [ ] { \"thieltges2011\" , \"preston2012\" , \"zander2011\" , \"mouritsen2011\" } ; int studyCount = 0 ; for ( java . lang . String dataset : datasetsUsingHechingerFormat ) { try { org . eol . globi . data . StudyImporterForRegistry importer = createImporter ( ) ; importer . importData ( ( \"globalbioticinteractions/\" + dataset ) ) ; java . util . List < org . eol . globi . domain . StudyNode > allStudies = org . eol . globi . util . NodeUtil . findAllStudies ( getGraphDb ( ) ) ; \"<AssertPlaceHolder>\" ; studyCount += 1 ; } catch ( java . lang . Exception e ) { throw new java . lang . Exception ( ( ( \"failed<sp>to<sp>import<sp>[\" + dataset ) + \"]\" ) , e ) ; } } } getGraphDb ( ) { if ( ( graphDb ) == null ) { graphDb = new org . neo4j . test . TestGraphDatabaseFactory ( ) . newImpermanentDatabase ( ) ; } return graphDb ; }", "answer": "org . junit . Assert . assertThat ( allStudies . size ( ) , org . hamcrest . core . Is . is ( ( studyCount + 1 ) ) )"}
{"focal": "equalTo ( java . util . Collection ) { return new org . mule . tck . util . EnumerationMatcher ( items ) ; }", "testMethod": "customExceptionHandler ( ) { final java . lang . String customHandler = \"custom\" ; java . lang . System . setProperty ( org . mule . runtime . module . launcher . log4j2 . MuleLog4jContextFactoryTestCase . ASYNC_LOGGER_EXCEPTION_HANDLER_PROPERTY , customHandler ) ; new org . mule . runtime . module . launcher . log4j2 . MuleLog4jContextFactory ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( customHandler , org . hamcrest . CoreMatchers . equalTo ( java . lang . System . getProperty ( org . mule . runtime . module . launcher . log4j2 . MuleLog4jContextFactoryTestCase . ASYNC_LOGGER_EXCEPTION_HANDLER_PROPERTY ) ) )", "total": "customExceptionHandler ( ) { final java . lang . String customHandler = \"custom\" ; java . lang . System . setProperty ( org . mule . runtime . module . launcher . log4j2 . MuleLog4jContextFactoryTestCase . ASYNC_LOGGER_EXCEPTION_HANDLER_PROPERTY , customHandler ) ; new org . mule . runtime . module . launcher . log4j2 . MuleLog4jContextFactory ( ) ; \"<AssertPlaceHolder>\" ; } equalTo ( java . util . Collection ) { return new org . mule . tck . util . EnumerationMatcher ( items ) ; }", "answer": "org . junit . Assert . assertThat ( customHandler , org . hamcrest . CoreMatchers . equalTo ( java . lang . System . getProperty ( org . mule . runtime . module . launcher . log4j2 . MuleLog4jContextFactoryTestCase . ASYNC_LOGGER_EXCEPTION_HANDLER_PROPERTY ) ) )"}
{"focal": "get ( ) { return widgets ; }", "testMethod": "booleanToRadioGroupSetsOnFalse ( ) { final org . tessell . tests . model . dsl . StubRadioButton b1 = new org . tessell . tests . model . dsl . StubRadioButton ( ) ; final org . tessell . tests . model . dsl . StubRadioButton b2 = new org . tessell . tests . model . dsl . StubRadioButton ( ) ; final org . tessell . tests . model . dsl . BooleanProperty b = booleanProperty ( \"b\" , true ) ; binder . bind ( b ) . to ( b1 , b2 ) ; b2 . click ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( b . get ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "booleanToRadioGroupSetsOnFalse ( ) { final org . tessell . tests . model . dsl . StubRadioButton b1 = new org . tessell . tests . model . dsl . StubRadioButton ( ) ; final org . tessell . tests . model . dsl . StubRadioButton b2 = new org . tessell . tests . model . dsl . StubRadioButton ( ) ; final org . tessell . tests . model . dsl . BooleanProperty b = booleanProperty ( \"b\" , true ) ; binder . bind ( b ) . to ( b1 , b2 ) ; b2 . click ( ) ; \"<AssertPlaceHolder>\" ; } get ( ) { return widgets ; }", "answer": "org . junit . Assert . assertThat ( b . get ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "hasParameter ( java . lang . String ) { return parameters . containsKey ( parameterName ) ; }", "testMethod": "getNonExistentParameter ( ) { \"<AssertPlaceHolder>\" ; operationContext . getParameter ( ( ( org . mule . runtime . module . extension . internal . runtime . DefaultExecutionContextTestCase . PARAM_NAME ) + \"_\" ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( operationContext . hasParameter ( ( ( org . mule . runtime . module . extension . internal . runtime . DefaultExecutionContextTestCase . PARAM_NAME ) + \"_\" ) ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "getNonExistentParameter ( ) { \"<AssertPlaceHolder>\" ; operationContext . getParameter ( ( ( org . mule . runtime . module . extension . internal . runtime . DefaultExecutionContextTestCase . PARAM_NAME ) + \"_\" ) ) ; } hasParameter ( java . lang . String ) { return parameters . containsKey ( parameterName ) ; }", "answer": "org . junit . Assert . assertThat ( operationContext . hasParameter ( ( ( org . mule . runtime . module . extension . internal . runtime . DefaultExecutionContextTestCase . PARAM_NAME ) + \"_\" ) ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "testMethod": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>source<sp>|<sp>rstrip<sp>}}\" , \"\" , \"{<sp>\\\"source\\\":<sp>null<sp>}\" } , new java . lang . String [ ] { \"{{<sp>source<sp>|<sp>rstrip<sp>}}\" , \"<sp>ab<sp>c\" , \"{<sp>\\\"source\\\":<sp>\\\"<sp>ab<sp>c<sp>\\\"<sp>}\" } , new java . lang . String [ ] { \"{{<sp>source<sp>|<sp>rstrip<sp>}}\" , \"<sp>\\tab<sp>c\" , \"{<sp>\\\"source\\\":<sp>\\\"<sp>\\\\tab<sp>c<sp>\\\\n<sp>\\\\t\\\"<sp>}\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( test [ 2 ] ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>source<sp>|<sp>rstrip<sp>}}\" , \"\" , \"{<sp>\\\"source\\\":<sp>null<sp>}\" } , new java . lang . String [ ] { \"{{<sp>source<sp>|<sp>rstrip<sp>}}\" , \"<sp>ab<sp>c\" , \"{<sp>\\\"source\\\":<sp>\\\"<sp>ab<sp>c<sp>\\\"<sp>}\" } , new java . lang . String [ ] { \"{{<sp>source<sp>|<sp>rstrip<sp>}}\" , \"<sp>\\tab<sp>c\" , \"{<sp>\\\"source\\\":<sp>\\\"<sp>\\\\tab<sp>c<sp>\\\\n<sp>\\\\t\\\"<sp>}\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( test [ 2 ] ) ) ; \"<AssertPlaceHolder>\" ; } } render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . StarRemovedEvent event = new com . github . seratch . jslack . api . model . event . StarRemovedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"star_removed\\\"}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . StarRemovedEvent event = new com . github . seratch . jslack . api . model . event . StarRemovedEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"star_removed\\\"}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testIsOpaqueEnabled ( ) { result2 = org . onosproject . ospf . protocol . util . OspfUtil . isOpaqueEnabled ( 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testIsOpaqueEnabled ( ) { result2 = org . onosproject . ospf . protocol . util . OspfUtil . isOpaqueEnabled ( 2 ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testCreateVtapNetworkWithCreateOperation ( ) { expect ( mockVtapService . createVtapNetwork ( anyObject ( ) , anyObject ( ) , anyObject ( ) ) ) . andReturn ( vtapNetwork ) . once ( ) ; replay ( mockVtapService ) ; final javax . ws . rs . client . WebTarget wt = target ( ) ; java . io . InputStream jsonStream = org . onosproject . openstackvtap . web . OpenstackVtapNetworkWebResourceTest . class . getResourceAsStream ( \"openstack-vtap-config.json\" ) ; javax . ws . rs . core . Response response = wt . path ( org . onosproject . openstackvtap . web . OpenstackVtapNetworkWebResourceTest . PATH ) . request ( MediaType . APPLICATION_JSON_TYPE ) . post ( javax . ws . rs . client . Entity . json ( jsonStream ) ) ; final int status = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; verify ( mockVtapService ) ; }", "assertLine": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( 200 ) )", "total": "testCreateVtapNetworkWithCreateOperation ( ) { expect ( mockVtapService . createVtapNetwork ( anyObject ( ) , anyObject ( ) , anyObject ( ) ) ) . andReturn ( vtapNetwork ) . once ( ) ; replay ( mockVtapService ) ; final javax . ws . rs . client . WebTarget wt = target ( ) ; java . io . InputStream jsonStream = org . onosproject . openstackvtap . web . OpenstackVtapNetworkWebResourceTest . class . getResourceAsStream ( \"openstack-vtap-config.json\" ) ; javax . ws . rs . core . Response response = wt . path ( org . onosproject . openstackvtap . web . OpenstackVtapNetworkWebResourceTest . PATH ) . request ( MediaType . APPLICATION_JSON_TYPE ) . post ( javax . ws . rs . client . Entity . json ( jsonStream ) ) ; final int status = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; verify ( mockVtapService ) ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( 200 ) )"}
{"focal": "load ( ) { java . io . InputStreamReader reader = null ; try { reader = new java . io . InputStreamReader ( loader . getInput ( ) ) ; java . lang . StringBuilder str = new java . lang . StringBuilder ( ) ; char [ ] buf = new char [ 512 ] ; for ( ; ; ) { int len = reader . read ( buf ) ; if ( len == ( - 1 ) ) break ; str . append ( new java . lang . String ( buf , 0 , len ) ) ; } return str . toString ( ) ; } finally { if ( reader != null ) reader . close ( ) ; } }", "testMethod": "load ( ) { java . lang . String expected = \"Hello<sp>World\" ; ch20 . ex03 . NetworkLoader mockLoader = mock ( ch20 . ex03 . NetworkLoader . class ) ; when ( mockLoader . getInput ( ) ) . thenReturn ( new java . io . ByteArrayInputStream ( expected . getBytes ( ) ) ) ; ch20 . ex03 . NetworkResources sut = new ch20 . ex03 . NetworkResources ( ) ; sut . loader = mockLoader ; java . lang . String actual = sut . load ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "load ( ) { java . lang . String expected = \"Hello<sp>World\" ; ch20 . ex03 . NetworkLoader mockLoader = mock ( ch20 . ex03 . NetworkLoader . class ) ; when ( mockLoader . getInput ( ) ) . thenReturn ( new java . io . ByteArrayInputStream ( expected . getBytes ( ) ) ) ; ch20 . ex03 . NetworkResources sut = new ch20 . ex03 . NetworkResources ( ) ; sut . loader = mockLoader ; java . lang . String actual = sut . load ( ) ; \"<AssertPlaceHolder>\" ; } load ( ) { java . io . InputStreamReader reader = null ; try { reader = new java . io . InputStreamReader ( loader . getInput ( ) ) ; java . lang . StringBuilder str = new java . lang . StringBuilder ( ) ; char [ ] buf = new char [ 512 ] ; for ( ; ; ) { int len = reader . read ( buf ) ; if ( len == ( - 1 ) ) break ; str . append ( new java . lang . String ( buf , 0 , len ) ) ; } return str . toString ( ) ; } finally { if ( reader != null ) reader . close ( ) ; } }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "is ( java . lang . reflect . Type ) { return org . apache . calcite . linq4j . tree . Primitive . PRIMITIVE_MAP . containsKey ( type ) ; }", "testMethod": "testUserDefinedFunctionInstanceCount ( ) { final java . lang . String sql = \"select<sp>\\\"adhoc\\\".my_det_plus(\\\"deptno\\\",<sp>100)<sp>as<sp>p\\n\" + \"from<sp>\\\"adhoc\\\".EMPLOYEES\" ; final java . util . concurrent . atomic . AtomicInteger c = Smalls . MyDeterministicPlusFunction . INSTANCE_COUNT ; final int before = c . get ( ) ; withUdf ( ) . query ( sql ) . returnsUnordered ( \"P=110\" , \"P=120\" , \"P=110\" , \"P=110\" ) ; final int after = c . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( after , org . hamcrest . CoreMatchers . is ( ( before + 1 ) ) )", "total": "testUserDefinedFunctionInstanceCount ( ) { final java . lang . String sql = \"select<sp>\\\"adhoc\\\".my_det_plus(\\\"deptno\\\",<sp>100)<sp>as<sp>p\\n\" + \"from<sp>\\\"adhoc\\\".EMPLOYEES\" ; final java . util . concurrent . atomic . AtomicInteger c = Smalls . MyDeterministicPlusFunction . INSTANCE_COUNT ; final int before = c . get ( ) ; withUdf ( ) . query ( sql ) . returnsUnordered ( \"P=110\" , \"P=120\" , \"P=110\" , \"P=110\" ) ; final int after = c . get ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . reflect . Type ) { return org . apache . calcite . linq4j . tree . Primitive . PRIMITIVE_MAP . containsKey ( type ) ; }", "answer": "org . junit . Assert . assertThat ( after , org . hamcrest . CoreMatchers . is ( ( before + 1 ) ) )"}
{"focal": "serialize ( T ) { if ( t == null ) { return new byte [ 0 ] ; } try { return com . alibaba . fastjson . JSON . toJSONBytes ( fastJsonConfig . getCharset ( ) , t , fastJsonConfig . getSerializeConfig ( ) , fastJsonConfig . getSerializeFilters ( ) , fastJsonConfig . getDateFormat ( ) , JSON . DEFAULT_GENERATE_FEATURE , fastJsonConfig . getSerializerFeatures ( ) ) ; } catch ( java . lang . Exception ex ) { throw new org . springframework . data . redis . serializer . SerializationException ( ( \"Could<sp>not<sp>serialize:<sp>\" + ( ex . getMessage ( ) ) ) , ex ) ; } }", "testMethod": "test_2 ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serializer . serialize ( null ) , org . hamcrest . core . Is . is ( new byte [ 0 ] ) )", "total": "test_2 ( ) { \"<AssertPlaceHolder>\" ; } serialize ( T ) { if ( t == null ) { return new byte [ 0 ] ; } try { return com . alibaba . fastjson . JSON . toJSONBytes ( fastJsonConfig . getCharset ( ) , t , fastJsonConfig . getSerializeConfig ( ) , fastJsonConfig . getSerializeFilters ( ) , fastJsonConfig . getDateFormat ( ) , JSON . DEFAULT_GENERATE_FEATURE , fastJsonConfig . getSerializerFeatures ( ) ) ; } catch ( java . lang . Exception ex ) { throw new org . springframework . data . redis . serializer . SerializationException ( ( \"Could<sp>not<sp>serialize:<sp>\" + ( ex . getMessage ( ) ) ) , ex ) ; } }", "answer": "org . junit . Assert . assertThat ( serializer . serialize ( null ) , org . hamcrest . core . Is . is ( new byte [ 0 ] ) )"}
{"focal": "trimAll ( java . lang . String ) { if ( src == null ) { return null ; } return src . replaceFirst ( \"@interface\" , \"interface\" ) . replaceAll ( \"@[^\\\\s\\r\\n\\\\(]+(\\\\([^\\\\)]*\\\\))*\" , \"<sp>\" ) . replaceAll ( \"@[^\\\\s\\r\\n]+\" , \"\" ) ; }", "testMethod": "trimAll_A$String_StringIsEmpty ( ) { org . junithelper . core . filter . impl . TrimInsideOfBraceFilter target = new org . junithelper . core . filter . impl . TrimInsideOfBraceFilter ( ) ; java . lang . String src = \"\" ; java . lang . String actual = target . trimAll ( src ) ; java . lang . String expected = \"\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , is ( equalTo ( expected ) ) )", "total": "trimAll_A$String_StringIsEmpty ( ) { org . junithelper . core . filter . impl . TrimInsideOfBraceFilter target = new org . junithelper . core . filter . impl . TrimInsideOfBraceFilter ( ) ; java . lang . String src = \"\" ; java . lang . String actual = target . trimAll ( src ) ; java . lang . String expected = \"\" ; \"<AssertPlaceHolder>\" ; } trimAll ( java . lang . String ) { if ( src == null ) { return null ; } return src . replaceFirst ( \"@interface\" , \"interface\" ) . replaceAll ( \"@[^\\\\s\\r\\n\\\\(]+(\\\\([^\\\\)]*\\\\))*\" , \"<sp>\" ) . replaceAll ( \"@[^\\\\s\\r\\n]+\" , \"\" ) ; }", "answer": "org . junit . Assert . assertThat ( actual , is ( equalTo ( expected ) ) )"}
{"focal": "onConnectionChangedAddedPre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = true ; } if ( exist ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "testMethod": "testOnConnectionChangedAddedPreWithAggTypeError ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"original\" , \"initializing\" , \"logic_id\" , \"add\" 2 ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"add\" 0 , \"running\" , \"logic_id\" , \"add\" 2 ) ) ; when ( curr . getObjectType ( ) ) . thenReturn ( \"add\" 1 ) ; when ( curr . getConnectionType ( ) ) . thenReturn ( \"AGGREGATED\" ) ; when ( target . getObjectId ( ) ) . thenReturn ( \"ComponentConnectionLogicAndNetwork.LOGIC_ID\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"add\" , prev , curr ) ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( true ) . when ( conversionTable , \"isConnectionType\" , \"AGGREGATED\" ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . onConnectionChangedAddedPre ( msg ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testOnConnectionChangedAddedPreWithAggTypeError ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"original\" , \"initializing\" , \"logic_id\" , \"add\" 2 ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"add\" 0 , \"running\" , \"logic_id\" , \"add\" 2 ) ) ; when ( curr . getObjectType ( ) ) . thenReturn ( \"add\" 1 ) ; when ( curr . getConnectionType ( ) ) . thenReturn ( \"AGGREGATED\" ) ; when ( target . getObjectId ( ) ) . thenReturn ( \"ComponentConnectionLogicAndNetwork.LOGIC_ID\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"add\" , prev , curr ) ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( true ) . when ( conversionTable , \"isConnectionType\" , \"AGGREGATED\" ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; } onConnectionChangedAddedPre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = true ; } if ( exist ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . onConnectionChangedAddedPre ( msg ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "toInteger ( java . lang . Object ) { java . util . Objects . requireNonNull ( object , \"Object<sp>cannot<sp>be<sp>null\" ) ; if ( object instanceof java . lang . Integer ) { return ( ( java . lang . Integer ) ( object ) ) ; } if ( object instanceof java . lang . Number ) { return ( ( java . lang . Number ) ( object ) ) . intValue ( ) ; } if ( object instanceof java . lang . String ) { try { return java . lang . Integer . parseInt ( ( ( java . lang . String ) ( object ) ) ) ; } catch ( final java . lang . NumberFormatException e ) { throw new io . confluent . ksql . util . KsqlException ( ( ( \"Cannot<sp>convert<sp>\" + object ) + \"<sp>to<sp>INT.\" ) , e ) ; } } throw new java . lang . IllegalArgumentException ( \"This<sp>Object<sp>doesn't<sp>represent<sp>an<sp>int\" ) ; }", "testMethod": "shouldConvertLongToIntCorrectly ( ) { final java . lang . Integer i = io . confluent . ksql . serde . util . SerdeUtils . toInteger ( 1L ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( i , org . hamcrest . CoreMatchers . equalTo ( 1 ) )", "total": "shouldConvertLongToIntCorrectly ( ) { final java . lang . Integer i = io . confluent . ksql . serde . util . SerdeUtils . toInteger ( 1L ) ; \"<AssertPlaceHolder>\" ; } toInteger ( java . lang . Object ) { java . util . Objects . requireNonNull ( object , \"Object<sp>cannot<sp>be<sp>null\" ) ; if ( object instanceof java . lang . Integer ) { return ( ( java . lang . Integer ) ( object ) ) ; } if ( object instanceof java . lang . Number ) { return ( ( java . lang . Number ) ( object ) ) . intValue ( ) ; } if ( object instanceof java . lang . String ) { try { return java . lang . Integer . parseInt ( ( ( java . lang . String ) ( object ) ) ) ; } catch ( final java . lang . NumberFormatException e ) { throw new io . confluent . ksql . util . KsqlException ( ( ( \"Cannot<sp>convert<sp>\" + object ) + \"<sp>to<sp>INT.\" ) , e ) ; } } throw new java . lang . IllegalArgumentException ( \"This<sp>Object<sp>doesn't<sp>represent<sp>an<sp>int\" ) ; }", "answer": "org . junit . Assert . assertThat ( i , org . hamcrest . CoreMatchers . equalTo ( 1 ) )"}
{"focal": "getBytes ( ) { return this . body ; }", "testMethod": "constructorSavesBody ( ) { final byte [ ] body = new byte [ ] { 1 , 2 , 3 } ; com . microsoft . azure . sdk . iot . device . Message msg = new com . microsoft . azure . sdk . iot . device . Message ( body ) ; byte [ ] testBody = msg . getBytes ( ) ; byte [ ] expectedBody = body ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testBody , org . hamcrest . CoreMatchers . is ( expectedBody ) )", "total": "constructorSavesBody ( ) { final byte [ ] body = new byte [ ] { 1 , 2 , 3 } ; com . microsoft . azure . sdk . iot . device . Message msg = new com . microsoft . azure . sdk . iot . device . Message ( body ) ; byte [ ] testBody = msg . getBytes ( ) ; byte [ ] expectedBody = body ; \"<AssertPlaceHolder>\" ; } getBytes ( ) { return this . body ; }", "answer": "org . junit . Assert . assertThat ( testBody , org . hamcrest . CoreMatchers . is ( expectedBody ) )"}
{"focal": "name ( java . lang . String ) { return ( org . bindgen . processor . BasicPropertiesTest . PACKAGE ) + className ; }", "testMethod": "shouldCreateDirectBindings ( ) { java . lang . ClassLoader loader = this . compile ( org . bindgen . processor . BasicPropertiesTest . path ( \"Address\" ) ) ; java . lang . Class < ? > addressClass = loader . loadClass ( org . bindgen . processor . BasicPropertiesTest . name ( \"Address\" ) ) ; java . lang . Class < ? > addressBindingClass = loader . loadClass ( org . bindgen . processor . BasicPropertiesTest . name ( \"AddressBinding\" ) ) ; java . lang . Object address = addressClass . newInstance ( ) ; addressClass . getField ( \"city\" ) . set ( address , org . bindgen . processor . BasicPropertiesTest . CITY ) ; java . lang . Object binding = addressBindingClass . getConstructor ( addressClass ) . newInstance ( address ) ; java . lang . Object cityBinding = addressBindingClass . getMethod ( \"city\" ) . invoke ( binding ) ; java . lang . String city = ( ( java . lang . String ) ( org . bindgen . Binding . class . getMethod ( \"get\" ) . invoke ( cityBinding ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . bindgen . processor . BasicPropertiesTest . CITY , org . hamcrest . CoreMatchers . is ( city ) )", "total": "shouldCreateDirectBindings ( ) { java . lang . ClassLoader loader = this . compile ( org . bindgen . processor . BasicPropertiesTest . path ( \"Address\" ) ) ; java . lang . Class < ? > addressClass = loader . loadClass ( org . bindgen . processor . BasicPropertiesTest . name ( \"Address\" ) ) ; java . lang . Class < ? > addressBindingClass = loader . loadClass ( org . bindgen . processor . BasicPropertiesTest . name ( \"AddressBinding\" ) ) ; java . lang . Object address = addressClass . newInstance ( ) ; addressClass . getField ( \"city\" ) . set ( address , org . bindgen . processor . BasicPropertiesTest . CITY ) ; java . lang . Object binding = addressBindingClass . getConstructor ( addressClass ) . newInstance ( address ) ; java . lang . Object cityBinding = addressBindingClass . getMethod ( \"city\" ) . invoke ( binding ) ; java . lang . String city = ( ( java . lang . String ) ( org . bindgen . Binding . class . getMethod ( \"get\" ) . invoke ( cityBinding ) ) ) ; \"<AssertPlaceHolder>\" ; } name ( java . lang . String ) { return ( org . bindgen . processor . BasicPropertiesTest . PACKAGE ) + className ; }", "answer": "org . junit . Assert . assertThat ( org . bindgen . processor . BasicPropertiesTest . CITY , org . hamcrest . CoreMatchers . is ( city ) )"}
{"focal": "getStrongestCipher ( ) { final java . lang . String cipher ; if ( ( cipherExists ( \"AES\" ) ) && ( caps . contains ( Capability . AES ) ) ) { cipher = \"AES\" ; } else if ( ( cipherExists ( \"DESede\" ) ) && ( caps . contains ( Capability . TRIPLE_DES ) ) ) { cipher = \"DESede\" ; } else { cipher = \"DES\" ; } return cipher ; }", "testMethod": "testNoAlgorithmSupportYieldsDefaultCipher ( ) { java . security . Provider [ ] providers = removeProviders ( ) ; org . jscep . transport . response . Capabilities caps = new org . jscep . transport . response . Capabilities ( Capability . TRIPLE_DES ) ; \"<AssertPlaceHolder>\" ; restoreProviders ( providers ) ; }", "assertLine": "org . junit . Assert . assertThat ( caps . getStrongestCipher ( ) , org . hamcrest . CoreMatchers . is ( \"DES\" ) )", "total": "testNoAlgorithmSupportYieldsDefaultCipher ( ) { java . security . Provider [ ] providers = removeProviders ( ) ; org . jscep . transport . response . Capabilities caps = new org . jscep . transport . response . Capabilities ( Capability . TRIPLE_DES ) ; \"<AssertPlaceHolder>\" ; restoreProviders ( providers ) ; } getStrongestCipher ( ) { final java . lang . String cipher ; if ( ( cipherExists ( \"AES\" ) ) && ( caps . contains ( Capability . AES ) ) ) { cipher = \"AES\" ; } else if ( ( cipherExists ( \"DESede\" ) ) && ( caps . contains ( Capability . TRIPLE_DES ) ) ) { cipher = \"DESede\" ; } else { cipher = \"DES\" ; } return cipher ; }", "answer": "org . junit . Assert . assertThat ( caps . getStrongestCipher ( ) , org . hamcrest . CoreMatchers . is ( \"DES\" ) )"}
{"focal": "supports ( net . ripe . db . whois . update . domain . PreparedUpdate ) { return ( update . getAction ( ) . equals ( Action . CREATE ) ) && ( ( update . getType ( ) . equals ( ObjectType . ROUTE ) ) || ( update . getType ( ) . equals ( ObjectType . ROUTE6 ) ) ) ; }", "testMethod": "does_not_support_updates_with_same_mntirts ( ) { when ( update . getNewValues ( AttributeType . MNT_IRT ) ) . thenReturn ( com . google . common . collect . Sets . < net . ripe . db . whois . common . domain . CIString > newHashSet ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( subject . supports ( update ) , org . hamcrest . core . Is . is ( false ) )", "total": "does_not_support_updates_with_same_mntirts ( ) { when ( update . getNewValues ( AttributeType . MNT_IRT ) ) . thenReturn ( com . google . common . collect . Sets . < net . ripe . db . whois . common . domain . CIString > newHashSet ( ) ) ; \"<AssertPlaceHolder>\" ; } supports ( net . ripe . db . whois . update . domain . PreparedUpdate ) { return ( update . getAction ( ) . equals ( Action . CREATE ) ) && ( ( update . getType ( ) . equals ( ObjectType . ROUTE ) ) || ( update . getType ( ) . equals ( ObjectType . ROUTE6 ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( subject . supports ( update ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "testMethod": "testQueryByNonExistingTenantId ( ) { org . camunda . bpm . engine . history . HistoricExternalTaskLogQuery query = historyService . createHistoricExternalTaskLogQuery ( ) . tenantIdIn ( \"nonExisting\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "testQueryByNonExistingTenantId ( ) { org . camunda . bpm . engine . history . HistoricExternalTaskLogQuery query = historyService . createHistoricExternalTaskLogQuery ( ) . tenantIdIn ( \"nonExisting\" ) ; \"<AssertPlaceHolder>\" ; } count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "get ( java . lang . String ) { com . google . common . base . Preconditions . checkNotNull ( key , \"key<sp>is<sp>null\" ) ; return values . get ( key ) ; }", "testMethod": "testAddOrUpdateOnNewRule_shouldWork ( ) { ruleManager . addOrUpdate ( id [ 0 ] , code [ 0 ] ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ruleManager . get ( id [ 0 ] ) , org . hamcrest . CoreMatchers . is ( code [ 0 ] ) )", "total": "testAddOrUpdateOnNewRule_shouldWork ( ) { ruleManager . addOrUpdate ( id [ 0 ] , code [ 0 ] ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . String ) { com . google . common . base . Preconditions . checkNotNull ( key , \"key<sp>is<sp>null\" ) ; return values . get ( key ) ; }", "answer": "org . junit . Assert . assertThat ( ruleManager . get ( id [ 0 ] ) , org . hamcrest . CoreMatchers . is ( code [ 0 ] ) )"}
{"focal": "map ( com . baidu . unbiz . easymapper . Person6 , com . baidu . unbiz . easymapper . PersonDto6 ) { personDto . setLastName ( person . lastName . toUpperCase ( ) ) ; }", "testMethod": "testGenericType ( ) { com . baidu . unbiz . easymapper . Person4 < java . lang . String > p = new com . baidu . unbiz . easymapper . Person4 < java . lang . String > ( ) ; p . firstName = \"neo\" ; p . lastName = \"jason\" ; p . jobTitles = com . google . common . collect . Lists . newArrayList ( \"1\" , \"2\" , \"3\" ) ; p . salary = 1000L ; p . family = new com . baidu . unbiz . easymapper . Family < java . lang . String > ( ) { @ com . baidu . unbiz . easymapper . Override public java . util . List < java . lang . String > getMembers ( ) { return com . google . common . collect . Lists . newArrayList ( \"father\" , \"mother\" ) ; } } ; com . baidu . unbiz . easymapper . PersonDto4 < java . lang . String > dto = com . baidu . unbiz . easymapper . MapperFactory . getCopyByRefMapper ( ) . mapClass ( com . baidu . unbiz . easymapper . Person4 . class , com . baidu . unbiz . easymapper . PersonDto4 . class ) . register ( ) . map ( p , com . baidu . unbiz . easymapper . PersonDto4 . class ) ; System . out . println ( dto ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( ( dto . family ) == ( p . family ) ) , org . hamcrest . Matchers . is ( true ) )", "total": "testGenericType ( ) { com . baidu . unbiz . easymapper . Person4 < java . lang . String > p = new com . baidu . unbiz . easymapper . Person4 < java . lang . String > ( ) ; p . firstName = \"neo\" ; p . lastName = \"jason\" ; p . jobTitles = com . google . common . collect . Lists . newArrayList ( \"1\" , \"2\" , \"3\" ) ; p . salary = 1000L ; p . family = new com . baidu . unbiz . easymapper . Family < java . lang . String > ( ) { @ com . baidu . unbiz . easymapper . Override public java . util . List < java . lang . String > getMembers ( ) { return com . google . common . collect . Lists . newArrayList ( \"father\" , \"mother\" ) ; } } ; com . baidu . unbiz . easymapper . PersonDto4 < java . lang . String > dto = com . baidu . unbiz . easymapper . MapperFactory . getCopyByRefMapper ( ) . mapClass ( com . baidu . unbiz . easymapper . Person4 . class , com . baidu . unbiz . easymapper . PersonDto4 . class ) . register ( ) . map ( p , com . baidu . unbiz . easymapper . PersonDto4 . class ) ; System . out . println ( dto ) ; \"<AssertPlaceHolder>\" ; } map ( com . baidu . unbiz . easymapper . Person6 , com . baidu . unbiz . easymapper . PersonDto6 ) { personDto . setLastName ( person . lastName . toUpperCase ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( ( ( dto . family ) == ( p . family ) ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "toString ( ) { return com . google . common . base . MoreObjects . toStringHelper ( getClass ( ) ) . omitNullValues ( ) . add ( \"binNumber\" , binNumber ) . add ( \"listOfLsp\" , listOfLsp ) . toString ( ) ; }", "testMethod": "testToString ( ) { org . onosproject . routing . bgp . BgpRouteEntry . AsPath asPath = generateAsPath ( ) ; java . lang . String expectedString = \"AsPath{pathSegments=[\" + ( ( ( \"PathSegment{type=AS_CONFED_SEQUENCE,<sp>segmentAsNumbers=[1,<sp>2,<sp>3]},<sp>\" + \"PathSegment{type=AS_CONFED_SET,<sp>segmentAsNumbers=[4,<sp>5,<sp>6]},<sp>\" ) + \"PathSegment{type=AS_SEQUENCE,<sp>segmentAsNumbers=[7,<sp>8,<sp>9]},<sp>\" ) + \"PathSegment{type=AS_SET,<sp>segmentAsNumbers=[10,<sp>11,<sp>12]}]}\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( asPath . toString ( ) , org . hamcrest . Matchers . is ( expectedString ) )", "total": "testToString ( ) { org . onosproject . routing . bgp . BgpRouteEntry . AsPath asPath = generateAsPath ( ) ; java . lang . String expectedString = \"AsPath{pathSegments=[\" + ( ( ( \"PathSegment{type=AS_CONFED_SEQUENCE,<sp>segmentAsNumbers=[1,<sp>2,<sp>3]},<sp>\" + \"PathSegment{type=AS_CONFED_SET,<sp>segmentAsNumbers=[4,<sp>5,<sp>6]},<sp>\" ) + \"PathSegment{type=AS_SEQUENCE,<sp>segmentAsNumbers=[7,<sp>8,<sp>9]},<sp>\" ) + \"PathSegment{type=AS_SET,<sp>segmentAsNumbers=[10,<sp>11,<sp>12]}]}\" ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return com . google . common . base . MoreObjects . toStringHelper ( getClass ( ) ) . omitNullValues ( ) . add ( \"binNumber\" , binNumber ) . add ( \"listOfLsp\" , listOfLsp ) . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( asPath . toString ( ) , org . hamcrest . Matchers . is ( expectedString ) )"}
{"focal": "getDefaultBatchappsLocation ( ) { return new java . io . File ( framework . getHome ( ) , TestDriverContext . DEFAULT_BATCHAPPS_PATH ) ; }", "testMethod": "use_system_batchapps_location ( ) { com . asakusafw . testdriver . FlowPartTester tester = new com . asakusafw . testdriver . FlowPartTester ( getClass ( ) ) ; tester . getDriverContext ( ) . useSystemBatchApplicationsInstallationPath ( true ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; com . asakusafw . vocabulary . flow . In < com . asakusafw . testdriver . testing . model . Simple > in = tester . input ( \"in\" , com . asakusafw . testdriver . testing . model . Simple . class ) . prepare ( \"data/simple-in.json\" ) ; com . asakusafw . vocabulary . flow . Out < com . asakusafw . testdriver . testing . model . Simple > out = tester . output ( \"out\" , com . asakusafw . testdriver . testing . model . Simple . class ) . verify ( \"data/simple-out.json\" , new com . asakusafw . testdriver . IdentityVerifier ( ) ) ; tester . runTest ( new com . asakusafw . testdriver . testing . dsl . SimpleFlowPart ( in , out ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( getDefaultBatchappsLocation ( ) . exists ( ) , is ( true ) )", "total": "use_system_batchapps_location ( ) { com . asakusafw . testdriver . FlowPartTester tester = new com . asakusafw . testdriver . FlowPartTester ( getClass ( ) ) ; tester . getDriverContext ( ) . useSystemBatchApplicationsInstallationPath ( true ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; com . asakusafw . vocabulary . flow . In < com . asakusafw . testdriver . testing . model . Simple > in = tester . input ( \"in\" , com . asakusafw . testdriver . testing . model . Simple . class ) . prepare ( \"data/simple-in.json\" ) ; com . asakusafw . vocabulary . flow . Out < com . asakusafw . testdriver . testing . model . Simple > out = tester . output ( \"out\" , com . asakusafw . testdriver . testing . model . Simple . class ) . verify ( \"data/simple-out.json\" , new com . asakusafw . testdriver . IdentityVerifier ( ) ) ; tester . runTest ( new com . asakusafw . testdriver . testing . dsl . SimpleFlowPart ( in , out ) ) ; \"<AssertPlaceHolder>\" ; } getDefaultBatchappsLocation ( ) { return new java . io . File ( framework . getHome ( ) , TestDriverContext . DEFAULT_BATCHAPPS_PATH ) ; }", "answer": "org . junit . Assert . assertThat ( getDefaultBatchappsLocation ( ) . exists ( ) , is ( true ) )"}
{"focal": "isHealthy ( ) { return healthy ; }", "testMethod": "errorPathTestCacheNotRefreshedInLast2Runs ( ) { java . util . Calendar currentTime = java . util . GregorianCalendar . getInstance ( ) ; currentTime . set ( 2017 , 2 , 5 , 3 , 30 ) ; when ( timeService . getCurrentTime ( ) ) . thenReturn ( currentTime . getTime ( ) ) ; java . util . Calendar currentTimeMinus11Minutes = java . util . GregorianCalendar . getInstance ( ) ; currentTimeMinus11Minutes . set ( 2017 , 2 , 5 , 3 , 19 ) ; when ( metadataCache . getLastRefreshTime ( ) ) . thenReturn ( currentTimeMinus11Minutes . getTime ( ) ) ; com . intuit . wasabi . assignment . cache . impl . AssignmentsMetadataCacheHealthCheck healthCheck = new com . intuit . wasabi . assignment . cache . impl . AssignmentsMetadataCacheHealthCheck ( metadataCache , timeService , metadataCacheInterval , allowedStaleTime , metadataCacheEnabled ) ; com . codahale . metrics . health . HealthCheck . Result result = healthCheck . check ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . isHealthy ( ) , org . hamcrest . core . Is . is ( true ) )", "total": "errorPathTestCacheNotRefreshedInLast2Runs ( ) { java . util . Calendar currentTime = java . util . GregorianCalendar . getInstance ( ) ; currentTime . set ( 2017 , 2 , 5 , 3 , 30 ) ; when ( timeService . getCurrentTime ( ) ) . thenReturn ( currentTime . getTime ( ) ) ; java . util . Calendar currentTimeMinus11Minutes = java . util . GregorianCalendar . getInstance ( ) ; currentTimeMinus11Minutes . set ( 2017 , 2 , 5 , 3 , 19 ) ; when ( metadataCache . getLastRefreshTime ( ) ) . thenReturn ( currentTimeMinus11Minutes . getTime ( ) ) ; com . intuit . wasabi . assignment . cache . impl . AssignmentsMetadataCacheHealthCheck healthCheck = new com . intuit . wasabi . assignment . cache . impl . AssignmentsMetadataCacheHealthCheck ( metadataCache , timeService , metadataCacheInterval , allowedStaleTime , metadataCacheEnabled ) ; com . codahale . metrics . health . HealthCheck . Result result = healthCheck . check ( ) ; \"<AssertPlaceHolder>\" ; } isHealthy ( ) { return healthy ; }", "answer": "org . junit . Assert . assertThat ( result . isHealthy ( ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "format ( io . kubernetes . client . custom . Quantity$Format , int ) { switch ( format ) { case DECIMAL_SI : return getDecimalSiSuffix ( exponent ) ; case BINARY_SI : return getBinarySiSuffix ( exponent ) ; case DECIMAL_EXPONENT : return exponent == 0 ? \"\" : \"e\" + exponent ; default : throw new java . lang . IllegalStateException ( ( ( ( \"Can't<sp>format<sp>\" + format ) + \"<sp>with<sp>exponent<sp>\" ) + exponent ) ) ; } }", "testMethod": "testFormatZeroDecimalExponent ( ) { final java . lang . String formattedString = new io . kubernetes . client . custom . SuffixFormatter ( ) . format ( Quantity . Format . DECIMAL_EXPONENT , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( formattedString , org . hamcrest . core . Is . is ( \"\" ) )", "total": "testFormatZeroDecimalExponent ( ) { final java . lang . String formattedString = new io . kubernetes . client . custom . SuffixFormatter ( ) . format ( Quantity . Format . DECIMAL_EXPONENT , 0 ) ; \"<AssertPlaceHolder>\" ; } format ( io . kubernetes . client . custom . Quantity$Format , int ) { switch ( format ) { case DECIMAL_SI : return getDecimalSiSuffix ( exponent ) ; case BINARY_SI : return getBinarySiSuffix ( exponent ) ; case DECIMAL_EXPONENT : return exponent == 0 ? \"\" : \"e\" + exponent ; default : throw new java . lang . IllegalStateException ( ( ( ( \"Can't<sp>format<sp>\" + format ) + \"<sp>with<sp>exponent<sp>\" ) + exponent ) ) ; } }", "answer": "org . junit . Assert . assertThat ( formattedString , org . hamcrest . core . Is . is ( \"\" ) )"}
{"focal": "getResources ( ) { final com . google . cloud . datastore . EntityQuery query = com . google . cloud . datastore . Query . newEntityQueryBuilder ( ) . setKind ( com . spotify . styx . storage . KIND_COUNTER_LIMIT ) . build ( ) ; final java . util . List < com . spotify . styx . model . Resource > resources = com . google . common . collect . Lists . newArrayList ( ) ; datastore . query ( query , ( entity ) -> resources . add ( entityToResource ( entity ) ) ) ; return resources ; }", "testMethod": "shouldReturnResources ( ) { storage . runInTransaction ( ( tx ) -> { tx . store ( com . spotify . styx . storage . DatastoreStorageTest . RESOURCE1 ) ; tx . store ( com . spotify . styx . storage . DatastoreStorageTest . RESOURCE2 ) ; return null ; } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( storage . getResources ( ) , org . hamcrest . Matchers . is ( java . util . List . of ( com . spotify . styx . storage . DatastoreStorageTest . RESOURCE1 , com . spotify . styx . storage . DatastoreStorageTest . RESOURCE2 ) ) )", "total": "shouldReturnResources ( ) { storage . runInTransaction ( ( tx ) -> { tx . store ( com . spotify . styx . storage . DatastoreStorageTest . RESOURCE1 ) ; tx . store ( com . spotify . styx . storage . DatastoreStorageTest . RESOURCE2 ) ; return null ; } ) ; \"<AssertPlaceHolder>\" ; } getResources ( ) { final com . google . cloud . datastore . EntityQuery query = com . google . cloud . datastore . Query . newEntityQueryBuilder ( ) . setKind ( com . spotify . styx . storage . KIND_COUNTER_LIMIT ) . build ( ) ; final java . util . List < com . spotify . styx . model . Resource > resources = com . google . common . collect . Lists . newArrayList ( ) ; datastore . query ( query , ( entity ) -> resources . add ( entityToResource ( entity ) ) ) ; return resources ; }", "answer": "org . junit . Assert . assertThat ( storage . getResources ( ) , org . hamcrest . Matchers . is ( java . util . List . of ( com . spotify . styx . storage . DatastoreStorageTest . RESOURCE1 , com . spotify . styx . storage . DatastoreStorageTest . RESOURCE2 ) ) )"}
{"focal": "getResultCollector ( ) { return this . resultCollector ; }", "testMethod": "executeWithNoResultWithFunctionIdAndArgs ( ) { java . lang . Object [ ] args = new java . lang . Object [ ] { \"test\" , \"testing\" , \"tested\" } ; org . mockito . Mockito . when ( mockFunctionExecution . setArgs ( args ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . setFunctionId ( \"TestFunction\" ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . setResultCollector ( mockResultCollector ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . setTimeout ( 500 ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . execute ( org . mockito . Matchers . eq ( false ) ) ) . thenReturn ( null ) ; org . springframework . data . gemfire . function . execution . AbstractFunctionTemplate functionTemplate = new org . springframework . data . gemfire . function . execution . AbstractFunctionTemplate ( ) { @ org . springframework . data . gemfire . function . execution . Override protected org . springframework . data . gemfire . function . execution . AbstractFunctionExecution getFunctionExecution ( ) { return mockFunctionExecution ; } } ; functionTemplate . setResultCollector ( mockResultCollector ) ; functionTemplate . setTimeout ( 500 ) ; functionTemplate . executeWithNoResult ( \"TestFunction\" , args ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setArgs ( args ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setFunctionId ( \"TestFunction\" ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setResultCollector ( org . mockito . Matchers . eq ( mockResultCollector ) ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setTimeout ( 500 ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . execute ( org . mockito . Matchers . eq ( false ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( functionTemplate . getResultCollector ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( mockResultCollector ) ) )", "total": "executeWithNoResultWithFunctionIdAndArgs ( ) { java . lang . Object [ ] args = new java . lang . Object [ ] { \"test\" , \"testing\" , \"tested\" } ; org . mockito . Mockito . when ( mockFunctionExecution . setArgs ( args ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . setFunctionId ( \"TestFunction\" ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . setResultCollector ( mockResultCollector ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . setTimeout ( 500 ) ) . thenReturn ( mockFunctionExecution ) ; org . mockito . Mockito . when ( mockFunctionExecution . execute ( org . mockito . Matchers . eq ( false ) ) ) . thenReturn ( null ) ; org . springframework . data . gemfire . function . execution . AbstractFunctionTemplate functionTemplate = new org . springframework . data . gemfire . function . execution . AbstractFunctionTemplate ( ) { @ org . springframework . data . gemfire . function . execution . Override protected org . springframework . data . gemfire . function . execution . AbstractFunctionExecution getFunctionExecution ( ) { return mockFunctionExecution ; } } ; functionTemplate . setResultCollector ( mockResultCollector ) ; functionTemplate . setTimeout ( 500 ) ; functionTemplate . executeWithNoResult ( \"TestFunction\" , args ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setArgs ( args ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setFunctionId ( \"TestFunction\" ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setResultCollector ( org . mockito . Matchers . eq ( mockResultCollector ) ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . setTimeout ( 500 ) ; org . mockito . Mockito . verify ( mockFunctionExecution , org . mockito . Mockito . times ( 1 ) ) . execute ( org . mockito . Matchers . eq ( false ) ) ; } getResultCollector ( ) { return this . resultCollector ; }", "answer": "org . junit . Assert . assertThat ( functionTemplate . getResultCollector ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( mockResultCollector ) ) )"}
{"focal": "getIconId ( ) { return iconId ; }", "testMethod": "should_createGroup_with_icon_create_the_icon ( ) { org . bonitasoft . engine . identity . Group mainGroup = getIdentityAPI ( ) . createGroup ( new org . bonitasoft . engine . identity . GroupCreator ( \"mainGroup\" ) . setIcon ( \"main.png\" , new byte [ ] { 1 , 2 , 3 } ) ) ; org . bonitasoft . engine . identity . Icon icon = getIdentityAPI ( ) . getIcon ( mainGroup . getIconId ( ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( new org . bonitasoft . engine . identity . impl . IconImpl ( icon . getId ( ) , \"image/png\" , new byte [ ] { 1 , 2 , 3 } ) ) ; deleteGroups ( getIdentityAPI ( ) . getGroupByPath ( \"/mainGroup\" ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( icon )", "total": "should_createGroup_with_icon_create_the_icon ( ) { org . bonitasoft . engine . identity . Group mainGroup = getIdentityAPI ( ) . createGroup ( new org . bonitasoft . engine . identity . GroupCreator ( \"mainGroup\" ) . setIcon ( \"main.png\" , new byte [ ] { 1 , 2 , 3 } ) ) ; org . bonitasoft . engine . identity . Icon icon = getIdentityAPI ( ) . getIcon ( mainGroup . getIconId ( ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( new org . bonitasoft . engine . identity . impl . IconImpl ( icon . getId ( ) , \"image/png\" , new byte [ ] { 1 , 2 , 3 } ) ) ; deleteGroups ( getIdentityAPI ( ) . getGroupByPath ( \"/mainGroup\" ) ) ; } getIconId ( ) { return iconId ; }", "answer": "org . junit . Assert . assertThat ( icon )"}
{"focal": "size ( ) { return ( this . list . size ( ) ) + 2 ; }", "testMethod": "data_should_be_removed_from_infinispan ( ) { org . infinispan . commons . api . BasicCache < java . lang . Object , java . lang . Object > cache = remoteCacheManager . getCache ( ) ; com . lordofthejars . nosqlunit . infinispan . InfinispanOperation infinispanOperation = new com . lordofthejars . nosqlunit . infinispan . InfinispanOperation ( cache ) ; infinispanOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . integration . WhenManagedInfinispanOperationsAreRequired . OBJECT_DATA . getBytes ( ) ) ) ; infinispanOperation . deleteAll ( ) ; org . infinispan . commons . api . BasicCache < java . lang . String , java . lang . String > usedCache = infinispanOperation . connectionManager ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( usedCache . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "data_should_be_removed_from_infinispan ( ) { org . infinispan . commons . api . BasicCache < java . lang . Object , java . lang . Object > cache = remoteCacheManager . getCache ( ) ; com . lordofthejars . nosqlunit . infinispan . InfinispanOperation infinispanOperation = new com . lordofthejars . nosqlunit . infinispan . InfinispanOperation ( cache ) ; infinispanOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . integration . WhenManagedInfinispanOperationsAreRequired . OBJECT_DATA . getBytes ( ) ) ) ; infinispanOperation . deleteAll ( ) ; org . infinispan . commons . api . BasicCache < java . lang . String , java . lang . String > usedCache = infinispanOperation . connectionManager ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return ( this . list . size ( ) ) + 2 ; }", "answer": "org . junit . Assert . assertThat ( usedCache . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "preorderIterator ( ) { return new com . pengyifan . commons . collections . tree . Tree . PreorderIterator ( getThis ( ) ) ; }", "testMethod": "testPreorderIterator ( ) { \"<AssertPlaceHolder>\" ; a . preorderIterator ( ) . remove ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( com . google . common . collect . Lists . newArrayList ( a . preorderIterator ( ) ) , org . hamcrest . CoreMatchers . is ( com . google . common . collect . Lists . newArrayList ( a , b , c , f , d , e ) ) )", "total": "testPreorderIterator ( ) { \"<AssertPlaceHolder>\" ; a . preorderIterator ( ) . remove ( ) ; } preorderIterator ( ) { return new com . pengyifan . commons . collections . tree . Tree . PreorderIterator ( getThis ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( com . google . common . collect . Lists . newArrayList ( a . preorderIterator ( ) ) , org . hamcrest . CoreMatchers . is ( com . google . common . collect . Lists . newArrayList ( a , b , c , f , d , e ) ) )"}
{"focal": "existsById ( ID ) { org . springframework . util . Assert . notNull ( id , org . springframework . data . jpa . repository . support . SimpleJpaRepository . ID_MUST_NOT_BE_NULL ) ; if ( ( entityInformation . getIdAttribute ( ) ) == null ) { return findById ( id ) . isPresent ( ) ; } java . lang . String placeholder = provider . getCountQueryPlaceholder ( ) ; java . lang . String entityName = entityInformation . getEntityName ( ) ; java . lang . Iterable < java . lang . String > idAttributeNames = entityInformation . getIdAttributeNames ( ) ; java . lang . String existsQuery = org . springframework . data . jpa . repository . support . QueryUtils . getExistsQueryString ( entityName , placeholder , idAttributeNames ) ; javax . persistence . TypedQuery < java . lang . Long > query = em . createQuery ( existsQuery , org . springframework . data . jpa . repository . support . Long . class ) ; if ( ! ( entityInformation . hasCompositeId ( ) ) ) { query . setParameter ( idAttributeNames . iterator ( ) . next ( ) , id ) ; return ( query . getSingleResult ( ) ) == 1L ; } for ( java . lang . String idAttributeName : idAttributeNames ) { java . lang . Object idAttributeValue = entityInformation . getCompositeIdAttributeValue ( id , idAttributeName ) ; boolean complexIdParameterValueDiscovered = ( idAttributeValue != null ) && ( ! ( query . getParameter ( idAttributeName ) . getParameterType ( ) . isAssignableFrom ( idAttributeValue . getClass ( ) ) ) ) ; if ( complexIdParameterValueDiscovered ) { return findById ( id ) . isPresent ( ) ; } query . setParameter ( idAttributeName , idAttributeValue ) ; } return ( query . getSingleResult ( ) ) == 1L ; }", "testMethod": "testExistsWithEmbeddedId ( ) { org . springframework . data . jpa . domain . sample . EmbeddedIdExampleDepartment dep1 = new org . springframework . data . jpa . domain . sample . EmbeddedIdExampleDepartment ( ) ; dep1 . setDepartmentId ( 1L ) ; dep1 . setName ( \"Dep1\" ) ; org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployeePK key = new org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployeePK ( ) ; key . setDepartmentId ( 1L ) ; key . setEmployeeId ( 1L ) ; org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployee emp = new org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployee ( ) ; emp . setDepartment ( dep1 ) ; emp . setEmployeePk ( key ) ; emp = employeeRepositoryWithEmbeddedId . save ( emp ) ; key . setDepartmentId ( emp . getDepartment ( ) . getDepartmentId ( ) ) ; key . setEmployeeId ( emp . getEmployeePk ( ) . getEmployeeId ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( employeeRepositoryWithEmbeddedId . existsById ( key ) , is ( true ) )", "total": "testExistsWithEmbeddedId ( ) { org . springframework . data . jpa . domain . sample . EmbeddedIdExampleDepartment dep1 = new org . springframework . data . jpa . domain . sample . EmbeddedIdExampleDepartment ( ) ; dep1 . setDepartmentId ( 1L ) ; dep1 . setName ( \"Dep1\" ) ; org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployeePK key = new org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployeePK ( ) ; key . setDepartmentId ( 1L ) ; key . setEmployeeId ( 1L ) ; org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployee emp = new org . springframework . data . jpa . domain . sample . EmbeddedIdExampleEmployee ( ) ; emp . setDepartment ( dep1 ) ; emp . setEmployeePk ( key ) ; emp = employeeRepositoryWithEmbeddedId . save ( emp ) ; key . setDepartmentId ( emp . getDepartment ( ) . getDepartmentId ( ) ) ; key . setEmployeeId ( emp . getEmployeePk ( ) . getEmployeeId ( ) ) ; \"<AssertPlaceHolder>\" ; } existsById ( ID ) { org . springframework . util . Assert . notNull ( id , org . springframework . data . jpa . repository . support . SimpleJpaRepository . ID_MUST_NOT_BE_NULL ) ; if ( ( entityInformation . getIdAttribute ( ) ) == null ) { return findById ( id ) . isPresent ( ) ; } java . lang . String placeholder = provider . getCountQueryPlaceholder ( ) ; java . lang . String entityName = entityInformation . getEntityName ( ) ; java . lang . Iterable < java . lang . String > idAttributeNames = entityInformation . getIdAttributeNames ( ) ; java . lang . String existsQuery = org . springframework . data . jpa . repository . support . QueryUtils . getExistsQueryString ( entityName , placeholder , idAttributeNames ) ; javax . persistence . TypedQuery < java . lang . Long > query = em . createQuery ( existsQuery , org . springframework . data . jpa . repository . support . Long . class ) ; if ( ! ( entityInformation . hasCompositeId ( ) ) ) { query . setParameter ( idAttributeNames . iterator ( ) . next ( ) , id ) ; return ( query . getSingleResult ( ) ) == 1L ; } for ( java . lang . String idAttributeName : idAttributeNames ) { java . lang . Object idAttributeValue = entityInformation . getCompositeIdAttributeValue ( id , idAttributeName ) ; boolean complexIdParameterValueDiscovered = ( idAttributeValue != null ) && ( ! ( query . getParameter ( idAttributeName ) . getParameterType ( ) . isAssignableFrom ( idAttributeValue . getClass ( ) ) ) ) ; if ( complexIdParameterValueDiscovered ) { return findById ( id ) . isPresent ( ) ; } query . setParameter ( idAttributeName , idAttributeValue ) ; } return ( query . getSingleResult ( ) ) == 1L ; }", "answer": "org . junit . Assert . assertThat ( employeeRepositoryWithEmbeddedId . existsById ( key ) , is ( true ) )"}
{"focal": "toPrimitiveByte ( java . lang . Object ) { java . lang . Byte b = org . slim3 . util . ByteUtil . toByte ( o ) ; if ( b == null ) { return 0 ; } return b . byteValue ( ) ; }", "testMethod": "toPrimitiveByteForString ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . slim3 . util . ByteUtil . toPrimitiveByte ( \"1\" ) , org . hamcrest . CoreMatchers . is ( ( ( byte ) ( 1 ) ) ) )", "total": "toPrimitiveByteForString ( ) { \"<AssertPlaceHolder>\" ; } toPrimitiveByte ( java . lang . Object ) { java . lang . Byte b = org . slim3 . util . ByteUtil . toByte ( o ) ; if ( b == null ) { return 0 ; } return b . byteValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . slim3 . util . ByteUtil . toPrimitiveByte ( \"1\" ) , org . hamcrest . CoreMatchers . is ( ( ( byte ) ( 1 ) ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testSetIdLength ( ) { defaultIsisInterface . setIdLength ( 8 ) ; resultInt = defaultIsisInterface . getIdLength ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultInt , org . hamcrest . CoreMatchers . is ( 8 ) )", "total": "testSetIdLength ( ) { defaultIsisInterface . setIdLength ( 8 ) ; resultInt = defaultIsisInterface . getIdLength ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( resultInt , org . hamcrest . CoreMatchers . is ( 8 ) )"}
{"focal": "is ( int ) { return ( get ( ) ) == err ; }", "testMethod": "testTimeoutNoActiveTimers ( ) { long timeout = timers . timeout ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( timeout , org . hamcrest . CoreMatchers . is ( ( - 1L ) ) )", "total": "testTimeoutNoActiveTimers ( ) { long timeout = timers . timeout ( ) ; \"<AssertPlaceHolder>\" ; } is ( int ) { return ( get ( ) ) == err ; }", "answer": "org . junit . Assert . assertThat ( timeout , org . hamcrest . CoreMatchers . is ( ( - 1L ) ) )"}
{"focal": "isFailedCommand ( ) { return new fr . treeptik . cloudunit . cli . integration . ShellMatchers . CommandStatusMatcher ( false ) ; }", "testMethod": "test_shouldNotChangeJavaVersionBecauseApplicationNotSelected ( ) { org . springframework . shell . core . CommandResult result = changeJavaVersion ( \"java8\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , isFailedCommand ( ) )", "total": "test_shouldNotChangeJavaVersionBecauseApplicationNotSelected ( ) { org . springframework . shell . core . CommandResult result = changeJavaVersion ( \"java8\" ) ; \"<AssertPlaceHolder>\" ; } isFailedCommand ( ) { return new fr . treeptik . cloudunit . cli . integration . ShellMatchers . CommandStatusMatcher ( false ) ; }", "answer": "org . junit . Assert . assertThat ( result , isFailedCommand ( ) )"}
{"focal": "getTotalCompleted ( ) { return totalCompleted ; }", "testMethod": "totalCompleted_is_a_running_total_and_not_just_how_many_stories_completed_in_the_iteration ( ) { iterationResult . setBatchSize ( 1 ) ; for ( java . lang . String workflowStepName : IterationResultSpecHelper . WORKFLOW_STEP_NAMES ) { iterationResult . setCapacity ( workflowStepName , iterationResult . getBatchSize ( ) ) ; } iterationResult . run ( 1 ) ; com . bigvisible . kanbansimulator . IterationResult nextIteration = iterationResult . nextIteration ( ) ; nextIteration . run ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( nextIteration . getTotalCompleted ( ) , is ( ( ( iterationResult . getTotalCompleted ( ) ) + 1 ) ) )", "total": "totalCompleted_is_a_running_total_and_not_just_how_many_stories_completed_in_the_iteration ( ) { iterationResult . setBatchSize ( 1 ) ; for ( java . lang . String workflowStepName : IterationResultSpecHelper . WORKFLOW_STEP_NAMES ) { iterationResult . setCapacity ( workflowStepName , iterationResult . getBatchSize ( ) ) ; } iterationResult . run ( 1 ) ; com . bigvisible . kanbansimulator . IterationResult nextIteration = iterationResult . nextIteration ( ) ; nextIteration . run ( 1 ) ; \"<AssertPlaceHolder>\" ; } getTotalCompleted ( ) { return totalCompleted ; }", "answer": "org . junit . Assert . assertThat ( nextIteration . getTotalCompleted ( ) , is ( ( ( iterationResult . getTotalCompleted ( ) ) + 1 ) ) )"}
{"focal": "copy ( java . lang . Object , java . lang . Object , org . slim3 . util . CopyOptions ) { if ( src == null ) { throw new java . lang . NullPointerException ( \"The<sp>src<sp>parameter<sp>is<sp>null.\" ) ; } if ( dest == null ) { throw new java . lang . NullPointerException ( \"The<sp>dest<sp>parameter<sp>is<sp>null.\" ) ; } if ( options == null ) { throw new java . lang . NullPointerException ( \"The<sp>options<sp>parameter<sp>is<sp>null.\" ) ; } org . slim3 . util . BeanDesc srcBeanDesc = org . slim3 . util . BeanUtil . getBeanDesc ( src . getClass ( ) ) ; org . slim3 . util . BeanDesc destBeanDesc = org . slim3 . util . BeanUtil . getBeanDesc ( dest . getClass ( ) ) ; int size = srcBeanDesc . getPropertyDescSize ( ) ; for ( int i = 0 ; i < size ; i ++ ) { org . slim3 . util . PropertyDesc srcPropertyDesc = srcBeanDesc . getPropertyDesc ( i ) ; java . lang . String propertyName = srcPropertyDesc . getName ( ) ; if ( ( ! ( srcPropertyDesc . isReadable ( ) ) ) || ( ! ( options . isTargetProperty ( propertyName ) ) ) ) { continue ; } org . slim3 . util . PropertyDesc destPropertyDesc = destBeanDesc . getPropertyDesc ( propertyName ) ; if ( destPropertyDesc == null ) { continue ; } if ( ! ( destPropertyDesc . isWritable ( ) ) ) { continue ; } java . lang . Object value = srcPropertyDesc . getValue ( src ) ; if ( ! ( options . isTargetValue ( value ) ) ) { continue ; } value = options . convertValue ( value , propertyName , destPropertyDesc . getPropertyClass ( ) ) ; destPropertyDesc . setValue ( dest , value ) ; } }", "testMethod": "copyBBForConverter ( ) { org . slim3 . util . BeanUtilTest . SrcBB src = new org . slim3 . util . BeanUtilTest . SrcBB ( ) ; src . fff = \"1,000\" ; org . slim3 . util . BeanUtilTest . DestBB dest = new org . slim3 . util . BeanUtilTest . DestBB ( ) ; org . slim3 . util . BeanUtil . copy ( src , dest , new org . slim3 . util . CopyOptions ( ) . numberConverter ( \"#,##0\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dest . fff , org . hamcrest . CoreMatchers . is ( 1000 ) )", "total": "copyBBForConverter ( ) { org . slim3 . util . BeanUtilTest . SrcBB src = new org . slim3 . util . BeanUtilTest . SrcBB ( ) ; src . fff = \"1,000\" ; org . slim3 . util . BeanUtilTest . DestBB dest = new org . slim3 . util . BeanUtilTest . DestBB ( ) ; org . slim3 . util . BeanUtil . copy ( src , dest , new org . slim3 . util . CopyOptions ( ) . numberConverter ( \"#,##0\" ) ) ; \"<AssertPlaceHolder>\" ; } copy ( java . lang . Object , java . lang . Object , org . slim3 . util . CopyOptions ) { if ( src == null ) { throw new java . lang . NullPointerException ( \"The<sp>src<sp>parameter<sp>is<sp>null.\" ) ; } if ( dest == null ) { throw new java . lang . NullPointerException ( \"The<sp>dest<sp>parameter<sp>is<sp>null.\" ) ; } if ( options == null ) { throw new java . lang . NullPointerException ( \"The<sp>options<sp>parameter<sp>is<sp>null.\" ) ; } org . slim3 . util . BeanDesc srcBeanDesc = org . slim3 . util . BeanUtil . getBeanDesc ( src . getClass ( ) ) ; org . slim3 . util . BeanDesc destBeanDesc = org . slim3 . util . BeanUtil . getBeanDesc ( dest . getClass ( ) ) ; int size = srcBeanDesc . getPropertyDescSize ( ) ; for ( int i = 0 ; i < size ; i ++ ) { org . slim3 . util . PropertyDesc srcPropertyDesc = srcBeanDesc . getPropertyDesc ( i ) ; java . lang . String propertyName = srcPropertyDesc . getName ( ) ; if ( ( ! ( srcPropertyDesc . isReadable ( ) ) ) || ( ! ( options . isTargetProperty ( propertyName ) ) ) ) { continue ; } org . slim3 . util . PropertyDesc destPropertyDesc = destBeanDesc . getPropertyDesc ( propertyName ) ; if ( destPropertyDesc == null ) { continue ; } if ( ! ( destPropertyDesc . isWritable ( ) ) ) { continue ; } java . lang . Object value = srcPropertyDesc . getValue ( src ) ; if ( ! ( options . isTargetValue ( value ) ) ) { continue ; } value = options . convertValue ( value , propertyName , destPropertyDesc . getPropertyClass ( ) ) ; destPropertyDesc . setValue ( dest , value ) ; } }", "answer": "org . junit . Assert . assertThat ( dest . fff , org . hamcrest . CoreMatchers . is ( 1000 ) )"}
{"focal": "exists ( ) { return new org . hamcrest . BaseMatcher < java . io . File > ( ) { @ com . asakusafw . operation . tools . directio . Override public boolean matches ( java . lang . Object item ) { return ( ( java . io . File ) ( item ) ) . exists ( ) ; } @ com . asakusafw . operation . tools . directio . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"exists\" ) ; } } ; }", "testMethod": "execute_sim ( ) { com . asakusafw . runtime . core . context . RuntimeContext . set ( RuntimeContext . DEFAULT . mode ( ExecutionMode . SIMULATION ) ) ; java . io . File in = folder . newFile ( \"in\" ) ; java . io . File out = folder . newFile ( \"out\" ) ; out . delete ( ) ; put ( in , \"aaa\" , \"bbb\" , \"ccc\" ) ; try ( com . asakusafw . windgate . core . GateTask task = new com . asakusafw . windgate . core . GateTask ( profile ( ) , script ( p ( \"testing\" , \"void\" , \"fs1\" , in , \"fs2\" , out ) ) , \"testing\" , true , true , new com . asakusafw . windgate . core . ParameterList ( ) ) ) { task . execute ( ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( out . exists ( ) , is ( false ) )", "total": "execute_sim ( ) { com . asakusafw . runtime . core . context . RuntimeContext . set ( RuntimeContext . DEFAULT . mode ( ExecutionMode . SIMULATION ) ) ; java . io . File in = folder . newFile ( \"in\" ) ; java . io . File out = folder . newFile ( \"out\" ) ; out . delete ( ) ; put ( in , \"aaa\" , \"bbb\" , \"ccc\" ) ; try ( com . asakusafw . windgate . core . GateTask task = new com . asakusafw . windgate . core . GateTask ( profile ( ) , script ( p ( \"testing\" , \"void\" , \"fs1\" , in , \"fs2\" , out ) ) , \"testing\" , true , true , new com . asakusafw . windgate . core . ParameterList ( ) ) ) { task . execute ( ) ; } \"<AssertPlaceHolder>\" ; } exists ( ) { return new org . hamcrest . BaseMatcher < java . io . File > ( ) { @ com . asakusafw . operation . tools . directio . Override public boolean matches ( java . lang . Object item ) { return ( ( java . io . File ) ( item ) ) . exists ( ) ; } @ com . asakusafw . operation . tools . directio . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"exists\" ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( out . exists ( ) , is ( false ) )"}
{"focal": "equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "testMethod": "testEncodeAndOwn ( ) { for ( byte [ ] value : org . apache . beam . sdk . coders . ByteArrayCoderTest . TEST_VALUES ) { byte [ ] encodedSlow = org . apache . beam . sdk . util . CoderUtils . encodeToByteArray ( org . apache . beam . sdk . coders . ByteArrayCoderTest . TEST_CODER , value ) ; byte [ ] encodedFast = org . apache . beam . sdk . coders . ByteArrayCoderTest . encodeToByteArrayAndOwn ( org . apache . beam . sdk . coders . ByteArrayCoderTest . TEST_CODER , value ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( encodedSlow , org . hamcrest . Matchers . equalTo ( encodedFast ) )", "total": "testEncodeAndOwn ( ) { for ( byte [ ] value : org . apache . beam . sdk . coders . ByteArrayCoderTest . TEST_VALUES ) { byte [ ] encodedSlow = org . apache . beam . sdk . util . CoderUtils . encodeToByteArray ( org . apache . beam . sdk . coders . ByteArrayCoderTest . TEST_CODER , value ) ; byte [ ] encodedFast = org . apache . beam . sdk . coders . ByteArrayCoderTest . encodeToByteArrayAndOwn ( org . apache . beam . sdk . coders . ByteArrayCoderTest . TEST_CODER , value ) ; \"<AssertPlaceHolder>\" ; } } equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( encodedSlow , org . hamcrest . Matchers . equalTo ( encodedFast ) )"}
{"focal": "build ( ) { return migrationPlan ; }", "testMethod": "testMapEqualBoundaryEvents ( ) { org . camunda . bpm . model . bpmn . BpmnModelInstance testProcess = org . camunda . bpm . engine . test . api . runtime . migration . ModifiableBpmnModelInstance . modify ( ProcessModels . ONE_TASK_PROCESS ) . activityBuilder ( \"userTask\" ) . boundaryEvent ( \"boundary\" ) . message ( org . camunda . bpm . engine . test . api . runtime . migration . MigrationPlanCreationTest . MESSAGE_NAME ) . done ( ) ; org . camunda . bpm . engine . repository . ProcessDefinition sourceProcessDefinition = testHelper . deployAndGetDefinition ( testProcess ) ; org . camunda . bpm . engine . repository . ProcessDefinition targetProcessDefinition = testHelper . deployAndGetDefinition ( testProcess ) ; org . camunda . bpm . engine . migration . MigrationPlan migrationPlan = runtimeService . createMigrationPlan ( sourceProcessDefinition . getId ( ) , targetProcessDefinition . getId ( ) ) . mapActivities ( \"userTask\" , \"userTask\" ) . mapActivities ( \"boundary\" , \"boundary\" ) . build ( ) ; \"<AssertPlaceHolder>\" . hasSourceProcessDefinition ( sourceProcessDefinition ) . hasTargetProcessDefinition ( targetProcessDefinition ) . hasInstructions ( migrate ( \"userTask\" ) . to ( \"userTask\" ) , migrate ( \"boundary\" ) . to ( \"boundary\" ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( migrationPlan )", "total": "testMapEqualBoundaryEvents ( ) { org . camunda . bpm . model . bpmn . BpmnModelInstance testProcess = org . camunda . bpm . engine . test . api . runtime . migration . ModifiableBpmnModelInstance . modify ( ProcessModels . ONE_TASK_PROCESS ) . activityBuilder ( \"userTask\" ) . boundaryEvent ( \"boundary\" ) . message ( org . camunda . bpm . engine . test . api . runtime . migration . MigrationPlanCreationTest . MESSAGE_NAME ) . done ( ) ; org . camunda . bpm . engine . repository . ProcessDefinition sourceProcessDefinition = testHelper . deployAndGetDefinition ( testProcess ) ; org . camunda . bpm . engine . repository . ProcessDefinition targetProcessDefinition = testHelper . deployAndGetDefinition ( testProcess ) ; org . camunda . bpm . engine . migration . MigrationPlan migrationPlan = runtimeService . createMigrationPlan ( sourceProcessDefinition . getId ( ) , targetProcessDefinition . getId ( ) ) . mapActivities ( \"userTask\" , \"userTask\" ) . mapActivities ( \"boundary\" , \"boundary\" ) . build ( ) ; \"<AssertPlaceHolder>\" . hasSourceProcessDefinition ( sourceProcessDefinition ) . hasTargetProcessDefinition ( targetProcessDefinition ) . hasInstructions ( migrate ( \"userTask\" ) . to ( \"userTask\" ) , migrate ( \"boundary\" ) . to ( \"boundary\" ) ) ; } build ( ) { return migrationPlan ; }", "answer": "org . junit . Assert . assertThat ( migrationPlan )"}
{"focal": "updateReferences ( org . eclipse . jgit . api . Git , java . lang . String , java . lang . String , java . util . Map , boolean ) { java . io . File updatedFile = new java . io . File ( fork . getRepository ( ) . getWorkTree ( ) , file ) ; if ( ! ( updatedFile . isFile ( ) ) ) { return ; } java . io . BufferedReader reader = null ; java . io . StringWriter sw = new java . io . StringWriter ( ) ; try { io . fabric8 . patch . management . impl . Activator . log2 ( org . osgi . service . log . LogService . LOG_INFO , ( ( \"Updating<sp>\\\"\" + file ) + \"\\\"\" ) ) ; reader = new java . io . BufferedReader ( new java . io . FileReader ( updatedFile ) ) ; java . lang . String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { for ( Map . Entry < java . lang . String , java . lang . String > entry : locationUpdates . entrySet ( ) ) { java . lang . String pattern = prefix + ( entry . getKey ( ) ) ; java . lang . String replacement = prefix + ( entry . getValue ( ) ) ; if ( useBackSlash ) { pattern = pattern . replaceAll ( \"/\" , \"\\\\\\\\\" ) ; replacement = replacement . replaceAll ( \"/\" , \"\\\\\\\\\" ) ; } if ( line . contains ( pattern ) ) { line = line . replace ( pattern , replacement ) ; } } sw . append ( line ) ; if ( useBackSlash ) { sw . append ( \"\\r\" ) ; } sw . append ( \"\\n\" ) ; } org . apache . commons . io . IOUtils . closeQuietly ( reader ) ; org . apache . commons . io . FileUtils . write ( updatedFile , sw . toString ( ) ) ; } catch ( java . lang . Exception e ) { io . fabric8 . patch . management . impl . Activator . log ( org . osgi . service . log . LogService . LOG_ERROR , null , e . getMessage ( ) , e , true ) ; } finally { org . apache . commons . io . IOUtils . closeQuietly ( reader ) ; } }", "testMethod": "updateEtcStartupReferences ( ) { java . io . File etcConfig = new java . io . File ( git . getRepository ( ) . getWorkTree ( ) , \"etc/startup.properties\" ) ; org . apache . commons . io . FileUtils . copyFile ( new java . io . File ( \"src/test/resources/files/etc/startup.properties\" ) , etcConfig ) ; java . util . List < io . fabric8 . patch . management . BundleUpdate > bundleUpdates = new java . util . LinkedList ( ) ; bundleUpdates . add ( io . fabric8 . patch . management . BundleUpdate . from ( \"mvn:org.ops4j.pax.url/pax-url-wrap/2.4.0/jar/uber\" ) . to ( \"mvn:org.ops4j.pax.url/pax-url-wrap/2.4.2/jar/uber\" ) ) ; bundleUpdates . add ( io . fabric8 . patch . management . BundleUpdate . from ( \"file:/opt/karaf/system/org/ops4j/pax/url/pax-url-aether/2.4.0/pax-url-aether-2.4.0.jar\" ) . to ( \"file:/opt/karaf/system/org/ops4j/pax/url/pax-url-aether/2.4.2/pax-url-aether-2.4.2.jar\" ) ) ; bundleUpdates . add ( io . fabric8 . patch . management . BundleUpdate . from ( \"mvn:org.apache.felix/org.apache.felix.bundlerepository/2.0.4\" ) . to ( \"mvn:org.apache.felix/org.apache.felix.bundlerepository/2.1.4\" ) ) ; java . util . Map < java . lang . String , java . lang . String > updates = io . fabric8 . patch . management . Utils . collectLocationUpdates ( bundleUpdates ) ; new io . fabric8 . patch . management . impl . GitPatchManagementServiceImpl ( context ) . updateReferences ( git , \"etc/startup.properties\" , \"\" , updates , false ) ; java . lang . String expected = org . apache . commons . io . FileUtils . readFileToString ( new java . io . File ( \"src/test/resources/files/etc/startup.properties.updated\" ) ) ; java . lang . String changed = org . apache . commons . io . FileUtils . readFileToString ( etcConfig ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( changed , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "updateEtcStartupReferences ( ) { java . io . File etcConfig = new java . io . File ( git . getRepository ( ) . getWorkTree ( ) , \"etc/startup.properties\" ) ; org . apache . commons . io . FileUtils . copyFile ( new java . io . File ( \"src/test/resources/files/etc/startup.properties\" ) , etcConfig ) ; java . util . List < io . fabric8 . patch . management . BundleUpdate > bundleUpdates = new java . util . LinkedList ( ) ; bundleUpdates . add ( io . fabric8 . patch . management . BundleUpdate . from ( \"mvn:org.ops4j.pax.url/pax-url-wrap/2.4.0/jar/uber\" ) . to ( \"mvn:org.ops4j.pax.url/pax-url-wrap/2.4.2/jar/uber\" ) ) ; bundleUpdates . add ( io . fabric8 . patch . management . BundleUpdate . from ( \"file:/opt/karaf/system/org/ops4j/pax/url/pax-url-aether/2.4.0/pax-url-aether-2.4.0.jar\" ) . to ( \"file:/opt/karaf/system/org/ops4j/pax/url/pax-url-aether/2.4.2/pax-url-aether-2.4.2.jar\" ) ) ; bundleUpdates . add ( io . fabric8 . patch . management . BundleUpdate . from ( \"mvn:org.apache.felix/org.apache.felix.bundlerepository/2.0.4\" ) . to ( \"mvn:org.apache.felix/org.apache.felix.bundlerepository/2.1.4\" ) ) ; java . util . Map < java . lang . String , java . lang . String > updates = io . fabric8 . patch . management . Utils . collectLocationUpdates ( bundleUpdates ) ; new io . fabric8 . patch . management . impl . GitPatchManagementServiceImpl ( context ) . updateReferences ( git , \"etc/startup.properties\" , \"\" , updates , false ) ; java . lang . String expected = org . apache . commons . io . FileUtils . readFileToString ( new java . io . File ( \"src/test/resources/files/etc/startup.properties.updated\" ) ) ; java . lang . String changed = org . apache . commons . io . FileUtils . readFileToString ( etcConfig ) ; \"<AssertPlaceHolder>\" ; } updateReferences ( org . eclipse . jgit . api . Git , java . lang . String , java . lang . String , java . util . Map , boolean ) { java . io . File updatedFile = new java . io . File ( fork . getRepository ( ) . getWorkTree ( ) , file ) ; if ( ! ( updatedFile . isFile ( ) ) ) { return ; } java . io . BufferedReader reader = null ; java . io . StringWriter sw = new java . io . StringWriter ( ) ; try { io . fabric8 . patch . management . impl . Activator . log2 ( org . osgi . service . log . LogService . LOG_INFO , ( ( \"Updating<sp>\\\"\" + file ) + \"\\\"\" ) ) ; reader = new java . io . BufferedReader ( new java . io . FileReader ( updatedFile ) ) ; java . lang . String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { for ( Map . Entry < java . lang . String , java . lang . String > entry : locationUpdates . entrySet ( ) ) { java . lang . String pattern = prefix + ( entry . getKey ( ) ) ; java . lang . String replacement = prefix + ( entry . getValue ( ) ) ; if ( useBackSlash ) { pattern = pattern . replaceAll ( \"/\" , \"\\\\\\\\\" ) ; replacement = replacement . replaceAll ( \"/\" , \"\\\\\\\\\" ) ; } if ( line . contains ( pattern ) ) { line = line . replace ( pattern , replacement ) ; } } sw . append ( line ) ; if ( useBackSlash ) { sw . append ( \"\\r\" ) ; } sw . append ( \"\\n\" ) ; } org . apache . commons . io . IOUtils . closeQuietly ( reader ) ; org . apache . commons . io . FileUtils . write ( updatedFile , sw . toString ( ) ) ; } catch ( java . lang . Exception e ) { io . fabric8 . patch . management . impl . Activator . log ( org . osgi . service . log . LogService . LOG_ERROR , null , e . getMessage ( ) , e , true ) ; } finally { org . apache . commons . io . IOUtils . closeQuietly ( reader ) ; } }", "answer": "org . junit . Assert . assertThat ( changed , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "is ( java . lang . annotation . Annotation ) { return is ( AnnotationDescription . ForLoadedAnnotation . of ( annotation ) ) ; }", "testMethod": "testNotMatchesRight ( ) { when ( left . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( false ) ; when ( right . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( true ) ; net . bytebuddy . agent . builder . AgentBuilder . RawMatcher rawMatcher = new net . bytebuddy . agent . builder . AgentBuilder . RawMatcher . Conjunction ( left , right ) ; \"<AssertPlaceHolder>\" ; verify ( left ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( left ) ; verifyZeroInteractions ( right ) ; }", "assertLine": "org . junit . Assert . assertThat ( rawMatcher . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testNotMatchesRight ( ) { when ( left . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( false ) ; when ( right . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( true ) ; net . bytebuddy . agent . builder . AgentBuilder . RawMatcher rawMatcher = new net . bytebuddy . agent . builder . AgentBuilder . RawMatcher . Conjunction ( left , right ) ; \"<AssertPlaceHolder>\" ; verify ( left ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( left ) ; verifyZeroInteractions ( right ) ; } is ( java . lang . annotation . Annotation ) { return is ( AnnotationDescription . ForLoadedAnnotation . of ( annotation ) ) ; }", "answer": "org . junit . Assert . assertThat ( rawMatcher . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "paths ( ) { int [ ] [ ] paths = new int [ this . paths . size ( ) ] [ 0 ] ; for ( int i = 0 ; i < ( this . paths . size ( ) ) ; i ++ ) paths [ i ] = this . paths . get ( i ) ; return paths ; }", "testMethod": "paths_napthalene ( ) { int [ ] [ ] napthalene = org . openscience . cdk . graph . InitialCyclesTest . naphthalene ( ) ; org . openscience . cdk . graph . VertexShortCycles vsc = new org . openscience . cdk . graph . VertexShortCycles ( napthalene ) ; int [ ] [ ] paths = vsc . paths ( ) ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { 5 , 0 , 1 , 2 , 3 , 4 , 5 } , new int [ ] { 5 , 4 , 7 , 8 , 9 , 6 , 5 } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( paths , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "paths_napthalene ( ) { int [ ] [ ] napthalene = org . openscience . cdk . graph . InitialCyclesTest . naphthalene ( ) ; org . openscience . cdk . graph . VertexShortCycles vsc = new org . openscience . cdk . graph . VertexShortCycles ( napthalene ) ; int [ ] [ ] paths = vsc . paths ( ) ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { 5 , 0 , 1 , 2 , 3 , 4 , 5 } , new int [ ] { 5 , 4 , 7 , 8 , 9 , 6 , 5 } } ; \"<AssertPlaceHolder>\" ; } paths ( ) { int [ ] [ ] paths = new int [ this . paths . size ( ) ] [ 0 ] ; for ( int i = 0 ; i < ( this . paths . size ( ) ) ; i ++ ) paths [ i ] = this . paths . get ( i ) ; return paths ; }", "answer": "org . junit . Assert . assertThat ( paths , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getAmount ( ) { return this . amount ; }", "testMethod": "shouldReturnInterestDueForNextInstallmentWhenWaiveInterestFlagIsOnAndInterestIsNotWaived ( ) { org . mifos . accounts . loan . business . LoanScheduleEntity loanScheduleEntity = new org . mifos . accounts . loan . business . LoanScheduleEntity ( ) { } ; org . mifos . framework . util . helpers . Money interest = org . mifos . framework . TestUtils . createMoney ( \"1234\" ) ; org . mifos . framework . util . helpers . Money interestPaid = org . mifos . framework . TestUtils . createMoney ( \"1200\" ) ; loanScheduleEntity . setInterest ( interest ) ; loanScheduleEntity . setInterestPaid ( interestPaid ) ; when ( loanBO . getDetailsOfNextInstallment ( ) ) . thenReturn ( loanScheduleEntity ) ; java . math . BigDecimal interestDue = ( ( org . mifos . application . servicefacade . LoanAccountServiceFacadeWebTier ) ( loanAccountServiceFacade ) ) . interestDueForNextInstallment ( BigDecimal . TEN , BigDecimal . ZERO , loanBO , false ) ; java . lang . Double expectedDue = interest . subtract ( interestPaid ) . getAmount ( ) . doubleValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( interestDue . doubleValue ( ) , org . hamcrest . Matchers . is ( expectedDue ) )", "total": "shouldReturnInterestDueForNextInstallmentWhenWaiveInterestFlagIsOnAndInterestIsNotWaived ( ) { org . mifos . accounts . loan . business . LoanScheduleEntity loanScheduleEntity = new org . mifos . accounts . loan . business . LoanScheduleEntity ( ) { } ; org . mifos . framework . util . helpers . Money interest = org . mifos . framework . TestUtils . createMoney ( \"1234\" ) ; org . mifos . framework . util . helpers . Money interestPaid = org . mifos . framework . TestUtils . createMoney ( \"1200\" ) ; loanScheduleEntity . setInterest ( interest ) ; loanScheduleEntity . setInterestPaid ( interestPaid ) ; when ( loanBO . getDetailsOfNextInstallment ( ) ) . thenReturn ( loanScheduleEntity ) ; java . math . BigDecimal interestDue = ( ( org . mifos . application . servicefacade . LoanAccountServiceFacadeWebTier ) ( loanAccountServiceFacade ) ) . interestDueForNextInstallment ( BigDecimal . TEN , BigDecimal . ZERO , loanBO , false ) ; java . lang . Double expectedDue = interest . subtract ( interestPaid ) . getAmount ( ) . doubleValue ( ) ; \"<AssertPlaceHolder>\" ; } getAmount ( ) { return this . amount ; }", "answer": "org . junit . Assert . assertThat ( interestDue . doubleValue ( ) , org . hamcrest . Matchers . is ( expectedDue ) )"}
{"focal": "filtrate ( java . util . List ) { return new com . github . bmsantos . core . cola . filters . FilterProcessor ( features ) ; }", "testMethod": "shouldGroupByFeature ( ) { java . lang . System . getProperties ( ) . setProperty ( \"cola.group\" , \"group\" ) ; uut = new com . github . bmsantos . core . cola . filters . TagFilter ( ) ; final com . github . bmsantos . core . cola . formatter . FeatureDetails feature = test . utils . TestUtils . loadFeatures ( \"com.github.bmsantos.core.cola.filters.TagFilterTest$GroupFeatureClass\" ) . get ( 0 ) ; final boolean result = uut . filtrate ( feature ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )", "total": "shouldGroupByFeature ( ) { java . lang . System . getProperties ( ) . setProperty ( \"cola.group\" , \"group\" ) ; uut = new com . github . bmsantos . core . cola . filters . TagFilter ( ) ; final com . github . bmsantos . core . cola . formatter . FeatureDetails feature = test . utils . TestUtils . loadFeatures ( \"com.github.bmsantos.core.cola.filters.TagFilterTest$GroupFeatureClass\" ) . get ( 0 ) ; final boolean result = uut . filtrate ( feature ) ; \"<AssertPlaceHolder>\" ; } filtrate ( java . util . List ) { return new com . github . bmsantos . core . cola . filters . FilterProcessor ( features ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getResult ( ) { return com . octo . android . sample . model . DummyComputer . RESULT ; }", "testMethod": "shouldUseCustomComputerUsingMockito ( ) { final int EXPECTED_RESULT = 1 ; com . octo . android . sample . ui . HelloAndroidActivity activityUnderTest = org . robolectric . Robolectric . buildActivity ( com . octo . android . sample . ui . HelloAndroidActivity . class ) . create ( ) . get ( ) ; com . octo . android . sample . model . Computer mockComputer = org . mockito . Mockito . mock ( com . octo . android . sample . model . Computer . class ) ; org . mockito . Mockito . when ( mockComputer . getResult ( ) ) . thenReturn ( EXPECTED_RESULT ) ; activityUnderTest . setComputer ( mockComputer ) ; android . widget . Button button = ( ( android . widget . Button ) ( activityUnderTest . findViewById ( R . id . button_main ) ) ) ; button . performClick ( ) ; org . mockito . Mockito . verify ( mockComputer , org . mockito . Mockito . times ( 1 ) ) . getResult ( ) ; android . widget . TextView textViewHello = ( ( android . widget . TextView ) ( activityUnderTest . findViewById ( R . id . textview_hello ) ) ) ; java . lang . String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( textViewHelloString , org . hamcrest . CoreMatchers . equalTo ( java . lang . String . valueOf ( EXPECTED_RESULT ) ) )", "total": "shouldUseCustomComputerUsingMockito ( ) { final int EXPECTED_RESULT = 1 ; com . octo . android . sample . ui . HelloAndroidActivity activityUnderTest = org . robolectric . Robolectric . buildActivity ( com . octo . android . sample . ui . HelloAndroidActivity . class ) . create ( ) . get ( ) ; com . octo . android . sample . model . Computer mockComputer = org . mockito . Mockito . mock ( com . octo . android . sample . model . Computer . class ) ; org . mockito . Mockito . when ( mockComputer . getResult ( ) ) . thenReturn ( EXPECTED_RESULT ) ; activityUnderTest . setComputer ( mockComputer ) ; android . widget . Button button = ( ( android . widget . Button ) ( activityUnderTest . findViewById ( R . id . button_main ) ) ) ; button . performClick ( ) ; org . mockito . Mockito . verify ( mockComputer , org . mockito . Mockito . times ( 1 ) ) . getResult ( ) ; android . widget . TextView textViewHello = ( ( android . widget . TextView ) ( activityUnderTest . findViewById ( R . id . textview_hello ) ) ) ; java . lang . String textViewHelloString = textViewHello . getText ( ) . toString ( ) ; \"<AssertPlaceHolder>\" ; } getResult ( ) { return com . octo . android . sample . model . DummyComputer . RESULT ; }", "answer": "org . junit . Assert . assertThat ( textViewHelloString , org . hamcrest . CoreMatchers . equalTo ( java . lang . String . valueOf ( EXPECTED_RESULT ) ) )"}
{"focal": "executeAndExtract ( ) { java . lang . Iterable < T > results = execute ( ) ; if ( ( results == null ) || ( ! ( results . iterator ( ) . hasNext ( ) ) ) ) { return null ; } java . lang . Object result = results . iterator ( ) . next ( ) ; if ( result instanceof java . lang . Throwable ) { throw new org . apache . geode . cache . execute . FunctionException ( java . lang . String . format ( \"Execution<sp>of<sp>Function<sp>%s<sp>failed\" , ( ( this . function ) != null ? this . function . getClass ( ) . getName ( ) : java . lang . String . format ( \"with<sp>ID<sp>[%s]\" , this . functionId ) ) ) , ( ( java . lang . Throwable ) ( result ) ) ) ; } return ( ( T ) ( result ) ) ; }", "testMethod": "executeAndExtractWithSingleResult ( ) { java . util . List < java . lang . String > results = java . util . Collections . singletonList ( \"test\" ) ; org . springframework . data . gemfire . function . execution . AbstractFunctionExecution functionExecution = new org . springframework . data . gemfire . function . execution . AbstractFunctionExecution ( ) { @ org . springframework . data . gemfire . function . execution . Override protected org . apache . geode . cache . execute . Execution getExecution ( ) { return mockExecution ; } @ org . springframework . data . gemfire . function . execution . SuppressWarnings ( \"unchecked\" ) @ org . springframework . data . gemfire . function . execution . Override < T > java . lang . Iterable < T > execute ( ) { return ( ( java . lang . Iterable < T > ) ( results ) ) ; } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( functionExecution . executeAndExtract ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"test\" ) ) )", "total": "executeAndExtractWithSingleResult ( ) { java . util . List < java . lang . String > results = java . util . Collections . singletonList ( \"test\" ) ; org . springframework . data . gemfire . function . execution . AbstractFunctionExecution functionExecution = new org . springframework . data . gemfire . function . execution . AbstractFunctionExecution ( ) { @ org . springframework . data . gemfire . function . execution . Override protected org . apache . geode . cache . execute . Execution getExecution ( ) { return mockExecution ; } @ org . springframework . data . gemfire . function . execution . SuppressWarnings ( \"unchecked\" ) @ org . springframework . data . gemfire . function . execution . Override < T > java . lang . Iterable < T > execute ( ) { return ( ( java . lang . Iterable < T > ) ( results ) ) ; } } ; \"<AssertPlaceHolder>\" ; } executeAndExtract ( ) { java . lang . Iterable < T > results = execute ( ) ; if ( ( results == null ) || ( ! ( results . iterator ( ) . hasNext ( ) ) ) ) { return null ; } java . lang . Object result = results . iterator ( ) . next ( ) ; if ( result instanceof java . lang . Throwable ) { throw new org . apache . geode . cache . execute . FunctionException ( java . lang . String . format ( \"Execution<sp>of<sp>Function<sp>%s<sp>failed\" , ( ( this . function ) != null ? this . function . getClass ( ) . getName ( ) : java . lang . String . format ( \"with<sp>ID<sp>[%s]\" , this . functionId ) ) ) , ( ( java . lang . Throwable ) ( result ) ) ) ; } return ( ( T ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( functionExecution . executeAndExtract ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"test\" ) ) )"}
{"focal": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "testMethod": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . MemberLeftChannelEvent event = new com . github . seratch . jslack . api . model . event . MemberLeftChannelEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"member_left_channel\\\"}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "total": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . MemberLeftChannelEvent event = new com . github . seratch . jslack . api . model . event . MemberLeftChannelEvent ( ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"member_left_channel\\\"}\" ; \"<AssertPlaceHolder>\" ; } createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "answer": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )"}
{"focal": "onConnectionChangedDeletePre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = false ; } if ( exist == false ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "testMethod": "testOnConnectionChangedDeletePreObjectTypeErr ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnection ( \"logic_id\" , \"LogicAndNetwork\" , \"initializing\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = new org . o3project . odenos . core . manager . system . ComponentConnection ( \"logic_id\" , \"Original\" , \"running\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"delete\" , prev , curr ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . onConnectionChangedDeletePre ( msg ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testOnConnectionChangedDeletePreObjectTypeErr ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnection ( \"logic_id\" , \"LogicAndNetwork\" , \"initializing\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = new org . o3project . odenos . core . manager . system . ComponentConnection ( \"logic_id\" , \"Original\" , \"running\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"delete\" , prev , curr ) ; \"<AssertPlaceHolder>\" ; } onConnectionChangedDeletePre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = false ; } if ( exist == false ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . onConnectionChangedDeletePre ( msg ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getAll ( ) { return ( ( java . util . List < T > ) ( this . template . loadAll ( persistentClass ) ) ) ; }", "testMethod": "whenAddTwoTasksAndDeleteFirstTaskByIdThenResultArrayWithSecondTask ( ) { vkaretko . start . Tracker tracker = new vkaretko . start . Tracker ( ) ; vkaretko . Item itemFirst = new vkaretko . Task ( \"test1\" , \"testDescription\" , 123L ) ; vkaretko . Item itemSecond = new vkaretko . Task ( \"test2\" , \"testDescription2\" , 1234L ) ; tracker . add ( itemFirst ) ; tracker . add ( itemSecond ) ; tracker . delete ( tracker . getAll ( ) [ firstElementOfArray ] . getId ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tracker . getAll ( ) [ firstElementOfArray ] , org . hamcrest . core . Is . is ( itemSecond ) )", "total": "whenAddTwoTasksAndDeleteFirstTaskByIdThenResultArrayWithSecondTask ( ) { vkaretko . start . Tracker tracker = new vkaretko . start . Tracker ( ) ; vkaretko . Item itemFirst = new vkaretko . Task ( \"test1\" , \"testDescription\" , 123L ) ; vkaretko . Item itemSecond = new vkaretko . Task ( \"test2\" , \"testDescription2\" , 1234L ) ; tracker . add ( itemFirst ) ; tracker . add ( itemSecond ) ; tracker . delete ( tracker . getAll ( ) [ firstElementOfArray ] . getId ( ) ) ; \"<AssertPlaceHolder>\" ; } getAll ( ) { return ( ( java . util . List < T > ) ( this . template . loadAll ( persistentClass ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( tracker . getAll ( ) [ firstElementOfArray ] , org . hamcrest . core . Is . is ( itemSecond ) )"}
{"focal": "getBuildKey ( org . jenkinsci . plugins . stashNotifier . Run , org . jenkinsci . plugins . stashNotifier . TaskListener ) { java . lang . StringBuilder key = new java . lang . StringBuilder ( ) ; if ( ( prependParentProjectKey ) || ( getDescriptor ( ) . isPrependParentProjectKey ( ) ) ) { if ( null != ( run . getParent ( ) . getParent ( ) ) ) { key . append ( run . getParent ( ) . getParent ( ) . getFullName ( ) ) . append ( '-' ) ; } } if ( ( ( projectKey ) != null ) && ( ( projectKey . trim ( ) . length ( ) ) > 0 ) ) { java . io . PrintStream logger = listener . getLogger ( ) ; try { if ( ! ( run instanceof org . jenkinsci . plugins . stashNotifier . AbstractBuild < ? , ? > ) ) { key . append ( org . jenkinsci . plugins . tokenmacro . TokenMacro . expandAll ( run , new org . jenkinsci . plugins . stashNotifier . FilePath ( run . getRootDir ( ) ) , listener , projectKey ) ) ; } else { key . append ( org . jenkinsci . plugins . tokenmacro . TokenMacro . expandAll ( ( ( org . jenkinsci . plugins . stashNotifier . AbstractBuild < ? , ? > ) ( run ) ) , listener , projectKey ) ) ; } } catch ( java . io . IOException | java . lang . InterruptedException | org . jenkinsci . plugins . tokenmacro . MacroEvaluationException ioe ) { logger . println ( \"Cannot<sp>expand<sp>build<sp>key<sp>from<sp>parameter.<sp>Processing<sp>with<sp>default<sp>build<sp>key\" ) ; ioe . printStackTrace ( logger ) ; key . append ( getDefaultBuildKey ( run ) ) ; } } else { key . append ( getDefaultBuildKey ( run ) ) ; } return org . apache . commons . lang . StringEscapeUtils . escapeJavaScript ( key . toString ( ) ) ; }", "testMethod": "test_getRunKey ( ) { java . lang . String key = \"someKey\" ; java . io . PrintStream logger = mock ( java . io . PrintStream . class ) ; when ( buildListener . getLogger ( ) ) . thenReturn ( logger ) ; final java . io . File tempDir = java . io . File . createTempFile ( \"stashNotifier\" , null ) ; when ( run . getRootDir ( ) ) . thenReturn ( tempDir ) ; org . powermock . api . mockito . PowerMockito . mockStatic ( org . jenkinsci . plugins . tokenmacro . TokenMacro . class ) ; org . powermock . api . mockito . PowerMockito . when ( org . jenkinsci . plugins . tokenmacro . TokenMacro . expandAll ( run , new hudson . FilePath ( tempDir ) , buildListener , key ) ) . thenReturn ( key ) ; sn = new org . jenkinsci . plugins . stashNotifier . StashNotifier ( \"\" , \"scot\" , true , null , true , key , true , false , false , new jenkins . model . JenkinsLocationConfiguration ( ) ) ; java . lang . String buildKey = sn . getBuildKey ( run , buildListener ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( buildKey , org . hamcrest . CoreMatchers . is ( key ) )", "total": "test_getRunKey ( ) { java . lang . String key = \"someKey\" ; java . io . PrintStream logger = mock ( java . io . PrintStream . class ) ; when ( buildListener . getLogger ( ) ) . thenReturn ( logger ) ; final java . io . File tempDir = java . io . File . createTempFile ( \"stashNotifier\" , null ) ; when ( run . getRootDir ( ) ) . thenReturn ( tempDir ) ; org . powermock . api . mockito . PowerMockito . mockStatic ( org . jenkinsci . plugins . tokenmacro . TokenMacro . class ) ; org . powermock . api . mockito . PowerMockito . when ( org . jenkinsci . plugins . tokenmacro . TokenMacro . expandAll ( run , new hudson . FilePath ( tempDir ) , buildListener , key ) ) . thenReturn ( key ) ; sn = new org . jenkinsci . plugins . stashNotifier . StashNotifier ( \"\" , \"scot\" , true , null , true , key , true , false , false , new jenkins . model . JenkinsLocationConfiguration ( ) ) ; java . lang . String buildKey = sn . getBuildKey ( run , buildListener ) ; \"<AssertPlaceHolder>\" ; } getBuildKey ( org . jenkinsci . plugins . stashNotifier . Run , org . jenkinsci . plugins . stashNotifier . TaskListener ) { java . lang . StringBuilder key = new java . lang . StringBuilder ( ) ; if ( ( prependParentProjectKey ) || ( getDescriptor ( ) . isPrependParentProjectKey ( ) ) ) { if ( null != ( run . getParent ( ) . getParent ( ) ) ) { key . append ( run . getParent ( ) . getParent ( ) . getFullName ( ) ) . append ( '-' ) ; } } if ( ( ( projectKey ) != null ) && ( ( projectKey . trim ( ) . length ( ) ) > 0 ) ) { java . io . PrintStream logger = listener . getLogger ( ) ; try { if ( ! ( run instanceof org . jenkinsci . plugins . stashNotifier . AbstractBuild < ? , ? > ) ) { key . append ( org . jenkinsci . plugins . tokenmacro . TokenMacro . expandAll ( run , new org . jenkinsci . plugins . stashNotifier . FilePath ( run . getRootDir ( ) ) , listener , projectKey ) ) ; } else { key . append ( org . jenkinsci . plugins . tokenmacro . TokenMacro . expandAll ( ( ( org . jenkinsci . plugins . stashNotifier . AbstractBuild < ? , ? > ) ( run ) ) , listener , projectKey ) ) ; } } catch ( java . io . IOException | java . lang . InterruptedException | org . jenkinsci . plugins . tokenmacro . MacroEvaluationException ioe ) { logger . println ( \"Cannot<sp>expand<sp>build<sp>key<sp>from<sp>parameter.<sp>Processing<sp>with<sp>default<sp>build<sp>key\" ) ; ioe . printStackTrace ( logger ) ; key . append ( getDefaultBuildKey ( run ) ) ; } } else { key . append ( getDefaultBuildKey ( run ) ) ; } return org . apache . commons . lang . StringEscapeUtils . escapeJavaScript ( key . toString ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( buildKey , org . hamcrest . CoreMatchers . is ( key ) )"}
{"focal": "get ( K ) { return this . cache . getOrDefault ( key , null ) ; }", "testMethod": "whenAddThreeElementThenSecondElementIsTwo ( ) { list . add ( 0 ) ; list . add ( 1 ) ; list . add ( 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . get ( 2 ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "whenAddThreeElementThenSecondElementIsTwo ( ) { list . add ( 0 ) ; list . add ( 1 ) ; list . add ( 2 ) ; \"<AssertPlaceHolder>\" ; } get ( K ) { return this . cache . getOrDefault ( key , null ) ; }", "answer": "org . junit . Assert . assertThat ( list . get ( 2 ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "asDocument ( ) { final long cursorId = myCursorId ; if ( cursorId != 0 ) { final com . allanbank . mongodb . bson . builder . DocumentBuilder b = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; b . add ( com . allanbank . mongodb . client . callback . NAME_SPACE_FIELD , ( ( ( myDatabaseName ) + \".\" ) + ( myCollectionName ) ) ) ; b . add ( com . allanbank . mongodb . client . callback . CURSOR_ID_FIELD , cursorId ) ; b . add ( com . allanbank . mongodb . client . callback . SERVER_FIELD , myAddress ) ; b . add ( com . allanbank . mongodb . client . callback . LIMIT_FIELD , myLimit ) ; b . add ( com . allanbank . mongodb . client . callback . BATCH_SIZE_FIELD , myBatchSize ) ; return b . build ( ) ; } return null ; }", "testMethod": "testAsDocument ( ) { final com . allanbank . mongodb . bson . Document doc = new com . allanbank . mongodb . bson . impl . EmptyDocument ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( doc . asDocument ( ) , org . hamcrest . CoreMatchers . is ( doc ) )", "total": "testAsDocument ( ) { final com . allanbank . mongodb . bson . Document doc = new com . allanbank . mongodb . bson . impl . EmptyDocument ( ) ; \"<AssertPlaceHolder>\" ; } asDocument ( ) { final long cursorId = myCursorId ; if ( cursorId != 0 ) { final com . allanbank . mongodb . bson . builder . DocumentBuilder b = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; b . add ( com . allanbank . mongodb . client . callback . NAME_SPACE_FIELD , ( ( ( myDatabaseName ) + \".\" ) + ( myCollectionName ) ) ) ; b . add ( com . allanbank . mongodb . client . callback . CURSOR_ID_FIELD , cursorId ) ; b . add ( com . allanbank . mongodb . client . callback . SERVER_FIELD , myAddress ) ; b . add ( com . allanbank . mongodb . client . callback . LIMIT_FIELD , myLimit ) ; b . add ( com . allanbank . mongodb . client . callback . BATCH_SIZE_FIELD , myBatchSize ) ; return b . build ( ) ; } return null ; }", "answer": "org . junit . Assert . assertThat ( doc . asDocument ( ) , org . hamcrest . CoreMatchers . is ( doc ) )"}
{"focal": "convert ( java . lang . String ) { java . util . regex . Matcher m = org . springframework . cloud . stream . module . gemfire . InetSocketAddressConverterConfiguration . InetSocketAddressConverter . HOST_AND_PORT_PATTERN . matcher ( hostAddress ) ; if ( m . matches ( ) ) { java . lang . String host = m . group ( 1 ) ; int port = java . lang . Integer . parseInt ( m . group ( 2 ) ) ; return new java . net . InetSocketAddress ( host , port ) ; } throw new java . lang . IllegalArgumentException ( java . lang . String . format ( \"%s<sp>is<sp>not<sp>a<sp>valid<sp>[host]:[port]<sp>value.\" , hostAddress ) ) ; }", "testMethod": "noValue ( ) { java . util . Map < java . lang . String , java . lang . String > result = converter . convert ( \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "noValue ( ) { java . util . Map < java . lang . String , java . lang . String > result = converter . convert ( \"\" ) ; \"<AssertPlaceHolder>\" ; } convert ( java . lang . String ) { java . util . regex . Matcher m = org . springframework . cloud . stream . module . gemfire . InetSocketAddressConverterConfiguration . InetSocketAddressConverter . HOST_AND_PORT_PATTERN . matcher ( hostAddress ) ; if ( m . matches ( ) ) { java . lang . String host = m . group ( 1 ) ; int port = java . lang . Integer . parseInt ( m . group ( 2 ) ) ; return new java . net . InetSocketAddress ( host , port ) ; } throw new java . lang . IllegalArgumentException ( java . lang . String . format ( \"%s<sp>is<sp>not<sp>a<sp>valid<sp>[host]:[port]<sp>value.\" , hostAddress ) ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "generate ( java . lang . String , java . util . Map ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( line ) ; java . util . regex . Matcher m = vkaretko . SimpleGenerator . PATTERN . matcher ( sb ) ; java . util . HashSet < java . lang . String > keySetFromLine = new java . util . HashSet ( ) ; while ( m . find ( ) ) { keySetFromLine . add ( m . group ( 0 ) ) ; if ( keyMap . containsKey ( m . group ( 0 ) ) ) { sb . replace ( m . start ( ) , m . end ( ) , keyMap . get ( m . group ( 0 ) ) ) ; } else { throw new vkaretko . NoKeyException ( \"Error:<sp>no<sp>Key<sp>in<sp>Map\" ) ; } m . reset ( sb ) ; } if ( ( keySetFromLine . size ( ) ) != ( keyMap . size ( ) ) ) { throw new vkaretko . WrongKeyException ( \"Error:<sp>Map<sp>has<sp>unnecessary<sp>key\" ) ; } return sb . toString ( ) ; }", "testMethod": "whenReplaceKeyInLineWithProperKeyMapThenResultLineWithReplacedWord ( ) { final java . lang . String lineToReplace = \"How<sp>${are}<sp>you<sp>${are}?<sp>${g}\" ; final java . lang . String expectedResult = \"How<sp>do<sp>you<sp>do?<sp>good\" ; try { java . lang . String result = generator . generate ( lineToReplace , keyMap ) ; \"<AssertPlaceHolder>\" ; } catch ( vkaretko . NoKeyException | vkaretko . WrongKeyException nke ) { nke . printStackTrace ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( expectedResult ) )", "total": "whenReplaceKeyInLineWithProperKeyMapThenResultLineWithReplacedWord ( ) { final java . lang . String lineToReplace = \"How<sp>${are}<sp>you<sp>${are}?<sp>${g}\" ; final java . lang . String expectedResult = \"How<sp>do<sp>you<sp>do?<sp>good\" ; try { java . lang . String result = generator . generate ( lineToReplace , keyMap ) ; \"<AssertPlaceHolder>\" ; } catch ( vkaretko . NoKeyException | vkaretko . WrongKeyException nke ) { nke . printStackTrace ( ) ; } } generate ( java . lang . String , java . util . Map ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( line ) ; java . util . regex . Matcher m = vkaretko . SimpleGenerator . PATTERN . matcher ( sb ) ; java . util . HashSet < java . lang . String > keySetFromLine = new java . util . HashSet ( ) ; while ( m . find ( ) ) { keySetFromLine . add ( m . group ( 0 ) ) ; if ( keyMap . containsKey ( m . group ( 0 ) ) ) { sb . replace ( m . start ( ) , m . end ( ) , keyMap . get ( m . group ( 0 ) ) ) ; } else { throw new vkaretko . NoKeyException ( \"Error:<sp>no<sp>Key<sp>in<sp>Map\" ) ; } m . reset ( sb ) ; } if ( ( keySetFromLine . size ( ) ) != ( keyMap . size ( ) ) ) { throw new vkaretko . WrongKeyException ( \"Error:<sp>Map<sp>has<sp>unnecessary<sp>key\" ) ; } return sb . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( expectedResult ) )"}
{"focal": "toString ( ) { return java . text . MessageFormat . format ( \"[{0}]<sp>{1}\" , name ( ) , getDescription ( ) ) ; }", "testMethod": "Super ( ) { java . lang . Class < ? > klass = getTypeDeclaration ( f . newEnumDeclaration ( null , java . util . Arrays . asList ( new com . asakusafw . utils . java . model . syntax . Attribute [ ] { f . newModifier ( ModifierKind . PUBLIC ) } ) , f . newSimpleName ( \"Testing\" ) , java . util . Collections . emptyList ( ) , java . util . Arrays . asList ( new com . asakusafw . utils . java . model . syntax . EnumConstantDeclaration [ ] { f . newEnumConstantDeclaration ( null , java . util . Collections . emptyList ( ) , f . newSimpleName ( \"A\" ) , java . util . Collections . emptyList ( ) , f . newClassBody ( java . util . Arrays . asList ( new com . asakusafw . utils . java . model . syntax . TypeBodyDeclaration [ ] { toString ( returnAsString ( f . newMethodInvocationExpression ( f . newSuper ( null ) , java . util . Collections . emptyList ( ) , f . newSimpleName ( \"name\" ) , java . util . Collections . emptyList ( ) ) ) ) } ) ) ) } ) , java . util . Collections . emptyList ( ) ) ) ; java . lang . Enum < ? > constant = java . lang . Enum . valueOf ( klass . asSubclass ( com . asakusafw . utils . java . internal . model . util . Enum . class ) , \"A\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( constant . toString ( ) , is ( \"A\" ) )", "total": "Super ( ) { java . lang . Class < ? > klass = getTypeDeclaration ( f . newEnumDeclaration ( null , java . util . Arrays . asList ( new com . asakusafw . utils . java . model . syntax . Attribute [ ] { f . newModifier ( ModifierKind . PUBLIC ) } ) , f . newSimpleName ( \"Testing\" ) , java . util . Collections . emptyList ( ) , java . util . Arrays . asList ( new com . asakusafw . utils . java . model . syntax . EnumConstantDeclaration [ ] { f . newEnumConstantDeclaration ( null , java . util . Collections . emptyList ( ) , f . newSimpleName ( \"A\" ) , java . util . Collections . emptyList ( ) , f . newClassBody ( java . util . Arrays . asList ( new com . asakusafw . utils . java . model . syntax . TypeBodyDeclaration [ ] { toString ( returnAsString ( f . newMethodInvocationExpression ( f . newSuper ( null ) , java . util . Collections . emptyList ( ) , f . newSimpleName ( \"name\" ) , java . util . Collections . emptyList ( ) ) ) ) } ) ) ) } ) , java . util . Collections . emptyList ( ) ) ) ; java . lang . Enum < ? > constant = java . lang . Enum . valueOf ( klass . asSubclass ( com . asakusafw . utils . java . internal . model . util . Enum . class ) , \"A\" ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return java . text . MessageFormat . format ( \"[{0}]<sp>{1}\" , name ( ) , getDescription ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( constant . toString ( ) , is ( \"A\" ) )"}
{"focal": "getResult ( ) { return super . getResult ( ) ; }", "testMethod": "testSkipFromTwoToFour ( ) { java . lang . String content = \"name,surname,id\" ; for ( int i = 0 ; i < ( names . length ) ; ++ i ) content += ( ( ( ( \"\\n\" + ( names [ i ] ) ) + \",\" ) + ( surnames [ i ] ) ) + \",\" ) + i ; configure ( ( ( ( ( \"{source:<sp>{<sp>content:<sp>{<sp>value:<sp>'\" + content ) + \"'<sp>}<sp>},<sp>\" ) + \"extractor<sp>:<sp>{<sp>csv:<sp>{skipFrom:<sp>1,<sp>skipTo:<sp>4}<sp>},<sp>\" ) + \"loader:<sp>{<sp>test:<sp>{}<sp>}<sp>}\" ) ) ; proc . execute ( ) ; \"<AssertPlaceHolder>\" . hasSize ( ( ( names . length ) - 4 ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( getResult ( ) )", "total": "testSkipFromTwoToFour ( ) { java . lang . String content = \"name,surname,id\" ; for ( int i = 0 ; i < ( names . length ) ; ++ i ) content += ( ( ( ( \"\\n\" + ( names [ i ] ) ) + \",\" ) + ( surnames [ i ] ) ) + \",\" ) + i ; configure ( ( ( ( ( \"{source:<sp>{<sp>content:<sp>{<sp>value:<sp>'\" + content ) + \"'<sp>}<sp>},<sp>\" ) + \"extractor<sp>:<sp>{<sp>csv:<sp>{skipFrom:<sp>1,<sp>skipTo:<sp>4}<sp>},<sp>\" ) + \"loader:<sp>{<sp>test:<sp>{}<sp>}<sp>}\" ) ) ; proc . execute ( ) ; \"<AssertPlaceHolder>\" . hasSize ( ( ( names . length ) - 4 ) ) ; } getResult ( ) { return super . getResult ( ) ; }", "answer": "org . junit . Assert . assertThat ( getResult ( ) )"}
{"focal": "getFileCharsetName ( net . pms . util . File ) { if ( file == null ) { return null ; } com . ibm . icu . text . CharsetMatch match = net . pms . util . FileUtil . getFileCharsetMatch ( file ) ; try { if ( java . nio . charset . Charset . isSupported ( match . getName ( ) ) ) { net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return match . getName ( ) . toUpperCase ( Locale . ROOT ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\",<sp>but<sp>cannot<sp>use<sp>it<sp>because<sp>it\\'s<sp>not<sp>supported<sp>by<sp>the<sp>Java<sp>Virual<sp>Machine\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return null ; } catch ( java . nio . charset . IllegalCharsetNameException e ) { net . pms . util . FileUtil . LOGGER . debug ( \"Illegal<sp>charset<sp>\\\"{}\\\"<sp>deteceted<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Found<sp>no<sp>matching<sp>charset<sp>for<sp>file<sp>\\\"{}\\\"\" , file . getAbsolutePath ( ) ) ; return null ; }", "testMethod": "testGetFileCharset_UTF32_BE ( ) { java . io . File file = org . apache . commons . io . FileUtils . toFile ( CLASS . getResource ( \"russian-utf32-be.srt\" ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( net . pms . util . CHARSET_UTF_32BE ) ; }", "assertLine": "org . junit . Assert . assertThat ( net . pms . util . FileUtil . getFileCharsetName ( file ) )", "total": "testGetFileCharset_UTF32_BE ( ) { java . io . File file = org . apache . commons . io . FileUtils . toFile ( CLASS . getResource ( \"russian-utf32-be.srt\" ) ) ; \"<AssertPlaceHolder>\" . isEqualTo ( net . pms . util . CHARSET_UTF_32BE ) ; } getFileCharsetName ( net . pms . util . File ) { if ( file == null ) { return null ; } com . ibm . icu . text . CharsetMatch match = net . pms . util . FileUtil . getFileCharsetMatch ( file ) ; try { if ( java . nio . charset . Charset . isSupported ( match . getName ( ) ) ) { net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return match . getName ( ) . toUpperCase ( Locale . ROOT ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Detected<sp>charset<sp>\\\"{}\\\"<sp>in<sp>file<sp>\\\"{}\\\",<sp>but<sp>cannot<sp>use<sp>it<sp>because<sp>it\\'s<sp>not<sp>supported<sp>by<sp>the<sp>Java<sp>Virual<sp>Machine\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; return null ; } catch ( java . nio . charset . IllegalCharsetNameException e ) { net . pms . util . FileUtil . LOGGER . debug ( \"Illegal<sp>charset<sp>\\\"{}\\\"<sp>deteceted<sp>in<sp>file<sp>\\\"{}\\\"\" , match . getName ( ) , file . getAbsolutePath ( ) ) ; } net . pms . util . FileUtil . LOGGER . debug ( \"Found<sp>no<sp>matching<sp>charset<sp>for<sp>file<sp>\\\"{}\\\"\" , file . getAbsolutePath ( ) ) ; return null ; }", "answer": "org . junit . Assert . assertThat ( net . pms . util . FileUtil . getFileCharsetName ( file ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "size2 ( ) { int actual = sut . size ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "size2 ( ) { int actual = sut . size ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testisIsOpaqueEnabled ( ) { result2 = org . onosproject . ospf . protocol . util . OspfUtil . isOpaqueEnabled ( 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testisIsOpaqueEnabled ( ) { result2 = org . onosproject . ospf . protocol . util . OspfUtil . isOpaqueEnabled ( 2 ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result2 , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldCountCustomMethodForContains ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity . setId ( documentId ) ; sampleEntity . setType ( \"test\" ) ; sampleEntity . setRate ( 10 ) ; sampleEntity . setMessage ( \"foo\" ) ; repository . save ( sampleEntity ) ; documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId ) ; sampleEntity2 . setType ( \"test\" ) ; sampleEntity2 . setRate ( 10 ) ; sampleEntity2 . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity2 ) ; long count = repository . countByMessageContaining ( \"fo\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )", "total": "shouldCountCustomMethodForContains ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity . setId ( documentId ) ; sampleEntity . setType ( \"test\" ) ; sampleEntity . setRate ( 10 ) ; sampleEntity . setMessage ( \"foo\" ) ; repository . save ( sampleEntity ) ; documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId ) ; sampleEntity2 . setType ( \"test\" ) ; sampleEntity2 . setRate ( 10 ) ; sampleEntity2 . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity2 ) ; long count = repository . countByMessageContaining ( \"fo\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )"}
{"focal": "resolveResources ( java . util . List ) { try { log . debug ( \"Resolving<sp>resources<sp>overrides<sp>and<sp>merges<sp>in<sp>[{}]\" , resourcesRoot ) ; java . util . List < com . github . swissquote . carnotzet . core . CarnotzetModule > processedModules = new java . util . ArrayList ( ) ; for ( com . github . swissquote . carnotzet . core . CarnotzetModule module : modules ) { processedModules . add ( module ) ; copyOwnResources ( processedModules , module ) ; mergeFiles ( processedModules , module ) ; overrideFiles ( processedModules , module ) ; } } catch ( java . io . IOException ex ) { throw new java . io . UncheckedIOException ( ( \"Resolve<sp>module<sp>resources<sp>\" + ex ) , ex ) ; } }", "testMethod": "merge_files ( ) { java . net . URL url = java . lang . Thread . currentThread ( ) . getContextClassLoader ( ) . getResource ( \"example_merge\" ) ; java . io . File example = new java . io . File ( url . getPath ( ) ) ; java . nio . file . Path resources = temp . newFolder ( ) . toPath ( ) ; org . apache . commons . io . FileUtils . copyDirectory ( example , resources . toFile ( ) ) ; com . github . swissquote . carnotzet . core . maven . ResourcesManager manager = new com . github . swissquote . carnotzet . core . maven . ResourcesManager ( resources , null ) ; java . util . List < com . github . swissquote . carnotzet . core . CarnotzetModule > modules = java . util . Arrays . asList ( com . github . swissquote . carnotzet . core . CarnotzetModule . builder ( ) . name ( \"service3\" ) . serviceId ( \"service3\" ) . build ( ) , com . github . swissquote . carnotzet . core . CarnotzetModule . builder ( ) . name ( \"service2\" ) . serviceId ( \"service2\" ) . build ( ) , com . github . swissquote . carnotzet . core . CarnotzetModule . builder ( ) . name ( \"service1\" ) . serviceId ( \"service1\" ) . build ( ) ) ; manager . resolveResources ( modules ) ; com . fasterxml . jackson . databind . ObjectMapper mapper = new com . fasterxml . jackson . databind . ObjectMapper ( ) ; com . fasterxml . jackson . databind . JsonNode service3datadesired = mapper . readTree ( resources . resolve ( \"desired/service3/files/data.json\" ) . toFile ( ) ) ; com . fasterxml . jackson . databind . JsonNode service3dataresolved = mapper . readTree ( resources . resolve ( \"resolved/service3/files/data.json\" ) . toFile ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( service3dataresolved . equals ( service3datadesired ) , org . hamcrest . core . Is . is ( true ) )", "total": "merge_files ( ) { java . net . URL url = java . lang . Thread . currentThread ( ) . getContextClassLoader ( ) . getResource ( \"example_merge\" ) ; java . io . File example = new java . io . File ( url . getPath ( ) ) ; java . nio . file . Path resources = temp . newFolder ( ) . toPath ( ) ; org . apache . commons . io . FileUtils . copyDirectory ( example , resources . toFile ( ) ) ; com . github . swissquote . carnotzet . core . maven . ResourcesManager manager = new com . github . swissquote . carnotzet . core . maven . ResourcesManager ( resources , null ) ; java . util . List < com . github . swissquote . carnotzet . core . CarnotzetModule > modules = java . util . Arrays . asList ( com . github . swissquote . carnotzet . core . CarnotzetModule . builder ( ) . name ( \"service3\" ) . serviceId ( \"service3\" ) . build ( ) , com . github . swissquote . carnotzet . core . CarnotzetModule . builder ( ) . name ( \"service2\" ) . serviceId ( \"service2\" ) . build ( ) , com . github . swissquote . carnotzet . core . CarnotzetModule . builder ( ) . name ( \"service1\" ) . serviceId ( \"service1\" ) . build ( ) ) ; manager . resolveResources ( modules ) ; com . fasterxml . jackson . databind . ObjectMapper mapper = new com . fasterxml . jackson . databind . ObjectMapper ( ) ; com . fasterxml . jackson . databind . JsonNode service3datadesired = mapper . readTree ( resources . resolve ( \"desired/service3/files/data.json\" ) . toFile ( ) ) ; com . fasterxml . jackson . databind . JsonNode service3dataresolved = mapper . readTree ( resources . resolve ( \"resolved/service3/files/data.json\" ) . toFile ( ) ) ; \"<AssertPlaceHolder>\" ; } resolveResources ( java . util . List ) { try { log . debug ( \"Resolving<sp>resources<sp>overrides<sp>and<sp>merges<sp>in<sp>[{}]\" , resourcesRoot ) ; java . util . List < com . github . swissquote . carnotzet . core . CarnotzetModule > processedModules = new java . util . ArrayList ( ) ; for ( com . github . swissquote . carnotzet . core . CarnotzetModule module : modules ) { processedModules . add ( module ) ; copyOwnResources ( processedModules , module ) ; mergeFiles ( processedModules , module ) ; overrideFiles ( processedModules , module ) ; } } catch ( java . io . IOException ex ) { throw new java . io . UncheckedIOException ( ( \"Resolve<sp>module<sp>resources<sp>\" + ex ) , ex ) ; } }", "answer": "org . junit . Assert . assertThat ( service3dataresolved . equals ( service3datadesired ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "linkDestinationIpAddress ( ) { return linkDestinationIpAddress ; }", "testMethod": "testSetLinkDestinationIpAddress ( ) { linkInformation . setLinkDestinationIpAddress ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( linkInformation . linkDestinationIpAddress ( ) , org . hamcrest . CoreMatchers . is ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) )", "total": "testSetLinkDestinationIpAddress ( ) { linkInformation . setLinkDestinationIpAddress ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) ; \"<AssertPlaceHolder>\" ; } linkDestinationIpAddress ( ) { return linkDestinationIpAddress ; }", "answer": "org . junit . Assert . assertThat ( linkInformation . linkDestinationIpAddress ( ) , org . hamcrest . CoreMatchers . is ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) )"}
{"focal": "contains ( org . joda . time . Interval ) { return ( this . interval . contains ( interval ) ) || ( isZeroDurationAtEndOfThisInterval ( interval ) ) ; }", "testMethod": "mergerKeepsOverlappingUpdateBroadcastAtStartOfInterval ( ) { org . atlasapi . query . content . merge . BroadcastMerger merger = org . atlasapi . query . content . merge . BroadcastMerger . parse ( \"\\\"channelUri\\\"|\\\"2016-01-05T00:00:00Z\\\"|\\\"2016-01-06T00:00:00Z\\\"\" ) ; org . atlasapi . media . entity . Broadcast broadcast = new org . atlasapi . media . entity . Broadcast ( \"channelUri\" , new org . joda . time . DateTime ( 2016 , 1 , 5 , 0 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) , new org . joda . time . DateTime ( 2016 , 1 , 5 , 2 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) ) ; com . google . common . collect . ImmutableSet < org . atlasapi . media . entity . Broadcast > merge = merger . merge ( com . google . common . collect . ImmutableSet . of ( broadcast ) , com . google . common . collect . ImmutableSet . of ( ) , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( merge . contains ( broadcast ) , org . hamcrest . core . Is . is ( true ) )", "total": "mergerKeepsOverlappingUpdateBroadcastAtStartOfInterval ( ) { org . atlasapi . query . content . merge . BroadcastMerger merger = org . atlasapi . query . content . merge . BroadcastMerger . parse ( \"\\\"channelUri\\\"|\\\"2016-01-05T00:00:00Z\\\"|\\\"2016-01-06T00:00:00Z\\\"\" ) ; org . atlasapi . media . entity . Broadcast broadcast = new org . atlasapi . media . entity . Broadcast ( \"channelUri\" , new org . joda . time . DateTime ( 2016 , 1 , 5 , 0 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) , new org . joda . time . DateTime ( 2016 , 1 , 5 , 2 , 0 , 0 , org . joda . time . DateTimeZone . UTC ) ) ; com . google . common . collect . ImmutableSet < org . atlasapi . media . entity . Broadcast > merge = merger . merge ( com . google . common . collect . ImmutableSet . of ( broadcast ) , com . google . common . collect . ImmutableSet . of ( ) , true ) ; \"<AssertPlaceHolder>\" ; } contains ( org . joda . time . Interval ) { return ( this . interval . contains ( interval ) ) || ( isZeroDurationAtEndOfThisInterval ( interval ) ) ; }", "answer": "org . junit . Assert . assertThat ( merge . contains ( broadcast ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "readAll ( boolean ) { if ( beanMappingCache . getOriginal ( ) . isHeader ( ) ) { try { getHeader ( true ) ; } catch ( com . github . mygreen . supercsv . exception . SuperCsvNoMatchColumnSizeException | com . github . mygreen . supercsv . exception . SuperCsvNoMatchHeaderException e ) { if ( ! continueOnError ) { throw e ; } } } final java . util . List < T > list = new java . util . ArrayList ( ) ; while ( true ) { try { final T record = com . github . mygreen . supercsv . io . CsvAnnotationBeanReader . read ( ) ; if ( record == null ) { break ; } list . add ( record ) ; } catch ( com . github . mygreen . supercsv . exception . SuperCsvNoMatchColumnSizeException | com . github . mygreen . supercsv . exception . SuperCsvBindingException e ) { if ( ! continueOnError ) { throw e ; } } } return list ; }", "testMethod": "testRead ( ) { com . github . mygreen . supercsv . io . CsvAnnotationBeanReader < com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv > csvReader = new com . github . mygreen . supercsv . io . CsvAnnotationBeanReader ( com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv . class , new java . io . StringReader ( com . github . mygreen . supercsv . builder . CallbackMethodTest . TEST_CSV ) , org . supercsv . prefs . CsvPreference . STANDARD_PREFERENCE , com . github . mygreen . supercsv . builder . CallbackMethodTest . Group1 . class , com . github . mygreen . supercsv . builder . CallbackMethodTest . Group2 . class ) ; java . util . List < com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv > list = csvReader . readAll ( false ) ; for ( com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv record : list ) { \"<AssertPlaceHolder>\" . containsExactly ( \"method::handlePreRead-null\" , \"listener::handlePreRead-null\" , ( \"validate::validate-\" + ( record . getId ( ) ) ) , ( \"method::handlePostRead-\" + ( record . getId ( ) ) ) , ( \"listener::handlePostRead-\" + ( record . getId ( ) ) ) ) ; } csvReader . close ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( record . messages )", "total": "testRead ( ) { com . github . mygreen . supercsv . io . CsvAnnotationBeanReader < com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv > csvReader = new com . github . mygreen . supercsv . io . CsvAnnotationBeanReader ( com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv . class , new java . io . StringReader ( com . github . mygreen . supercsv . builder . CallbackMethodTest . TEST_CSV ) , org . supercsv . prefs . CsvPreference . STANDARD_PREFERENCE , com . github . mygreen . supercsv . builder . CallbackMethodTest . Group1 . class , com . github . mygreen . supercsv . builder . CallbackMethodTest . Group2 . class ) ; java . util . List < com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv > list = csvReader . readAll ( false ) ; for ( com . github . mygreen . supercsv . builder . CallbackMethodTest . TestCsv record : list ) { \"<AssertPlaceHolder>\" . containsExactly ( \"method::handlePreRead-null\" , \"listener::handlePreRead-null\" , ( \"validate::validate-\" + ( record . getId ( ) ) ) , ( \"method::handlePostRead-\" + ( record . getId ( ) ) ) , ( \"listener::handlePostRead-\" + ( record . getId ( ) ) ) ) ; } csvReader . close ( ) ; } readAll ( boolean ) { if ( beanMappingCache . getOriginal ( ) . isHeader ( ) ) { try { getHeader ( true ) ; } catch ( com . github . mygreen . supercsv . exception . SuperCsvNoMatchColumnSizeException | com . github . mygreen . supercsv . exception . SuperCsvNoMatchHeaderException e ) { if ( ! continueOnError ) { throw e ; } } } final java . util . List < T > list = new java . util . ArrayList ( ) ; while ( true ) { try { final T record = com . github . mygreen . supercsv . io . CsvAnnotationBeanReader . read ( ) ; if ( record == null ) { break ; } list . add ( record ) ; } catch ( com . github . mygreen . supercsv . exception . SuperCsvNoMatchColumnSizeException | com . github . mygreen . supercsv . exception . SuperCsvBindingException e ) { if ( ! continueOnError ) { throw e ; } } } return list ; }", "answer": "org . junit . Assert . assertThat ( record . messages )"}
{"focal": "matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "testMethod": "testCoberturaMethodWithWildcards ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"japicmp.*#__cobertura*()\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test\" ) . addToClassPool ( classPool ) ; javassist . CtMethod ctMethod = japicmp . util . CtMethodBuilder . create ( ) . name ( \"__cobertura_classmap\" ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( filter . matches ( ctMethod ) , org . hamcrest . core . Is . is ( true ) )", "total": "testCoberturaMethodWithWildcards ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"japicmp.*#__cobertura*()\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test\" ) . addToClassPool ( classPool ) ; javassist . CtMethod ctMethod = japicmp . util . CtMethodBuilder . create ( ) . name ( \"__cobertura_classmap\" ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; } matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "answer": "org . junit . Assert . assertThat ( filter . matches ( ctMethod ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "validateSqlQueryTabularInputs ( java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String ) { final java . util . List < java . lang . String > validationList = io . cloudslang . content . database . utils . SQLInputsValidator . validateCommonSqlInputs ( dbServerName , dbType , username , password , instance , dbPort , database , authenticationType , trustAllRoots , trustStore , trustStorePassword , resultSetType , resultSetConcurrency , authLibraryPath ) ; io . cloudslang . content . database . utils . SQLInputsValidator . validateNoneEmpty ( command , io . cloudslang . content . database . utils . INVALID_COMMAND , validationList ) ; io . cloudslang . content . database . utils . SQLInputsValidator . validateTimeout ( timeout , validationList ) ; return validationList ; }", "testMethod": "validateSqlQueryTabularInputsValid ( ) { final java . util . List < java . lang . String > validationList = validateSqlQueryTabularInputs ( \"1\" , io . cloudslang . content . database . utils . MSSQL_DB_TYPE , \"username\" , \"Password\" , \"someInstance\" , \"123\" , \"database\" , io . cloudslang . content . database . utils . AUTH_SQL , \"Command\" , \"true\" , org . apache . commons . lang3 . StringUtils . EMPTY , org . apache . commons . lang3 . StringUtils . EMPTY , \"1\" , io . cloudslang . content . database . utils . TYPE_FORWARD_ONLY , io . cloudslang . content . database . utils . CONCUR_READ_ONLY , org . apache . commons . lang3 . StringUtils . EMPTY ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( validationList , org . hamcrest . CoreMatchers . is ( java . util . Collections . < java . lang . String > emptyList ( ) ) )", "total": "validateSqlQueryTabularInputsValid ( ) { final java . util . List < java . lang . String > validationList = validateSqlQueryTabularInputs ( \"1\" , io . cloudslang . content . database . utils . MSSQL_DB_TYPE , \"username\" , \"Password\" , \"someInstance\" , \"123\" , \"database\" , io . cloudslang . content . database . utils . AUTH_SQL , \"Command\" , \"true\" , org . apache . commons . lang3 . StringUtils . EMPTY , org . apache . commons . lang3 . StringUtils . EMPTY , \"1\" , io . cloudslang . content . database . utils . TYPE_FORWARD_ONLY , io . cloudslang . content . database . utils . CONCUR_READ_ONLY , org . apache . commons . lang3 . StringUtils . EMPTY ) ; \"<AssertPlaceHolder>\" ; } validateSqlQueryTabularInputs ( java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String , java . lang . String ) { final java . util . List < java . lang . String > validationList = io . cloudslang . content . database . utils . SQLInputsValidator . validateCommonSqlInputs ( dbServerName , dbType , username , password , instance , dbPort , database , authenticationType , trustAllRoots , trustStore , trustStorePassword , resultSetType , resultSetConcurrency , authLibraryPath ) ; io . cloudslang . content . database . utils . SQLInputsValidator . validateNoneEmpty ( command , io . cloudslang . content . database . utils . INVALID_COMMAND , validationList ) ; io . cloudslang . content . database . utils . SQLInputsValidator . validateTimeout ( timeout , validationList ) ; return validationList ; }", "answer": "org . junit . Assert . assertThat ( validationList , org . hamcrest . CoreMatchers . is ( java . util . Collections . < java . lang . String > emptyList ( ) ) )"}
{"focal": "skipLastSlash ( java . lang . String ) { if ( ! ( uri . endsWith ( \"/\" ) ) ) { return uri ; } return uri . substring ( 0 , uri . lastIndexOf ( \"/\" ) ) ; }", "testMethod": "skipLastSlashWithExistingSlash ( ) { java . lang . String expected = \"hey\" ; java . lang . String origin = \"hey/\" ; java . lang . String actual = this . cut . skipLastSlash ( origin ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "skipLastSlashWithExistingSlash ( ) { java . lang . String expected = \"hey\" ; java . lang . String origin = \"hey/\" ; java . lang . String actual = this . cut . skipLastSlash ( origin ) ; \"<AssertPlaceHolder>\" ; } skipLastSlash ( java . lang . String ) { if ( ! ( uri . endsWith ( \"/\" ) ) ) { return uri ; } return uri . substring ( 0 , uri . lastIndexOf ( \"/\" ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getAlpha3 ( ) { return alpha3 ; }", "testMethod": "getByCodeWithAlpha3CodeShouldReturnCountryCode ( ) { for ( org . iban4j . CountryCode code : org . iban4j . CountryCode . values ( ) ) { org . iban4j . CountryCode newCode = org . iban4j . CountryCode . getByCode ( code . getAlpha3 ( ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( newCode , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( code ) ) )", "total": "getByCodeWithAlpha3CodeShouldReturnCountryCode ( ) { for ( org . iban4j . CountryCode code : org . iban4j . CountryCode . values ( ) ) { org . iban4j . CountryCode newCode = org . iban4j . CountryCode . getByCode ( code . getAlpha3 ( ) ) ; \"<AssertPlaceHolder>\" ; } } getAlpha3 ( ) { return alpha3 ; }", "answer": "org . junit . Assert . assertThat ( newCode , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( code ) ) )"}
{"focal": "hasEnoughNodes ( ) { return ( interpreter . minNodes ( ) ) <= ( polygon . size ( ) ) ; }", "testMethod": "hasEnoughNodes_BUILDING_false ( ) { polygon . clear ( ) ; touchview . setInterpretationType ( InterpretationType . BUILDING ) ; polygon . add ( point1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( touchview . hasEnoughNodes ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "hasEnoughNodes_BUILDING_false ( ) { polygon . clear ( ) ; touchview . setInterpretationType ( InterpretationType . BUILDING ) ; polygon . add ( point1 ) ; \"<AssertPlaceHolder>\" ; } hasEnoughNodes ( ) { return ( interpreter . minNodes ( ) ) <= ( polygon . size ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( touchview . hasEnoughNodes ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "testLezenBlobBestaandeBlob ( ) { final java . lang . Integer persoonId = 2000001 ; final org . springframework . transaction . TransactionStatus transactieStatus = zorgDatAfnemerindicatieBlobBestaatInTransactie ( persoonId ) ; transactionManager . commit ( transactieStatus ) ; final java . util . Set < ? > indicaties = afnemerIndicatieBlobifierService . leesBlob ( persoonId ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( indicaties . size ( ) , org . hamcrest . Matchers . is ( 2 ) )", "total": "testLezenBlobBestaandeBlob ( ) { final java . lang . Integer persoonId = 2000001 ; final org . springframework . transaction . TransactionStatus transactieStatus = zorgDatAfnemerindicatieBlobBestaatInTransactie ( persoonId ) ; transactionManager . commit ( transactieStatus ) ; final java . util . Set < ? > indicaties = afnemerIndicatieBlobifierService . leesBlob ( persoonId ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( indicaties . size ( ) , org . hamcrest . Matchers . is ( 2 ) )"}
{"focal": "passesCrlCheck ( java . security . cert . X509Certificate [ ] ) { if ( ( org . codice . ddf . security . handler . pki . CrlChecker . crlCache . get ( ) ) == null ) { java . lang . String errorMsg = \"CRL<sp>is<sp>not<sp>set.<sp>Skipping<sp>CRL<sp>check\" ; org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( errorMsg ) ; return true ; } org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( \"Checking<sp>request<sp>certs<sp>against<sp>CRL.\" ) ; return passesCrl ( certs ) ; }", "testMethod": "testEnabledCrlFileNullCertsPass ( ) { org . codice . ddf . security . handler . pki . CrlChecker crlChecker = getConfiguredCrlChecker ( \"encryption-crl-revoked.properties\" ) ; java . security . cert . X509Certificate [ ] certs = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( crlChecker . passesCrlCheck ( certs ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "testEnabledCrlFileNullCertsPass ( ) { org . codice . ddf . security . handler . pki . CrlChecker crlChecker = getConfiguredCrlChecker ( \"encryption-crl-revoked.properties\" ) ; java . security . cert . X509Certificate [ ] certs = null ; \"<AssertPlaceHolder>\" ; } passesCrlCheck ( java . security . cert . X509Certificate [ ] ) { if ( ( org . codice . ddf . security . handler . pki . CrlChecker . crlCache . get ( ) ) == null ) { java . lang . String errorMsg = \"CRL<sp>is<sp>not<sp>set.<sp>Skipping<sp>CRL<sp>check\" ; org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( errorMsg ) ; return true ; } org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( \"Checking<sp>request<sp>certs<sp>against<sp>CRL.\" ) ; return passesCrl ( certs ) ; }", "answer": "org . junit . Assert . assertThat ( crlChecker . passesCrlCheck ( certs ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "chargeAdjunctText ( int , int ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; if ( unpaired == 1 ) { if ( charge != 0 ) { sb . append ( '(' ) . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) . append ( ')' ) ; } else { sb . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) ; } } else if ( unpaired > 1 ) { if ( charge != 0 ) { sb . append ( '(' ) . append ( unpaired ) . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) . append ( ')' ) ; } else { sb . append ( unpaired ) . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) ; } } final char sign = ( charge < 0 ) ? org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . MINUS : org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . PLUS ; final int coefficient = java . lang . Math . abs ( charge ) ; if ( coefficient > 1 ) sb . append ( coefficient ) ; if ( coefficient > 0 ) sb . append ( sign ) ; return sb . toString ( ) ; }", "testMethod": "radical ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . chargeAdjunctText ( 0 , 1 ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "radical ( ) { \"<AssertPlaceHolder>\" ; } chargeAdjunctText ( int , int ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; if ( unpaired == 1 ) { if ( charge != 0 ) { sb . append ( '(' ) . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) . append ( ')' ) ; } else { sb . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) ; } } else if ( unpaired > 1 ) { if ( charge != 0 ) { sb . append ( '(' ) . append ( unpaired ) . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) . append ( ')' ) ; } else { sb . append ( unpaired ) . append ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . BULLET ) ; } } final char sign = ( charge < 0 ) ? org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . MINUS : org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . PLUS ; final int coefficient = java . lang . Math . abs ( charge ) ; if ( coefficient > 1 ) sb . append ( coefficient ) ; if ( coefficient > 0 ) sb . append ( sign ) ; return sb . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . openscience . cdk . renderer . generators . standard . StandardAtomGenerator . chargeAdjunctText ( 0 , 1 ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "isDurable ( org . apache . geode . cache . client . ClientCache ) { return java . util . Optional . ofNullable ( clientCache ) . < org . apache . geode . distributed . DistributedSystem > map ( org . springframework . data . gemfire . util . CacheUtils :: getDistributedSystem ) . filter ( DistributedSystem :: isConnected ) . map ( DistributedSystem :: getProperties ) . map ( ( properties ) -> properties . getProperty ( org . springframework . data . gemfire . util . DURABLE_CLIENT_ID_PROPERTY_NAME , null ) ) . filter ( StringUtils :: hasText ) . isPresent ( ) ; }", "testMethod": "isDurableWithNonDurableClientIsFalse ( ) { org . apache . geode . cache . client . ClientCache mockClientCache = mock ( org . apache . geode . cache . client . ClientCache . class ) ; org . apache . geode . distributed . DistributedSystem mockDistributedSystem = mock ( org . apache . geode . distributed . DistributedSystem . class ) ; java . util . Properties gemfireProperties = new java . util . Properties ( ) ; gemfireProperties . setProperty ( GemfireUtils . DURABLE_CLIENT_ID_PROPERTY_NAME , \"<sp>\" ) ; when ( mockClientCache . getDistributedSystem ( ) ) . thenReturn ( mockDistributedSystem ) ; when ( mockDistributedSystem . isConnected ( ) ) . thenReturn ( true ) ; when ( mockDistributedSystem . getProperties ( ) ) . thenReturn ( gemfireProperties ) ; \"<AssertPlaceHolder>\" ; verify ( mockClientCache , times ( 1 ) ) . getDistributedSystem ( ) ; verify ( mockDistributedSystem , times ( 1 ) ) . isConnected ( ) ; verify ( mockDistributedSystem , times ( 1 ) ) . getProperties ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( org . springframework . data . gemfire . GemfireUtils . isDurable ( mockClientCache ) , org . hamcrest . Matchers . is ( false ) )", "total": "isDurableWithNonDurableClientIsFalse ( ) { org . apache . geode . cache . client . ClientCache mockClientCache = mock ( org . apache . geode . cache . client . ClientCache . class ) ; org . apache . geode . distributed . DistributedSystem mockDistributedSystem = mock ( org . apache . geode . distributed . DistributedSystem . class ) ; java . util . Properties gemfireProperties = new java . util . Properties ( ) ; gemfireProperties . setProperty ( GemfireUtils . DURABLE_CLIENT_ID_PROPERTY_NAME , \"<sp>\" ) ; when ( mockClientCache . getDistributedSystem ( ) ) . thenReturn ( mockDistributedSystem ) ; when ( mockDistributedSystem . isConnected ( ) ) . thenReturn ( true ) ; when ( mockDistributedSystem . getProperties ( ) ) . thenReturn ( gemfireProperties ) ; \"<AssertPlaceHolder>\" ; verify ( mockClientCache , times ( 1 ) ) . getDistributedSystem ( ) ; verify ( mockDistributedSystem , times ( 1 ) ) . isConnected ( ) ; verify ( mockDistributedSystem , times ( 1 ) ) . getProperties ( ) ; } isDurable ( org . apache . geode . cache . client . ClientCache ) { return java . util . Optional . ofNullable ( clientCache ) . < org . apache . geode . distributed . DistributedSystem > map ( org . springframework . data . gemfire . util . CacheUtils :: getDistributedSystem ) . filter ( DistributedSystem :: isConnected ) . map ( DistributedSystem :: getProperties ) . map ( ( properties ) -> properties . getProperty ( org . springframework . data . gemfire . util . DURABLE_CLIENT_ID_PROPERTY_NAME , null ) ) . filter ( StringUtils :: hasText ) . isPresent ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . springframework . data . gemfire . GemfireUtils . isDurable ( mockClientCache ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "toLong ( java . lang . Object ) { java . util . Objects . requireNonNull ( object , \"Object<sp>cannot<sp>be<sp>null\" ) ; if ( object instanceof java . lang . Long ) { return ( ( java . lang . Long ) ( object ) ) ; } if ( object instanceof java . lang . Number ) { return ( ( java . lang . Number ) ( object ) ) . longValue ( ) ; } if ( object instanceof java . lang . String ) { try { return java . lang . Long . parseLong ( ( ( java . lang . String ) ( object ) ) ) ; } catch ( final java . lang . NumberFormatException e ) { throw new io . confluent . ksql . util . KsqlException ( ( ( \"Cannot<sp>convert<sp>\" + object ) + \"<sp>to<sp>BIGINT.\" ) , e ) ; } } throw new java . lang . IllegalArgumentException ( \"This<sp>Object<sp>doesn't<sp>represent<sp>a<sp>long\" ) ; }", "testMethod": "shouldConvertIntToLongCorrectly ( ) { final java . lang . Long l = io . confluent . ksql . serde . util . SerdeUtils . toLong ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( l , org . hamcrest . CoreMatchers . equalTo ( 1L ) )", "total": "shouldConvertIntToLongCorrectly ( ) { final java . lang . Long l = io . confluent . ksql . serde . util . SerdeUtils . toLong ( 1 ) ; \"<AssertPlaceHolder>\" ; } toLong ( java . lang . Object ) { java . util . Objects . requireNonNull ( object , \"Object<sp>cannot<sp>be<sp>null\" ) ; if ( object instanceof java . lang . Long ) { return ( ( java . lang . Long ) ( object ) ) ; } if ( object instanceof java . lang . Number ) { return ( ( java . lang . Number ) ( object ) ) . longValue ( ) ; } if ( object instanceof java . lang . String ) { try { return java . lang . Long . parseLong ( ( ( java . lang . String ) ( object ) ) ) ; } catch ( final java . lang . NumberFormatException e ) { throw new io . confluent . ksql . util . KsqlException ( ( ( \"Cannot<sp>convert<sp>\" + object ) + \"<sp>to<sp>BIGINT.\" ) , e ) ; } } throw new java . lang . IllegalArgumentException ( \"This<sp>Object<sp>doesn't<sp>represent<sp>a<sp>long\" ) ; }", "answer": "org . junit . Assert . assertThat ( l , org . hamcrest . CoreMatchers . equalTo ( 1L ) )"}
{"focal": "patternForDate ( net . time4j . format . DisplayMode , java . util . Locale ) { return net . time4j . format . CalendarText . FORMAT_PATTERN_PROVIDER . getDatePattern ( mode , locale ) ; }", "testMethod": "patternForUnsupportedLocale ( ) { java . lang . String patternXX = net . time4j . format . CalendarText . patternForDate ( DisplayMode . FULL , new java . util . Locale ( \"xx\" ) ) ; java . lang . String patternRoot = net . time4j . format . CalendarText . patternForDate ( DisplayMode . FULL , Locale . ROOT ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( patternXX , org . hamcrest . CoreMatchers . is ( patternRoot ) )", "total": "patternForUnsupportedLocale ( ) { java . lang . String patternXX = net . time4j . format . CalendarText . patternForDate ( DisplayMode . FULL , new java . util . Locale ( \"xx\" ) ) ; java . lang . String patternRoot = net . time4j . format . CalendarText . patternForDate ( DisplayMode . FULL , Locale . ROOT ) ; \"<AssertPlaceHolder>\" ; } patternForDate ( net . time4j . format . DisplayMode , java . util . Locale ) { return net . time4j . format . CalendarText . FORMAT_PATTERN_PROVIDER . getDatePattern ( mode , locale ) ; }", "answer": "org . junit . Assert . assertThat ( patternXX , org . hamcrest . CoreMatchers . is ( patternRoot ) )"}
{"focal": "parse ( java . lang . String [ ] ) { try { jCommander . parse ( args ) ; } catch ( java . lang . Exception e ) { throw new java . lang . IllegalArgumentException ( ( \"Unable<sp>to<sp>parse<sp>arguments:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) , e ) ; } if ( options . isHelp ( ) ) { return options ; } for ( org . apache . hadoop . fs . Path source : options . getSources ( ) ) { if ( ! ( source . isAbsolute ( ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Source<sp>paths<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } } if ( ! ( options . getTarget ( ) . isAbsolute ( ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Destination<sp>URI<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } if ( ( ( options . getCredentialsProvider ( ) ) != null ) && ( ! ( options . getCredentialsProvider ( ) . isAbsolute ( ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Credentials<sp>provider<sp>URI<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } if ( ( options . getMaxMaps ( ) ) <= 0 ) { options . setMaxMaps ( 1 ) ; } if ( ( ( options . getLogPath ( ) ) != null ) && ( ! ( options . getLogPath ( ) . isAbsolute ( ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Log<sp>path<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } return options ; }", "testMethod": "empty ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( parser . parse ( \"\" ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "empty ( ) { \"<AssertPlaceHolder>\" ; } parse ( java . lang . String [ ] ) { try { jCommander . parse ( args ) ; } catch ( java . lang . Exception e ) { throw new java . lang . IllegalArgumentException ( ( \"Unable<sp>to<sp>parse<sp>arguments:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) , e ) ; } if ( options . isHelp ( ) ) { return options ; } for ( org . apache . hadoop . fs . Path source : options . getSources ( ) ) { if ( ! ( source . isAbsolute ( ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Source<sp>paths<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } } if ( ! ( options . getTarget ( ) . isAbsolute ( ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Destination<sp>URI<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } if ( ( ( options . getCredentialsProvider ( ) ) != null ) && ( ! ( options . getCredentialsProvider ( ) . isAbsolute ( ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Credentials<sp>provider<sp>URI<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } if ( ( options . getMaxMaps ( ) ) <= 0 ) { options . setMaxMaps ( 1 ) ; } if ( ( ( options . getLogPath ( ) ) != null ) && ( ! ( options . getLogPath ( ) . isAbsolute ( ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Log<sp>path<sp>must<sp>be<sp>absolute:<sp>\" + ( java . util . Arrays . toString ( args ) ) ) ) ; } return options ; }", "answer": "org . junit . Assert . assertThat ( parser . parse ( \"\" ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "hasFurtherParams ( ) { return externalEntitiesIterator . hasNext ( ) ; }", "testMethod": "nullPayloadPosition ( ) { wsattacker . library . intelligentdos . helper . IterateModel iterateModel = wsattacker . library . intelligentdos . helper . IterateModel . custom ( ) . startAt ( 2 ) . stopAt ( 2 ) . build ( ) ; hashCollision . setNumberOfCollisionsIterator ( iterateModel ) ; \"<AssertPlaceHolder>\" ; hashCollision . nextParam ( ) ; hashCollision . getTamperedRequest ( \"\" , null ) ; }", "assertLine": "org . junit . Assert . assertThat ( hashCollision . hasFurtherParams ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "nullPayloadPosition ( ) { wsattacker . library . intelligentdos . helper . IterateModel iterateModel = wsattacker . library . intelligentdos . helper . IterateModel . custom ( ) . startAt ( 2 ) . stopAt ( 2 ) . build ( ) ; hashCollision . setNumberOfCollisionsIterator ( iterateModel ) ; \"<AssertPlaceHolder>\" ; hashCollision . nextParam ( ) ; hashCollision . getTamperedRequest ( \"\" , null ) ; } hasFurtherParams ( ) { return externalEntitiesIterator . hasNext ( ) ; }", "answer": "org . junit . Assert . assertThat ( hashCollision . hasFurtherParams ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "hasSameAncestor ( org . modeshape . jcr . value . Path ) { org . modeshape . common . util . CheckArg . isNotNull ( that , \"that\" ) ; if ( ( that . size ( ) ) != ( this . size ( ) ) ) return false ; if ( ( this . size ( ) ) == 1 ) return true ; for ( int i = ( this . size ( ) ) - 2 ; i >= 0 ; -- i ) { org . modeshape . jcr . value . Path . Segment thisSegment = this . getSegment ( i ) ; org . modeshape . jcr . value . Path . Segment thatSegment = that . getSegment ( i ) ; if ( ! ( thisSegment . equals ( thatSegment ) ) ) return false ; } return true ; }", "testMethod": "shouldConsiderANodeToHaveSameAncestorAsItself ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( path . hasSameAncestor ( path ) , org . hamcrest . core . Is . is ( true ) )", "total": "shouldConsiderANodeToHaveSameAncestorAsItself ( ) { \"<AssertPlaceHolder>\" ; } hasSameAncestor ( org . modeshape . jcr . value . Path ) { org . modeshape . common . util . CheckArg . isNotNull ( that , \"that\" ) ; if ( ( that . size ( ) ) != ( this . size ( ) ) ) return false ; if ( ( this . size ( ) ) == 1 ) return true ; for ( int i = ( this . size ( ) ) - 2 ; i >= 0 ; -- i ) { org . modeshape . jcr . value . Path . Segment thisSegment = this . getSegment ( i ) ; org . modeshape . jcr . value . Path . Segment thatSegment = that . getSegment ( i ) ; if ( ! ( thisSegment . equals ( thatSegment ) ) ) return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( path . hasSameAncestor ( path ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "testGeenGroepenMutatieLevering ( ) { final java . util . Set < nl . bzk . brp . model . algemeen . stamgegeven . autaut . DienstbundelGroep > dienstbundelGroepen = new java . util . HashSet ( ) ; final nl . bzk . brp . model . hisvolledig . predikaat . MagHistorieTonenPredikaat predikaat = new nl . bzk . brp . model . hisvolledig . predikaat . MagHistorieTonenPredikaat ( dienstbundelGroepen , false ) ; final java . util . Set < nl . bzk . brp . model . operationeel . kern . HisPersoonGeboorteModel > alleModellen = maakTestPersoon ( ) . getPersoonGeboorteHistorie ( ) . getHistorie ( ) ; final java . util . Collection gefilterdeModellen = org . apache . commons . collections . CollectionUtils . select ( alleModellen , predikaat ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( gefilterdeModellen . size ( ) , org . hamcrest . Matchers . is ( 1 ) )", "total": "testGeenGroepenMutatieLevering ( ) { final java . util . Set < nl . bzk . brp . model . algemeen . stamgegeven . autaut . DienstbundelGroep > dienstbundelGroepen = new java . util . HashSet ( ) ; final nl . bzk . brp . model . hisvolledig . predikaat . MagHistorieTonenPredikaat predikaat = new nl . bzk . brp . model . hisvolledig . predikaat . MagHistorieTonenPredikaat ( dienstbundelGroepen , false ) ; final java . util . Set < nl . bzk . brp . model . operationeel . kern . HisPersoonGeboorteModel > alleModellen = maakTestPersoon ( ) . getPersoonGeboorteHistorie ( ) . getHistorie ( ) ; final java . util . Collection gefilterdeModellen = org . apache . commons . collections . CollectionUtils . select ( alleModellen , predikaat ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( gefilterdeModellen . size ( ) , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "isAllowed ( ) { boolean allowed = false ; boolean canTrasmitOnWAN = ( context . getConfiguration ( ) . optBoolean ( com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . ConnectivityPolicy . ALLOW_WAN_KEY , com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . ConnectivityPolicy . ALLOW_WAN_DEFAULT ) ) && ( isWanAllowed ) ; if ( connectivity . isConnected ( ) ) { allowed = ( ( connectivity . hasWifi ( ) ) || ( connectivity . hasWired ( ) ) ) || ( ( connectivity . hasWAN ( ) ) && canTrasmitOnWAN ) ; } return allowed ; }", "testMethod": "isAllowed_enoughTimeHasPassed_policyIsTrue ( ) { when ( mockPreferences . getLong ( \"SubmissionTimePolicy.submissionTime\" , 0 ) ) . thenReturn ( ( ( java . lang . System . currentTimeMillis ( ) ) - 2000L ) ) ; com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . SubmissionTimePolicy target = new com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . SubmissionTimePolicy ( mockContext , 1000L ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . isAllowed ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "isAllowed_enoughTimeHasPassed_policyIsTrue ( ) { when ( mockPreferences . getLong ( \"SubmissionTimePolicy.submissionTime\" , 0 ) ) . thenReturn ( ( ( java . lang . System . currentTimeMillis ( ) ) - 2000L ) ) ; com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . SubmissionTimePolicy target = new com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . SubmissionTimePolicy ( mockContext , 1000L ) ; \"<AssertPlaceHolder>\" ; } isAllowed ( ) { boolean allowed = false ; boolean canTrasmitOnWAN = ( context . getConfiguration ( ) . optBoolean ( com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . ConnectivityPolicy . ALLOW_WAN_KEY , com . amazonaws . mobileconnectors . amazonmobileanalytics . internal . delivery . policy . ConnectivityPolicy . ALLOW_WAN_DEFAULT ) ) && ( isWanAllowed ) ; if ( connectivity . isConnected ( ) ) { allowed = ( ( connectivity . hasWifi ( ) ) || ( connectivity . hasWired ( ) ) ) || ( ( connectivity . hasWAN ( ) ) && canTrasmitOnWAN ) ; } return allowed ; }", "answer": "org . junit . Assert . assertThat ( target . isAllowed ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getLoadCount ( ) { return loadCount . get ( ) ; }", "testMethod": "shouldNotLoadWithNullKeyUsingLoadAll ( ) { org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > cacheLoader = new org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > ( ) ; cacheLoaderServer . setCacheLoader ( cacheLoader ) ; java . util . HashSet < java . lang . String > keys = new java . util . HashSet ( ) ; keys . add ( null ) ; try { javax . cache . integration . CompletionListenerFuture future = new javax . cache . integration . CompletionListenerFuture ( ) ; cache . loadAll ( keys , false , future ) ; org . junit . Assert . fail ( \"Expected<sp>a<sp>NullPointerException\" ) ; } catch ( java . lang . NullPointerException e ) { } finally { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( cacheLoader . getLoadCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "shouldNotLoadWithNullKeyUsingLoadAll ( ) { org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > cacheLoader = new org . jsr107 . tck . integration . RecordingCacheLoader < java . lang . String > ( ) ; cacheLoaderServer . setCacheLoader ( cacheLoader ) ; java . util . HashSet < java . lang . String > keys = new java . util . HashSet ( ) ; keys . add ( null ) ; try { javax . cache . integration . CompletionListenerFuture future = new javax . cache . integration . CompletionListenerFuture ( ) ; cache . loadAll ( keys , false , future ) ; org . junit . Assert . fail ( \"Expected<sp>a<sp>NullPointerException\" ) ; } catch ( java . lang . NullPointerException e ) { } finally { \"<AssertPlaceHolder>\" ; } } getLoadCount ( ) { return loadCount . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( cacheLoader . getLoadCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "passesCrlCheck ( java . security . cert . X509Certificate [ ] ) { if ( ( org . codice . ddf . security . handler . pki . CrlChecker . crlCache . get ( ) ) == null ) { java . lang . String errorMsg = \"CRL<sp>is<sp>not<sp>set.<sp>Skipping<sp>CRL<sp>check\" ; org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( errorMsg ) ; return true ; } org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( \"Checking<sp>request<sp>certs<sp>against<sp>CRL.\" ) ; return passesCrl ( certs ) ; }", "testMethod": "testEnabledCrlFileUnRevokedCertPasses ( ) { org . codice . ddf . security . handler . pki . CrlChecker crlChecker = getConfiguredCrlChecker ( \"encryption-crl-revoked.properties\" ) ; java . lang . String certificateString = getUnrevokedCert ( ) ; java . security . cert . X509Certificate [ ] certs = extractX509CertsFromString ( certificateString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( crlChecker . passesCrlCheck ( certs ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "testEnabledCrlFileUnRevokedCertPasses ( ) { org . codice . ddf . security . handler . pki . CrlChecker crlChecker = getConfiguredCrlChecker ( \"encryption-crl-revoked.properties\" ) ; java . lang . String certificateString = getUnrevokedCert ( ) ; java . security . cert . X509Certificate [ ] certs = extractX509CertsFromString ( certificateString ) ; \"<AssertPlaceHolder>\" ; } passesCrlCheck ( java . security . cert . X509Certificate [ ] ) { if ( ( org . codice . ddf . security . handler . pki . CrlChecker . crlCache . get ( ) ) == null ) { java . lang . String errorMsg = \"CRL<sp>is<sp>not<sp>set.<sp>Skipping<sp>CRL<sp>check\" ; org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( errorMsg ) ; return true ; } org . codice . ddf . security . handler . pki . CrlChecker . LOGGER . trace ( \"Checking<sp>request<sp>certs<sp>against<sp>CRL.\" ) ; return passesCrl ( certs ) ; }", "answer": "org . junit . Assert . assertThat ( crlChecker . passesCrlCheck ( certs ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "apply ( T ) { return isTrue . apply ( input ) ; }", "testMethod": "applyMaterieelFormeelGeldigHistorieVormGeen_PeilmomentNaTsRegEnGeenDatumEinde ( ) { nl . bzk . brp . domain . leveringmodel . MetaGroep . Builder groepBuilder = new nl . bzk . brp . domain . leveringmodel . MetaGroep . Builder ( null ) ; groepBuilder . metGroepElement ( Element . PERSOON_ADRES_STANDAARD . getId ( ) ) ; final nl . bzk . brp . domain . leveringmodel . MetaGroep metaGroep = groepBuilder . build ( null ) ; final int jaarTsReg = 2014 ; final int maandTsReg = 1 ; final int dagTsReg = 1 ; final java . time . ZonedDateTime actieInhoudTsReg = maakDatumTijdAttribuut ( jaarTsReg , maandTsReg , dagTsReg ) ; java . util . Calendar calendarActie = java . util . Calendar . getInstance ( ) ; calendarActie . set ( jaarTsReg , maandTsReg , dagTsReg ) ; final nl . bzk . brp . domain . leveringmodel . Actie actieInhoud = nl . bzk . brp . domain . leveringmodel . TestVerantwoording . maakActie ( 1 , actieInhoudTsReg ) ; nl . bzk . brp . domain . leveringmodel . MetaRecord . Builder recordBuilder = new nl . bzk . brp . domain . leveringmodel . MetaRecord . Builder ( groepBuilder ) ; recordBuilder . metActieInhoud ( actieInhoud ) ; recordBuilder . metDatumAanvangGeldigheid ( maakDatumInteger ( jaarTsReg , maandTsReg , dagTsReg ) ) ; final nl . bzk . brp . domain . leveringmodel . MetaRecord metaRecord = recordBuilder . build ( metaGroep ) ; final java . lang . Integer peilDatumMaterieel = maakDatumInteger ( jaarTsReg , ( maandTsReg + 6 ) , dagTsReg ) ; final java . time . ZonedDateTime peilDatumFormeel = java . time . LocalDate . parse ( peilDatumMaterieel . toString ( ) , nl . bzk . brp . service . maakbericht . filterstappen . HistoriePredikaatTest . FORMATTER ) . atStartOfDay ( DatumUtil . BRP_ZONE_ID ) ; final nl . bzk . brp . domain . leveringmodel . persoon . PeilmomentHistorievormPredicate bevragingHistoriePredikaat = new nl . bzk . brp . domain . leveringmodel . persoon . PeilmomentHistorievormPredicate ( peilDatumMaterieel , peilDatumFormeel , nl . bzk . algemeenbrp . dal . domein . brp . enums . HistorieVorm . GEEN ) ; final boolean apply = bevragingHistoriePredikaat . apply ( metaRecord ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( apply , org . hamcrest . core . Is . is ( true ) )", "total": "applyMaterieelFormeelGeldigHistorieVormGeen_PeilmomentNaTsRegEnGeenDatumEinde ( ) { nl . bzk . brp . domain . leveringmodel . MetaGroep . Builder groepBuilder = new nl . bzk . brp . domain . leveringmodel . MetaGroep . Builder ( null ) ; groepBuilder . metGroepElement ( Element . PERSOON_ADRES_STANDAARD . getId ( ) ) ; final nl . bzk . brp . domain . leveringmodel . MetaGroep metaGroep = groepBuilder . build ( null ) ; final int jaarTsReg = 2014 ; final int maandTsReg = 1 ; final int dagTsReg = 1 ; final java . time . ZonedDateTime actieInhoudTsReg = maakDatumTijdAttribuut ( jaarTsReg , maandTsReg , dagTsReg ) ; java . util . Calendar calendarActie = java . util . Calendar . getInstance ( ) ; calendarActie . set ( jaarTsReg , maandTsReg , dagTsReg ) ; final nl . bzk . brp . domain . leveringmodel . Actie actieInhoud = nl . bzk . brp . domain . leveringmodel . TestVerantwoording . maakActie ( 1 , actieInhoudTsReg ) ; nl . bzk . brp . domain . leveringmodel . MetaRecord . Builder recordBuilder = new nl . bzk . brp . domain . leveringmodel . MetaRecord . Builder ( groepBuilder ) ; recordBuilder . metActieInhoud ( actieInhoud ) ; recordBuilder . metDatumAanvangGeldigheid ( maakDatumInteger ( jaarTsReg , maandTsReg , dagTsReg ) ) ; final nl . bzk . brp . domain . leveringmodel . MetaRecord metaRecord = recordBuilder . build ( metaGroep ) ; final java . lang . Integer peilDatumMaterieel = maakDatumInteger ( jaarTsReg , ( maandTsReg + 6 ) , dagTsReg ) ; final java . time . ZonedDateTime peilDatumFormeel = java . time . LocalDate . parse ( peilDatumMaterieel . toString ( ) , nl . bzk . brp . service . maakbericht . filterstappen . HistoriePredikaatTest . FORMATTER ) . atStartOfDay ( DatumUtil . BRP_ZONE_ID ) ; final nl . bzk . brp . domain . leveringmodel . persoon . PeilmomentHistorievormPredicate bevragingHistoriePredikaat = new nl . bzk . brp . domain . leveringmodel . persoon . PeilmomentHistorievormPredicate ( peilDatumMaterieel , peilDatumFormeel , nl . bzk . algemeenbrp . dal . domein . brp . enums . HistorieVorm . GEEN ) ; final boolean apply = bevragingHistoriePredikaat . apply ( metaRecord ) ; \"<AssertPlaceHolder>\" ; } apply ( T ) { return isTrue . apply ( input ) ; }", "answer": "org . junit . Assert . assertThat ( apply , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getResultsList ( org . openmrs . module . webservices . rest . SimpleObject ) { return ( ( java . util . List < java . lang . Object > ) ( org . apache . commons . beanutils . PropertyUtils . getProperty ( result , \"results\" ) ) ) ; }", "testMethod": "shouldFindConceptsBySource ( ) { org . openmrs . module . webservices . rest . SimpleObject response = deserialize ( handle ( newGetRequest ( getURI ( ) , new org . openmrs . module . webservices . rest . web . v1_0 . controller . openmrs1_9 . Parameter ( \"source\" , \"Some<sp>Standardized<sp>Terminology\" ) ) ) ) ; java . util . List < java . lang . Object > results = org . openmrs . module . webservices . rest . test . Util . getResultsList ( response ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results . size ( ) , org . hamcrest . CoreMatchers . is ( 6 ) )", "total": "shouldFindConceptsBySource ( ) { org . openmrs . module . webservices . rest . SimpleObject response = deserialize ( handle ( newGetRequest ( getURI ( ) , new org . openmrs . module . webservices . rest . web . v1_0 . controller . openmrs1_9 . Parameter ( \"source\" , \"Some<sp>Standardized<sp>Terminology\" ) ) ) ) ; java . util . List < java . lang . Object > results = org . openmrs . module . webservices . rest . test . Util . getResultsList ( response ) ; \"<AssertPlaceHolder>\" ; } getResultsList ( org . openmrs . module . webservices . rest . SimpleObject ) { return ( ( java . util . List < java . lang . Object > ) ( org . apache . commons . beanutils . PropertyUtils . getProperty ( result , \"results\" ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( results . size ( ) , org . hamcrest . CoreMatchers . is ( 6 ) )"}
{"focal": "isCompatible ( ) { for ( oracle . kubernetes . operator . helpers . CompatibilityCheck check : checks ) if ( ! ( check . isCompatible ( ) ) ) return false ; return true ; }", "testMethod": "whenActualKeysHaveDifferentValues_reportNotCompatible ( ) { oracle . kubernetes . operator . helpers . CompatibilityCheck check = new oracle . kubernetes . operator . helpers . CompatibleMaps ( \"letters\" , com . google . common . collect . ImmutableMap . of ( \"a\" , 1 , \"b\" , 2 ) , com . google . common . collect . ImmutableMap . of ( \"b\" , 5 , \"c\" , 3 , \"a\" , 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( check . isCompatible ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "whenActualKeysHaveDifferentValues_reportNotCompatible ( ) { oracle . kubernetes . operator . helpers . CompatibilityCheck check = new oracle . kubernetes . operator . helpers . CompatibleMaps ( \"letters\" , com . google . common . collect . ImmutableMap . of ( \"a\" , 1 , \"b\" , 2 ) , com . google . common . collect . ImmutableMap . of ( \"b\" , 5 , \"c\" , 3 , \"a\" , 1 ) ) ; \"<AssertPlaceHolder>\" ; } isCompatible ( ) { for ( oracle . kubernetes . operator . helpers . CompatibilityCheck check : checks ) if ( ! ( check . isCompatible ( ) ) ) return false ; return true ; }", "answer": "org . junit . Assert . assertThat ( check . isCompatible ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "size ( ) { return elements . size ( ) ; }", "testMethod": "givenUsersExist_whenFindingUserWithNameStartWithA_thenUsersAreFound ( ) { com . baeldung . model . User user = new com . baeldung . model . User ( ) ; user . setName ( \"Eric\" ) ; user . setAge ( 45 ) ; mongoOps . insert ( user ) ; user = new com . baeldung . model . User ( ) ; user . setName ( \"Antony\" ) ; user . setAge ( 33 ) ; mongoOps . insert ( user ) ; user = new com . baeldung . model . User ( ) ; user . setName ( \"Alice\" ) ; user . setAge ( 35 ) ; mongoOps . insert ( user ) ; java . util . List < com . baeldung . model . User > users = userRepository . findByNameStartingWith ( \"A\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( users . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "givenUsersExist_whenFindingUserWithNameStartWithA_thenUsersAreFound ( ) { com . baeldung . model . User user = new com . baeldung . model . User ( ) ; user . setName ( \"Eric\" ) ; user . setAge ( 45 ) ; mongoOps . insert ( user ) ; user = new com . baeldung . model . User ( ) ; user . setName ( \"Antony\" ) ; user . setAge ( 33 ) ; mongoOps . insert ( user ) ; user = new com . baeldung . model . User ( ) ; user . setName ( \"Alice\" ) ; user . setAge ( 35 ) ; mongoOps . insert ( user ) ; java . util . List < com . baeldung . model . User > users = userRepository . findByNameStartingWith ( \"A\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elements . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( users . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "getBegin ( ) { org . mockito . Mockito . when ( influxDB . query ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ) . thenReturn ( new com . github . groupon . monsoon . history . influx . JsonQueryResult ( \"InfluxHistory_getBegin\" ) . getQueryResult ( ) ) ; org . junit . Assert . assertThat ( history . getBegin ( ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . of ( new org . joda . time . DateTime ( 1505241470000L , org . joda . time . DateTimeZone . UTC ) ) ) ) ; verify ( influxDB , times ( 1 ) ) . query ( org . mockito . Mockito . argThat ( org . hamcrest . Matchers . allOf ( org . hamcrest . Matchers . hasProperty ( \"command\" , org . hamcrest . Matchers . equalToIgnoringCase ( \"select<sp>*<sp>from<sp>/.*/<sp>order<sp>by<sp>time<sp>asc<sp>limit<sp>1\" ) ) , org . hamcrest . Matchers . hasProperty ( \"database\" , org . hamcrest . Matchers . equalTo ( com . github . groupon . monsoon . history . influx . InfluxHistoryTest . DATABASE ) ) ) ) , org . mockito . Mockito . eq ( TimeUnit . MILLISECONDS ) ) ; verifyNoMoreInteractions ( influxDB ) ; }", "testMethod": "getBegin ( ) { org . mockito . Mockito . when ( influxDB . query ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ) . thenReturn ( new com . github . groupon . monsoon . history . influx . JsonQueryResult ( \"InfluxHistory_getBegin\" ) . getQueryResult ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( influxDB , times ( 1 ) ) . query ( org . mockito . Mockito . argThat ( org . hamcrest . Matchers . allOf ( org . hamcrest . Matchers . hasProperty ( \"command\" , org . hamcrest . Matchers . equalToIgnoringCase ( \"select<sp>*<sp>from<sp>/.*/<sp>order<sp>by<sp>time<sp>asc<sp>limit<sp>1\" ) ) , org . hamcrest . Matchers . hasProperty ( \"database\" , org . hamcrest . Matchers . equalTo ( com . github . groupon . monsoon . history . influx . InfluxHistoryTest . DATABASE ) ) ) ) , org . mockito . Mockito . eq ( TimeUnit . MILLISECONDS ) ) ; verifyNoMoreInteractions ( influxDB ) ; }", "assertLine": "org . junit . Assert . assertThat ( history . getBegin ( ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . of ( new org . joda . time . DateTime ( 1505241470000L , org . joda . time . DateTimeZone . UTC ) ) ) )", "total": "getBegin ( ) { org . mockito . Mockito . when ( influxDB . query ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ) . thenReturn ( new com . github . groupon . monsoon . history . influx . JsonQueryResult ( \"InfluxHistory_getBegin\" ) . getQueryResult ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( influxDB , times ( 1 ) ) . query ( org . mockito . Mockito . argThat ( org . hamcrest . Matchers . allOf ( org . hamcrest . Matchers . hasProperty ( \"command\" , org . hamcrest . Matchers . equalToIgnoringCase ( \"select<sp>*<sp>from<sp>/.*/<sp>order<sp>by<sp>time<sp>asc<sp>limit<sp>1\" ) ) , org . hamcrest . Matchers . hasProperty ( \"database\" , org . hamcrest . Matchers . equalTo ( com . github . groupon . monsoon . history . influx . InfluxHistoryTest . DATABASE ) ) ) ) , org . mockito . Mockito . eq ( TimeUnit . MILLISECONDS ) ) ; verifyNoMoreInteractions ( influxDB ) ; } getBegin ( ) { org . mockito . Mockito . when ( influxDB . query ( org . mockito . Mockito . any ( ) , org . mockito . Mockito . any ( ) ) ) . thenReturn ( new com . github . groupon . monsoon . history . influx . JsonQueryResult ( \"InfluxHistory_getBegin\" ) . getQueryResult ( ) ) ; org . junit . Assert . assertThat ( history . getBegin ( ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . of ( new org . joda . time . DateTime ( 1505241470000L , org . joda . time . DateTimeZone . UTC ) ) ) ) ; verify ( influxDB , times ( 1 ) ) . query ( org . mockito . Mockito . argThat ( org . hamcrest . Matchers . allOf ( org . hamcrest . Matchers . hasProperty ( \"command\" , org . hamcrest . Matchers . equalToIgnoringCase ( \"select<sp>*<sp>from<sp>/.*/<sp>order<sp>by<sp>time<sp>asc<sp>limit<sp>1\" ) ) , org . hamcrest . Matchers . hasProperty ( \"database\" , org . hamcrest . Matchers . equalTo ( com . github . groupon . monsoon . history . influx . InfluxHistoryTest . DATABASE ) ) ) ) , org . mockito . Mockito . eq ( TimeUnit . MILLISECONDS ) ) ; verifyNoMoreInteractions ( influxDB ) ; }", "answer": "org . junit . Assert . assertThat ( history . getBegin ( ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . of ( new org . joda . time . DateTime ( 1505241470000L , org . joda . time . DateTimeZone . UTC ) ) ) )"}
{"focal": "getQuery ( ) { java . lang . StringBuilder query = new java . lang . StringBuilder ( ) ; query . append ( getEdmEntityName ( ) ) ; if ( ! ( isSingletonEntity ( ) ) ) { query . append ( generateParameters ( ) ) ; } return query . toString ( ) ; }", "testMethod": "createQueryWithMultipleFilters ( ) { com . sdl . odata . client . api . ODataClientQuery query = new com . sdl . odata . client . BasicODataClientQuery . Builder ( ) . withEntityType ( com . sdl . odata . client . DefaultODataClientQueryTest . EmptyEntity . class ) . withFilterMap ( \"Area\" , \"Web\" ) . withFilterMap ( \"Environment\" , \"e1\" ) . build ( ) ; java . lang . String expectedToString = \"EmptyEntities?$filter=Area<sp>eq<sp>'Web'<sp>and<sp>Environment<sp>eq<sp>'e1'\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . getQuery ( ) , org . hamcrest . core . Is . is ( expectedToString ) )", "total": "createQueryWithMultipleFilters ( ) { com . sdl . odata . client . api . ODataClientQuery query = new com . sdl . odata . client . BasicODataClientQuery . Builder ( ) . withEntityType ( com . sdl . odata . client . DefaultODataClientQueryTest . EmptyEntity . class ) . withFilterMap ( \"Area\" , \"Web\" ) . withFilterMap ( \"Environment\" , \"e1\" ) . build ( ) ; java . lang . String expectedToString = \"EmptyEntities?$filter=Area<sp>eq<sp>'Web'<sp>and<sp>Environment<sp>eq<sp>'e1'\" ; \"<AssertPlaceHolder>\" ; } getQuery ( ) { java . lang . StringBuilder query = new java . lang . StringBuilder ( ) ; query . append ( getEdmEntityName ( ) ) ; if ( ! ( isSingletonEntity ( ) ) ) { query . append ( generateParameters ( ) ) ; } return query . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( query . getQuery ( ) , org . hamcrest . core . Is . is ( expectedToString ) )"}
{"focal": "getBatchSize ( ) { return batchSize ; }", "testMethod": "WHEN_a_value_is_set_in_the_table_for_batch_size_AND_the_WorkflowModel_is_asked_for_simulator_configuration_THEN_a_corresponding_IterationParameter_is_included ( ) { int expectedBatchSize = 10 ; com . bigvisible . kanbansimulator . app . WorkflowModel workflowModel = new com . bigvisible . kanbansimulator . app . WorkflowModel ( ) ; workflowModel . addIteration ( ) ; workflowModel . getIterationParameterTableModel ( ) . setValueAt ( expectedBatchSize , 0 , 1 ) ; com . bigvisible . kanbansimulator . IterationParameter iterationParameter = workflowModel . getIterationParameters ( ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( iterationParameter . getBatchSize ( ) , is ( expectedBatchSize ) )", "total": "WHEN_a_value_is_set_in_the_table_for_batch_size_AND_the_WorkflowModel_is_asked_for_simulator_configuration_THEN_a_corresponding_IterationParameter_is_included ( ) { int expectedBatchSize = 10 ; com . bigvisible . kanbansimulator . app . WorkflowModel workflowModel = new com . bigvisible . kanbansimulator . app . WorkflowModel ( ) ; workflowModel . addIteration ( ) ; workflowModel . getIterationParameterTableModel ( ) . setValueAt ( expectedBatchSize , 0 , 1 ) ; com . bigvisible . kanbansimulator . IterationParameter iterationParameter = workflowModel . getIterationParameters ( ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; } getBatchSize ( ) { return batchSize ; }", "answer": "org . junit . Assert . assertThat ( iterationParameter . getBatchSize ( ) , is ( expectedBatchSize ) )"}
{"focal": "toString ( ) { java . lang . StringBuilder out = new java . lang . StringBuilder ( ) ; try { com . squareup . javapoet . CodeWriter codeWriter = new com . squareup . javapoet . CodeWriter ( out ) ; emit ( codeWriter , \"Constructor\" , java . util . Collections . emptySet ( ) ) ; return out . toString ( ) ; } catch ( java . io . IOException e ) { throw new java . lang . AssertionError ( ) ; } }", "testMethod": "wildcardSuperType ( ) { com . squareup . javapoet . WildcardTypeName type = com . squareup . javapoet . WildcardTypeName . supertypeOf ( java . lang . String . class ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"?<sp>super<sp>java.lang.String\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( type . toString ( ) )", "total": "wildcardSuperType ( ) { com . squareup . javapoet . WildcardTypeName type = com . squareup . javapoet . WildcardTypeName . supertypeOf ( java . lang . String . class ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"?<sp>super<sp>java.lang.String\" ) ; } toString ( ) { java . lang . StringBuilder out = new java . lang . StringBuilder ( ) ; try { com . squareup . javapoet . CodeWriter codeWriter = new com . squareup . javapoet . CodeWriter ( out ) ; emit ( codeWriter , \"Constructor\" , java . util . Collections . emptySet ( ) ) ; return out . toString ( ) ; } catch ( java . io . IOException e ) { throw new java . lang . AssertionError ( ) ; } }", "answer": "org . junit . Assert . assertThat ( type . toString ( ) )"}
{"focal": "size ( ) { if ( ( tokenName . getValue ( ) ) == null ) { return 0 ; } return tokenName . getValue ( ) . size ( ) ; }", "testMethod": "getBigSample2 ( ) { runtime . initialize ( null , org . talend . components . bigquery . runtime . BigQueryTestConstants . createDatasetFromQuery ( org . talend . components . bigquery . runtime . BigQueryTestConstants . createDatastore ( ) , \"SELECT<sp>*<sp>FROM<sp>`engineering-152721.datastreams_celia_us.stackoverflow`\" , false ) ) ; final java . util . List < org . apache . avro . generic . IndexedRecord > actual = new java . util . ArrayList ( ) ; runtime . getSample ( 100 , new org . talend . daikon . java8 . Consumer < org . apache . avro . generic . IndexedRecord > ( ) { @ org . talend . components . bigquery . runtime . Override public void accept ( org . apache . avro . generic . IndexedRecord indexedRecord ) { actual . add ( indexedRecord ) ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . size ( ) , org . hamcrest . Matchers . is ( 100 ) )", "total": "getBigSample2 ( ) { runtime . initialize ( null , org . talend . components . bigquery . runtime . BigQueryTestConstants . createDatasetFromQuery ( org . talend . components . bigquery . runtime . BigQueryTestConstants . createDatastore ( ) , \"SELECT<sp>*<sp>FROM<sp>`engineering-152721.datastreams_celia_us.stackoverflow`\" , false ) ) ; final java . util . List < org . apache . avro . generic . IndexedRecord > actual = new java . util . ArrayList ( ) ; runtime . getSample ( 100 , new org . talend . daikon . java8 . Consumer < org . apache . avro . generic . IndexedRecord > ( ) { @ org . talend . components . bigquery . runtime . Override public void accept ( org . apache . avro . generic . IndexedRecord indexedRecord ) { actual . add ( indexedRecord ) ; } } ) ; \"<AssertPlaceHolder>\" ; } size ( ) { if ( ( tokenName . getValue ( ) ) == null ) { return 0 ; } return tokenName . getValue ( ) . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( actual . size ( ) , org . hamcrest . Matchers . is ( 100 ) )"}
{"focal": "next ( ) { java . math . BigInteger oldValue ; java . math . BigInteger newValue ; do { oldValue = ( ( java . math . BigInteger ) ( refCounter . get ( ) ) ) ; newValue = ( oldValue == null ) ? java . math . BigInteger . valueOf ( 1 ) : oldValue . shiftLeft ( 1 ) ; } while ( ! ( refCounter . compareAndSet ( oldValue , newValue ) ) ) ; return newValue ; }", "testMethod": "whenNeedLoopByListItDoIterator ( ) { ru . szhernovoy . list . DynamicArray < java . lang . String > container = new ru . szhernovoy . list . DynamicArray ( ) ; container . add ( \"First<sp>message\" ) ; container . add ( \"Second<sp>message\" ) ; container . add ( \"Third<sp>message\" ) ; java . util . Iterator < java . lang . String > iter = container . iterator ( ) ; int index = 0 ; java . lang . String message = \"\" ; while ( ( iter . hasNext ( ) ) && ( index < 2 ) ) { message = iter . next ( ) ; index ++ ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( \"Second<sp>message\" , org . hamcrest . core . Is . is ( message ) )", "total": "whenNeedLoopByListItDoIterator ( ) { ru . szhernovoy . list . DynamicArray < java . lang . String > container = new ru . szhernovoy . list . DynamicArray ( ) ; container . add ( \"First<sp>message\" ) ; container . add ( \"Second<sp>message\" ) ; container . add ( \"Third<sp>message\" ) ; java . util . Iterator < java . lang . String > iter = container . iterator ( ) ; int index = 0 ; java . lang . String message = \"\" ; while ( ( iter . hasNext ( ) ) && ( index < 2 ) ) { message = iter . next ( ) ; index ++ ; } \"<AssertPlaceHolder>\" ; } next ( ) { java . math . BigInteger oldValue ; java . math . BigInteger newValue ; do { oldValue = ( ( java . math . BigInteger ) ( refCounter . get ( ) ) ) ; newValue = ( oldValue == null ) ? java . math . BigInteger . valueOf ( 1 ) : oldValue . shiftLeft ( 1 ) ; } while ( ! ( refCounter . compareAndSet ( oldValue , newValue ) ) ) ; return newValue ; }", "answer": "org . junit . Assert . assertThat ( \"Second<sp>message\" , org . hamcrest . core . Is . is ( message ) )"}
{"focal": "toXml ( java . lang . String ) { return documentBuilder . parse ( new org . xml . sax . InputSource ( new java . io . StringReader ( xml ) ) ) . getDocumentElement ( ) ; }", "testMethod": "test_getExecutionEvents_return_empty_searching_two_types ( ) { java . lang . String xml = \"<mavenExecution>\" + ( \"<ExecutionEvent<sp>type='ProjectSkipped'<sp>/>\" + \"</mavenExecution>\" ) ; org . w3c . dom . Element documentElement = toXml ( xml ) ; java . util . List < org . w3c . dom . Element > actualElements = org . jenkinsci . plugins . pipeline . maven . util . XmlUtils . getExecutionEvents ( documentElement , \"ProjectSucceeded\" , \"ProjectFailed\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualElements . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "test_getExecutionEvents_return_empty_searching_two_types ( ) { java . lang . String xml = \"<mavenExecution>\" + ( \"<ExecutionEvent<sp>type='ProjectSkipped'<sp>/>\" + \"</mavenExecution>\" ) ; org . w3c . dom . Element documentElement = toXml ( xml ) ; java . util . List < org . w3c . dom . Element > actualElements = org . jenkinsci . plugins . pipeline . maven . util . XmlUtils . getExecutionEvents ( documentElement , \"ProjectSucceeded\" , \"ProjectFailed\" ) ; \"<AssertPlaceHolder>\" ; } toXml ( java . lang . String ) { return documentBuilder . parse ( new org . xml . sax . InputSource ( new java . io . StringReader ( xml ) ) ) . getDocumentElement ( ) ; }", "answer": "org . junit . Assert . assertThat ( actualElements . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "isIncomplete ( ) { java . lang . Boolean noStreams = streams . isEmpty ( ) ; java . lang . Boolean noMeasurements = any ( streams . values ( ) , new com . google . common . base . Predicate < pl . llp . aircasting . model . MeasurementStream > ( ) { @ pl . llp . aircasting . model . Override public boolean apply ( @ org . jetbrains . annotations . Nullable pl . llp . aircasting . model . MeasurementStream input ) { return input . isEmpty ( ) ; } } ) ; return noStreams || noMeasurements ; }", "testMethod": "returnsFalseWhenAllOfStreamsHasMeasurements ( ) { pl . llp . aircasting . model . MeasurementStream stream1 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream1 . isEmpty ( ) ) . thenReturn ( false ) ; pl . llp . aircasting . model . MeasurementStream stream2 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream2 . isEmpty ( ) ) . thenReturn ( false ) ; session . add ( stream1 ) ; session . add ( stream2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( session . isIncomplete ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "returnsFalseWhenAllOfStreamsHasMeasurements ( ) { pl . llp . aircasting . model . MeasurementStream stream1 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream1 . isEmpty ( ) ) . thenReturn ( false ) ; pl . llp . aircasting . model . MeasurementStream stream2 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream2 . isEmpty ( ) ) . thenReturn ( false ) ; session . add ( stream1 ) ; session . add ( stream2 ) ; \"<AssertPlaceHolder>\" ; } isIncomplete ( ) { java . lang . Boolean noStreams = streams . isEmpty ( ) ; java . lang . Boolean noMeasurements = any ( streams . values ( ) , new com . google . common . base . Predicate < pl . llp . aircasting . model . MeasurementStream > ( ) { @ pl . llp . aircasting . model . Override public boolean apply ( @ org . jetbrains . annotations . Nullable pl . llp . aircasting . model . MeasurementStream input ) { return input . isEmpty ( ) ; } } ) ; return noStreams || noMeasurements ; }", "answer": "org . junit . Assert . assertThat ( session . isIncomplete ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "getPool ( ) { return this . pool ; }", "testMethod": "getPoolNameWhenBeanNameAndNameSet ( ) { org . springframework . data . gemfire . client . PoolFactoryBean poolFactoryBean = new org . springframework . data . gemfire . client . PoolFactoryBean ( ) ; poolFactoryBean . setBeanName ( \"PoolBean\" ) ; poolFactoryBean . setName ( \"TestPool\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( poolFactoryBean . getPool ( ) . getName ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( \"TestPool\" ) ) )", "total": "getPoolNameWhenBeanNameAndNameSet ( ) { org . springframework . data . gemfire . client . PoolFactoryBean poolFactoryBean = new org . springframework . data . gemfire . client . PoolFactoryBean ( ) ; poolFactoryBean . setBeanName ( \"PoolBean\" ) ; poolFactoryBean . setName ( \"TestPool\" ) ; \"<AssertPlaceHolder>\" ; } getPool ( ) { return this . pool ; }", "answer": "org . junit . Assert . assertThat ( poolFactoryBean . getPool ( ) . getName ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( \"TestPool\" ) ) )"}
{"focal": "getValue ( ) { return value ; }", "testMethod": "testPerMinute_null_previous_value ( ) { org . joda . time . DateTime previousTime = new org . joda . time . DateTime ( 2013 , 1 , 1 , 14 , 1 , 31 ) ; org . jmxtrans . agent . QueryResult previous = new org . jmxtrans . agent . QueryResult ( \"metric1\" , null , previousTime . getMillis ( ) ) ; org . joda . time . DateTime currentTime = previousTime . plusSeconds ( 60 ) . plusMillis ( 45 ) ; org . jmxtrans . agent . QueryResult current = new org . jmxtrans . agent . QueryResult ( \"metric1\" , 13 , currentTime . getMillis ( ) ) ; org . jmxtrans . agent . QueryResult actualResult = writer . perMinute ( current , previous ) ; int actualPerMinuteValue = ( ( java . lang . Integer ) ( actualResult . getValue ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualPerMinuteValue , is ( 13 ) )", "total": "testPerMinute_null_previous_value ( ) { org . joda . time . DateTime previousTime = new org . joda . time . DateTime ( 2013 , 1 , 1 , 14 , 1 , 31 ) ; org . jmxtrans . agent . QueryResult previous = new org . jmxtrans . agent . QueryResult ( \"metric1\" , null , previousTime . getMillis ( ) ) ; org . joda . time . DateTime currentTime = previousTime . plusSeconds ( 60 ) . plusMillis ( 45 ) ; org . jmxtrans . agent . QueryResult current = new org . jmxtrans . agent . QueryResult ( \"metric1\" , 13 , currentTime . getMillis ( ) ) ; org . jmxtrans . agent . QueryResult actualResult = writer . perMinute ( current , previous ) ; int actualPerMinuteValue = ( ( java . lang . Integer ) ( actualResult . getValue ( ) ) ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return value ; }", "answer": "org . junit . Assert . assertThat ( actualPerMinuteValue , is ( 13 ) )"}
{"focal": "fromString ( java . lang . String ) { arg = \"\" . concat ( arg ) . toLowerCase ( ) ; if ( ( ! ( arg . isEmpty ( ) ) ) && ( arg . startsWith ( \"private\" ) ) ) { return org . apache . camel . component . wordpress . api . model . PublishableStatus . private_ ; } if ( ( ! ( arg . isEmpty ( ) ) ) && ( arg . startsWith ( \"auto\" ) ) ) { return org . apache . camel . component . wordpress . api . model . PublishableStatus . auto_draft ; } return org . apache . camel . component . wordpress . api . model . PublishableStatus . valueOf ( arg ) ; }", "testMethod": "testFromStringNull ( ) { final java . lang . String input4 = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . apache . camel . component . wordpress . api . model . PublishableStatus . fromString ( input4 ) , org . hamcrest . CoreMatchers . is ( PublishableStatus . private_ ) )", "total": "testFromStringNull ( ) { final java . lang . String input4 = null ; \"<AssertPlaceHolder>\" ; } fromString ( java . lang . String ) { arg = \"\" . concat ( arg ) . toLowerCase ( ) ; if ( ( ! ( arg . isEmpty ( ) ) ) && ( arg . startsWith ( \"private\" ) ) ) { return org . apache . camel . component . wordpress . api . model . PublishableStatus . private_ ; } if ( ( ! ( arg . isEmpty ( ) ) ) && ( arg . startsWith ( \"auto\" ) ) ) { return org . apache . camel . component . wordpress . api . model . PublishableStatus . auto_draft ; } return org . apache . camel . component . wordpress . api . model . PublishableStatus . valueOf ( arg ) ; }", "answer": "org . junit . Assert . assertThat ( org . apache . camel . component . wordpress . api . model . PublishableStatus . fromString ( input4 ) , org . hamcrest . CoreMatchers . is ( PublishableStatus . private_ ) )"}
{"focal": "eval ( java . io . InputStream ) { return getRuntime ( ) . evaluate ( new org . dynjs . runtime . source . InputStreamSourceProvider ( in ) ) ; }", "testMethod": "testMinValue ( ) { java . lang . Object minValue = eval ( \"Number.MIN_VALUE\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( Double . MIN_VALUE ) ; }", "assertLine": "org . junit . Assert . assertThat ( minValue )", "total": "testMinValue ( ) { java . lang . Object minValue = eval ( \"Number.MIN_VALUE\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( Double . MIN_VALUE ) ; } eval ( java . io . InputStream ) { return getRuntime ( ) . evaluate ( new org . dynjs . runtime . source . InputStreamSourceProvider ( in ) ) ; }", "answer": "org . junit . Assert . assertThat ( minValue )"}
{"focal": "of ( long , U extends net . time4j . IsoUnit ) { if ( amount == 0 ) { return net . time4j . Duration . ofZero ( ) ; } U u = unit ; long value = amount ; if ( amount < 0 ) { value = net . time4j . base . MathUtils . safeNegate ( amount ) ; } if ( unit instanceof net . time4j . ClockUnit . ClockUnit ) { switch ( unit . getSymbol ( ) ) { case '3' : u = net . time4j . Duration . cast ( ClockUnit . NANOS ) ; value = net . time4j . base . MathUtils . safeMultiply ( value , net . time4j . Duration . MIO ) ; break ; case '6' : u = net . time4j . Duration . cast ( ClockUnit . NANOS ) ; value = net . time4j . base . MathUtils . safeMultiply ( value , 1000 ) ; break ; default : } } java . util . List < net . time4j . Item < U > > items = new java . util . ArrayList ( 1 ) ; items . add ( net . time4j . Item . of ( value , u ) ) ; return new net . time4j . Duration ( items , ( amount < 0 ) ) ; }", "testMethod": "getNominalDurationOfMomentInterval ( ) { net . time4j . Moment m1 = net . time4j . Moment . of ( 1278028823 , TimeScale . UTC ) ; net . time4j . Moment m2 = net . time4j . Moment . of ( 1278028826 , 1 , TimeScale . UTC ) ; net . time4j . Duration < ? > duration = net . time4j . range . MomentInterval . between ( m1 , m2 ) . getNominalDuration ( net . time4j . tz . Timezone . of ( ZonalOffset . UTC ) , ClockUnit . SECONDS ) ; net . time4j . Duration < ? > expected = net . time4j . Duration . of ( 2 , ClockUnit . SECONDS ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( duration , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "getNominalDurationOfMomentInterval ( ) { net . time4j . Moment m1 = net . time4j . Moment . of ( 1278028823 , TimeScale . UTC ) ; net . time4j . Moment m2 = net . time4j . Moment . of ( 1278028826 , 1 , TimeScale . UTC ) ; net . time4j . Duration < ? > duration = net . time4j . range . MomentInterval . between ( m1 , m2 ) . getNominalDuration ( net . time4j . tz . Timezone . of ( ZonalOffset . UTC ) , ClockUnit . SECONDS ) ; net . time4j . Duration < ? > expected = net . time4j . Duration . of ( 2 , ClockUnit . SECONDS ) ; \"<AssertPlaceHolder>\" ; } of ( long , U extends net . time4j . IsoUnit ) { if ( amount == 0 ) { return net . time4j . Duration . ofZero ( ) ; } U u = unit ; long value = amount ; if ( amount < 0 ) { value = net . time4j . base . MathUtils . safeNegate ( amount ) ; } if ( unit instanceof net . time4j . ClockUnit . ClockUnit ) { switch ( unit . getSymbol ( ) ) { case '3' : u = net . time4j . Duration . cast ( ClockUnit . NANOS ) ; value = net . time4j . base . MathUtils . safeMultiply ( value , net . time4j . Duration . MIO ) ; break ; case '6' : u = net . time4j . Duration . cast ( ClockUnit . NANOS ) ; value = net . time4j . base . MathUtils . safeMultiply ( value , 1000 ) ; break ; default : } } java . util . List < net . time4j . Item < U > > items = new java . util . ArrayList ( 1 ) ; items . add ( net . time4j . Item . of ( value , u ) ) ; return new net . time4j . Duration ( items , ( amount < 0 ) ) ; }", "answer": "org . junit . Assert . assertThat ( duration , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "isAllowed ( java . lang . String , java . net . URI ) { checkNotNull ( crawlerAgentString , \"crawlerAgentString<sp>is<sp>null\" ) ; checkNotNull ( resourceUri , \"resourceUri<sp>is<sp>null\" ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolving<sp>robots<sp>URL<sp>for:<sp>{}\" , resourceUri ) ; final java . net . URI robotsUri = utilities . getRobotsURIForResource ( resourceUri ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolved<sp>robots<sp>URI<sp>to:<sp>{}\" , robotsUri ) ; final com . brandwatch . robots . domain . Robots robots ; try { robots = loader . load ( robotsUri ) ; } catch ( java . lang . Exception e ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Download<sp>failure<sp>{}\" , e . getMessage ( ) ) ; return allow ( resourceUri ) ; } if ( robots . getGroups ( ) . isEmpty ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>agent<sp>groups<sp>found\" , resourceUri ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . Group > group = matcherUtils . getMostSpecificMatchingGroup ( robots . getGroups ( ) , crawlerAgentString ) ; if ( group . isPresent ( ) ) { if ( com . brandwatch . robots . RobotsServiceImpl . log . isDebugEnabled ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>user-agent<sp>group:<sp>{}\" , matcherUtils . getMostSpecificMatch ( group . get ( ) , crawlerAgentString ) . get ( ) . getValue ( ) ) ; } } else { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>user-agent<sp>group<sp>matched\" ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . PathDirective > bestMatch = matcherUtils . getMostSpecificMatch ( group . get ( ) . getDirectives ( com . brandwatch . robots . domain . PathDirective . class ) , utilities . getResourceLocalComponents ( resourceUri ) ) ; if ( ! ( bestMatch . isPresent ( ) ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>matching<sp>path<sp>directive\" ) ; return allow ( resourceUri ) ; } else { final com . brandwatch . robots . domain . PathDirective directive = bestMatch . get ( ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>path<sp>directive<sp>{}:{}\" , directive . getField ( ) , directive . getValue ( ) ) ; return directive . isAllowed ( ) ? allow ( resourceUri ) : disallow ( resourceUri ) ; } }", "testMethod": "givenExampleUri_whenIsAllowed_thenReturnsTrue ( ) { boolean result = instance . isAllowed ( com . brandwatch . robots . RobotsServiceImplTest . CRAWLER_AGENT , com . brandwatch . robots . RobotsServiceImplTest . RESOURCE_URI ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )", "total": "givenExampleUri_whenIsAllowed_thenReturnsTrue ( ) { boolean result = instance . isAllowed ( com . brandwatch . robots . RobotsServiceImplTest . CRAWLER_AGENT , com . brandwatch . robots . RobotsServiceImplTest . RESOURCE_URI ) ; \"<AssertPlaceHolder>\" ; } isAllowed ( java . lang . String , java . net . URI ) { checkNotNull ( crawlerAgentString , \"crawlerAgentString<sp>is<sp>null\" ) ; checkNotNull ( resourceUri , \"resourceUri<sp>is<sp>null\" ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolving<sp>robots<sp>URL<sp>for:<sp>{}\" , resourceUri ) ; final java . net . URI robotsUri = utilities . getRobotsURIForResource ( resourceUri ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolved<sp>robots<sp>URI<sp>to:<sp>{}\" , robotsUri ) ; final com . brandwatch . robots . domain . Robots robots ; try { robots = loader . load ( robotsUri ) ; } catch ( java . lang . Exception e ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Download<sp>failure<sp>{}\" , e . getMessage ( ) ) ; return allow ( resourceUri ) ; } if ( robots . getGroups ( ) . isEmpty ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>agent<sp>groups<sp>found\" , resourceUri ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . Group > group = matcherUtils . getMostSpecificMatchingGroup ( robots . getGroups ( ) , crawlerAgentString ) ; if ( group . isPresent ( ) ) { if ( com . brandwatch . robots . RobotsServiceImpl . log . isDebugEnabled ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>user-agent<sp>group:<sp>{}\" , matcherUtils . getMostSpecificMatch ( group . get ( ) , crawlerAgentString ) . get ( ) . getValue ( ) ) ; } } else { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>user-agent<sp>group<sp>matched\" ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . PathDirective > bestMatch = matcherUtils . getMostSpecificMatch ( group . get ( ) . getDirectives ( com . brandwatch . robots . domain . PathDirective . class ) , utilities . getResourceLocalComponents ( resourceUri ) ) ; if ( ! ( bestMatch . isPresent ( ) ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>matching<sp>path<sp>directive\" ) ; return allow ( resourceUri ) ; } else { final com . brandwatch . robots . domain . PathDirective directive = bestMatch . get ( ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>path<sp>directive<sp>{}:{}\" , directive . getField ( ) , directive . getValue ( ) ) ; return directive . isAllowed ( ) ? allow ( resourceUri ) : disallow ( resourceUri ) ; } }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "sort ( int [ ] ) { int p = 0 ; int r = ( input . length ) - 1 ; this . mergeSort ( input , p , r ) ; return input ; }", "testMethod": "sortTest ( ) { int [ ] input = new int [ ] { 8 , 31 , 48 , 73 , 3 , 65 , 20 , 29 , 11 , 15 } ; int [ ] output = new int [ ] { 3 , 8 , 11 , 15 , 20 , 29 , 31 , 48 , 65 , 73 } ; chapter3 . selectionsort . SelectionSort selectionSort = new chapter3 . selectionsort . ILhyunSelectionSort ( ) ; int [ ] result = selectionSort . sort ( input ) ; for ( int i = 0 ; i < ( input . length ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( result [ i ] , org . hamcrest . CoreMatchers . is ( output [ i ] ) )", "total": "sortTest ( ) { int [ ] input = new int [ ] { 8 , 31 , 48 , 73 , 3 , 65 , 20 , 29 , 11 , 15 } ; int [ ] output = new int [ ] { 3 , 8 , 11 , 15 , 20 , 29 , 31 , 48 , 65 , 73 } ; chapter3 . selectionsort . SelectionSort selectionSort = new chapter3 . selectionsort . ILhyunSelectionSort ( ) ; int [ ] result = selectionSort . sort ( input ) ; for ( int i = 0 ; i < ( input . length ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } } sort ( int [ ] ) { int p = 0 ; int r = ( input . length ) - 1 ; this . mergeSort ( input , p , r ) ; return input ; }", "answer": "org . junit . Assert . assertThat ( result [ i ] , org . hamcrest . CoreMatchers . is ( output [ i ] ) )"}
{"focal": "getTag ( ) { return NO_TAG ; }", "testMethod": "testTagInTransformedRoute ( ) { setUpPeers ( true ) ; org . batfish . datamodel . AbstractRoute route = org . batfish . datamodel . StaticRoute . builder ( ) . setNetwork ( org . batfish . dataplane . protocols . BgpProtocolHelperTransformBgpRouteOnExportTest . DEST_NETWORK ) . setTag ( 12345 ) . setAdministrativeCost ( 1 ) . build ( ) ; org . batfish . datamodel . BgpRoute . Builder transformedRoute = runTransformBgpRoutePreExport ( route ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( transformedRoute . getTag ( ) , org . hamcrest . Matchers . equalTo ( 12345 ) )", "total": "testTagInTransformedRoute ( ) { setUpPeers ( true ) ; org . batfish . datamodel . AbstractRoute route = org . batfish . datamodel . StaticRoute . builder ( ) . setNetwork ( org . batfish . dataplane . protocols . BgpProtocolHelperTransformBgpRouteOnExportTest . DEST_NETWORK ) . setTag ( 12345 ) . setAdministrativeCost ( 1 ) . build ( ) ; org . batfish . datamodel . BgpRoute . Builder transformedRoute = runTransformBgpRoutePreExport ( route ) ; \"<AssertPlaceHolder>\" ; } getTag ( ) { return NO_TAG ; }", "answer": "org . junit . Assert . assertThat ( transformedRoute . getTag ( ) , org . hamcrest . Matchers . equalTo ( 12345 ) )"}
{"focal": "getRules ( ) { final java . util . Collection < hudson . plugins . cigame . model . Rule > rules = new hudson . plugins . cigame . rules . plugins . jacoco . JacocoRuleSet ( ) . getRules ( ) ; org . junit . Assert . assertThat ( rules , org . hamcrest . Matchers . contains ( org . hamcrest . Matchers . instanceOf ( hudson . plugins . cigame . rules . plugins . jacoco . DefaultJacocoRule . class ) ) ) ; }", "testMethod": "getRules ( ) { final java . util . Collection < hudson . plugins . cigame . model . Rule > rules = new hudson . plugins . cigame . rules . plugins . jacoco . JacocoRuleSet ( ) . getRules ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rules , org . hamcrest . Matchers . contains ( org . hamcrest . Matchers . instanceOf ( hudson . plugins . cigame . rules . plugins . jacoco . DefaultJacocoRule . class ) ) )", "total": "getRules ( ) { final java . util . Collection < hudson . plugins . cigame . model . Rule > rules = new hudson . plugins . cigame . rules . plugins . jacoco . JacocoRuleSet ( ) . getRules ( ) ; \"<AssertPlaceHolder>\" ; } getRules ( ) { final java . util . Collection < hudson . plugins . cigame . model . Rule > rules = new hudson . plugins . cigame . rules . plugins . jacoco . JacocoRuleSet ( ) . getRules ( ) ; org . junit . Assert . assertThat ( rules , org . hamcrest . Matchers . contains ( org . hamcrest . Matchers . instanceOf ( hudson . plugins . cigame . rules . plugins . jacoco . DefaultJacocoRule . class ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( rules , org . hamcrest . Matchers . contains ( org . hamcrest . Matchers . instanceOf ( hudson . plugins . cigame . rules . plugins . jacoco . DefaultJacocoRule . class ) ) )"}
{"focal": "save ( com . depli . store . persistent . entity . JMXNode ) { jmxNodeRepository . save ( jmxNode ) ; return reinitializeDataStore ( ) ; }", "testMethod": "saveANode ( ) { com . depli . store . persistent . entity . JMXNode node = new com . depli . store . persistent . entity . JMXNode ( \"node1\" , \"service:jmx:rmi:///jndi/rmi://localhost:9024/jmxrmi\" , false ) ; org . mockito . Mockito . when ( jmxNodeRepository . save ( node ) ) . then ( new org . mockito . stubbing . Answer < com . depli . store . persistent . entity . JMXNode > ( ) { @ com . depli . service . store . persistent . impl . Override public com . depli . store . persistent . entity . JMXNode answer ( org . mockito . invocation . InvocationOnMock invocation ) throws java . lang . Throwable { node . setNodeId ( 1L ) ; return node ; } } ) ; boolean result = nodeServiceImpl . save ( node ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )", "total": "saveANode ( ) { com . depli . store . persistent . entity . JMXNode node = new com . depli . store . persistent . entity . JMXNode ( \"node1\" , \"service:jmx:rmi:///jndi/rmi://localhost:9024/jmxrmi\" , false ) ; org . mockito . Mockito . when ( jmxNodeRepository . save ( node ) ) . then ( new org . mockito . stubbing . Answer < com . depli . store . persistent . entity . JMXNode > ( ) { @ com . depli . service . store . persistent . impl . Override public com . depli . store . persistent . entity . JMXNode answer ( org . mockito . invocation . InvocationOnMock invocation ) throws java . lang . Throwable { node . setNodeId ( 1L ) ; return node ; } } ) ; boolean result = nodeServiceImpl . save ( node ) ; \"<AssertPlaceHolder>\" ; } save ( com . depli . store . persistent . entity . JMXNode ) { jmxNodeRepository . save ( jmxNode ) ; return reinitializeDataStore ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "hasPermission ( fr . xephi . authme . listener . JoiningPlayer , fr . xephi . authme . permission . PermissionNode ) { return joiningPlayer . getPermissionLookupFunction ( ) . apply ( this , permissionNode ) ; }", "testMethod": "shouldGrantToOpCommandSender ( ) { fr . xephi . authme . permission . PermissionNode node = TestPermissions . DELETE_USER ; org . bukkit . command . CommandSender sender = mock ( org . bukkit . command . CommandSender . class ) ; given ( sender . isOp ( ) ) . willReturn ( true ) ; boolean result = permissionsManager . hasPermission ( sender , node ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldGrantToOpCommandSender ( ) { fr . xephi . authme . permission . PermissionNode node = TestPermissions . DELETE_USER ; org . bukkit . command . CommandSender sender = mock ( org . bukkit . command . CommandSender . class ) ; given ( sender . isOp ( ) ) . willReturn ( true ) ; boolean result = permissionsManager . hasPermission ( sender , node ) ; \"<AssertPlaceHolder>\" ; } hasPermission ( fr . xephi . authme . listener . JoiningPlayer , fr . xephi . authme . permission . PermissionNode ) { return joiningPlayer . getPermissionLookupFunction ( ) . apply ( this , permissionNode ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "execute ( java . lang . String , java . util . Map ) { return getGraphDatabaseAPI ( ) . execute ( query , parameters ) ; }", "testMethod": "create_node_using_create_unique_with_java_maps ( ) { java . util . Map < java . lang . String , java . lang . Object > props = new java . util . HashMap ( ) ; props . put ( \"name\" , \"Andy\" ) ; props . put ( \"position\" , \"Developer\" ) ; java . util . Map < java . lang . String , java . lang . Object > params = new java . util . HashMap ( ) ; params . put ( \"props\" , props ) ; java . lang . String query = \"MATCH<sp>(n)<sp>WHERE<sp>id(n)<sp>=<sp>0<sp>\" + ( \"MERGE<sp>p<sp>=<sp>(n)-[:REL]->({name:<sp>$props.name,<sp>position:<sp>$props.position})<sp>\" + \"RETURN<sp>last(nodes(p))<sp>AS<sp>X\" ) ; org . neo4j . graphdb . Result result = db . execute ( query , params ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count ( result ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "create_node_using_create_unique_with_java_maps ( ) { java . util . Map < java . lang . String , java . lang . Object > props = new java . util . HashMap ( ) ; props . put ( \"name\" , \"Andy\" ) ; props . put ( \"position\" , \"Developer\" ) ; java . util . Map < java . lang . String , java . lang . Object > params = new java . util . HashMap ( ) ; params . put ( \"props\" , props ) ; java . lang . String query = \"MATCH<sp>(n)<sp>WHERE<sp>id(n)<sp>=<sp>0<sp>\" + ( \"MERGE<sp>p<sp>=<sp>(n)-[:REL]->({name:<sp>$props.name,<sp>position:<sp>$props.position})<sp>\" + \"RETURN<sp>last(nodes(p))<sp>AS<sp>X\" ) ; org . neo4j . graphdb . Result result = db . execute ( query , params ) ; \"<AssertPlaceHolder>\" ; } execute ( java . lang . String , java . util . Map ) { return getGraphDatabaseAPI ( ) . execute ( query , parameters ) ; }", "answer": "org . junit . Assert . assertThat ( count ( result ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "isEmpty ( ) { return all ( streams . values ( ) , new com . google . common . base . Predicate < pl . llp . aircasting . model . MeasurementStream > ( ) { @ pl . llp . aircasting . model . Override public boolean apply ( @ org . jetbrains . annotations . Nullable pl . llp . aircasting . model . MeasurementStream input ) { return input . isEmpty ( ) ; } } ) ; }", "testMethod": "should_be_empty_if_all_streams_are_empty ( ) { pl . llp . aircasting . model . MeasurementStream stream1 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream1 . isEmpty ( ) ) . thenReturn ( true ) ; pl . llp . aircasting . model . MeasurementStream stream2 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream2 . isEmpty ( ) ) . thenReturn ( true ) ; session . add ( stream1 ) ; session . add ( stream2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( session . isEmpty ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "should_be_empty_if_all_streams_are_empty ( ) { pl . llp . aircasting . model . MeasurementStream stream1 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream1 . isEmpty ( ) ) . thenReturn ( true ) ; pl . llp . aircasting . model . MeasurementStream stream2 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream2 . isEmpty ( ) ) . thenReturn ( true ) ; session . add ( stream1 ) ; session . add ( stream2 ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return all ( streams . values ( ) , new com . google . common . base . Predicate < pl . llp . aircasting . model . MeasurementStream > ( ) { @ pl . llp . aircasting . model . Override public boolean apply ( @ org . jetbrains . annotations . Nullable pl . llp . aircasting . model . MeasurementStream input ) { return input . isEmpty ( ) ; } } ) ; }", "answer": "org . junit . Assert . assertThat ( session . isEmpty ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "toString ( ) { return this . originalSql ; }", "testMethod": "test ( ) { java . lang . String str = \"hello<sp>world!<sp>\" ; java . lang . Character [ ] chars = new java . lang . Character [ str . length ( ) ] ; for ( int i = 0 ; i < ( chars . length ) ; i ++ ) { chars [ i ] = str . charAt ( i ) ; } com . firefly . utils . codec . HuffmanCodec < java . lang . Character > codec = new com . firefly . utils . codec . HuffmanCodec ( chars ) ; java . util . Map < java . lang . Character , com . firefly . utils . codec . HuffmanCodec . HuffmanCode > map = codec . getCodecMap ( ) ; System . out . println ( map ) ; System . out . println ( ( \"str<sp>length:<sp>\" + ( str . getBytes ( StandardCharsets . UTF_8 ) . length ) ) ) ; com . firefly . utils . codec . HuffmanCodec . BitBuilder bits = codec . encode ( chars ) ; System . out . println ( ( ( ( \"encode<sp>length:<sp>\" + ( bits . toByteArray ( ) . length ) ) + \"|<sp>bit<sp>length:<sp>\" ) + ( bits . getLength ( ) ) ) ) ; System . out . println ( com . firefly . utils . codec . HexUtils . bytesToHex ( bits . toByteArray ( ) ) ) ; System . out . println ( bits ) ; System . out . println ( java . util . BitSet . valueOf ( bits . toByteArray ( ) ) ) ; java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; java . util . List < java . lang . Character > c = codec . decode ( bits ) ; for ( char ch : c ) { sb . append ( ch ) ; } System . out . println ( sb ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sb . toString ( ) , org . hamcrest . Matchers . is ( str ) )", "total": "test ( ) { java . lang . String str = \"hello<sp>world!<sp>\" ; java . lang . Character [ ] chars = new java . lang . Character [ str . length ( ) ] ; for ( int i = 0 ; i < ( chars . length ) ; i ++ ) { chars [ i ] = str . charAt ( i ) ; } com . firefly . utils . codec . HuffmanCodec < java . lang . Character > codec = new com . firefly . utils . codec . HuffmanCodec ( chars ) ; java . util . Map < java . lang . Character , com . firefly . utils . codec . HuffmanCodec . HuffmanCode > map = codec . getCodecMap ( ) ; System . out . println ( map ) ; System . out . println ( ( \"str<sp>length:<sp>\" + ( str . getBytes ( StandardCharsets . UTF_8 ) . length ) ) ) ; com . firefly . utils . codec . HuffmanCodec . BitBuilder bits = codec . encode ( chars ) ; System . out . println ( ( ( ( \"encode<sp>length:<sp>\" + ( bits . toByteArray ( ) . length ) ) + \"|<sp>bit<sp>length:<sp>\" ) + ( bits . getLength ( ) ) ) ) ; System . out . println ( com . firefly . utils . codec . HexUtils . bytesToHex ( bits . toByteArray ( ) ) ) ; System . out . println ( bits ) ; System . out . println ( java . util . BitSet . valueOf ( bits . toByteArray ( ) ) ) ; java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; java . util . List < java . lang . Character > c = codec . decode ( bits ) ; for ( char ch : c ) { sb . append ( ch ) ; } System . out . println ( sb ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return this . originalSql ; }", "answer": "org . junit . Assert . assertThat ( sb . toString ( ) , org . hamcrest . Matchers . is ( str ) )"}
{"focal": "equals ( java . lang . Object ) { if ( ( this ) == o ) { return true ; } if ( ( o == null ) || ( ( getClass ( ) ) != ( o . getClass ( ) ) ) ) { return false ; } org . terasoluna . gfw . common . fullhalf . FullHalfPair that = ( ( org . terasoluna . gfw . common . fullhalf . FullHalfPair ) ( o ) ) ; if ( ! ( fullwidth . equals ( that . fullwidth ) ) ) { return false ; } return halfwidth . equals ( that . halfwidth ) ; }", "testMethod": "testFullHalfPairEqualsNull ( ) { org . terasoluna . gfw . common . fullhalf . FullHalfPair FullHalfPair = new org . terasoluna . gfw . common . fullhalf . FullHalfPair ( \"\" , \"a\" ) ; java . lang . String str = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( FullHalfPair . equals ( str ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testFullHalfPairEqualsNull ( ) { org . terasoluna . gfw . common . fullhalf . FullHalfPair FullHalfPair = new org . terasoluna . gfw . common . fullhalf . FullHalfPair ( \"\" , \"a\" ) ; java . lang . String str = null ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( ( this ) == o ) { return true ; } if ( ( o == null ) || ( ( getClass ( ) ) != ( o . getClass ( ) ) ) ) { return false ; } org . terasoluna . gfw . common . fullhalf . FullHalfPair that = ( ( org . terasoluna . gfw . common . fullhalf . FullHalfPair ) ( o ) ) ; if ( ! ( fullwidth . equals ( that . fullwidth ) ) ) { return false ; } return halfwidth . equals ( that . halfwidth ) ; }", "answer": "org . junit . Assert . assertThat ( FullHalfPair . equals ( str ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "invoke ( org . aopalliance . intercept . MethodInvocation ) { if ( ( startingPoint . get ( ) ) == null ) { startingPoint . set ( invocation ) ; } try { return invocation . proceed ( ) ; } catch ( org . terasoluna . gfw . common . exception . ResultMessagesNotificationException e ) { if ( isStartingPoint ( invocation ) ) { logResultMessagesNotificationException ( e ) ; } throw e ; } finally { if ( isStartingPoint ( invocation ) ) { startingPoint . remove ( ) ; } } }", "testMethod": "testInvokeOccurBusinessexception02 ( ) { org . terasoluna . gfw . common . exception . BusinessException occurException = new org . terasoluna . gfw . common . exception . BusinessException ( org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( \"e.cm.xxx1\" , \"args1\" , \"args2\" ) ) ; when ( mockMethodInvocation . proceed ( ) ) . thenThrow ( occurException ) ; try { testTarget . invoke ( mockMethodInvocation ) ; org . junit . Assert . fail ( \"don't<sp>occur<sp>BusinessException.\" ) ; } catch ( org . terasoluna . gfw . common . exception . BusinessException e ) { \"<AssertPlaceHolder>\" ; verify ( mockExceptionLogger , times ( 1 ) ) . warn ( occurException ) ; verify ( mockExceptionLogger , times ( 1 ) ) . warn ( any ( org . terasoluna . gfw . common . exception . Exception . class ) ) ; } }", "assertLine": "org . junit . Assert . assertThat ( e , org . hamcrest . CoreMatchers . is ( occurException ) )", "total": "testInvokeOccurBusinessexception02 ( ) { org . terasoluna . gfw . common . exception . BusinessException occurException = new org . terasoluna . gfw . common . exception . BusinessException ( org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( \"e.cm.xxx1\" , \"args1\" , \"args2\" ) ) ; when ( mockMethodInvocation . proceed ( ) ) . thenThrow ( occurException ) ; try { testTarget . invoke ( mockMethodInvocation ) ; org . junit . Assert . fail ( \"don't<sp>occur<sp>BusinessException.\" ) ; } catch ( org . terasoluna . gfw . common . exception . BusinessException e ) { \"<AssertPlaceHolder>\" ; verify ( mockExceptionLogger , times ( 1 ) ) . warn ( occurException ) ; verify ( mockExceptionLogger , times ( 1 ) ) . warn ( any ( org . terasoluna . gfw . common . exception . Exception . class ) ) ; } } invoke ( org . aopalliance . intercept . MethodInvocation ) { if ( ( startingPoint . get ( ) ) == null ) { startingPoint . set ( invocation ) ; } try { return invocation . proceed ( ) ; } catch ( org . terasoluna . gfw . common . exception . ResultMessagesNotificationException e ) { if ( isStartingPoint ( invocation ) ) { logResultMessagesNotificationException ( e ) ; } throw e ; } finally { if ( isStartingPoint ( invocation ) ) { startingPoint . remove ( ) ; } } }", "answer": "org . junit . Assert . assertThat ( e , org . hamcrest . CoreMatchers . is ( occurException ) )"}
{"focal": "getMyInteger ( ) { return myInteger ; }", "testMethod": "integer ( ) { model . setMyInteger ( 1 ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model2 . getMyInteger ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "integer ( ) { model . setMyInteger ( 1 ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; } getMyInteger ( ) { return myInteger ; }", "answer": "org . junit . Assert . assertThat ( model2 . getMyInteger ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "is ( java . lang . Class ) { br . com . caelum . vraptor . proxy . MethodInvocation < T > handler = new br . com . caelum . vraptor . proxy . MethodInvocation < T > ( ) { @ br . com . caelum . vraptor . http . route . Override public java . lang . Object intercept ( java . lang . Object proxy , java . lang . reflect . Method method , java . lang . Object [ ] args , br . com . caelum . vraptor . proxy . SuperMethod superMethod ) { boolean alreadySetTheStrategy = ! ( strategy . getClass ( ) . equals ( br . com . caelum . vraptor . http . route . NoStrategy . class ) ) ; if ( alreadySetTheStrategy ) { return null ; } is ( type , method ) ; return null ; } } ; return proxifier . proxify ( type , handler ) ; }", "testMethod": "shouldSerializeCalendarTimeWithISO8601 ( ) { br . com . caelum . vraptor . serialization . gson . GsonJSONSerializationTest . Client c = new br . com . caelum . vraptor . serialization . gson . GsonJSONSerializationTest . Client ( \"renan\" ) ; c . included = new java . util . GregorianCalendar ( 2012 , 8 , 3 , 1 , 5 , 9 ) ; c . included . setTimeZone ( java . util . TimeZone . getTimeZone ( \"GMT-0300\" ) ) ; serialization . from ( c ) . serialize ( ) ; java . lang . String result = result ( ) ; java . lang . String expectedResult = \"{\\\"client\\\":{\\\"name\\\":\\\"renan\\\",\\\"included\\\":\\\"2012-09-03T01:05:09-03:00\\\"}}\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldSerializeCalendarTimeWithISO8601 ( ) { br . com . caelum . vraptor . serialization . gson . GsonJSONSerializationTest . Client c = new br . com . caelum . vraptor . serialization . gson . GsonJSONSerializationTest . Client ( \"renan\" ) ; c . included = new java . util . GregorianCalendar ( 2012 , 8 , 3 , 1 , 5 , 9 ) ; c . included . setTimeZone ( java . util . TimeZone . getTimeZone ( \"GMT-0300\" ) ) ; serialization . from ( c ) . serialize ( ) ; java . lang . String result = result ( ) ; java . lang . String expectedResult = \"{\\\"client\\\":{\\\"name\\\":\\\"renan\\\",\\\"included\\\":\\\"2012-09-03T01:05:09-03:00\\\"}}\" ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { br . com . caelum . vraptor . proxy . MethodInvocation < T > handler = new br . com . caelum . vraptor . proxy . MethodInvocation < T > ( ) { @ br . com . caelum . vraptor . http . route . Override public java . lang . Object intercept ( java . lang . Object proxy , java . lang . reflect . Method method , java . lang . Object [ ] args , br . com . caelum . vraptor . proxy . SuperMethod superMethod ) { boolean alreadySetTheStrategy = ! ( strategy . getClass ( ) . equals ( br . com . caelum . vraptor . http . route . NoStrategy . class ) ) ; if ( alreadySetTheStrategy ) { return null ; } is ( type , method ) ; return null ; } } ; return proxifier . proxify ( type , handler ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsSuperFalse ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPushPbb obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPushPbb ( ) ; doReturn ( \"false\" ) . when ( target ) . getType ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsSuperFalse ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPushPbb obj = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlowActionPushPbb ( ) ; doReturn ( \"false\" ) . when ( target ) . getType ( ) ; boolean result = target . equals ( obj ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "build_shouldSetId ( ) { com . testwithspring . starter . assertions . task . Task task = com . testwithspring . starter . assertions . task . Task . getBuilder ( ) . withId ( com . testwithspring . starter . assertions . task . TaskTest . ID ) . withAssignee ( com . testwithspring . starter . assertions . task . TaskTest . ASSIGNEE_ID ) . withCreator ( com . testwithspring . starter . assertions . task . TaskTest . CREATOR_ID ) . withTitle ( com . testwithspring . starter . assertions . task . TaskTest . TITLE ) . withDescription ( com . testwithspring . starter . assertions . task . TaskTest . DESCRIPTION ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( task . getId ( ) , org . hamcrest . Matchers . is ( com . testwithspring . starter . assertions . task . TaskTest . ID ) )", "total": "build_shouldSetId ( ) { com . testwithspring . starter . assertions . task . Task task = com . testwithspring . starter . assertions . task . Task . getBuilder ( ) . withId ( com . testwithspring . starter . assertions . task . TaskTest . ID ) . withAssignee ( com . testwithspring . starter . assertions . task . TaskTest . ASSIGNEE_ID ) . withCreator ( com . testwithspring . starter . assertions . task . TaskTest . CREATOR_ID ) . withTitle ( com . testwithspring . starter . assertions . task . TaskTest . TITLE ) . withDescription ( com . testwithspring . starter . assertions . task . TaskTest . DESCRIPTION ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( task . getId ( ) , org . hamcrest . Matchers . is ( com . testwithspring . starter . assertions . task . TaskTest . ID ) )"}
{"focal": "sort ( int [ ] ) { int p = 0 ; int r = ( input . length ) - 1 ; this . mergeSort ( input , p , r ) ; return input ; }", "testMethod": "sortTest ( ) { int [ ] input = new int [ ] { 8 , 31 , 48 , 73 , 3 , 65 , 20 , 29 , 11 , 15 } ; int [ ] output = new int [ ] { 3 , 8 , 11 , 15 , 20 , 29 , 31 , 48 , 65 , 73 } ; chapter3 . insertsort . InsertionSort insertionSort = new chapter3 . insertsort . ILhyunInsertionSort ( ) ; int [ ] result = insertionSort . sort ( input ) ; for ( int i = 0 ; i < ( input . length ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( result [ i ] , org . hamcrest . CoreMatchers . is ( output [ i ] ) )", "total": "sortTest ( ) { int [ ] input = new int [ ] { 8 , 31 , 48 , 73 , 3 , 65 , 20 , 29 , 11 , 15 } ; int [ ] output = new int [ ] { 3 , 8 , 11 , 15 , 20 , 29 , 31 , 48 , 65 , 73 } ; chapter3 . insertsort . InsertionSort insertionSort = new chapter3 . insertsort . ILhyunInsertionSort ( ) ; int [ ] result = insertionSort . sort ( input ) ; for ( int i = 0 ; i < ( input . length ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } } sort ( int [ ] ) { int p = 0 ; int r = ( input . length ) - 1 ; this . mergeSort ( input , p , r ) ; return input ; }", "answer": "org . junit . Assert . assertThat ( result [ i ] , org . hamcrest . CoreMatchers . is ( output [ i ] ) )"}
{"focal": "splitPath ( java . lang . String ) { java . util . List < java . lang . String > segments = new java . util . LinkedList < java . lang . String > ( ) ; int curr = 0 ; int nextBrace = rawPath . indexOf ( '{' ) ; int nextSlash = rawPath . indexOf ( '/' ) ; while ( true ) { if ( ( ( nextSlash == ( - 1 ) ) && ( nextBrace > ( - 1 ) ) ) || ( ( nextBrace > ( - 1 ) ) && ( nextBrace < nextSlash ) ) ) { int nextClosingBrace = rawPath . indexOf ( '}' , nextBrace ) ; if ( nextClosingBrace == ( - 1 ) ) { throw new org . modeshape . jcr . value . ValueFormatException ( rawPath , getPropertyType ( ) , GraphI18n . missingClosingBrace . text ( rawPath ) ) ; } nextSlash = rawPath . indexOf ( '/' , ( nextClosingBrace + 1 ) ) ; nextBrace = rawPath . indexOf ( '{' , ( nextClosingBrace + 1 ) ) ; } else if ( ( ( nextBrace == ( - 1 ) ) && ( nextSlash > ( - 1 ) ) ) || ( ( nextSlash > ( - 1 ) ) && ( nextSlash < nextBrace ) ) ) { if ( nextSlash > 0 ) { segments . add ( rawPath . substring ( curr , nextSlash ) ) ; } curr = nextSlash + 1 ; nextSlash = rawPath . indexOf ( '/' , curr ) ; } else { segments . add ( rawPath . substring ( curr ) ) ; return segments . toArray ( new java . lang . String [ segments . size ( ) ] ) ; } } }", "testMethod": "shouldSplitPathWithoutExpandedNamespace ( ) { java . lang . String [ ] splits = factory . splitPath ( \"/jcr:foo/bar/blah:baz\" ) ; java . lang . String [ ] correctSplits = new java . lang . String [ ] { \"jcr:foo\" , \"bar\" , \"blah:baz\" } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( splits , org . hamcrest . core . Is . is ( correctSplits ) )", "total": "shouldSplitPathWithoutExpandedNamespace ( ) { java . lang . String [ ] splits = factory . splitPath ( \"/jcr:foo/bar/blah:baz\" ) ; java . lang . String [ ] correctSplits = new java . lang . String [ ] { \"jcr:foo\" , \"bar\" , \"blah:baz\" } ; \"<AssertPlaceHolder>\" ; } splitPath ( java . lang . String ) { java . util . List < java . lang . String > segments = new java . util . LinkedList < java . lang . String > ( ) ; int curr = 0 ; int nextBrace = rawPath . indexOf ( '{' ) ; int nextSlash = rawPath . indexOf ( '/' ) ; while ( true ) { if ( ( ( nextSlash == ( - 1 ) ) && ( nextBrace > ( - 1 ) ) ) || ( ( nextBrace > ( - 1 ) ) && ( nextBrace < nextSlash ) ) ) { int nextClosingBrace = rawPath . indexOf ( '}' , nextBrace ) ; if ( nextClosingBrace == ( - 1 ) ) { throw new org . modeshape . jcr . value . ValueFormatException ( rawPath , getPropertyType ( ) , GraphI18n . missingClosingBrace . text ( rawPath ) ) ; } nextSlash = rawPath . indexOf ( '/' , ( nextClosingBrace + 1 ) ) ; nextBrace = rawPath . indexOf ( '{' , ( nextClosingBrace + 1 ) ) ; } else if ( ( ( nextBrace == ( - 1 ) ) && ( nextSlash > ( - 1 ) ) ) || ( ( nextSlash > ( - 1 ) ) && ( nextSlash < nextBrace ) ) ) { if ( nextSlash > 0 ) { segments . add ( rawPath . substring ( curr , nextSlash ) ) ; } curr = nextSlash + 1 ; nextSlash = rawPath . indexOf ( '/' , curr ) ; } else { segments . add ( rawPath . substring ( curr ) ) ; return segments . toArray ( new java . lang . String [ segments . size ( ) ] ) ; } } }", "answer": "org . junit . Assert . assertThat ( splits , org . hamcrest . core . Is . is ( correctSplits ) )"}
{"focal": "refresh ( java . util . Map ) { org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . LOGGER . trace ( \"WfsSource<sp>{}:<sp>Refresh<sp>called\" , getId ( ) ) ; java . lang . String url = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . WFSURL_KEY ) ) ) ; java . lang . String coordOrder = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . COORDINATE_ORDER_KEY ) ) ) ; java . lang . String passwordValue = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . PASSWORD_KEY ) ) ) ; java . lang . String usernameValue = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . USERNAME_KEY ) ) ) ; java . lang . Boolean disableCnCheckProp = ( ( java . lang . Boolean ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . DISABLE_CN_CHECK_KEY ) ) ) ; java . lang . String id = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . ID_KEY ) ) ) ; java . lang . Boolean allowRedirects = ( ( java . lang . Boolean ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . ALLOW_REDIRECTS_KEY ) ) ) ; java . lang . Integer connectionTimeout = ( ( java . lang . Integer ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . CONNECTION_TIMEOUT_KEY ) ) ) ; java . lang . Integer receiveTimeout = ( ( java . lang . Integer ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . RECEIVE_TIMEOUT_KEY ) ) ) ; if ( hasSourceIdChanged ( id ) ) { setId ( id ) ; configureWfsFeatures ( ) ; } setSrsName ( ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . SRS_NAME_KEY ) ) ) ) ; this . nonQueryableProperties = ( ( java . lang . String [ ] ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . NON_QUERYABLE_PROPS_KEY ) ) ) ; java . lang . Integer newPollInterval = ( ( java . lang . Integer ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . POLL_INTERVAL_KEY ) ) ) ; if ( ( ( ( ( ( ( hasWfsUrlChanged ( url ) ) || ( hasDisableCnCheckChanged ( disableCnCheckProp ) ) ) || ( hasUsernameChanged ( usernameValue ) ) ) || ( hasPasswordChanged ( passwordValue ) ) ) || ( hasAllowRedirectsChanged ( allowRedirects ) ) ) || ( hasConnectionTimeoutChanged ( connectionTimeout ) ) ) || ( hasReceiveTimeoutChanged ( receiveTimeout ) ) ) { this . wfsUrl = url ; this . password = encryptionService . decryptValue ( passwordValue ) ; this . username = usernameValue ; this . disableCnCheck = disableCnCheckProp ; this . coordinateOrder = coordOrder ; this . allowRedirects = allowRedirects ; setConnectionTimeout ( connectionTimeout ) ; setReceiveTimeout ( receiveTimeout ) ; createClientFactory ( ) ; configureWfsFeatures ( ) ; } else { java . lang . String spatialFilter = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . SPATIAL_FILTER_KEY ) ) ) ; if ( ! ( org . apache . commons . lang . StringUtils . equals ( forceSpatialFilter , spatialFilter ) ) ) { java . util . List < java . lang . String > geoFilters = new java . util . ArrayList ( ) ; if ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . NO_FORCED_SPATIAL_FILTER . equals ( spatialFilter ) ) { geoFilters . addAll ( supportedGeoFilters ) ; } else { geoFilters . add ( spatialFilter ) ; } for ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsFilterDelegate delegate : featureTypeFilters . values ( ) ) { delegate . setSupportedGeoFilters ( geoFilters ) ; } } } if ( ! ( pollInterval . equals ( newPollInterval ) ) ) { org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . LOGGER . trace ( \"Poll<sp>Interval<sp>was<sp>changed<sp>for<sp>source<sp>{}.\" , getId ( ) ) ; setPollInterval ( newPollInterval ) ; availabilityPollFuture . cancel ( true ) ; setupAvailabilityPoll ( ) ; } }", "testMethod": "testContentLength ( ) { doReturn ( 24L ) . when ( mockResource ) . getContentLength ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( entry . refresh ( mockResource ) , org . hamcrest . Matchers . is ( true ) )", "total": "testContentLength ( ) { doReturn ( 24L ) . when ( mockResource ) . getContentLength ( ) ; \"<AssertPlaceHolder>\" ; } refresh ( java . util . Map ) { org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . LOGGER . trace ( \"WfsSource<sp>{}:<sp>Refresh<sp>called\" , getId ( ) ) ; java . lang . String url = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . WFSURL_KEY ) ) ) ; java . lang . String coordOrder = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . COORDINATE_ORDER_KEY ) ) ) ; java . lang . String passwordValue = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . PASSWORD_KEY ) ) ) ; java . lang . String usernameValue = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . USERNAME_KEY ) ) ) ; java . lang . Boolean disableCnCheckProp = ( ( java . lang . Boolean ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . DISABLE_CN_CHECK_KEY ) ) ) ; java . lang . String id = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . ID_KEY ) ) ) ; java . lang . Boolean allowRedirects = ( ( java . lang . Boolean ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . ALLOW_REDIRECTS_KEY ) ) ) ; java . lang . Integer connectionTimeout = ( ( java . lang . Integer ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . CONNECTION_TIMEOUT_KEY ) ) ) ; java . lang . Integer receiveTimeout = ( ( java . lang . Integer ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . RECEIVE_TIMEOUT_KEY ) ) ) ; if ( hasSourceIdChanged ( id ) ) { setId ( id ) ; configureWfsFeatures ( ) ; } setSrsName ( ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . SRS_NAME_KEY ) ) ) ) ; this . nonQueryableProperties = ( ( java . lang . String [ ] ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . NON_QUERYABLE_PROPS_KEY ) ) ) ; java . lang . Integer newPollInterval = ( ( java . lang . Integer ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . POLL_INTERVAL_KEY ) ) ) ; if ( ( ( ( ( ( ( hasWfsUrlChanged ( url ) ) || ( hasDisableCnCheckChanged ( disableCnCheckProp ) ) ) || ( hasUsernameChanged ( usernameValue ) ) ) || ( hasPasswordChanged ( passwordValue ) ) ) || ( hasAllowRedirectsChanged ( allowRedirects ) ) ) || ( hasConnectionTimeoutChanged ( connectionTimeout ) ) ) || ( hasReceiveTimeoutChanged ( receiveTimeout ) ) ) { this . wfsUrl = url ; this . password = encryptionService . decryptValue ( passwordValue ) ; this . username = usernameValue ; this . disableCnCheck = disableCnCheckProp ; this . coordinateOrder = coordOrder ; this . allowRedirects = allowRedirects ; setConnectionTimeout ( connectionTimeout ) ; setReceiveTimeout ( receiveTimeout ) ; createClientFactory ( ) ; configureWfsFeatures ( ) ; } else { java . lang . String spatialFilter = ( ( java . lang . String ) ( configuration . get ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . SPATIAL_FILTER_KEY ) ) ) ; if ( ! ( org . apache . commons . lang . StringUtils . equals ( forceSpatialFilter , spatialFilter ) ) ) { java . util . List < java . lang . String > geoFilters = new java . util . ArrayList ( ) ; if ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . NO_FORCED_SPATIAL_FILTER . equals ( spatialFilter ) ) { geoFilters . addAll ( supportedGeoFilters ) ; } else { geoFilters . add ( spatialFilter ) ; } for ( org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsFilterDelegate delegate : featureTypeFilters . values ( ) ) { delegate . setSupportedGeoFilters ( geoFilters ) ; } } } if ( ! ( pollInterval . equals ( newPollInterval ) ) ) { org . codice . ddf . spatial . ogc . wfs . v110 . catalog . source . WfsSource . LOGGER . trace ( \"Poll<sp>Interval<sp>was<sp>changed<sp>for<sp>source<sp>{}.\" , getId ( ) ) ; setPollInterval ( newPollInterval ) ; availabilityPollFuture . cancel ( true ) ; setupAvailabilityPoll ( ) ; } }", "answer": "org . junit . Assert . assertThat ( entry . refresh ( mockResource ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "id ( ) { return id ; }", "testMethod": "testOomScoreAdj ( ) { requireDockerApiVersionAtLeast ( \"1.22\" , \"OomScoreAdj\" ) ; sut . pull ( com . spotify . docker . client . DefaultDockerClientTest . BUSYBOX_LATEST ) ; final com . spotify . docker . client . messages . ContainerConfig config = com . spotify . docker . client . messages . ContainerConfig . builder ( ) . image ( com . spotify . docker . client . DefaultDockerClientTest . BUSYBOX_LATEST ) . hostConfig ( com . spotify . docker . client . messages . HostConfig . builder ( ) . oomScoreAdj ( 500 ) . build ( ) ) . build ( ) ; final com . spotify . docker . client . messages . ContainerCreation container = sut . createContainer ( config , randomName ( ) ) ; final com . spotify . docker . client . messages . ContainerInfo info = sut . inspectContainer ( container . id ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( info . hostConfig ( ) . oomScoreAdj ( ) , org . hamcrest . Matchers . is ( 500 ) )", "total": "testOomScoreAdj ( ) { requireDockerApiVersionAtLeast ( \"1.22\" , \"OomScoreAdj\" ) ; sut . pull ( com . spotify . docker . client . DefaultDockerClientTest . BUSYBOX_LATEST ) ; final com . spotify . docker . client . messages . ContainerConfig config = com . spotify . docker . client . messages . ContainerConfig . builder ( ) . image ( com . spotify . docker . client . DefaultDockerClientTest . BUSYBOX_LATEST ) . hostConfig ( com . spotify . docker . client . messages . HostConfig . builder ( ) . oomScoreAdj ( 500 ) . build ( ) ) . build ( ) ; final com . spotify . docker . client . messages . ContainerCreation container = sut . createContainer ( config , randomName ( ) ) ; final com . spotify . docker . client . messages . ContainerInfo info = sut . inspectContainer ( container . id ( ) ) ; \"<AssertPlaceHolder>\" ; } id ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( info . hostConfig ( ) . oomScoreAdj ( ) , org . hamcrest . Matchers . is ( 500 ) )"}
{"focal": "toString ( ) { return this . methodName ; }", "testMethod": "toString_A$ ( ) { com . m3 . curly . Method method = new com . m3 . curly . Method ( \"GET\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( method . toString ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"GET\" ) ) )", "total": "toString_A$ ( ) { com . m3 . curly . Method method = new com . m3 . curly . Method ( \"GET\" ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return this . methodName ; }", "answer": "org . junit . Assert . assertThat ( method . toString ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"GET\" ) ) )"}
{"focal": "getValue ( ) { return value ; }", "testMethod": "itHasATrueValueForTransfer ( ) { final com . wesabe . xmlson . XmlsonObject envelope = presenter . present ( txaction , Locale . UK ) ; final com . wesabe . xmlson . XmlsonBoolean representation = ( ( com . wesabe . xmlson . XmlsonBoolean ) ( envelope . get ( \"transfer\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( representation . getValue ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "itHasATrueValueForTransfer ( ) { final com . wesabe . xmlson . XmlsonObject envelope = presenter . present ( txaction , Locale . UK ) ; final com . wesabe . xmlson . XmlsonBoolean representation = ( ( com . wesabe . xmlson . XmlsonBoolean ) ( envelope . get ( \"transfer\" ) ) ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return value ; }", "answer": "org . junit . Assert . assertThat ( representation . getValue ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "testMethod": "shouldCountCustomMethod ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity . setId ( documentId ) ; sampleEntity . setType ( \"test\" ) ; sampleEntity . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity ) ; documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId ) ; sampleEntity2 . setType ( \"test2\" ) ; sampleEntity2 . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity2 ) ; long count = repository . countByType ( \"test\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )", "total": "shouldCountCustomMethod ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity . setId ( documentId ) ; sampleEntity . setType ( \"test\" ) ; sampleEntity . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity ) ; documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId ) ; sampleEntity2 . setType ( \"test2\" ) ; sampleEntity2 . setMessage ( \"some<sp>message\" ) ; repository . save ( sampleEntity2 ) ; long count = repository . countByType ( \"test\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Object ) { queryCriteria . add ( new org . springframework . data . elasticsearch . core . query . Criteria . CriteriaEntry ( org . springframework . data . elasticsearch . core . query . Criteria . OperationKey . EQUALS , o ) ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( count , is ( equalTo ( 1L ) ) )"}
{"focal": "get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "testMethod": "runnable ( ) { compiler . withFlow ( ( conf , flow , portMap ) -> { flow . start ( ) ; return getSimpleArtifact ( \"testing\" , \"in\" , \"out\" ) ; } ) ; com . asakusafw . testdriver . FlowPartTester tester = new com . asakusafw . testdriver . FlowPartTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; com . asakusafw . vocabulary . flow . In < com . asakusafw . testdriver . testing . model . Simple > in = tester . input ( \"in\" , com . asakusafw . testdriver . testing . model . Simple . class ) . prepare ( \"data/simple-in.json\" ) ; com . asakusafw . vocabulary . flow . Out < com . asakusafw . testdriver . testing . model . Simple > out = tester . output ( \"out\" , com . asakusafw . testdriver . testing . model . Simple . class ) . verify ( \"data/simple-out.json\" , new com . asakusafw . testdriver . IdentityVerifier ( ) ) ; java . util . concurrent . atomic . AtomicBoolean resolved = new java . util . concurrent . atomic . AtomicBoolean ( ) ; tester . runTest ( ( ) -> { out . add ( in ) ; resolved . set ( true ) ; } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resolved . get ( ) , is ( true ) )", "total": "runnable ( ) { compiler . withFlow ( ( conf , flow , portMap ) -> { flow . start ( ) ; return getSimpleArtifact ( \"testing\" , \"in\" , \"out\" ) ; } ) ; com . asakusafw . testdriver . FlowPartTester tester = new com . asakusafw . testdriver . FlowPartTester ( getClass ( ) ) ; tester . setFrameworkHomePath ( framework . getHome ( ) ) ; com . asakusafw . vocabulary . flow . In < com . asakusafw . testdriver . testing . model . Simple > in = tester . input ( \"in\" , com . asakusafw . testdriver . testing . model . Simple . class ) . prepare ( \"data/simple-in.json\" ) ; com . asakusafw . vocabulary . flow . Out < com . asakusafw . testdriver . testing . model . Simple > out = tester . output ( \"out\" , com . asakusafw . testdriver . testing . model . Simple . class ) . verify ( \"data/simple-out.json\" , new com . asakusafw . testdriver . IdentityVerifier ( ) ) ; java . util . concurrent . atomic . AtomicBoolean resolved = new java . util . concurrent . atomic . AtomicBoolean ( ) ; tester . runTest ( ( ) -> { out . add ( in ) ; resolved . set ( true ) ; } ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "answer": "org . junit . Assert . assertThat ( resolved . get ( ) , is ( true ) )"}
{"focal": "playAGameWithAPlayerOfPosition ( com . blogspot . toomuchcoding . service . PositionType ) { com . blogspot . toomuchcoding . service . Player player = playerFactory . createPlayer ( positionType ) ; player . run ( ) ; performAdditionalActions ( player ) ; return player ; }", "testMethod": "shouldReturnDefensivePlayerBeingADjAndAJavaDev ( ) { given ( playerFactory . createPlayer ( PositionType . GK ) ) . willReturn ( defensivePlayerWithDjAndJavaDevSkills ) ; doAnswer ( new org . mockito . stubbing . Answer < java . lang . Object > ( ) { @ com . blogspot . toomuchcoding . service . Override public java . lang . Object answer ( org . mockito . invocation . InvocationOnMock invocationOnMock ) throws java . lang . Throwable { System . out . println ( \"Hit<sp>me<sp>baby<sp>one<sp>more<sp>time!\" ) ; return null ; } } ) . when ( ( ( com . blogspot . toomuchcoding . service . DJ ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . playSomeMusic ( ) ; doAnswer ( new org . mockito . stubbing . Answer < java . lang . Object > ( ) { @ com . blogspot . toomuchcoding . service . Override public java . lang . Object answer ( org . mockito . invocation . InvocationOnMock invocationOnMock ) throws java . lang . Throwable { System . out . println ( \"public<sp>static<sp>void<sp>main(String...<sp>args){\\n}\" ) ; return null ; } } ) . when ( ( ( com . blogspot . toomuchcoding . service . JavaDeveloper ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . doSomeSeriousCoding ( ) ; com . blogspot . toomuchcoding . service . Player createdPlayer = objectUnderTest . playAGameWithAPlayerOfPosition ( PositionType . GK ) ; \"<AssertPlaceHolder>\" ; verify ( defensivePlayerWithDjAndJavaDevSkills ) . run ( ) ; verify ( defensivePlayerWithDjAndJavaDevSkills ) . defend ( ) ; verify ( ( ( com . blogspot . toomuchcoding . service . DJ ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . playSomeMusic ( ) ; verify ( ( ( com . blogspot . toomuchcoding . service . JavaDeveloper ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . doSomeSeriousCoding ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( ( createdPlayer == ( defensivePlayerWithDjAndJavaDevSkills ) ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "shouldReturnDefensivePlayerBeingADjAndAJavaDev ( ) { given ( playerFactory . createPlayer ( PositionType . GK ) ) . willReturn ( defensivePlayerWithDjAndJavaDevSkills ) ; doAnswer ( new org . mockito . stubbing . Answer < java . lang . Object > ( ) { @ com . blogspot . toomuchcoding . service . Override public java . lang . Object answer ( org . mockito . invocation . InvocationOnMock invocationOnMock ) throws java . lang . Throwable { System . out . println ( \"Hit<sp>me<sp>baby<sp>one<sp>more<sp>time!\" ) ; return null ; } } ) . when ( ( ( com . blogspot . toomuchcoding . service . DJ ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . playSomeMusic ( ) ; doAnswer ( new org . mockito . stubbing . Answer < java . lang . Object > ( ) { @ com . blogspot . toomuchcoding . service . Override public java . lang . Object answer ( org . mockito . invocation . InvocationOnMock invocationOnMock ) throws java . lang . Throwable { System . out . println ( \"public<sp>static<sp>void<sp>main(String...<sp>args){\\n}\" ) ; return null ; } } ) . when ( ( ( com . blogspot . toomuchcoding . service . JavaDeveloper ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . doSomeSeriousCoding ( ) ; com . blogspot . toomuchcoding . service . Player createdPlayer = objectUnderTest . playAGameWithAPlayerOfPosition ( PositionType . GK ) ; \"<AssertPlaceHolder>\" ; verify ( defensivePlayerWithDjAndJavaDevSkills ) . run ( ) ; verify ( defensivePlayerWithDjAndJavaDevSkills ) . defend ( ) ; verify ( ( ( com . blogspot . toomuchcoding . service . DJ ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . playSomeMusic ( ) ; verify ( ( ( com . blogspot . toomuchcoding . service . JavaDeveloper ) ( defensivePlayerWithDjAndJavaDevSkills ) ) ) . doSomeSeriousCoding ( ) ; } playAGameWithAPlayerOfPosition ( com . blogspot . toomuchcoding . service . PositionType ) { com . blogspot . toomuchcoding . service . Player player = playerFactory . createPlayer ( positionType ) ; player . run ( ) ; performAdditionalActions ( player ) ; return player ; }", "answer": "org . junit . Assert . assertThat ( ( createdPlayer == ( defensivePlayerWithDjAndJavaDevSkills ) ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getTimeoutTask ( ) { return timeoutTask ; }", "testMethod": "shouldCancelExistingTimeoutTask ( ) { org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; fr . xephi . authme . data . limbo . LimboPlayer limboPlayer = new fr . xephi . authme . data . limbo . LimboPlayer ( null , false , java . util . Collections . emptyList ( ) , true , 0.3F , 0.1F ) ; org . bukkit . scheduler . BukkitTask existingTask = mock ( org . bukkit . scheduler . BukkitTask . class ) ; limboPlayer . setTimeoutTask ( existingTask ) ; given ( settings . getProperty ( RestrictionSettings . TIMEOUT ) ) . willReturn ( 18 ) ; org . bukkit . scheduler . BukkitTask bukkitTask = mock ( org . bukkit . scheduler . BukkitTask . class ) ; given ( bukkitService . runTaskLater ( any ( fr . xephi . authme . task . TimeoutTask . class ) , anyLong ( ) ) ) . willReturn ( bukkitTask ) ; limboPlayerTaskManager . registerTimeoutTask ( player , limboPlayer ) ; verify ( existingTask ) . cancel ( ) ; \"<AssertPlaceHolder>\" ; verify ( bukkitService ) . runTaskLater ( any ( fr . xephi . authme . task . TimeoutTask . class ) , eq ( 360L ) ) ; verify ( messages ) . retrieveSingle ( player , MessageKey . LOGIN_TIMEOUT_ERROR ) ; }", "assertLine": "org . junit . Assert . assertThat ( limboPlayer . getTimeoutTask ( ) , org . hamcrest . Matchers . equalTo ( bukkitTask ) )", "total": "shouldCancelExistingTimeoutTask ( ) { org . bukkit . entity . Player player = mock ( org . bukkit . entity . Player . class ) ; fr . xephi . authme . data . limbo . LimboPlayer limboPlayer = new fr . xephi . authme . data . limbo . LimboPlayer ( null , false , java . util . Collections . emptyList ( ) , true , 0.3F , 0.1F ) ; org . bukkit . scheduler . BukkitTask existingTask = mock ( org . bukkit . scheduler . BukkitTask . class ) ; limboPlayer . setTimeoutTask ( existingTask ) ; given ( settings . getProperty ( RestrictionSettings . TIMEOUT ) ) . willReturn ( 18 ) ; org . bukkit . scheduler . BukkitTask bukkitTask = mock ( org . bukkit . scheduler . BukkitTask . class ) ; given ( bukkitService . runTaskLater ( any ( fr . xephi . authme . task . TimeoutTask . class ) , anyLong ( ) ) ) . willReturn ( bukkitTask ) ; limboPlayerTaskManager . registerTimeoutTask ( player , limboPlayer ) ; verify ( existingTask ) . cancel ( ) ; \"<AssertPlaceHolder>\" ; verify ( bukkitService ) . runTaskLater ( any ( fr . xephi . authme . task . TimeoutTask . class ) , eq ( 360L ) ) ; verify ( messages ) . retrieveSingle ( player , MessageKey . LOGIN_TIMEOUT_ERROR ) ; } getTimeoutTask ( ) { return timeoutTask ; }", "answer": "org . junit . Assert . assertThat ( limboPlayer . getTimeoutTask ( ) , org . hamcrest . Matchers . equalTo ( bukkitTask ) )"}
{"focal": "exists ( ) { return ( getId ( ) ) != null ; }", "testMethod": "convertAnODTDocumentToPDF ( ) { java . io . File convertedDocument = converter . convert ( document , inFormat ( pdf ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( convertedDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "convertAnODTDocumentToPDF ( ) { java . io . File convertedDocument = converter . convert ( document , inFormat ( pdf ) ) ; \"<AssertPlaceHolder>\" ; } exists ( ) { return ( getId ( ) ) != null ; }", "answer": "org . junit . Assert . assertThat ( convertedDocument . exists ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getCriterionsNumber ( org . libreplan . business . resources . entities . ICriterionType ) { return adHocTransactionService . runOnTransaction ( new org . libreplan . business . common . IOnTransaction < java . lang . Integer > ( ) { @ org . libreplan . web . resources . Override public org . libreplan . web . resources . Integer execute ( ) { return criterionDAO . findByType ( type ) . size ( ) ; } } ) . intValue ( ) ; }", "testMethod": "modifyingDontAlterTheNumberOfCriterions ( ) { givenCreatedCriterionFor ( PredefinedCriterionTypes . CATEGORY ) ; int initial = getCriterionsNumber ( PredefinedCriterionTypes . CATEGORY ) ; java . lang . String newName = ( java . util . UUID . randomUUID ( ) . toString ( ) ) + \"random\" ; criterion . setName ( newName ) ; criterionDAO . save ( criterion ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( getCriterionsNumber ( PredefinedCriterionTypes . CATEGORY ) , org . hamcrest . CoreMatchers . equalTo ( initial ) )", "total": "modifyingDontAlterTheNumberOfCriterions ( ) { givenCreatedCriterionFor ( PredefinedCriterionTypes . CATEGORY ) ; int initial = getCriterionsNumber ( PredefinedCriterionTypes . CATEGORY ) ; java . lang . String newName = ( java . util . UUID . randomUUID ( ) . toString ( ) ) + \"random\" ; criterion . setName ( newName ) ; criterionDAO . save ( criterion ) ; \"<AssertPlaceHolder>\" ; } getCriterionsNumber ( org . libreplan . business . resources . entities . ICriterionType ) { return adHocTransactionService . runOnTransaction ( new org . libreplan . business . common . IOnTransaction < java . lang . Integer > ( ) { @ org . libreplan . web . resources . Override public org . libreplan . web . resources . Integer execute ( ) { return criterionDAO . findByType ( type ) . size ( ) ; } } ) . intValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( getCriterionsNumber ( PredefinedCriterionTypes . CATEGORY ) , org . hamcrest . CoreMatchers . equalTo ( initial ) )"}
{"focal": "getURI ( ) { return \"orderfrequency\" ; }", "testMethod": "shouldAddAttributeToPerson ( ) { int before = service . getPersonByUuid ( personUuid ) . getAttributes ( ) . size ( ) ; java . lang . String json = \"{<sp>\\\"attributeType\\\":\\\"b3b6d540-a32e-44c7-91b3-292d97667518\\\",<sp>\\\"value\\\":\\\"testing\\\"}\" ; handle ( newPostRequest ( getURI ( ) , json ) ) ; int after = service . getPersonByUuid ( personUuid ) . getAttributes ( ) . size ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( after , org . hamcrest . Matchers . is ( ( before + 1 ) ) )", "total": "shouldAddAttributeToPerson ( ) { int before = service . getPersonByUuid ( personUuid ) . getAttributes ( ) . size ( ) ; java . lang . String json = \"{<sp>\\\"attributeType\\\":\\\"b3b6d540-a32e-44c7-91b3-292d97667518\\\",<sp>\\\"value\\\":\\\"testing\\\"}\" ; handle ( newPostRequest ( getURI ( ) , json ) ) ; int after = service . getPersonByUuid ( personUuid ) . getAttributes ( ) . size ( ) ; \"<AssertPlaceHolder>\" ; } getURI ( ) { return \"orderfrequency\" ; }", "answer": "org . junit . Assert . assertThat ( after , org . hamcrest . Matchers . is ( ( before + 1 ) ) )"}
{"focal": "next ( ) { return safeElement ( org . xwiki . script . internal . safe . SafeIterator . getWrapped ( ) . next ( ) ) ; }", "testMethod": "testPreCalculatedSignature ( ) { byte [ ] signature = generator . generate ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , new org . xwiki . crypto . signer . param . CMSSignedDataGeneratorParameters ( ) . addSigner ( org . xwiki . crypto . pkix . CertifyingSigner . getInstance ( true , new org . xwiki . crypto . pkix . params . CertifiedKeyPair ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . dsaPrivateKey , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3Cert ) , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . dsaSignerFactory ) ) ) ; org . xwiki . crypto . signer . param . CMSSignedDataVerified result = verifier . verify ( signature , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , java . util . Arrays . asList ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3Cert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3InterCaCert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3CaCert ) ) ; byte [ ] signature2 = generator . generate ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , new org . xwiki . crypto . signer . param . CMSSignedDataGeneratorParameters ( ) . addSignature ( result . getSignatures ( ) . iterator ( ) . next ( ) ) ) ; result = verifier . verify ( signature2 , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , java . util . Arrays . asList ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3Cert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3InterCaCert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3CaCert ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( signature2 , org . hamcrest . Matchers . equalTo ( signature ) )", "total": "testPreCalculatedSignature ( ) { byte [ ] signature = generator . generate ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , new org . xwiki . crypto . signer . param . CMSSignedDataGeneratorParameters ( ) . addSigner ( org . xwiki . crypto . pkix . CertifyingSigner . getInstance ( true , new org . xwiki . crypto . pkix . params . CertifiedKeyPair ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . dsaPrivateKey , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3Cert ) , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . dsaSignerFactory ) ) ) ; org . xwiki . crypto . signer . param . CMSSignedDataVerified result = verifier . verify ( signature , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , java . util . Arrays . asList ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3Cert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3InterCaCert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3CaCert ) ) ; byte [ ] signature2 = generator . generate ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , new org . xwiki . crypto . signer . param . CMSSignedDataGeneratorParameters ( ) . addSignature ( result . getSignatures ( ) . iterator ( ) . next ( ) ) ) ; result = verifier . verify ( signature2 , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . text , java . util . Arrays . asList ( org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3Cert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3InterCaCert , org . xwiki . crypto . signer . internal . cms . DefaultCMSSignedDataTest . v3CaCert ) ) ; \"<AssertPlaceHolder>\" ; } next ( ) { return safeElement ( org . xwiki . script . internal . safe . SafeIterator . getWrapped ( ) . next ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( signature2 , org . hamcrest . Matchers . equalTo ( signature ) )"}
{"focal": "reverseOverlay ( java . util . List , java . util . List ) { return top . equals ( bottom ) ? null : top ; }", "testMethod": "testReverseOverlayList_valuesNotEqual ( ) { java . util . List < java . lang . String > str = sut . reverseOverlay ( newArrayList ( \"bottom\" ) , newArrayList ( \"top\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( str , org . hamcrest . Matchers . contains ( \"top\" ) )", "total": "testReverseOverlayList_valuesNotEqual ( ) { java . util . List < java . lang . String > str = sut . reverseOverlay ( newArrayList ( \"bottom\" ) , newArrayList ( \"top\" ) ) ; \"<AssertPlaceHolder>\" ; } reverseOverlay ( java . util . List , java . util . List ) { return top . equals ( bottom ) ? null : top ; }", "answer": "org . junit . Assert . assertThat ( str , org . hamcrest . Matchers . contains ( \"top\" ) )"}
{"focal": "hasPendingChanges ( ) { return session ( ) . hasPendingChanges ( ) ; }", "testMethod": "shouldNotHavePendingChanges ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( session . hasPendingChanges ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "shouldNotHavePendingChanges ( ) { \"<AssertPlaceHolder>\" ; } hasPendingChanges ( ) { return session ( ) . hasPendingChanges ( ) ; }", "answer": "org . junit . Assert . assertThat ( session . hasPendingChanges ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testDeleteVtapNetworkWithDeletionOperation ( ) { expect ( mockVtapService . removeVtapNetwork ( ) ) . andReturn ( vtapNetwork ) . once ( ) ; replay ( mockVtapService ) ; final javax . ws . rs . client . WebTarget wt = target ( ) ; javax . ws . rs . core . Response response = wt . path ( org . onosproject . openstackvtap . web . OpenstackVtapNetworkWebResourceTest . PATH ) . request ( MediaType . APPLICATION_JSON_TYPE ) . delete ( ) ; final int status = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; verify ( mockVtapService ) ; }", "assertLine": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( 200 ) )", "total": "testDeleteVtapNetworkWithDeletionOperation ( ) { expect ( mockVtapService . removeVtapNetwork ( ) ) . andReturn ( vtapNetwork ) . once ( ) ; replay ( mockVtapService ) ; final javax . ws . rs . client . WebTarget wt = target ( ) ; javax . ws . rs . core . Response response = wt . path ( org . onosproject . openstackvtap . web . OpenstackVtapNetworkWebResourceTest . PATH ) . request ( MediaType . APPLICATION_JSON_TYPE ) . delete ( ) ; final int status = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; verify ( mockVtapService ) ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( status , org . hamcrest . Matchers . is ( 200 ) )"}
{"focal": "getCause ( ) { return cause ; }", "testMethod": "throwExceptionWhenFailedToReadEvents ( ) { java . io . IOException exception = new java . io . IOException ( ) ; when ( storage . readEvents ( com . spotify . styx . util . WORKFLOW_INSTANCE ) ) . thenThrow ( exception ) ; try { com . spotify . styx . util . ReplayEvents . getBackfillRunStateData ( com . spotify . styx . util . WORKFLOW_INSTANCE , storage , \"bf-1\" ) ; org . junit . Assert . fail ( ) ; } catch ( java . lang . RuntimeException e ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( e . getCause ( ) , org . hamcrest . core . Is . is ( exception ) )", "total": "throwExceptionWhenFailedToReadEvents ( ) { java . io . IOException exception = new java . io . IOException ( ) ; when ( storage . readEvents ( com . spotify . styx . util . WORKFLOW_INSTANCE ) ) . thenThrow ( exception ) ; try { com . spotify . styx . util . ReplayEvents . getBackfillRunStateData ( com . spotify . styx . util . WORKFLOW_INSTANCE , storage , \"bf-1\" ) ; org . junit . Assert . fail ( ) ; } catch ( java . lang . RuntimeException e ) { \"<AssertPlaceHolder>\" ; } } getCause ( ) { return cause ; }", "answer": "org . junit . Assert . assertThat ( e . getCause ( ) , org . hamcrest . core . Is . is ( exception ) )"}
{"focal": "isContainerMode ( ) { return this . containerMode ; }", "testMethod": "createsContainerConfiguration ( ) { org . mule . runtime . module . deployment . impl . internal . domain . DomainMuleContextBuilder builder = new org . mule . runtime . module . deployment . impl . internal . domain . DomainMuleContextBuilder ( \"test\" ) ; org . mule . runtime . core . api . config . MuleConfiguration muleConfiguration = builder . getMuleConfiguration ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( muleConfiguration . isContainerMode ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "createsContainerConfiguration ( ) { org . mule . runtime . module . deployment . impl . internal . domain . DomainMuleContextBuilder builder = new org . mule . runtime . module . deployment . impl . internal . domain . DomainMuleContextBuilder ( \"test\" ) ; org . mule . runtime . core . api . config . MuleConfiguration muleConfiguration = builder . getMuleConfiguration ( ) ; \"<AssertPlaceHolder>\" ; } isContainerMode ( ) { return this . containerMode ; }", "answer": "org . junit . Assert . assertThat ( muleConfiguration . isContainerMode ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "hashCode ( ) { return hash ; }", "testMethod": "shouldReturnSameHashCodeForNamesWithSameNamespaceUriAndLocalPart ( ) { org . modeshape . jcr . value . Name other = new org . modeshape . jcr . value . basic . BasicName ( name . getNamespaceUri ( ) , name . getLocalName ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( name . hashCode ( ) , org . hamcrest . core . Is . is ( other . hashCode ( ) ) )", "total": "shouldReturnSameHashCodeForNamesWithSameNamespaceUriAndLocalPart ( ) { org . modeshape . jcr . value . Name other = new org . modeshape . jcr . value . basic . BasicName ( name . getNamespaceUri ( ) , name . getLocalName ( ) ) ; \"<AssertPlaceHolder>\" ; } hashCode ( ) { return hash ; }", "answer": "org . junit . Assert . assertThat ( name . hashCode ( ) , org . hamcrest . core . Is . is ( other . hashCode ( ) ) )"}
{"focal": "size ( ) { return delegate . size ( ) ; }", "testMethod": "convertsSingleMapToRedisServerReturnsCollectionCorrectly ( ) { java . util . Map < java . lang . String , java . lang . String > values = getRedisServerInfoMap ( \"mymaster\" , 23697 ) ; java . util . List < org . springframework . data . redis . connection . RedisServer > servers = org . springframework . data . redis . connection . jedis . JedisConverters . toListOfRedisServer ( java . util . Collections . singletonList ( values ) ) ; \"<AssertPlaceHolder>\" ; verifyRedisServerInfo ( servers . get ( 0 ) , values ) ; }", "assertLine": "org . junit . Assert . assertThat ( servers . size ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "convertsSingleMapToRedisServerReturnsCollectionCorrectly ( ) { java . util . Map < java . lang . String , java . lang . String > values = getRedisServerInfoMap ( \"mymaster\" , 23697 ) ; java . util . List < org . springframework . data . redis . connection . RedisServer > servers = org . springframework . data . redis . connection . jedis . JedisConverters . toListOfRedisServer ( java . util . Collections . singletonList ( values ) ) ; \"<AssertPlaceHolder>\" ; verifyRedisServerInfo ( servers . get ( 0 ) , values ) ; } size ( ) { return delegate . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( servers . size ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "testMethod": "projectionAsFirstOperation1 ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"Records\" ) , Projection ( Sequence ( Property ( \"userIdentity\" ) , Array ( java . util . Arrays . asList ( Property ( \"userName\" ) , Sequence ( Property ( \"sessionContext\" ) , Sequence ( Property ( \"attributes\" ) , Property ( \"mfaAuthenticated\" ) ) ) ) ) ) ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"Records[*].userIdentity.[userName,<sp>sessionContext.attributes.mfaAuthenticated]\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "projectionAsFirstOperation1 ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"Records\" ) , Projection ( Sequence ( Property ( \"userIdentity\" ) , Array ( java . util . Arrays . asList ( Property ( \"userName\" ) , Sequence ( Property ( \"sessionContext\" ) , Sequence ( Property ( \"attributes\" ) , Property ( \"mfaAuthenticated\" ) ) ) ) ) ) ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"Records[*].userIdentity.[userName,<sp>sessionContext.attributes.mfaAuthenticated]\" ) ; \"<AssertPlaceHolder>\" ; } compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "initElements ( org . openqa . selenium . WebDriver , java . lang . Class ) { T page = org . openqa . selenium . support . PageFactory . instantiatePage ( driver , pageClassToProxy ) ; org . openqa . selenium . support . PageFactory . initElements ( driver , page ) ; return page ; }", "testMethod": "shouldUseAConstructorThatTakesAWebDriverAsAnArgument ( ) { driver = mock ( org . openqa . selenium . WebDriver . class ) ; org . openqa . selenium . support . PageFactoryTest . ConstructedPage page = org . openqa . selenium . support . PageFactory . initElements ( driver , org . openqa . selenium . support . PageFactoryTest . ConstructedPage . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( driver , org . hamcrest . Matchers . equalTo ( page . driver ) )", "total": "shouldUseAConstructorThatTakesAWebDriverAsAnArgument ( ) { driver = mock ( org . openqa . selenium . WebDriver . class ) ; org . openqa . selenium . support . PageFactoryTest . ConstructedPage page = org . openqa . selenium . support . PageFactory . initElements ( driver , org . openqa . selenium . support . PageFactoryTest . ConstructedPage . class ) ; \"<AssertPlaceHolder>\" ; } initElements ( org . openqa . selenium . WebDriver , java . lang . Class ) { T page = org . openqa . selenium . support . PageFactory . instantiatePage ( driver , pageClassToProxy ) ; org . openqa . selenium . support . PageFactory . initElements ( driver , page ) ; return page ; }", "answer": "org . junit . Assert . assertThat ( driver , org . hamcrest . Matchers . equalTo ( page . driver ) )"}
{"focal": "equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "testMethod": "testSourceGetOutputCoderReturnsConstructorCoder ( ) { org . apache . beam . sdk . coders . Coder < java . lang . Integer > coder = org . apache . beam . sdk . coders . VarIntCoder . of ( ) ; org . apache . beam . sdk . transforms . Create . Values . CreateSource < java . lang . Integer > source = org . apache . beam . sdk . transforms . Create . Values . CreateSource . fromIterable ( org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . of ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) , coder ) ; org . apache . beam . sdk . coders . Coder < java . lang . Integer > defaultCoder = source . getOutputCoder ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( defaultCoder , org . hamcrest . Matchers . equalTo ( coder ) )", "total": "testSourceGetOutputCoderReturnsConstructorCoder ( ) { org . apache . beam . sdk . coders . Coder < java . lang . Integer > coder = org . apache . beam . sdk . coders . VarIntCoder . of ( ) ; org . apache . beam . sdk . transforms . Create . Values . CreateSource < java . lang . Integer > source = org . apache . beam . sdk . transforms . Create . Values . CreateSource . fromIterable ( org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableList . of ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) , coder ) ; org . apache . beam . sdk . coders . Coder < java . lang . Integer > defaultCoder = source . getOutputCoder ( ) ; \"<AssertPlaceHolder>\" ; } equalTo ( T extends java . io . Serializable ) { return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . equalTo ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( defaultCoder , org . hamcrest . Matchers . equalTo ( coder ) )"}
{"focal": "eval ( java . io . InputStream ) { return getRuntime ( ) . evaluate ( new org . dynjs . runtime . source . InputStreamSourceProvider ( in ) ) ; }", "testMethod": "testNumberToStringWithNoRadix ( ) { java . lang . Object result = eval ( \"Number(255).toString()\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"255\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( result )", "total": "testNumberToStringWithNoRadix ( ) { java . lang . Object result = eval ( \"Number(255).toString()\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( \"255\" ) ; } eval ( java . io . InputStream ) { return getRuntime ( ) . evaluate ( new org . dynjs . runtime . source . InputStreamSourceProvider ( in ) ) ; }", "answer": "org . junit . Assert . assertThat ( result )"}
{"focal": "lspEntry ( ) { return lspEntryList ; }", "testMethod": "testLspEntry ( ) { lspEntriesTlv . addLspEntry ( new org . onosproject . isis . io . isispacket . tlv . LspEntry ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( lspEntriesTlv . lspEntry ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testLspEntry ( ) { lspEntriesTlv . addLspEntry ( new org . onosproject . isis . io . isispacket . tlv . LspEntry ( ) ) ; \"<AssertPlaceHolder>\" ; } lspEntry ( ) { return lspEntryList ; }", "answer": "org . junit . Assert . assertThat ( lspEntriesTlv . lspEntry ( ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getURI ( ) { java . lang . String host = getOptions ( ) . getUriHost ( ) ; if ( host == null ) { if ( ( getDestination ( ) ) != null ) { host = getDestination ( ) . getHostAddress ( ) ; } else { host = \"localhost\" ; } } java . lang . Integer port = getOptions ( ) . getUriPort ( ) ; if ( port == null ) { port = getDestinationPort ( ) ; } if ( port > 0 ) { if ( org . eclipse . californium . core . coap . CoAP . isSupportedScheme ( getScheme ( ) ) ) { if ( ( org . eclipse . californium . core . coap . CoAP . getDefaultPort ( getScheme ( ) ) ) == port ) { port = - 1 ; } } } else { port = - 1 ; } java . lang . String path = \"/\" + ( getOptions ( ) . getUriPathString ( ) ) ; java . lang . String query = ( ( getOptions ( ) . getURIQueryCount ( ) ) > 0 ) ? getOptions ( ) . getUriQueryString ( ) : null ; try { java . net . URI uri = new java . net . URI ( getScheme ( ) , null , host , port , path , query , null ) ; return uri . toASCIIString ( ) ; } catch ( java . net . URISyntaxException e ) { throw new java . lang . IllegalStateException ( \"cannot<sp>create<sp>URI<sp>from<sp>request\" , e ) ; } }", "testMethod": "testGetURIWithPathAndWithoutQuery ( ) { org . eclipse . californium . core . coap . Request req = org . eclipse . californium . core . coap . Request . newGet ( ) . setURI ( \"coap://192.168.0.1:12000/30/40\" ) ; java . lang . String uri = req . getURI ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uri , org . hamcrest . CoreMatchers . is ( \"coap://192.168.0.1:12000/30/40\" ) )", "total": "testGetURIWithPathAndWithoutQuery ( ) { org . eclipse . californium . core . coap . Request req = org . eclipse . californium . core . coap . Request . newGet ( ) . setURI ( \"coap://192.168.0.1:12000/30/40\" ) ; java . lang . String uri = req . getURI ( ) ; \"<AssertPlaceHolder>\" ; } getURI ( ) { java . lang . String host = getOptions ( ) . getUriHost ( ) ; if ( host == null ) { if ( ( getDestination ( ) ) != null ) { host = getDestination ( ) . getHostAddress ( ) ; } else { host = \"localhost\" ; } } java . lang . Integer port = getOptions ( ) . getUriPort ( ) ; if ( port == null ) { port = getDestinationPort ( ) ; } if ( port > 0 ) { if ( org . eclipse . californium . core . coap . CoAP . isSupportedScheme ( getScheme ( ) ) ) { if ( ( org . eclipse . californium . core . coap . CoAP . getDefaultPort ( getScheme ( ) ) ) == port ) { port = - 1 ; } } } else { port = - 1 ; } java . lang . String path = \"/\" + ( getOptions ( ) . getUriPathString ( ) ) ; java . lang . String query = ( ( getOptions ( ) . getURIQueryCount ( ) ) > 0 ) ? getOptions ( ) . getUriQueryString ( ) : null ; try { java . net . URI uri = new java . net . URI ( getScheme ( ) , null , host , port , path , query , null ) ; return uri . toASCIIString ( ) ; } catch ( java . net . URISyntaxException e ) { throw new java . lang . IllegalStateException ( \"cannot<sp>create<sp>URI<sp>from<sp>request\" , e ) ; } }", "answer": "org . junit . Assert . assertThat ( uri , org . hamcrest . CoreMatchers . is ( \"coap://192.168.0.1:12000/30/40\" ) )"}
{"focal": "arangoSearch ( java . lang . String ) { return new com . arangodb . internal . ArangoSearchImpl ( this , name ) ; }", "testMethod": "exists ( ) { if ( ! ( requireVersion ( 3 , 4 ) ) ) { return ; } db . createArangoSearch ( com . arangodb . ArangoSearchTest . VIEW_NAME , new com . arangodb . model . arangosearch . ArangoSearchCreateOptions ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( db . arangoSearch ( com . arangodb . ArangoSearchTest . VIEW_NAME ) . exists ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "exists ( ) { if ( ! ( requireVersion ( 3 , 4 ) ) ) { return ; } db . createArangoSearch ( com . arangodb . ArangoSearchTest . VIEW_NAME , new com . arangodb . model . arangosearch . ArangoSearchCreateOptions ( ) ) ; \"<AssertPlaceHolder>\" ; } arangoSearch ( java . lang . String ) { return new com . arangodb . internal . ArangoSearchImpl ( this , name ) ; }", "answer": "org . junit . Assert . assertThat ( db . arangoSearch ( com . arangodb . ArangoSearchTest . VIEW_NAME ) . exists ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getWarnMessages ( ) { return warnMessages ; }", "testMethod": "testWarn ( ) { mockBaseCommands . warn ( \"test\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( logger . getWarnMessages ( ) , org . hamcrest . Matchers . contains ( \"test\" ) )", "total": "testWarn ( ) { mockBaseCommands . warn ( \"test\" ) ; \"<AssertPlaceHolder>\" ; } getWarnMessages ( ) { return warnMessages ; }", "answer": "org . junit . Assert . assertThat ( logger . getWarnMessages ( ) , org . hamcrest . Matchers . contains ( \"test\" ) )"}
{"focal": "evalAndGet ( com . spotify . flo . Task ) { com . spotify . flo . context . AwaitingConsumer < T > val = new com . spotify . flo . context . AwaitingConsumer ( ) ; com . spotify . flo . EvalContext . sync ( ) . evaluate ( task ) . consume ( val ) ; return val . awaitAndGet ( ) ; }", "testMethod": "shouldHandleStreamParameters ( ) { com . spotify . flo . Fn < com . spotify . flo . Task < java . lang . Integer > > countSupplier = com . spotify . flo . TaskEvalBehaviorTest . countConstructor ( ) ; java . util . List < com . spotify . flo . Task < java . lang . Integer > > fiveInts = java . util . stream . Stream . generate ( countSupplier ) . limit ( 5 ) . collect ( toList ( ) ) ; com . spotify . flo . Task < java . lang . Integer > sum = com . spotify . flo . Task . named ( \"Sum\" ) . ofType ( com . spotify . flo . Integer . class ) . inputs ( ( ) -> fiveInts ) . process ( com . spotify . flo . TaskEvalBehaviorTest :: sumInts ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . spotify . flo . TestUtils . evalAndGet ( sum ) , org . hamcrest . Matchers . is ( 15 ) )", "total": "shouldHandleStreamParameters ( ) { com . spotify . flo . Fn < com . spotify . flo . Task < java . lang . Integer > > countSupplier = com . spotify . flo . TaskEvalBehaviorTest . countConstructor ( ) ; java . util . List < com . spotify . flo . Task < java . lang . Integer > > fiveInts = java . util . stream . Stream . generate ( countSupplier ) . limit ( 5 ) . collect ( toList ( ) ) ; com . spotify . flo . Task < java . lang . Integer > sum = com . spotify . flo . Task . named ( \"Sum\" ) . ofType ( com . spotify . flo . Integer . class ) . inputs ( ( ) -> fiveInts ) . process ( com . spotify . flo . TaskEvalBehaviorTest :: sumInts ) ; \"<AssertPlaceHolder>\" ; } evalAndGet ( com . spotify . flo . Task ) { com . spotify . flo . context . AwaitingConsumer < T > val = new com . spotify . flo . context . AwaitingConsumer ( ) ; com . spotify . flo . EvalContext . sync ( ) . evaluate ( task ) . consume ( val ) ; return val . awaitAndGet ( ) ; }", "answer": "org . junit . Assert . assertThat ( com . spotify . flo . TestUtils . evalAndGet ( sum ) , org . hamcrest . Matchers . is ( 15 ) )"}
{"focal": "apply ( java . lang . String ) { return java . lang . String . format ( \"%s=%s\" , input , params . get ( input ) ) ; }", "testMethod": "apply_no_md5 ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( \"mntner:<sp>WEIRD-MNT\\n\" + \"auth:<sp>value\\n\" ) + \"source:<sp>RIPE\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject response = subject . apply ( rpslObject ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response , org . hamcrest . Matchers . is ( rpslObject ) )", "total": "apply_no_md5 ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( \"mntner:<sp>WEIRD-MNT\\n\" + \"auth:<sp>value\\n\" ) + \"source:<sp>RIPE\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject response = subject . apply ( rpslObject ) ; \"<AssertPlaceHolder>\" ; } apply ( java . lang . String ) { return java . lang . String . format ( \"%s=%s\" , input , params . get ( input ) ) ; }", "answer": "org . junit . Assert . assertThat ( response , org . hamcrest . Matchers . is ( rpslObject ) )"}
{"focal": "getCodeLists ( ) { return codeLists ; }", "testMethod": "testAfterPropertiesSet_not_define_CodeList ( ) { testTarget . setApplicationContext ( new org . springframework . context . support . StaticApplicationContext ( ) ) ; testTarget . afterPropertiesSet ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testTarget . getCodeLists ( ) . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testAfterPropertiesSet_not_define_CodeList ( ) { testTarget . setApplicationContext ( new org . springframework . context . support . StaticApplicationContext ( ) ) ; testTarget . afterPropertiesSet ( ) ; \"<AssertPlaceHolder>\" ; } getCodeLists ( ) { return codeLists ; }", "answer": "org . junit . Assert . assertThat ( testTarget . getCodeLists ( ) . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "isDone ( ) { return delegate . isDone ( ) ; }", "testMethod": "testConcurrentLeadershipOperationsBlockingGainLeadership ( ) { final java . util . concurrent . CompletableFuture < java . lang . Exception > suspendFuture = new java . util . concurrent . CompletableFuture ( ) ; final java . util . concurrent . CompletableFuture < org . apache . flink . runtime . messages . Acknowledge > startFuture = new java . util . concurrent . CompletableFuture ( ) ; org . apache . flink . runtime . jobmaster . factories . TestingJobMasterServiceFactory jobMasterServiceFactory = new org . apache . flink . runtime . jobmaster . factories . TestingJobMasterServiceFactory ( ( ) -> new org . apache . flink . runtime . jobmaster . TestingJobMasterService ( \"localhost\" , ( e ) -> { suspendFuture . complete ( e ) ; return java . util . concurrent . CompletableFuture . completedFuture ( org . apache . flink . runtime . messages . Acknowledge . get ( ) ) ; } , ( ignored ) -> startFuture ) ) ; org . apache . flink . runtime . jobmaster . JobManagerRunner jobManagerRunner = createJobManagerRunner ( jobMasterServiceFactory ) ; jobManagerRunner . start ( ) ; leaderElectionService . isLeader ( java . util . UUID . randomUUID ( ) ) ; leaderElectionService . notLeader ( ) ; \"<AssertPlaceHolder>\" ; try { suspendFuture . get ( 1L , TimeUnit . MILLISECONDS ) ; org . junit . Assert . fail ( \"Suspended<sp>leadership<sp>even<sp>though<sp>the<sp>JobMaster<sp>has<sp>not<sp>been<sp>started.\" ) ; } catch ( java . util . concurrent . TimeoutException expected ) { } startFuture . complete ( org . apache . flink . runtime . messages . Acknowledge . get ( ) ) ; suspendFuture . get ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( suspendFuture . isDone ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "testConcurrentLeadershipOperationsBlockingGainLeadership ( ) { final java . util . concurrent . CompletableFuture < java . lang . Exception > suspendFuture = new java . util . concurrent . CompletableFuture ( ) ; final java . util . concurrent . CompletableFuture < org . apache . flink . runtime . messages . Acknowledge > startFuture = new java . util . concurrent . CompletableFuture ( ) ; org . apache . flink . runtime . jobmaster . factories . TestingJobMasterServiceFactory jobMasterServiceFactory = new org . apache . flink . runtime . jobmaster . factories . TestingJobMasterServiceFactory ( ( ) -> new org . apache . flink . runtime . jobmaster . TestingJobMasterService ( \"localhost\" , ( e ) -> { suspendFuture . complete ( e ) ; return java . util . concurrent . CompletableFuture . completedFuture ( org . apache . flink . runtime . messages . Acknowledge . get ( ) ) ; } , ( ignored ) -> startFuture ) ) ; org . apache . flink . runtime . jobmaster . JobManagerRunner jobManagerRunner = createJobManagerRunner ( jobMasterServiceFactory ) ; jobManagerRunner . start ( ) ; leaderElectionService . isLeader ( java . util . UUID . randomUUID ( ) ) ; leaderElectionService . notLeader ( ) ; \"<AssertPlaceHolder>\" ; try { suspendFuture . get ( 1L , TimeUnit . MILLISECONDS ) ; org . junit . Assert . fail ( \"Suspended<sp>leadership<sp>even<sp>though<sp>the<sp>JobMaster<sp>has<sp>not<sp>been<sp>started.\" ) ; } catch ( java . util . concurrent . TimeoutException expected ) { } startFuture . complete ( org . apache . flink . runtime . messages . Acknowledge . get ( ) ) ; suspendFuture . get ( ) ; } isDone ( ) { return delegate . isDone ( ) ; }", "answer": "org . junit . Assert . assertThat ( suspendFuture . isDone ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "zouGeenMeldingenMoetenGevenOmdatNieuweSituatieNullIs ( ) { java . util . List < nl . bzk . brp . model . validatie . Melding > meldings = brby0901 . executeer ( oudeSituatie , null , null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( meldings . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "zouGeenMeldingenMoetenGevenOmdatNieuweSituatieNullIs ( ) { java . util . List < nl . bzk . brp . model . validatie . Melding > meldings = brby0901 . executeer ( oudeSituatie , null , null ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( meldings . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "saveQuestionGroupInstance ( org . mifos . platform . questionnaire . service . dtos . QuestionGroupInstanceDto ) { org . mifos . platform . questionnaire . domain . QuestionGroupInstance questionGroupInstance = questionnaireMapper . mapToQuestionGroupInstance ( questionGroupInstanceDto ) ; return questionGroupInstanceDao . create ( questionGroupInstance ) ; }", "testMethod": "testSaveQuestionGroupInstance ( ) { org . mifos . platform . questionnaire . service . dtos . QuestionGroupInstanceDto questionGroupInstanceDto = new org . mifos . platform . questionnaire . service . dtos . QuestionGroupInstanceDto ( ) ; when ( questionnaireService . saveQuestionGroupInstance ( questionGroupInstanceDto ) ) . thenReturn ( 1234 ) ; java . lang . Integer qgInstanceId = questionnaireServiceFacade . saveQuestionGroupInstance ( questionGroupInstanceDto ) ; \"<AssertPlaceHolder>\" ; verify ( questionnaireService ) . saveQuestionGroupInstance ( questionGroupInstanceDto ) ; }", "assertLine": "org . junit . Assert . assertThat ( qgInstanceId , org . hamcrest . Matchers . is ( 1234 ) )", "total": "testSaveQuestionGroupInstance ( ) { org . mifos . platform . questionnaire . service . dtos . QuestionGroupInstanceDto questionGroupInstanceDto = new org . mifos . platform . questionnaire . service . dtos . QuestionGroupInstanceDto ( ) ; when ( questionnaireService . saveQuestionGroupInstance ( questionGroupInstanceDto ) ) . thenReturn ( 1234 ) ; java . lang . Integer qgInstanceId = questionnaireServiceFacade . saveQuestionGroupInstance ( questionGroupInstanceDto ) ; \"<AssertPlaceHolder>\" ; verify ( questionnaireService ) . saveQuestionGroupInstance ( questionGroupInstanceDto ) ; } saveQuestionGroupInstance ( org . mifos . platform . questionnaire . service . dtos . QuestionGroupInstanceDto ) { org . mifos . platform . questionnaire . domain . QuestionGroupInstance questionGroupInstance = questionnaireMapper . mapToQuestionGroupInstance ( questionGroupInstanceDto ) ; return questionGroupInstanceDao . create ( questionGroupInstance ) ; }", "answer": "org . junit . Assert . assertThat ( qgInstanceId , org . hamcrest . Matchers . is ( 1234 ) )"}
{"focal": "toString ( ) { return ( ( ( \"ReportSet{id='\" + ( getId ( ) ) ) + \"',<sp>reports=\" ) + ( reports ) ) + \"}\" ; }", "testMethod": "copyByteArrayValidWriterJunkEncoding ( ) { java . lang . String probe = \"A<sp>string<sp>\" ; java . io . StringWriter writer = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseStringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( probe . getBytes ( ) , writer , \"junk\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( writer . toString ( ) . getBytes ( ) , org . hamcrest . CoreMatchers . is ( probe . getBytes ( ) ) )", "total": "copyByteArrayValidWriterJunkEncoding ( ) { java . lang . String probe = \"A<sp>string<sp>\" ; java . io . StringWriter writer = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseStringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( probe . getBytes ( ) , writer , \"junk\" ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return ( ( ( \"ReportSet{id='\" + ( getId ( ) ) ) + \"',<sp>reports=\" ) + ( reports ) ) + \"}\" ; }", "answer": "org . junit . Assert . assertThat ( writer . toString ( ) . getBytes ( ) , org . hamcrest . CoreMatchers . is ( probe . getBytes ( ) ) )"}
{"focal": "getEffectiveDomainPermissions ( com . acciente . oacc . Resource , java . lang . String ) { com . acciente . oacc . sql . internal . persister . SQLConnection connection = null ; __assertAuthenticated ( ) ; __assertResourceSpecified ( accessorResource ) ; __assertDomainSpecified ( domainName ) ; try { connection = __getConnection ( ) ; accessorResource = __resolveResource ( connection , accessorResource ) ; __assertQueryAuthorization ( connection , accessorResource ) ; return __getEffectiveDomainPermissions ( connection , accessorResource , domainName ) ; } finally { __closeConnection ( connection ) ; } }", "testMethod": "getEffectiveDomainPermissions_whitespaceConsistent ( ) { authenticateSystemResource ( ) ; final com . acciente . oacc . DomainPermission domCreatePerm_child = com . acciente . oacc . DomainPermissions . getInstance ( DomainPermissions . CREATE_CHILD_DOMAIN ) ; final java . lang . String domainName = generateDomain ( ) ; final java . lang . String domainName_whitespaced = ( \"<sp>\" + domainName ) + \"\\t\" ; com . acciente . oacc . Resource accessorResource = generateUnauthenticatableResource ( ) ; java . util . Set < com . acciente . oacc . DomainPermission > domainPermissions_pre = new java . util . HashSet ( ) ; domainPermissions_pre . add ( domCreatePerm_child ) ; accessControlContext . setDomainPermissions ( accessorResource , domainName , domainPermissions_pre ) ; final java . util . Set < com . acciente . oacc . DomainPermission > domainPermissions_post = accessControlContext . getEffectiveDomainPermissions ( accessorResource , domainName_whitespaced ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( domainPermissions_post , org . hamcrest . CoreMatchers . is ( domainPermissions_pre ) )", "total": "getEffectiveDomainPermissions_whitespaceConsistent ( ) { authenticateSystemResource ( ) ; final com . acciente . oacc . DomainPermission domCreatePerm_child = com . acciente . oacc . DomainPermissions . getInstance ( DomainPermissions . CREATE_CHILD_DOMAIN ) ; final java . lang . String domainName = generateDomain ( ) ; final java . lang . String domainName_whitespaced = ( \"<sp>\" + domainName ) + \"\\t\" ; com . acciente . oacc . Resource accessorResource = generateUnauthenticatableResource ( ) ; java . util . Set < com . acciente . oacc . DomainPermission > domainPermissions_pre = new java . util . HashSet ( ) ; domainPermissions_pre . add ( domCreatePerm_child ) ; accessControlContext . setDomainPermissions ( accessorResource , domainName , domainPermissions_pre ) ; final java . util . Set < com . acciente . oacc . DomainPermission > domainPermissions_post = accessControlContext . getEffectiveDomainPermissions ( accessorResource , domainName_whitespaced ) ; \"<AssertPlaceHolder>\" ; } getEffectiveDomainPermissions ( com . acciente . oacc . Resource , java . lang . String ) { com . acciente . oacc . sql . internal . persister . SQLConnection connection = null ; __assertAuthenticated ( ) ; __assertResourceSpecified ( accessorResource ) ; __assertDomainSpecified ( domainName ) ; try { connection = __getConnection ( ) ; accessorResource = __resolveResource ( connection , accessorResource ) ; __assertQueryAuthorization ( connection , accessorResource ) ; return __getEffectiveDomainPermissions ( connection , accessorResource , domainName ) ; } finally { __closeConnection ( connection ) ; } }", "answer": "org . junit . Assert . assertThat ( domainPermissions_post , org . hamcrest . CoreMatchers . is ( domainPermissions_pre ) )"}
{"focal": "subtract ( dk . alexandra . fresco . suite . spdz2k . datatypes . UInt32 ) { return new dk . alexandra . fresco . suite . spdz2k . datatypes . UInt32 ( ( ( value ) - ( other . value ) ) ) ; }", "testMethod": "negate ( ) { dk . alexandra . fresco . framework . builder . numeric . field . FieldElement result = element . negate ( ) ; java . math . BigInteger actual = dk . alexandra . fresco . suite . spdz2k . datatypes . CompUInt128 . extractValue ( result ) ; java . math . BigInteger expected = twoTo128 . subtract ( java . math . BigInteger . valueOf ( 9 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . core . Is . is ( expected ) )", "total": "negate ( ) { dk . alexandra . fresco . framework . builder . numeric . field . FieldElement result = element . negate ( ) ; java . math . BigInteger actual = dk . alexandra . fresco . suite . spdz2k . datatypes . CompUInt128 . extractValue ( result ) ; java . math . BigInteger expected = twoTo128 . subtract ( java . math . BigInteger . valueOf ( 9 ) ) ; \"<AssertPlaceHolder>\" ; } subtract ( dk . alexandra . fresco . suite . spdz2k . datatypes . UInt32 ) { return new dk . alexandra . fresco . suite . spdz2k . datatypes . UInt32 ( ( ( value ) - ( other . value ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . core . Is . is ( expected ) )"}
{"focal": "getChildren ( org . junit . runners . model . TestClass ) { if ( testClass == null ) return java . util . Collections . emptyList ( ) ; return testClass . getAnnotatedMethods ( org . junit . Test . class ) ; }", "testMethod": "whenCalledWithEmptyTestClass_emptyListIsReturned ( ) { org . junit . runners . model . TestClass testClass = de . bechte . junit . runners . model . TestClassPool . forClass ( de . bechte . junit . runners . context . processing . EmptyTestClassStub . class ) ; java . util . List < java . lang . Class < ? > > children = resolver . getChildren ( testClass ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( children , is ( empty ( ) ) )", "total": "whenCalledWithEmptyTestClass_emptyListIsReturned ( ) { org . junit . runners . model . TestClass testClass = de . bechte . junit . runners . model . TestClassPool . forClass ( de . bechte . junit . runners . context . processing . EmptyTestClassStub . class ) ; java . util . List < java . lang . Class < ? > > children = resolver . getChildren ( testClass ) ; \"<AssertPlaceHolder>\" ; } getChildren ( org . junit . runners . model . TestClass ) { if ( testClass == null ) return java . util . Collections . emptyList ( ) ; return testClass . getAnnotatedMethods ( org . junit . Test . class ) ; }", "answer": "org . junit . Assert . assertThat ( children , is ( empty ( ) ) )"}
{"focal": "toInt ( ) { return value . intValue ( ) ; }", "testMethod": "__A$BigDecimal ( ) { java . math . BigDecimal i_ = new java . math . BigDecimal ( 123 ) ; com . m3 . scalaflavor4j . SNum actual = com . m3 . scalaflavor4j . SNum . apply ( i_ ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . toInt ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 123 ) ) )", "total": "__A$BigDecimal ( ) { java . math . BigDecimal i_ = new java . math . BigDecimal ( 123 ) ; com . m3 . scalaflavor4j . SNum actual = com . m3 . scalaflavor4j . SNum . apply ( i_ ) ; \"<AssertPlaceHolder>\" ; } toInt ( ) { return value . intValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( actual . toInt ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 123 ) ) )"}
{"focal": "get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "testMethod": "write_max ( ) { com . asakusafw . runtime . value . ShortOption option = new com . asakusafw . runtime . value . ShortOption ( ) ; option . modify ( Short . MAX_VALUE ) ; com . asakusafw . runtime . value . ShortOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )", "total": "write_max ( ) { com . asakusafw . runtime . value . ShortOption option = new com . asakusafw . runtime . value . ShortOption ( ) ; option . modify ( Short . MAX_VALUE ) ; com . asakusafw . runtime . value . ShortOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "answer": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )"}
{"focal": "create ( java . lang . String , java . lang . String ) { com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo attr = new com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo ( ) ; attr . name = name ; attr . value = value ; return attr ; }", "testMethod": "testCreateWithNotSupportType ( ) { java . util . Optional < com . gh . mygreen . xlsmapper . fieldaccessor . PositionGetter > positionGetter = getterFactory . create ( com . gh . mygreen . xlsmapper . fieldaccessor . PositionGetterFactoryTest . ByField . NotSupportTypeRecord . class , \"test\" ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( positionGetter )", "total": "testCreateWithNotSupportType ( ) { java . util . Optional < com . gh . mygreen . xlsmapper . fieldaccessor . PositionGetter > positionGetter = getterFactory . create ( com . gh . mygreen . xlsmapper . fieldaccessor . PositionGetterFactoryTest . ByField . NotSupportTypeRecord . class , \"test\" ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; } create ( java . lang . String , java . lang . String ) { com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo attr = new com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo ( ) ; attr . name = name ; attr . value = value ; return attr ; }", "answer": "org . junit . Assert . assertThat ( positionGetter )"}
{"focal": "equivalent ( org . apache . hc . client5 . http . cache . HttpCacheEntry ) { return new org . apache . hc . client5 . http . impl . cache . HttpCacheEntryMatcher ( target ) ; }", "testMethod": "testCacheGet ( ) { final java . lang . String key = \"foo\" ; final org . apache . hc . client5 . http . cache . HttpCacheEntry value = org . apache . hc . client5 . http . impl . cache . HttpTestUtils . makeCacheEntry ( ) ; when ( impl . digestToStorageKey ( key ) ) . thenReturn ( \"bar\" ) ; when ( impl . restore ( \"bar\" ) ) . thenReturn ( org . apache . hc . client5 . http . impl . cache . TestAbstractSerializingCacheStorage . serialize ( key , value ) ) ; final org . apache . hc . client5 . http . cache . HttpCacheEntry resultingEntry = impl . getEntry ( key ) ; verify ( impl ) . restore ( \"bar\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultingEntry , org . apache . hc . client5 . http . impl . cache . HttpCacheEntryMatcher . equivalent ( value ) )", "total": "testCacheGet ( ) { final java . lang . String key = \"foo\" ; final org . apache . hc . client5 . http . cache . HttpCacheEntry value = org . apache . hc . client5 . http . impl . cache . HttpTestUtils . makeCacheEntry ( ) ; when ( impl . digestToStorageKey ( key ) ) . thenReturn ( \"bar\" ) ; when ( impl . restore ( \"bar\" ) ) . thenReturn ( org . apache . hc . client5 . http . impl . cache . TestAbstractSerializingCacheStorage . serialize ( key , value ) ) ; final org . apache . hc . client5 . http . cache . HttpCacheEntry resultingEntry = impl . getEntry ( key ) ; verify ( impl ) . restore ( \"bar\" ) ; \"<AssertPlaceHolder>\" ; } equivalent ( org . apache . hc . client5 . http . cache . HttpCacheEntry ) { return new org . apache . hc . client5 . http . impl . cache . HttpCacheEntryMatcher ( target ) ; }", "answer": "org . junit . Assert . assertThat ( resultingEntry , org . apache . hc . client5 . http . impl . cache . HttpCacheEntryMatcher . equivalent ( value ) )"}
{"focal": "isEmpty ( ) { return new com . annimon . stream . test . hamcrest . OptionalIntMatcher . IsEmptyMatcher ( ) ; }", "testMethod": "testSelectOnEmptyOptional ( ) { com . annimon . stream . Optional < java . lang . Integer > result = com . annimon . stream . Optional . empty ( ) . select ( com . annimon . stream . Integer . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , isEmpty ( ) )", "total": "testSelectOnEmptyOptional ( ) { com . annimon . stream . Optional < java . lang . Integer > result = com . annimon . stream . Optional . empty ( ) . select ( com . annimon . stream . Integer . class ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return new com . annimon . stream . test . hamcrest . OptionalIntMatcher . IsEmptyMatcher ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , isEmpty ( ) )"}
{"focal": "getStatus ( ) { return status ; }", "testMethod": "request_A$Method$Request_HeaderInjection ( ) { com . m3 . curly . com . m3 . curly . Method method = Method . GET ; com . m3 . curly . com . m3 . curly . Request request = new com . m3 . curly . com . m3 . curly . Request ( \"http://localhost:8801/\" ) ; request . setHeader ( \"H1\" , \"dummy\\n<sp>H2:<sp>evil\" ) ; com . m3 . curly . com . m3 . curly . Response response = com . m3 . curly . com . m3 . curly . HTTP . request ( method , request ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . getStatus ( ) , is ( 200 ) )", "total": "request_A$Method$Request_HeaderInjection ( ) { com . m3 . curly . com . m3 . curly . Method method = Method . GET ; com . m3 . curly . com . m3 . curly . Request request = new com . m3 . curly . com . m3 . curly . Request ( \"http://localhost:8801/\" ) ; request . setHeader ( \"H1\" , \"dummy\\n<sp>H2:<sp>evil\" ) ; com . m3 . curly . com . m3 . curly . Response response = com . m3 . curly . com . m3 . curly . HTTP . request ( method , request ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( response . getStatus ( ) , is ( 200 ) )"}
{"focal": "validateValues ( cascading . tuple . Fields , java . lang . Object [ ] ) { if ( ( values == null ) || ( ( values . length ) == 0 ) ) { values = new java . lang . Object [ fields . size ( ) ] ; } else if ( ( values . length ) != ( fields . size ( ) ) ) { throw new java . lang . IllegalStateException ( ( \"Value<sp>array<sp>length<sp>not<sp>suitable<sp>for<sp>fields:<sp>\" + fields ) ) ; } for ( int i = 0 ; i < ( values . length ) ; i ++ ) { java . lang . Class < ? > typeClass = fields . getTypeClass ( i ) ; if ( typeClass != null ) { java . lang . Object value = values [ i ] ; if ( ( typeClass . isPrimitive ( ) ) && ( value == null ) ) { throw new java . lang . IllegalStateException ( ( \"null<sp>cannot<sp>be<sp>converted<sp>to<sp>\" + typeClass ) ) ; } if ( ( typeClass . isPrimitive ( ) ) && ( value != null ) ) { java . lang . Class < ? > nonPrimitiveTypeClass = cascading . tuple . coerce . Coercions . asNonPrimitive ( typeClass ) ; java . lang . Class < ? > nonPrimitiveValueClass = cascading . tuple . coerce . Coercions . asNonPrimitive ( value . getClass ( ) ) ; if ( ! ( nonPrimitiveTypeClass . isAssignableFrom ( nonPrimitiveValueClass ) ) ) { throw new java . lang . IllegalStateException ( ( ( ( value . getClass ( ) ) + \"<sp>cannot<sp>be<sp>converted<sp>to<sp>\" ) + typeClass ) ) ; } } } } return values ; }", "testMethod": "validateNoType ( ) { cascading . tuple . Fields input = new cascading . tuple . Fields ( \"foo\" ) ; java . lang . Object [ ] result = com . hotels . plunger . FieldTypeValidator . validateValues ( input , \"someValue\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( new java . lang . Object [ ] { \"someValue\" } ) )", "total": "validateNoType ( ) { cascading . tuple . Fields input = new cascading . tuple . Fields ( \"foo\" ) ; java . lang . Object [ ] result = com . hotels . plunger . FieldTypeValidator . validateValues ( input , \"someValue\" ) ; \"<AssertPlaceHolder>\" ; } validateValues ( cascading . tuple . Fields , java . lang . Object [ ] ) { if ( ( values == null ) || ( ( values . length ) == 0 ) ) { values = new java . lang . Object [ fields . size ( ) ] ; } else if ( ( values . length ) != ( fields . size ( ) ) ) { throw new java . lang . IllegalStateException ( ( \"Value<sp>array<sp>length<sp>not<sp>suitable<sp>for<sp>fields:<sp>\" + fields ) ) ; } for ( int i = 0 ; i < ( values . length ) ; i ++ ) { java . lang . Class < ? > typeClass = fields . getTypeClass ( i ) ; if ( typeClass != null ) { java . lang . Object value = values [ i ] ; if ( ( typeClass . isPrimitive ( ) ) && ( value == null ) ) { throw new java . lang . IllegalStateException ( ( \"null<sp>cannot<sp>be<sp>converted<sp>to<sp>\" + typeClass ) ) ; } if ( ( typeClass . isPrimitive ( ) ) && ( value != null ) ) { java . lang . Class < ? > nonPrimitiveTypeClass = cascading . tuple . coerce . Coercions . asNonPrimitive ( typeClass ) ; java . lang . Class < ? > nonPrimitiveValueClass = cascading . tuple . coerce . Coercions . asNonPrimitive ( value . getClass ( ) ) ; if ( ! ( nonPrimitiveTypeClass . isAssignableFrom ( nonPrimitiveValueClass ) ) ) { throw new java . lang . IllegalStateException ( ( ( ( value . getClass ( ) ) + \"<sp>cannot<sp>be<sp>converted<sp>to<sp>\" ) + typeClass ) ) ; } } } } return values ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( new java . lang . Object [ ] { \"someValue\" } ) )"}
{"focal": "cancel ( java . lang . String ) { org . terasoluna . tourreservation . domain . model . Reserve reserve = findOne ( reserveNo ) ; java . lang . String transfer = reserve . getTransfer ( ) ; if ( Reserve . TRANSFERED . equals ( transfer ) ) { org . terasoluna . gfw . common . message . ResultMessages message = org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( MessageId . E_TR_0001 ) ; throw new org . terasoluna . gfw . common . exception . BusinessException ( message ) ; } org . terasoluna . tourreservation . domain . model . TourInfo info = reserve . getTourInfo ( ) ; if ( tourInfoSharedService . isOverPaymentLimit ( info ) ) { org . terasoluna . gfw . common . message . ResultMessages message = org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( MessageId . E_TR_0002 ) ; throw new org . terasoluna . gfw . common . exception . BusinessException ( message ) ; } reserve = reserveRepository . findOneForUpdate ( reserveNo ) ; if ( reserve != null ) { reserveRepository . deleteById ( reserveNo ) ; } else { org . terasoluna . gfw . common . message . ResultMessages message = org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( MessageId . E_TR_0003 ) ; throw new org . terasoluna . gfw . common . exception . BusinessException ( message ) ; } log . debug ( \"canceled<sp>reserveNo={}\" , reserveNo ) ; }", "testMethod": "testCancel01 ( ) { org . terasoluna . tourreservation . domain . model . Reserve reserve = new org . terasoluna . tourreservation . domain . model . Reserve ( \"001\" ) ; reserve . setAdultCount ( 1 ) ; reserve . setChildCount ( 2 ) ; org . terasoluna . tourreservation . domain . model . TourInfo tour = new org . terasoluna . tourreservation . domain . model . TourInfo ( \"01\" ) ; reserve . setTourInfo ( tour ) ; reserve . setTransfer ( Reserve . NOT_TRANSFERED ) ; when ( reserveRepository . findById ( \"001\" ) ) . thenReturn ( java . util . Optional . of ( reserve ) ) ; when ( reserveRepository . findOneForUpdate ( \"001\" ) ) . thenReturn ( reserve ) ; when ( tourInfoSharedService . isOverPaymentLimit ( tour ) ) . thenReturn ( false ) ; reserveService . cancel ( \"001\" ) ; org . mockito . ArgumentCaptor < java . lang . String > argOfDelete = org . mockito . ArgumentCaptor . forClass ( java . lang . String . class ) ; verify ( reserveRepository , times ( 1 ) ) . deleteById ( argOfDelete . capture ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( argOfDelete . getValue ( ) , org . hamcrest . CoreMatchers . is ( \"001\" ) )", "total": "testCancel01 ( ) { org . terasoluna . tourreservation . domain . model . Reserve reserve = new org . terasoluna . tourreservation . domain . model . Reserve ( \"001\" ) ; reserve . setAdultCount ( 1 ) ; reserve . setChildCount ( 2 ) ; org . terasoluna . tourreservation . domain . model . TourInfo tour = new org . terasoluna . tourreservation . domain . model . TourInfo ( \"01\" ) ; reserve . setTourInfo ( tour ) ; reserve . setTransfer ( Reserve . NOT_TRANSFERED ) ; when ( reserveRepository . findById ( \"001\" ) ) . thenReturn ( java . util . Optional . of ( reserve ) ) ; when ( reserveRepository . findOneForUpdate ( \"001\" ) ) . thenReturn ( reserve ) ; when ( tourInfoSharedService . isOverPaymentLimit ( tour ) ) . thenReturn ( false ) ; reserveService . cancel ( \"001\" ) ; org . mockito . ArgumentCaptor < java . lang . String > argOfDelete = org . mockito . ArgumentCaptor . forClass ( java . lang . String . class ) ; verify ( reserveRepository , times ( 1 ) ) . deleteById ( argOfDelete . capture ( ) ) ; \"<AssertPlaceHolder>\" ; } cancel ( java . lang . String ) { org . terasoluna . tourreservation . domain . model . Reserve reserve = findOne ( reserveNo ) ; java . lang . String transfer = reserve . getTransfer ( ) ; if ( Reserve . TRANSFERED . equals ( transfer ) ) { org . terasoluna . gfw . common . message . ResultMessages message = org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( MessageId . E_TR_0001 ) ; throw new org . terasoluna . gfw . common . exception . BusinessException ( message ) ; } org . terasoluna . tourreservation . domain . model . TourInfo info = reserve . getTourInfo ( ) ; if ( tourInfoSharedService . isOverPaymentLimit ( info ) ) { org . terasoluna . gfw . common . message . ResultMessages message = org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( MessageId . E_TR_0002 ) ; throw new org . terasoluna . gfw . common . exception . BusinessException ( message ) ; } reserve = reserveRepository . findOneForUpdate ( reserveNo ) ; if ( reserve != null ) { reserveRepository . deleteById ( reserveNo ) ; } else { org . terasoluna . gfw . common . message . ResultMessages message = org . terasoluna . gfw . common . message . ResultMessages . error ( ) . add ( MessageId . E_TR_0003 ) ; throw new org . terasoluna . gfw . common . exception . BusinessException ( message ) ; } log . debug ( \"canceled<sp>reserveNo={}\" , reserveNo ) ; }", "answer": "org . junit . Assert . assertThat ( argOfDelete . getValue ( ) , org . hamcrest . CoreMatchers . is ( \"001\" ) )"}
{"focal": "isSticky ( ) { return getStyle ( ) . getBooleanStyleProperty ( BandStyleKeys . STICKY , false ) ; }", "testMethod": "testIsSticky ( ) { org . pentaho . reporting . engine . classic . core . DetailsFooter footer = new org . pentaho . reporting . engine . classic . core . DetailsFooter ( ) ; footer . getStyle ( ) . setBooleanStyleProperty ( BandStyleKeys . STICKY , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( footer . isSticky ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )", "total": "testIsSticky ( ) { org . pentaho . reporting . engine . classic . core . DetailsFooter footer = new org . pentaho . reporting . engine . classic . core . DetailsFooter ( ) ; footer . getStyle ( ) . setBooleanStyleProperty ( BandStyleKeys . STICKY , true ) ; \"<AssertPlaceHolder>\" ; } isSticky ( ) { return getStyle ( ) . getBooleanStyleProperty ( BandStyleKeys . STICKY , false ) ; }", "answer": "org . junit . Assert . assertThat ( footer . isSticky ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )"}
{"focal": "instanceOf ( java . lang . Class ) { return clazz :: isInstance ; }", "testMethod": "transactionCommittedShouldFailWhenStoreIsClosed ( ) { org . neo4j . kernel . impl . store . MetaDataStore metaDataStore = newMetaDataStore ( ) ; metaDataStore . close ( ) ; try { metaDataStore . transactionCommitted ( 1 , 1 , org . neo4j . kernel . impl . store . BASE_TX_COMMIT_TIMESTAMP ) ; org . junit . Assert . fail ( \"Expected<sp>exception<sp>reading<sp>from<sp>MetaDataStore<sp>after<sp>being<sp>closed.\" ) ; } catch ( java . lang . Exception e ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( e , org . hamcrest . Matchers . instanceOf ( org . neo4j . kernel . impl . store . IllegalStateException . class ) )", "total": "transactionCommittedShouldFailWhenStoreIsClosed ( ) { org . neo4j . kernel . impl . store . MetaDataStore metaDataStore = newMetaDataStore ( ) ; metaDataStore . close ( ) ; try { metaDataStore . transactionCommitted ( 1 , 1 , org . neo4j . kernel . impl . store . BASE_TX_COMMIT_TIMESTAMP ) ; org . junit . Assert . fail ( \"Expected<sp>exception<sp>reading<sp>from<sp>MetaDataStore<sp>after<sp>being<sp>closed.\" ) ; } catch ( java . lang . Exception e ) { \"<AssertPlaceHolder>\" ; } } instanceOf ( java . lang . Class ) { return clazz :: isInstance ; }", "answer": "org . junit . Assert . assertThat ( e , org . hamcrest . Matchers . instanceOf ( org . neo4j . kernel . impl . store . IllegalStateException . class ) )"}
{"focal": "getAmount ( ) { return account ; }", "testMethod": "shouldDeposit ( ) { bean . deposit ( 1000 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( bean . getAmount ( ) , org . hamcrest . core . Is . is ( 1000 ) )", "total": "shouldDeposit ( ) { bean . deposit ( 1000 ) ; \"<AssertPlaceHolder>\" ; } getAmount ( ) { return account ; }", "answer": "org . junit . Assert . assertThat ( bean . getAmount ( ) , org . hamcrest . core . Is . is ( 1000 ) )"}
{"focal": "mapToQuery ( java . util . Map , org . springframework . beans . BeanWrapper ) { if ( ( map == null ) || ( map . isEmpty ( ) ) ) { return \"\" ; } org . springframework . web . util . UriComponentsBuilder builder = org . springframework . web . util . UriComponentsBuilder . fromPath ( \"\" ) ; for ( java . util . Map . Entry < java . lang . String , ? > e : map . entrySet ( ) ) { java . lang . String name = e . getKey ( ) ; java . lang . Object value = e . getValue ( ) ; org . springframework . core . convert . TypeDescriptor sourceType ; if ( beanWrapper != null ) { sourceType = beanWrapper . getPropertyTypeDescriptor ( name ) ; } else { sourceType = org . springframework . core . convert . TypeDescriptor . forObject ( value ) ; } builder . queryParam ( name , org . terasoluna . gfw . web . el . Functions . CONVERSION_SERVICE . convert ( value , sourceType , org . terasoluna . gfw . web . el . Functions . STRING_DESC ) ) ; } java . lang . String query = builder . build ( ) . encode ( ) . toString ( ) ; return org . terasoluna . gfw . web . el . Functions . extraEncodeQuery ( query . substring ( 1 ) ) ; }", "testMethod": "testDeprecatedMapToQueryIsEmpty ( ) { java . util . Map < java . lang . String , java . lang . Object > map = new java . util . LinkedHashMap < java . lang . String , java . lang . Object > ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . terasoluna . gfw . web . el . Functions . mapToQuery ( map , null ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "testDeprecatedMapToQueryIsEmpty ( ) { java . util . Map < java . lang . String , java . lang . Object > map = new java . util . LinkedHashMap < java . lang . String , java . lang . Object > ( ) ; \"<AssertPlaceHolder>\" ; } mapToQuery ( java . util . Map , org . springframework . beans . BeanWrapper ) { if ( ( map == null ) || ( map . isEmpty ( ) ) ) { return \"\" ; } org . springframework . web . util . UriComponentsBuilder builder = org . springframework . web . util . UriComponentsBuilder . fromPath ( \"\" ) ; for ( java . util . Map . Entry < java . lang . String , ? > e : map . entrySet ( ) ) { java . lang . String name = e . getKey ( ) ; java . lang . Object value = e . getValue ( ) ; org . springframework . core . convert . TypeDescriptor sourceType ; if ( beanWrapper != null ) { sourceType = beanWrapper . getPropertyTypeDescriptor ( name ) ; } else { sourceType = org . springframework . core . convert . TypeDescriptor . forObject ( value ) ; } builder . queryParam ( name , org . terasoluna . gfw . web . el . Functions . CONVERSION_SERVICE . convert ( value , sourceType , org . terasoluna . gfw . web . el . Functions . STRING_DESC ) ) ; } java . lang . String query = builder . build ( ) . encode ( ) . toString ( ) ; return org . terasoluna . gfw . web . el . Functions . extraEncodeQuery ( query . substring ( 1 ) ) ; }", "answer": "org . junit . Assert . assertThat ( org . terasoluna . gfw . web . el . Functions . mapToQuery ( map , null ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectOtherDifferentProperty ( ) { org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork obj = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"objectId\" , \"connectionType\" , \"none\" , \"logicId\" , \"networkId\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsObjectOtherDifferentProperty ( ) { org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork obj = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"objectId\" , \"connectionType\" , \"none\" , \"logicId\" , \"networkId\" ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "dumpConfigs ( org . apache . metron . common . configuration . ConfigurationType , java . util . Optional ) { java . lang . String [ ] args = new java . lang . String [ ] { \"-z\" , zookeeperUrl , \"--mode\" , \"DUMP\" , \"--config_type\" , type . toString ( ) } ; if ( configName . isPresent ( ) ) { args = org . apache . commons . lang3 . ArrayUtils . addAll ( args , \"--config_name\" , configName . get ( ) ) ; } org . apache . metron . common . cli . ConfigurationManager manager = new org . apache . metron . common . cli . ConfigurationManager ( ) ; return redirectSystemOut ( args , ( a ) -> { manager . run ( ConfigurationManager . ConfigurationOptions . parse ( new org . apache . commons . cli . PosixParser ( ) , a ) ) ; } ) ; }", "testMethod": "testPushProfiler ( ) { java . io . File configFile = new java . io . File ( configDir , \"profiler.json\" ) ; org . apache . metron . integration . utils . TestUtils . write ( configFile , org . apache . metron . common . cli . ConfigurationManagerIntegrationTest . someProfilerConfig ) ; java . util . Optional < java . lang . String > configName = java . util . Optional . empty ( ) ; pushConfigs ( org . apache . metron . common . cli . PROFILER , configDir , configName ) ; byte [ ] expected = JSONUtils . INSTANCE . toJSONPretty ( org . apache . metron . common . cli . ConfigurationManagerIntegrationTest . someProfilerConfig ) ; byte [ ] actual = JSONUtils . INSTANCE . toJSONPretty ( stripLines ( dumpConfigs ( org . apache . metron . common . cli . PROFILER , configName ) , 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "testPushProfiler ( ) { java . io . File configFile = new java . io . File ( configDir , \"profiler.json\" ) ; org . apache . metron . integration . utils . TestUtils . write ( configFile , org . apache . metron . common . cli . ConfigurationManagerIntegrationTest . someProfilerConfig ) ; java . util . Optional < java . lang . String > configName = java . util . Optional . empty ( ) ; pushConfigs ( org . apache . metron . common . cli . PROFILER , configDir , configName ) ; byte [ ] expected = JSONUtils . INSTANCE . toJSONPretty ( org . apache . metron . common . cli . ConfigurationManagerIntegrationTest . someProfilerConfig ) ; byte [ ] actual = JSONUtils . INSTANCE . toJSONPretty ( stripLines ( dumpConfigs ( org . apache . metron . common . cli . PROFILER , configName ) , 1 ) ) ; \"<AssertPlaceHolder>\" ; } dumpConfigs ( org . apache . metron . common . configuration . ConfigurationType , java . util . Optional ) { java . lang . String [ ] args = new java . lang . String [ ] { \"-z\" , zookeeperUrl , \"--mode\" , \"DUMP\" , \"--config_type\" , type . toString ( ) } ; if ( configName . isPresent ( ) ) { args = org . apache . commons . lang3 . ArrayUtils . addAll ( args , \"--config_name\" , configName . get ( ) ) ; } org . apache . metron . common . cli . ConfigurationManager manager = new org . apache . metron . common . cli . ConfigurationManager ( ) ; return redirectSystemOut ( args , ( a ) -> { manager . run ( ConfigurationManager . ConfigurationOptions . parse ( new org . apache . commons . cli . PosixParser ( ) , a ) ) ; } ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "value ( int ) { return icmpType == ( org . batfish . datamodel . IcmpType . UNSET ) ? _var . getFactory ( ) . one ( ) : _var . value ( icmpType ) ; }", "testMethod": "test_dscps ( ) { org . batfish . datamodel . HeaderSpace headerSpace = org . batfish . datamodel . HeaderSpace . builder ( ) . setDscps ( com . google . common . collect . ImmutableSet . of ( 1 , 2 , 3 ) ) . setNotDscps ( com . google . common . collect . ImmutableSet . of ( 3 , 4 , 5 ) ) . build ( ) ; net . sf . javabdd . BDD bdd = _toBDD . toBDD ( headerSpace ) ; org . batfish . common . bdd . BDDInteger dscp = _pkt . getDscp ( ) ; net . sf . javabdd . BDD dscpBDD = dscp . value ( 1 ) . or ( dscp . value ( 2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( bdd , org . hamcrest . Matchers . equalTo ( dscpBDD ) )", "total": "test_dscps ( ) { org . batfish . datamodel . HeaderSpace headerSpace = org . batfish . datamodel . HeaderSpace . builder ( ) . setDscps ( com . google . common . collect . ImmutableSet . of ( 1 , 2 , 3 ) ) . setNotDscps ( com . google . common . collect . ImmutableSet . of ( 3 , 4 , 5 ) ) . build ( ) ; net . sf . javabdd . BDD bdd = _toBDD . toBDD ( headerSpace ) ; org . batfish . common . bdd . BDDInteger dscp = _pkt . getDscp ( ) ; net . sf . javabdd . BDD dscpBDD = dscp . value ( 1 ) . or ( dscp . value ( 2 ) ) ; \"<AssertPlaceHolder>\" ; } value ( int ) { return icmpType == ( org . batfish . datamodel . IcmpType . UNSET ) ? _var . getFactory ( ) . one ( ) : _var . value ( icmpType ) ; }", "answer": "org . junit . Assert . assertThat ( bdd , org . hamcrest . Matchers . equalTo ( dscpBDD ) )"}
{"focal": "apply ( java . lang . String ) { return s . equals ( list . get ( 0 ) ) ; }", "testMethod": "whenConvertingPredicateToFunction_thenCorrect ( ) { final java . util . List < java . lang . Integer > numbers = com . google . common . collect . Lists . newArrayList ( 1 , 2 , 3 , 6 ) ; final com . google . common . base . Predicate < java . lang . Integer > acceptEvenNumber = new com . google . common . base . Predicate < java . lang . Integer > ( ) { @ org . baeldung . guava . Override public final boolean apply ( final java . lang . Integer number ) { return ( number % 2 ) == 0 ; } } ; final com . google . common . base . Function < java . lang . Integer , java . lang . Boolean > isEventNumberFunction = com . google . common . base . Functions . forPredicate ( acceptEvenNumber ) ; final java . util . List < java . lang . Boolean > areNumbersEven = com . google . common . collect . Lists . transform ( numbers , isEventNumberFunction ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( areNumbersEven , org . hamcrest . Matchers . contains ( false , true , false , true ) )", "total": "whenConvertingPredicateToFunction_thenCorrect ( ) { final java . util . List < java . lang . Integer > numbers = com . google . common . collect . Lists . newArrayList ( 1 , 2 , 3 , 6 ) ; final com . google . common . base . Predicate < java . lang . Integer > acceptEvenNumber = new com . google . common . base . Predicate < java . lang . Integer > ( ) { @ org . baeldung . guava . Override public final boolean apply ( final java . lang . Integer number ) { return ( number % 2 ) == 0 ; } } ; final com . google . common . base . Function < java . lang . Integer , java . lang . Boolean > isEventNumberFunction = com . google . common . base . Functions . forPredicate ( acceptEvenNumber ) ; final java . util . List < java . lang . Boolean > areNumbersEven = com . google . common . collect . Lists . transform ( numbers , isEventNumberFunction ) ; \"<AssertPlaceHolder>\" ; } apply ( java . lang . String ) { return s . equals ( list . get ( 0 ) ) ; }", "answer": "org . junit . Assert . assertThat ( areNumbersEven , org . hamcrest . Matchers . contains ( false , true , false , true ) )"}
{"focal": "updateMap ( java . util . Map , com . google . common . collect . MapDifference ) { java . util . Map < K , V > result = new java . util . HashMap < K , V > ( original ) ; if ( diff . areEqual ( ) ) { return result ; } for ( java . util . Map . Entry < K , V > entry : diff . entriesOnlyOnLeft ( ) . entrySet ( ) ) { V originalValue = original . get ( entry . getKey ( ) ) ; if ( org . apache . commons . lang . ObjectUtils . equals ( originalValue , entry . getValue ( ) ) ) { result . remove ( entry . getKey ( ) ) ; } } for ( java . util . Map . Entry < K , V > entry : diff . entriesOnlyOnRight ( ) . entrySet ( ) ) { K key = entry . getKey ( ) ; if ( original . containsKey ( key ) ) { if ( org . apache . commons . lang . ObjectUtils . notEqual ( original . get ( key ) , entry . getValue ( ) ) ) { throw new org . openengsb . core . util . MergeException ( java . lang . String . format ( \"tried<sp>to<sp>introduce<sp>a<sp>new<sp>value,<sp>but<sp>it<sp>was<sp>already<sp>there:<sp>%s<sp>(%s,%s)\" , key , original . get ( key ) , entry . getValue ( ) ) ) ; } } result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } for ( java . util . Map . Entry < K , com . google . common . collect . MapDifference . ValueDifference < V > > entry : diff . entriesDiffering ( ) . entrySet ( ) ) { K key = entry . getKey ( ) ; V originalValue = original . get ( entry . getKey ( ) ) ; if ( org . apache . commons . lang . ObjectUtils . equals ( originalValue , entry . getValue ( ) . leftValue ( ) ) ) { result . put ( key , entry . getValue ( ) . rightValue ( ) ) ; } else if ( org . apache . commons . lang . ObjectUtils . equals ( originalValue , entry . getValue ( ) . rightValue ( ) ) ) { result . put ( key , originalValue ) ; } else { java . lang . String errorMessage = java . lang . String . format ( ( \"Changes<sp>could<sp>not<sp>be<sp>applied,<sp>because<sp>original<sp>value<sp>differes<sp>from<sp>left-side<sp>of<sp>the\" + \"MapDifference:<sp>%s<sp>(%s,%s)\" ) , entry . getKey ( ) , original . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; throw new org . openengsb . core . util . MergeException ( errorMessage ) ; } } return result ; }", "testMethod": "testValueChange_shouldChangeValue ( ) { java . util . Map < java . lang . String , java . lang . String > original = com . google . common . collect . ImmutableMap . of ( \"foo\" , \"bar\" , \"test\" , \"42\" ) ; java . util . Map < java . lang . String , java . lang . String > oldMap = com . google . common . collect . ImmutableMap . copyOf ( original ) ; java . util . Map < java . lang . String , java . lang . String > newMap = com . google . common . collect . ImmutableMap . of ( \"foo\" , \"bar\" , \"test\" , \"21\" ) ; com . google . common . collect . MapDifference < java . lang . String , java . lang . String > difference = com . google . common . collect . Maps . difference ( oldMap , newMap ) ; java . util . Map < java . lang . String , java . lang . String > result = org . openengsb . core . util . ConfigUtils . updateMap ( original , difference ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( newMap ) )", "total": "testValueChange_shouldChangeValue ( ) { java . util . Map < java . lang . String , java . lang . String > original = com . google . common . collect . ImmutableMap . of ( \"foo\" , \"bar\" , \"test\" , \"42\" ) ; java . util . Map < java . lang . String , java . lang . String > oldMap = com . google . common . collect . ImmutableMap . copyOf ( original ) ; java . util . Map < java . lang . String , java . lang . String > newMap = com . google . common . collect . ImmutableMap . of ( \"foo\" , \"bar\" , \"test\" , \"21\" ) ; com . google . common . collect . MapDifference < java . lang . String , java . lang . String > difference = com . google . common . collect . Maps . difference ( oldMap , newMap ) ; java . util . Map < java . lang . String , java . lang . String > result = org . openengsb . core . util . ConfigUtils . updateMap ( original , difference ) ; \"<AssertPlaceHolder>\" ; } updateMap ( java . util . Map , com . google . common . collect . MapDifference ) { java . util . Map < K , V > result = new java . util . HashMap < K , V > ( original ) ; if ( diff . areEqual ( ) ) { return result ; } for ( java . util . Map . Entry < K , V > entry : diff . entriesOnlyOnLeft ( ) . entrySet ( ) ) { V originalValue = original . get ( entry . getKey ( ) ) ; if ( org . apache . commons . lang . ObjectUtils . equals ( originalValue , entry . getValue ( ) ) ) { result . remove ( entry . getKey ( ) ) ; } } for ( java . util . Map . Entry < K , V > entry : diff . entriesOnlyOnRight ( ) . entrySet ( ) ) { K key = entry . getKey ( ) ; if ( original . containsKey ( key ) ) { if ( org . apache . commons . lang . ObjectUtils . notEqual ( original . get ( key ) , entry . getValue ( ) ) ) { throw new org . openengsb . core . util . MergeException ( java . lang . String . format ( \"tried<sp>to<sp>introduce<sp>a<sp>new<sp>value,<sp>but<sp>it<sp>was<sp>already<sp>there:<sp>%s<sp>(%s,%s)\" , key , original . get ( key ) , entry . getValue ( ) ) ) ; } } result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } for ( java . util . Map . Entry < K , com . google . common . collect . MapDifference . ValueDifference < V > > entry : diff . entriesDiffering ( ) . entrySet ( ) ) { K key = entry . getKey ( ) ; V originalValue = original . get ( entry . getKey ( ) ) ; if ( org . apache . commons . lang . ObjectUtils . equals ( originalValue , entry . getValue ( ) . leftValue ( ) ) ) { result . put ( key , entry . getValue ( ) . rightValue ( ) ) ; } else if ( org . apache . commons . lang . ObjectUtils . equals ( originalValue , entry . getValue ( ) . rightValue ( ) ) ) { result . put ( key , originalValue ) ; } else { java . lang . String errorMessage = java . lang . String . format ( ( \"Changes<sp>could<sp>not<sp>be<sp>applied,<sp>because<sp>original<sp>value<sp>differes<sp>from<sp>left-side<sp>of<sp>the\" + \"MapDifference:<sp>%s<sp>(%s,%s)\" ) , entry . getKey ( ) , original . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; throw new org . openengsb . core . util . MergeException ( errorMessage ) ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( newMap ) )"}
{"focal": "nbsp ( java . lang . String ) { if ( org . slim3 . util . StringUtil . isEmpty ( input ) ) { return \"\" ; } return input . replaceAll ( \"<sp>\" , org . slim3 . jsp . Functions . NBSP ) ; }", "testMethod": "nbspForEmptyString ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . slim3 . jsp . Functions . nbsp ( \"\" ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "nbspForEmptyString ( ) { \"<AssertPlaceHolder>\" ; } nbsp ( java . lang . String ) { if ( org . slim3 . util . StringUtil . isEmpty ( input ) ) { return \"\" ; } return input . replaceAll ( \"<sp>\" , org . slim3 . jsp . Functions . NBSP ) ; }", "answer": "org . junit . Assert . assertThat ( org . slim3 . jsp . Functions . nbsp ( \"\" ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "testResolveAnObjectAsANonString ( ) { java . lang . Integer value = 1 ; java . lang . Object actual = org . silverpeas . core . util . VariableResolver . resolve ( value ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( 1 ) )", "total": "testResolveAnObjectAsANonString ( ) { java . lang . Integer value = 1 ; java . lang . Object actual = org . silverpeas . core . util . VariableResolver . resolve ( value ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "newMd5Checksum ( java . lang . String ) { return new org . dcache . util . Checksum ( org . dcache . util . ChecksumType . ChecksumType . MD5_TYPE , value ) ; }", "testMethod": "shouldReturnBothForAdler32AndMd5 ( ) { java . util . Set < org . dcache . util . Checksum > result = org . dcache . util . Checksums . decodeRfc3230 ( \"md5=HUXZLQLMuI/KZ5KDcJPcOA==,adler32=03da0195\" ) ; java . util . Set < org . dcache . util . Checksum > expected = com . google . common . collect . Sets . newHashSet ( newAdler32Checksum ( \"03da0195\" ) , newMd5Checksum ( \"1d45d92d02ccb88fca6792837093dc38\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , equalTo ( expected ) )", "total": "shouldReturnBothForAdler32AndMd5 ( ) { java . util . Set < org . dcache . util . Checksum > result = org . dcache . util . Checksums . decodeRfc3230 ( \"md5=HUXZLQLMuI/KZ5KDcJPcOA==,adler32=03da0195\" ) ; java . util . Set < org . dcache . util . Checksum > expected = com . google . common . collect . Sets . newHashSet ( newAdler32Checksum ( \"03da0195\" ) , newMd5Checksum ( \"1d45d92d02ccb88fca6792837093dc38\" ) ) ; \"<AssertPlaceHolder>\" ; } newMd5Checksum ( java . lang . String ) { return new org . dcache . util . Checksum ( org . dcache . util . ChecksumType . ChecksumType . MD5_TYPE , value ) ; }", "answer": "org . junit . Assert . assertThat ( result , equalTo ( expected ) )"}
{"focal": "render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "testMethod": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>4.5<sp>|<sp>at_least:5<sp>}}\" 1 , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>5<sp>|<sp>at_least:5<sp>}}\" , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>5<sp>|<sp>at_least:6<sp>}}\" , \"6\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>4.5<sp>|<sp>at_least:5<sp>}}\" , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>width<sp>|<sp>at_least:5<sp>}}\" , \"6\" , \"{<sp>\\\"width\\\":<sp>6<sp>}\" } , new java . lang . String [ ] { \"{{<sp>width<sp>|<sp>at_least:5<sp>}}\" , \"5\" , \"{<sp>\\\"width\\\":<sp>4<sp>}\" } , new java . lang . String [ ] { \"{{<sp>4.5<sp>|<sp>at_least:5<sp>}}\" 0 , \"6\" , \"{<sp>\\\"width\\\":<sp>6<sp>}\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( test [ 2 ] ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>4.5<sp>|<sp>at_least:5<sp>}}\" 1 , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>5<sp>|<sp>at_least:5<sp>}}\" , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>5<sp>|<sp>at_least:6<sp>}}\" , \"6\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>4.5<sp>|<sp>at_least:5<sp>}}\" , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>width<sp>|<sp>at_least:5<sp>}}\" , \"6\" , \"{<sp>\\\"width\\\":<sp>6<sp>}\" } , new java . lang . String [ ] { \"{{<sp>width<sp>|<sp>at_least:5<sp>}}\" , \"5\" , \"{<sp>\\\"width\\\":<sp>4<sp>}\" } , new java . lang . String [ ] { \"{{<sp>4.5<sp>|<sp>at_least:5<sp>}}\" 0 , \"6\" , \"{<sp>\\\"width\\\":<sp>6<sp>}\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( test [ 2 ] ) ) ; \"<AssertPlaceHolder>\" ; } } render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "getMissingRomFiles ( org . tibennetwork . iarcade . internetarchive . MachineRomSet . MachineRomSetFormat , java . util . Set ) { java . util . Set < java . lang . String > missingRomFiles = new java . util . HashSet ( ) ; romfileloop : for ( java . lang . String romFile : this . getNeededRomFiles ( format ) ) { for ( java . io . File romPath : romPaths ) { java . lang . String romFileInRomPathWithoutExtension = ( ( romPath . getAbsolutePath ( ) ) + ( java . io . File . separator ) ) + romFile ; java . io . File zippedRomFileInRomPath = new java . io . File ( ( romFileInRomPathWithoutExtension + \".zip\" ) ) ; java . io . File SevenZippedRomFileInRomPath = new java . io . File ( ( romFileInRomPathWithoutExtension + \".7z\" ) ) ; if ( ( zippedRomFileInRomPath . exists ( ) ) || ( SevenZippedRomFileInRomPath . exists ( ) ) ) { continue romfileloop ; } } missingRomFiles . add ( romFile ) ; } return missingRomFiles ; }", "testMethod": "testGetMissingRomsFilesWithMissingPartsRomPath ( ) { org . tibennetwork . iarcade . mame . FakeMameRuntime mame = new org . tibennetwork . iarcade . mame . FakeMameRuntime ( ) ; java . util . List < java . io . InputStream > inputStreams = new java . util . ArrayList ( ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/neomrdo.xml\" ) ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/neogeo.xml\" ) ) ; mame . setInputStreamsToReturn ( inputStreams ) ; org . tibennetwork . iarcade . mame . MachineRepository mr = new org . tibennetwork . iarcade . mame . MachineRepository ( mame ) ; org . tibennetwork . iarcade . mame . Machine m = mr . findByName ( \"neomrdo\" ) ; java . util . Set < java . io . File > romPaths = new java . util . HashSet ( ) ; romPaths . add ( new java . io . File ( \"src/test/resources/missing-parts-rompath\" ) ) ; java . util . Set < java . lang . String > missingFiles = m . getMissingRomFiles ( MachineRomSetFormat . SPLIT , romPaths ) ; java . util . Set < java . lang . String > expectedMissingFiles = new java . util . HashSet ( ) ; expectedMissingFiles . add ( \"neomrdo\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( missingFiles , org . hamcrest . CoreMatchers . equalTo ( expectedMissingFiles ) )", "total": "testGetMissingRomsFilesWithMissingPartsRomPath ( ) { org . tibennetwork . iarcade . mame . FakeMameRuntime mame = new org . tibennetwork . iarcade . mame . FakeMameRuntime ( ) ; java . util . List < java . io . InputStream > inputStreams = new java . util . ArrayList ( ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/neomrdo.xml\" ) ) ; inputStreams . add ( new java . io . FileInputStream ( \"src/test/resources/xml/neogeo.xml\" ) ) ; mame . setInputStreamsToReturn ( inputStreams ) ; org . tibennetwork . iarcade . mame . MachineRepository mr = new org . tibennetwork . iarcade . mame . MachineRepository ( mame ) ; org . tibennetwork . iarcade . mame . Machine m = mr . findByName ( \"neomrdo\" ) ; java . util . Set < java . io . File > romPaths = new java . util . HashSet ( ) ; romPaths . add ( new java . io . File ( \"src/test/resources/missing-parts-rompath\" ) ) ; java . util . Set < java . lang . String > missingFiles = m . getMissingRomFiles ( MachineRomSetFormat . SPLIT , romPaths ) ; java . util . Set < java . lang . String > expectedMissingFiles = new java . util . HashSet ( ) ; expectedMissingFiles . add ( \"neomrdo\" ) ; \"<AssertPlaceHolder>\" ; } getMissingRomFiles ( org . tibennetwork . iarcade . internetarchive . MachineRomSet . MachineRomSetFormat , java . util . Set ) { java . util . Set < java . lang . String > missingRomFiles = new java . util . HashSet ( ) ; romfileloop : for ( java . lang . String romFile : this . getNeededRomFiles ( format ) ) { for ( java . io . File romPath : romPaths ) { java . lang . String romFileInRomPathWithoutExtension = ( ( romPath . getAbsolutePath ( ) ) + ( java . io . File . separator ) ) + romFile ; java . io . File zippedRomFileInRomPath = new java . io . File ( ( romFileInRomPathWithoutExtension + \".zip\" ) ) ; java . io . File SevenZippedRomFileInRomPath = new java . io . File ( ( romFileInRomPathWithoutExtension + \".7z\" ) ) ; if ( ( zippedRomFileInRomPath . exists ( ) ) || ( SevenZippedRomFileInRomPath . exists ( ) ) ) { continue romfileloop ; } } missingRomFiles . add ( romFile ) ; } return missingRomFiles ; }", "answer": "org . junit . Assert . assertThat ( missingFiles , org . hamcrest . CoreMatchers . equalTo ( expectedMissingFiles ) )"}
{"focal": "mapper ( ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER ; }", "testMethod": "testIpSpaceJacksonSerialization ( ) { org . batfish . datamodel . Ip ip = org . batfish . datamodel . Ip . parse ( \"1.0.0.0\" ) ; org . batfish . datamodel . IpIpSpace ipIpSpace = ip . toIpSpace ( ) ; org . batfish . datamodel . Prefix p = org . batfish . datamodel . Prefix . create ( ip , 24 ) ; org . batfish . datamodel . IpSpace prefixIpSpace = p . toIpSpace ( ) ; org . batfish . datamodel . IpWildcard ipWildcard1 = new org . batfish . datamodel . IpWildcard ( p ) ; org . batfish . datamodel . IpWildcardIpSpace ipWildcard1IpSpace = ipWildcard1 . toIpSpace ( ) ; org . batfish . datamodel . IpWildcard ipWildcard2 = new org . batfish . datamodel . IpWildcard ( ip ) ; org . batfish . datamodel . IpWildcardIpSpace ipWildcard2IpSpace = ipWildcard2 . toIpSpace ( ) ; org . batfish . datamodel . IpWildcard ipWildcard3 = new org . batfish . datamodel . IpWildcard ( ip , org . batfish . datamodel . Ip . parse ( \"0.255.0.255\" ) ) ; org . batfish . datamodel . IpWildcardIpSpace ipWildcard3IpSpace = ipWildcard3 . toIpSpace ( ) ; org . batfish . datamodel . IpSpace ipWildcardSetIpSpace = org . batfish . datamodel . IpWildcardSetIpSpace . builder ( ) . including ( ipWildcard1 , ipWildcard2 , ipWildcard3 ) . build ( ) ; org . batfish . datamodel . IpSpace aclIpSpace1 = org . batfish . datamodel . AclIpSpace . permitting ( ipWildcardSetIpSpace ) . thenPermitting ( ipIpSpace ) . thenPermitting ( prefixIpSpace ) . thenRejecting ( ipWildcard1IpSpace ) . thenPermitting ( EmptyIpSpace . INSTANCE ) . thenRejecting ( UniverseIpSpace . INSTANCE ) . build ( ) ; for ( org . batfish . datamodel . IpSpace ipSpace : com . google . common . collect . ImmutableList . < org . batfish . datamodel . IpSpace > of ( ipIpSpace , prefixIpSpace , ipWildcard1IpSpace , ipWildcard2IpSpace , ipWildcard3IpSpace , ipWildcardSetIpSpace , aclIpSpace1 ) ) { java . lang . String jsonString = org . batfish . common . util . BatfishObjectMapper . writePrettyString ( ipSpace ) ; org . batfish . datamodel . IpSpace deserializedIpSpace = org . batfish . common . util . BatfishObjectMapper . mapper ( ) . readValue ( jsonString , org . batfish . datamodel . IpSpace . class ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( ipSpace , org . hamcrest . Matchers . equalTo ( deserializedIpSpace ) )", "total": "testIpSpaceJacksonSerialization ( ) { org . batfish . datamodel . Ip ip = org . batfish . datamodel . Ip . parse ( \"1.0.0.0\" ) ; org . batfish . datamodel . IpIpSpace ipIpSpace = ip . toIpSpace ( ) ; org . batfish . datamodel . Prefix p = org . batfish . datamodel . Prefix . create ( ip , 24 ) ; org . batfish . datamodel . IpSpace prefixIpSpace = p . toIpSpace ( ) ; org . batfish . datamodel . IpWildcard ipWildcard1 = new org . batfish . datamodel . IpWildcard ( p ) ; org . batfish . datamodel . IpWildcardIpSpace ipWildcard1IpSpace = ipWildcard1 . toIpSpace ( ) ; org . batfish . datamodel . IpWildcard ipWildcard2 = new org . batfish . datamodel . IpWildcard ( ip ) ; org . batfish . datamodel . IpWildcardIpSpace ipWildcard2IpSpace = ipWildcard2 . toIpSpace ( ) ; org . batfish . datamodel . IpWildcard ipWildcard3 = new org . batfish . datamodel . IpWildcard ( ip , org . batfish . datamodel . Ip . parse ( \"0.255.0.255\" ) ) ; org . batfish . datamodel . IpWildcardIpSpace ipWildcard3IpSpace = ipWildcard3 . toIpSpace ( ) ; org . batfish . datamodel . IpSpace ipWildcardSetIpSpace = org . batfish . datamodel . IpWildcardSetIpSpace . builder ( ) . including ( ipWildcard1 , ipWildcard2 , ipWildcard3 ) . build ( ) ; org . batfish . datamodel . IpSpace aclIpSpace1 = org . batfish . datamodel . AclIpSpace . permitting ( ipWildcardSetIpSpace ) . thenPermitting ( ipIpSpace ) . thenPermitting ( prefixIpSpace ) . thenRejecting ( ipWildcard1IpSpace ) . thenPermitting ( EmptyIpSpace . INSTANCE ) . thenRejecting ( UniverseIpSpace . INSTANCE ) . build ( ) ; for ( org . batfish . datamodel . IpSpace ipSpace : com . google . common . collect . ImmutableList . < org . batfish . datamodel . IpSpace > of ( ipIpSpace , prefixIpSpace , ipWildcard1IpSpace , ipWildcard2IpSpace , ipWildcard3IpSpace , ipWildcardSetIpSpace , aclIpSpace1 ) ) { java . lang . String jsonString = org . batfish . common . util . BatfishObjectMapper . writePrettyString ( ipSpace ) ; org . batfish . datamodel . IpSpace deserializedIpSpace = org . batfish . common . util . BatfishObjectMapper . mapper ( ) . readValue ( jsonString , org . batfish . datamodel . IpSpace . class ) ; \"<AssertPlaceHolder>\" ; } } mapper ( ) { return org . batfish . common . util . BatfishObjectMapper . MAPPER ; }", "answer": "org . junit . Assert . assertThat ( ipSpace , org . hamcrest . Matchers . equalTo ( deserializedIpSpace ) )"}
{"focal": "readError ( ) { byte [ ] error = new byte [ 0 ] ; try ( java . io . InputStream errorStream = this . connection . getErrorStream ( ) ) { if ( errorStream != null ) { error = com . microsoft . azure . sdk . iot . service . transport . http . HttpConnection . readInputStream ( errorStream ) ; } } return error ; }", "testMethod": "readErrorReturnsEmptyErrorReasonIfNoErrorReason ( ) { final com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod . GET ; byte [ ] expectedError = new byte [ ] { } ; new mockit . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"https\" ; mockUrl . openConnection ( ) ; result = mockUrlConn ; mockUrlConn . getRequestMethod ( ) ; result = httpsMethod . name ( ) ; mockUrlConn . getErrorStream ( ) ; result = null ; } } ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpConnection conn = new com . microsoft . azure . sdk . iot . deps . transport . http . HttpConnection ( mockUrl , httpsMethod ) ; conn . connect ( ) ; byte [ ] testError = conn . readError ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testError , org . hamcrest . CoreMatchers . is ( expectedError ) )", "total": "readErrorReturnsEmptyErrorReasonIfNoErrorReason ( ) { final com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . deps . transport . http . HttpMethod . GET ; byte [ ] expectedError = new byte [ ] { } ; new mockit . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"https\" ; mockUrl . openConnection ( ) ; result = mockUrlConn ; mockUrlConn . getRequestMethod ( ) ; result = httpsMethod . name ( ) ; mockUrlConn . getErrorStream ( ) ; result = null ; } } ; com . microsoft . azure . sdk . iot . deps . transport . http . HttpConnection conn = new com . microsoft . azure . sdk . iot . deps . transport . http . HttpConnection ( mockUrl , httpsMethod ) ; conn . connect ( ) ; byte [ ] testError = conn . readError ( ) ; \"<AssertPlaceHolder>\" ; } readError ( ) { byte [ ] error = new byte [ 0 ] ; try ( java . io . InputStream errorStream = this . connection . getErrorStream ( ) ) { if ( errorStream != null ) { error = com . microsoft . azure . sdk . iot . service . transport . http . HttpConnection . readInputStream ( errorStream ) ; } } return error ; }", "answer": "org . junit . Assert . assertThat ( testError , org . hamcrest . CoreMatchers . is ( expectedError ) )"}
{"focal": "toJSONPretty ( java . lang . Object ) { return org . apache . metron . common . utils . JSONUtils . _mapper . get ( ) . writerWithDefaultPrettyPrinter ( ) . writeValueAsBytes ( config ) ; }", "testMethod": "modifiesSingleParserConfiguration ( ) { org . apache . metron . common . configuration . ConfigurationType type = ConfigurationType . PARSER ; java . lang . String parserName = \"a-happy-metron-parser\" ; byte [ ] config = JSONUtils . INSTANCE . toJSONPretty ( org . apache . metron . common . configuration . ConfigurationsUtilsTest . someParserConfig ) ; org . apache . metron . common . configuration . ConfigurationsUtils . writeConfigToZookeeper ( type , java . util . Optional . of ( parserName ) , config , zookeeperUrl ) ; byte [ ] actual = org . apache . metron . common . configuration . ConfigurationsUtils . readConfigBytesFromZookeeper ( type , java . util . Optional . of ( parserName ) , zookeeperUrl ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( JSONUtils . INSTANCE . toJSONPretty ( org . apache . metron . common . configuration . ConfigurationsUtilsTest . someParserConfig ) ) )", "total": "modifiesSingleParserConfiguration ( ) { org . apache . metron . common . configuration . ConfigurationType type = ConfigurationType . PARSER ; java . lang . String parserName = \"a-happy-metron-parser\" ; byte [ ] config = JSONUtils . INSTANCE . toJSONPretty ( org . apache . metron . common . configuration . ConfigurationsUtilsTest . someParserConfig ) ; org . apache . metron . common . configuration . ConfigurationsUtils . writeConfigToZookeeper ( type , java . util . Optional . of ( parserName ) , config , zookeeperUrl ) ; byte [ ] actual = org . apache . metron . common . configuration . ConfigurationsUtils . readConfigBytesFromZookeeper ( type , java . util . Optional . of ( parserName ) , zookeeperUrl ) ; \"<AssertPlaceHolder>\" ; } toJSONPretty ( java . lang . Object ) { return org . apache . metron . common . utils . JSONUtils . _mapper . get ( ) . writerWithDefaultPrettyPrinter ( ) . writeValueAsBytes ( config ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( JSONUtils . INSTANCE . toJSONPretty ( org . apache . metron . common . configuration . ConfigurationsUtilsTest . someParserConfig ) ) )"}
{"focal": "getKey ( ) { return key ; }", "testMethod": "setKey ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . Datastore . allocateId ( org . slim3 . datastore . model . Hoge . class ) ; ref . setKey ( key ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ref . getKey ( ) , org . hamcrest . CoreMatchers . is ( key ) )", "total": "setKey ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . Datastore . allocateId ( org . slim3 . datastore . model . Hoge . class ) ; ref . setKey ( key ) ; \"<AssertPlaceHolder>\" ; } getKey ( ) { return key ; }", "answer": "org . junit . Assert . assertThat ( ref . getKey ( ) , org . hamcrest . CoreMatchers . is ( key ) )"}
{"focal": "empty ( ) { synchronized ( keyEntry ) { try ( com . sleepycat . je . Cursor cursor = database . openCursor ( null , null ) ) { while ( ( cursor . getNext ( keyEntry , valueEntry , LockMode . DEFAULT ) ) == ( com . sleepycat . je . OperationStatus . SUCCESS ) ) { cursor . delete ( ) ; } } } }", "testMethod": "filterFiltersAllTheVerticesFromTheTraversalWhenNoneMatch ( ) { org . apache . tinkerpop . gremlin . process . traversal . dsl . graph . GraphTraversal < org . apache . tinkerpop . gremlin . structure . Vertex , org . apache . tinkerpop . gremlin . structure . Vertex > traversal = newGraph ( ) . withVertex ( ( vertex ) -> vertex . withTimId ( \"v1\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , \"value1\" ) ) . withVertex ( ( vertex ) -> vertex . withTimId ( \"v2\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , \"value2\" ) ) . withVertex ( ( vertex ) -> vertex . withTimId ( \"v3\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , \"value\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . BACKUP_PROPERTY , \"value1\" ) ) . build ( ) . traversal ( ) . V ( ) ; nl . knaw . huygens . timbuctoo . server . mediatypes . v2 . search . FullTextSearchParameter fullTextSearchParameter = new nl . knaw . huygens . timbuctoo . server . mediatypes . v2 . search . FullTextSearchParameter ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . NAME , \"Not<sp>matching\" ) ; nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescription instance = nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescription . createLocalFullTextSearchDescriptionWithBackupProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . NAME , nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . BACKUP_PROPERTY ) ; instance . filter ( traversal , fullTextSearchParameter ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( traversal . toList ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . empty ( ) ) )", "total": "filterFiltersAllTheVerticesFromTheTraversalWhenNoneMatch ( ) { org . apache . tinkerpop . gremlin . process . traversal . dsl . graph . GraphTraversal < org . apache . tinkerpop . gremlin . structure . Vertex , org . apache . tinkerpop . gremlin . structure . Vertex > traversal = newGraph ( ) . withVertex ( ( vertex ) -> vertex . withTimId ( \"v1\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , \"value1\" ) ) . withVertex ( ( vertex ) -> vertex . withTimId ( \"v2\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , \"value2\" ) ) . withVertex ( ( vertex ) -> vertex . withTimId ( \"v3\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , \"value\" ) . withProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . BACKUP_PROPERTY , \"value1\" ) ) . build ( ) . traversal ( ) . V ( ) ; nl . knaw . huygens . timbuctoo . server . mediatypes . v2 . search . FullTextSearchParameter fullTextSearchParameter = new nl . knaw . huygens . timbuctoo . server . mediatypes . v2 . search . FullTextSearchParameter ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . NAME , \"Not<sp>matching\" ) ; nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescription instance = nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescription . createLocalFullTextSearchDescriptionWithBackupProperty ( nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . NAME , nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . PROPERTY , nl . knaw . huygens . timbuctoo . search . description . fulltext . FullTextSearchDescriptionTest . BACKUP_PROPERTY ) ; instance . filter ( traversal , fullTextSearchParameter ) ; \"<AssertPlaceHolder>\" ; } empty ( ) { synchronized ( keyEntry ) { try ( com . sleepycat . je . Cursor cursor = database . openCursor ( null , null ) ) { while ( ( cursor . getNext ( keyEntry , valueEntry , LockMode . DEFAULT ) ) == ( com . sleepycat . je . OperationStatus . SUCCESS ) ) { cursor . delete ( ) ; } } } }", "answer": "org . junit . Assert . assertThat ( traversal . toList ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . empty ( ) ) )"}
{"focal": "counts ( com . myshop . common . jpaspec . Specification ) { javax . persistence . criteria . CriteriaBuilder cb = em . getCriteriaBuilder ( ) ; javax . persistence . criteria . CriteriaQuery < java . lang . Long > criteriaQuery = cb . createQuery ( com . myshop . order . infra . dao . Long . class ) ; javax . persistence . criteria . Root < com . myshop . order . query . dto . OrderSummary > root = criteriaQuery . from ( com . myshop . order . query . dto . OrderSummary . class ) ; if ( spec != null ) { javax . persistence . criteria . Predicate predicate = spec . toPredicate ( root , cb ) ; criteriaQuery . where ( predicate ) ; } criteriaQuery . select ( cb . count ( root ) ) ; javax . persistence . TypedQuery < java . lang . Long > query = em . createQuery ( criteriaQuery ) ; return query . getSingleResult ( ) . longValue ( ) ; }", "testMethod": "counts ( ) { java . time . LocalDateTime fromTime = java . time . LocalDateTime . of ( 2016 , 1 , 1 , 0 , 0 , 0 ) ; java . time . LocalDateTime toTime = java . time . LocalDateTime . of ( 2016 , 1 , 2 , 0 , 0 , 0 ) ; com . myshop . common . jpaspec . Specification < com . myshop . order . infra . repository . Order > specs = com . myshop . common . jpaspec . Specs . and ( com . myshop . order . infra . repository . OrderSpecs . orderer ( \"user1\" ) , com . myshop . order . infra . repository . OrderSpecs . between ( java . sql . Date . from ( fromTime . atZone ( java . time . ZoneId . systemDefault ( ) ) . toInstant ( ) ) , java . sql . Date . from ( toTime . atZone ( java . time . ZoneId . systemDefault ( ) ) . toInstant ( ) ) ) ) ; java . lang . Long counts = orderRepository . counts ( specs ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( counts . longValue ( ) , org . hamcrest . Matchers . equalTo ( 1L ) )", "total": "counts ( ) { java . time . LocalDateTime fromTime = java . time . LocalDateTime . of ( 2016 , 1 , 1 , 0 , 0 , 0 ) ; java . time . LocalDateTime toTime = java . time . LocalDateTime . of ( 2016 , 1 , 2 , 0 , 0 , 0 ) ; com . myshop . common . jpaspec . Specification < com . myshop . order . infra . repository . Order > specs = com . myshop . common . jpaspec . Specs . and ( com . myshop . order . infra . repository . OrderSpecs . orderer ( \"user1\" ) , com . myshop . order . infra . repository . OrderSpecs . between ( java . sql . Date . from ( fromTime . atZone ( java . time . ZoneId . systemDefault ( ) ) . toInstant ( ) ) , java . sql . Date . from ( toTime . atZone ( java . time . ZoneId . systemDefault ( ) ) . toInstant ( ) ) ) ) ; java . lang . Long counts = orderRepository . counts ( specs ) ; \"<AssertPlaceHolder>\" ; } counts ( com . myshop . common . jpaspec . Specification ) { javax . persistence . criteria . CriteriaBuilder cb = em . getCriteriaBuilder ( ) ; javax . persistence . criteria . CriteriaQuery < java . lang . Long > criteriaQuery = cb . createQuery ( com . myshop . order . infra . dao . Long . class ) ; javax . persistence . criteria . Root < com . myshop . order . query . dto . OrderSummary > root = criteriaQuery . from ( com . myshop . order . query . dto . OrderSummary . class ) ; if ( spec != null ) { javax . persistence . criteria . Predicate predicate = spec . toPredicate ( root , cb ) ; criteriaQuery . where ( predicate ) ; } criteriaQuery . select ( cb . count ( root ) ) ; javax . persistence . TypedQuery < java . lang . Long > query = em . createQuery ( criteriaQuery ) ; return query . getSingleResult ( ) . longValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( counts . longValue ( ) , org . hamcrest . Matchers . equalTo ( 1L ) )"}
{"focal": "getHeader ( java . lang . String ) { java . util . List < java . lang . String > values = getHeaderList ( name ) ; if ( values != null ) { return values . get ( 0 ) ; } return null ; }", "testMethod": "header ( ) { request . setHeader ( \"aaa\" , \"111\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( request . getHeader ( \"aaa\" ) , org . hamcrest . CoreMatchers . is ( \"111\" ) )", "total": "header ( ) { request . setHeader ( \"aaa\" , \"111\" ) ; \"<AssertPlaceHolder>\" ; } getHeader ( java . lang . String ) { java . util . List < java . lang . String > values = getHeaderList ( name ) ; if ( values != null ) { return values . get ( 0 ) ; } return null ; }", "answer": "org . junit . Assert . assertThat ( request . getHeader ( \"aaa\" ) , org . hamcrest . CoreMatchers . is ( \"111\" ) )"}
{"focal": "children ( ) { if ( ( children ) == null ) { return java . util . Collections . emptyList ( ) ; } else { return children ; } }", "testMethod": "testChildrenIterator ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . google . common . collect . Lists . newArrayList ( a . children ( ) ) , org . hamcrest . CoreMatchers . is ( com . google . common . collect . Lists . newArrayList ( b , d , e ) ) )", "total": "testChildrenIterator ( ) { \"<AssertPlaceHolder>\" ; } children ( ) { if ( ( children ) == null ) { return java . util . Collections . emptyList ( ) ; } else { return children ; } }", "answer": "org . junit . Assert . assertThat ( com . google . common . collect . Lists . newArrayList ( a . children ( ) ) , org . hamcrest . CoreMatchers . is ( com . google . common . collect . Lists . newArrayList ( b , d , e ) ) )"}
{"focal": "setBaseVersion ( java . lang . String ) { this . baseVersion = baseVersion ; if ( ( baseVersion != null ) && ( baseVersion . endsWith ( \"SNAPSHOT\" ) ) ) { this . snapshot = true ; } }", "testMethod": "isSameCause_multiArtifact_multiClassifiers_on_firstCause_withBaseVersion_true ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifactSources = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifactSources . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; firstArtifactSources . setClassifier ( \"sources\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-second-jar:jar:1.0-20100529-1214-1\" ) ; secondArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact sameAsFirstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; sameAsFirstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact , firstArtifactSources , secondArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( sameAsFirstArtifact ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( matchingArtifacts . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "isSameCause_multiArtifact_multiClassifiers_on_firstCause_withBaseVersion_true ( ) { org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact firstArtifactSources = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; firstArtifactSources . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; firstArtifactSources . setClassifier ( \"sources\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact secondArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-second-jar:jar:1.0-20100529-1214-1\" ) ; secondArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; org . jenkinsci . plugins . pipeline . maven . MavenArtifact sameAsFirstArtifact = new org . jenkinsci . plugins . pipeline . maven . MavenArtifact ( \"com.example:my-jar:jar:1.0-20100529-1213-1\" ) ; sameAsFirstArtifact . setBaseVersion ( \"1.0-SNAPSHOT\" ) ; java . util . List < org . jenkinsci . plugins . pipeline . maven . MavenArtifact > matchingArtifacts = org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelper . isSameCause ( new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( firstArtifact , firstArtifactSources , secondArtifact ) , new org . jenkinsci . plugins . pipeline . maven . cause . MavenDependencyCauseHelperTest . MavenDependencyTestCause ( sameAsFirstArtifact ) ) ; \"<AssertPlaceHolder>\" ; } setBaseVersion ( java . lang . String ) { this . baseVersion = baseVersion ; if ( ( baseVersion != null ) && ( baseVersion . endsWith ( \"SNAPSHOT\" ) ) ) { this . snapshot = true ; } }", "answer": "org . junit . Assert . assertThat ( matchingArtifacts . isEmpty ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "expr ( org . openscience . cdk . isomorphism . matchers . Expr$Type ) { return new org . openscience . cdk . isomorphism . matchers . Expr ( type ) ; }", "testMethod": "ringMembership2 ( ) { org . openscience . cdk . isomorphism . matchers . Expr actual = org . openscience . cdk . smarts . SmartsExprReadTest . getAtomExpr ( \"[!R0]\" ) ; org . openscience . cdk . isomorphism . matchers . Expr expected = org . openscience . cdk . smarts . SmartsExprReadTest . expr ( org . openscience . cdk . smarts . IS_IN_RING ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "ringMembership2 ( ) { org . openscience . cdk . isomorphism . matchers . Expr actual = org . openscience . cdk . smarts . SmartsExprReadTest . getAtomExpr ( \"[!R0]\" ) ; org . openscience . cdk . isomorphism . matchers . Expr expected = org . openscience . cdk . smarts . SmartsExprReadTest . expr ( org . openscience . cdk . smarts . IS_IN_RING ) ; \"<AssertPlaceHolder>\" ; } expr ( org . openscience . cdk . isomorphism . matchers . Expr$Type ) { return new org . openscience . cdk . isomorphism . matchers . Expr ( type ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "between ( net . time4j . range . Boundary , net . time4j . range . Boundary ) { return new net . time4j . range . DateInterval ( start , end ) ; }", "testMethod": "containsTemporalLeftEdgeClosed ( ) { net . time4j . PlainDate start = net . time4j . PlainDate . of ( 2014 , 2 , 27 ) ; net . time4j . PlainDate end = net . time4j . PlainDate . of ( 2014 , 5 , 14 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . range . DateInterval . between ( start , end ) . contains ( start ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "containsTemporalLeftEdgeClosed ( ) { net . time4j . PlainDate start = net . time4j . PlainDate . of ( 2014 , 2 , 27 ) ; net . time4j . PlainDate end = net . time4j . PlainDate . of ( 2014 , 5 , 14 ) ; \"<AssertPlaceHolder>\" ; } between ( net . time4j . range . Boundary , net . time4j . range . Boundary ) { return new net . time4j . range . DateInterval ( start , end ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . range . DateInterval . between ( start , end ) . contains ( start ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "testMethod": "testParseSizeErr ( ) { params = new java . util . HashMap < java . lang . String , java . lang . String > ( ) { { put ( \"type\" , \"aaa\" ) ; put ( \"vendor_id\" , \"12\" ) ; } } ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowMatchQuery ( params ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testParseSizeErr ( ) { params = new java . util . HashMap < java . lang . String , java . lang . String > ( ) { { put ( \"type\" , \"aaa\" ) ; put ( \"vendor_id\" , \"12\" ) ; } } ; target = new org . o3project . odenos . core . component . network . flow . query . OFPFlowMatchQuery ( params ) ; \"<AssertPlaceHolder>\" ; } parse ( ) { if ( ! ( super . parse ( ) ) ) { return false ; } if ( ! ( org . o3project . odenos . core . component . network . BasicQuery . checkMapExactly ( this . actions , new java . lang . String [ ] { } ) ) ) { return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . parse ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getTest ( ) { return test ; }", "testMethod": "setTestAndRetrieveValue ( ) { final org . apache . maven . surefire . test . App app = new org . apache . maven . surefire . test . App ( ) ; final java . lang . String val = \"foo\" ; app . setTest ( val ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( app . getTest ( ) , org . hamcrest . CoreMatchers . equalTo ( val ) )", "total": "setTestAndRetrieveValue ( ) { final org . apache . maven . surefire . test . App app = new org . apache . maven . surefire . test . App ( ) ; final java . lang . String val = \"foo\" ; app . setTest ( val ) ; \"<AssertPlaceHolder>\" ; } getTest ( ) { return test ; }", "answer": "org . junit . Assert . assertThat ( app . getTest ( ) , org . hamcrest . CoreMatchers . equalTo ( val ) )"}
{"focal": "between ( net . time4j . PlainTimestamp , net . time4j . PlainTimestamp ) { return new net . time4j . range . TimestampInterval ( net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . CLOSED , start ) , net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . OPEN , end ) ) ; }", "testMethod": "containsTemporalOutside ( ) { net . time4j . PlainTimestamp start = net . time4j . PlainTimestamp . of ( 2014 , 2 , 27 , 0 , 0 ) ; net . time4j . PlainTimestamp end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . range . TimestampInterval . between ( start , end ) . contains ( net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 , 1 ) ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "containsTemporalOutside ( ) { net . time4j . PlainTimestamp start = net . time4j . PlainTimestamp . of ( 2014 , 2 , 27 , 0 , 0 ) ; net . time4j . PlainTimestamp end = net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; } between ( net . time4j . PlainTimestamp , net . time4j . PlainTimestamp ) { return new net . time4j . range . TimestampInterval ( net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . CLOSED , start ) , net . time4j . range . Boundary . of ( net . time4j . range . IntervalEdge . OPEN , end ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . range . TimestampInterval . between ( start , end ) . contains ( net . time4j . PlainTimestamp . of ( 2014 , 5 , 14 , 0 , 0 , 1 ) ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectOtherSameProperty ( ) { org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork obj = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"objectId\" , \"connectionType\" , \"connectionState\" , \"logicId\" , \"networkId\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testEqualsObjectOtherSameProperty ( ) { org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork obj = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"objectId\" , \"connectionType\" , \"connectionState\" , \"logicId\" , \"networkId\" ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( obj ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "select ( java . lang . String ) { java . lang . ref . SoftReference < java . lang . String > file = files . get ( fileName ) ; if ( file == null ) { file = new java . lang . ref . SoftReference ( readFile ( fileName ) ) ; files . put ( fileName , file ) ; } return file . get ( ) ; }", "testMethod": "whenReadFileAndAddNewLineToFileThenSecondReadFromHashWithoutLine ( ) { vkaretko . Cache cache = new vkaretko . Cache ( \"c:/temp\" ) ; java . lang . String before = cache . readFile ( \"names2.txt\" ) ; java . lang . String result = cache . select ( \"names2.txt\" ) ; java . lang . String path = \"c:/temp/names2.txt\" ; try ( java . io . FileWriter writer = new java . io . FileWriter ( path , true ) ; java . io . BufferedWriter bufferWriter = new java . io . BufferedWriter ( writer ) ) { bufferWriter . write ( \"test\" ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } result = cache . select ( \"names2.txt\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( before ) )", "total": "whenReadFileAndAddNewLineToFileThenSecondReadFromHashWithoutLine ( ) { vkaretko . Cache cache = new vkaretko . Cache ( \"c:/temp\" ) ; java . lang . String before = cache . readFile ( \"names2.txt\" ) ; java . lang . String result = cache . select ( \"names2.txt\" ) ; java . lang . String path = \"c:/temp/names2.txt\" ; try ( java . io . FileWriter writer = new java . io . FileWriter ( path , true ) ; java . io . BufferedWriter bufferWriter = new java . io . BufferedWriter ( writer ) ) { bufferWriter . write ( \"test\" ) ; } catch ( java . io . IOException e ) { e . printStackTrace ( ) ; } result = cache . select ( \"names2.txt\" ) ; \"<AssertPlaceHolder>\" ; } select ( java . lang . String ) { java . lang . ref . SoftReference < java . lang . String > file = files . get ( fileName ) ; if ( file == null ) { file = new java . lang . ref . SoftReference ( readFile ( fileName ) ) ; files . put ( fileName , file ) ; } return file . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( before ) )"}
{"focal": "toWritableObject ( java . lang . Object ) { if ( value == null ) { return null ; } try { return toWritableObjectInternal ( value ) ; } catch ( java . lang . ClassCastException e ) { throw new com . hotels . corc . UnexpectedTypeException ( value ) ; } }", "testMethod": "listStringWritable ( ) { com . hotels . corc . Converter converter = getConverter ( org . apache . hadoop . hive . serde2 . typeinfo . TypeInfoFactory . getListTypeInfo ( TypeInfoFactory . stringTypeInfo ) ) ; java . util . List < org . apache . hadoop . io . Text > writableList = java . util . Arrays . asList ( new org . apache . hadoop . io . Text ( \"a\" ) ) ; java . util . List < java . lang . String > javaList = java . util . Arrays . asList ( \"a\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( converter . toWritableObject ( javaList ) , org . hamcrest . CoreMatchers . is ( ( ( java . lang . Object ) ( writableList ) ) ) )", "total": "listStringWritable ( ) { com . hotels . corc . Converter converter = getConverter ( org . apache . hadoop . hive . serde2 . typeinfo . TypeInfoFactory . getListTypeInfo ( TypeInfoFactory . stringTypeInfo ) ) ; java . util . List < org . apache . hadoop . io . Text > writableList = java . util . Arrays . asList ( new org . apache . hadoop . io . Text ( \"a\" ) ) ; java . util . List < java . lang . String > javaList = java . util . Arrays . asList ( \"a\" ) ; \"<AssertPlaceHolder>\" ; } toWritableObject ( java . lang . Object ) { if ( value == null ) { return null ; } try { return toWritableObjectInternal ( value ) ; } catch ( java . lang . ClassCastException e ) { throw new com . hotels . corc . UnexpectedTypeException ( value ) ; } }", "answer": "org . junit . Assert . assertThat ( converter . toWritableObject ( javaList ) , org . hamcrest . CoreMatchers . is ( ( ( java . lang . Object ) ( writableList ) ) ) )"}
{"focal": "getSortColumn ( ) { return this . sortColumn ; }", "testMethod": "shouldGetSortColumn ( ) { java . lang . String sortColumn = \"column\" ; this . state . setSortColumn ( sortColumn ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( this . adapter . getSortColumn ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( sortColumn ) ) )", "total": "shouldGetSortColumn ( ) { java . lang . String sortColumn = \"column\" ; this . state . setSortColumn ( sortColumn ) ; \"<AssertPlaceHolder>\" ; } getSortColumn ( ) { return this . sortColumn ; }", "answer": "org . junit . Assert . assertThat ( this . adapter . getSortColumn ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( sortColumn ) ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "kanDataExtracten ( ) { java . sql . ResultSet resultSet = mock ( java . sql . ResultSet . class ) ; when ( resultSet . next ( ) ) . thenReturn ( true ) . thenReturn ( false ) ; when ( resultSet . getBytes ( anyInt ( ) ) ) . thenReturn ( new byte [ ] { } ) ; when ( persoonLeveringService . leverPersoon ( any ( byte [ ] . class ) ) ) . thenReturn ( com . google . common . base . Optional . of ( false ) ) ; java . util . List < nl . bzk . brp . bevraging . commands . BevraagInfo > result = extractor . extractData ( resultSet ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . Matchers . is ( 1 ) )", "total": "kanDataExtracten ( ) { java . sql . ResultSet resultSet = mock ( java . sql . ResultSet . class ) ; when ( resultSet . next ( ) ) . thenReturn ( true ) . thenReturn ( false ) ; when ( resultSet . getBytes ( anyInt ( ) ) ) . thenReturn ( new byte [ ] { } ) ; when ( persoonLeveringService . leverPersoon ( any ( byte [ ] . class ) ) ) . thenReturn ( com . google . common . base . Optional . of ( false ) ) ; java . util . List < nl . bzk . brp . bevraging . commands . BevraagInfo > result = extractor . extractData ( resultSet ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . Matchers . is ( 1 ) )"}
{"focal": "onFileDelete ( java . io . File , org . apache . camel . spi . Synchronization ) { java . lang . String referenceKey = file . toURI ( ) . toASCIIString ( ) ; java . lang . String metacardId = getMetacardIdFromReference ( referenceKey , org . codice . ddf . catalog . content . monitor . DurableFileAlterationListener . CATALOG_DELETE , productToMetacardIdMap ) ; if ( org . apache . commons . lang3 . StringUtils . isEmpty ( metacardId ) ) { cb . onComplete ( null ) ; return ; } org . apache . camel . Exchange exchange = new org . codice . ddf . catalog . content . monitor . AbstractDurableFileConsumer . ExchangeHelper ( file , ( ( org . apache . camel . component . file . GenericFileEndpoint ) ( consumer . getEndpoint ( ) ) ) ) . setBody ( java . util . Collections . singletonList ( metacardId ) ) . addHeader ( org . codice . ddf . catalog . content . monitor . DurableFileAlterationListener . OPERATION_HEADER , org . codice . ddf . catalog . content . monitor . DurableFileAlterationListener . CATALOG_DELETE ) . addSynchronization ( new org . codice . ddf . catalog . content . monitor . synchronizations . DeletionSynchronization ( referenceKey , productToMetacardIdMap ) ) . addSynchronization ( cb ) . getExchange ( ) ; consumer . submitExchange ( exchange ) ; }", "testMethod": "testCreateWithErrors ( ) { java . io . File [ ] files = initFiles ( 9 , monitoredDirectory , \"file00\" ) ; timesToFail . set ( files . length ) ; observer . checkAndNotify ( ) ; verify ( fileListener , times ( files . length ) ) . onFileCreate ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; observer . checkAndNotify ( ) ; verify ( fileListener , times ( ( ( files . length ) + ( failures ) ) ) ) . onFileCreate ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; verify ( fileListener , never ( ) ) . onFileChange ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; verify ( fileListener , never ( ) ) . onFileDelete ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( failures , org . hamcrest . Matchers . is ( files . length ) )", "total": "testCreateWithErrors ( ) { java . io . File [ ] files = initFiles ( 9 , monitoredDirectory , \"file00\" ) ; timesToFail . set ( files . length ) ; observer . checkAndNotify ( ) ; verify ( fileListener , times ( files . length ) ) . onFileCreate ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; observer . checkAndNotify ( ) ; verify ( fileListener , times ( ( ( files . length ) + ( failures ) ) ) ) . onFileCreate ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; verify ( fileListener , never ( ) ) . onFileChange ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; verify ( fileListener , never ( ) ) . onFileDelete ( any ( java . io . File . class ) , any ( org . apache . camel . spi . Synchronization . class ) ) ; \"<AssertPlaceHolder>\" ; } onFileDelete ( java . io . File , org . apache . camel . spi . Synchronization ) { java . lang . String referenceKey = file . toURI ( ) . toASCIIString ( ) ; java . lang . String metacardId = getMetacardIdFromReference ( referenceKey , org . codice . ddf . catalog . content . monitor . DurableFileAlterationListener . CATALOG_DELETE , productToMetacardIdMap ) ; if ( org . apache . commons . lang3 . StringUtils . isEmpty ( metacardId ) ) { cb . onComplete ( null ) ; return ; } org . apache . camel . Exchange exchange = new org . codice . ddf . catalog . content . monitor . AbstractDurableFileConsumer . ExchangeHelper ( file , ( ( org . apache . camel . component . file . GenericFileEndpoint ) ( consumer . getEndpoint ( ) ) ) ) . setBody ( java . util . Collections . singletonList ( metacardId ) ) . addHeader ( org . codice . ddf . catalog . content . monitor . DurableFileAlterationListener . OPERATION_HEADER , org . codice . ddf . catalog . content . monitor . DurableFileAlterationListener . CATALOG_DELETE ) . addSynchronization ( new org . codice . ddf . catalog . content . monitor . synchronizations . DeletionSynchronization ( referenceKey , productToMetacardIdMap ) ) . addSynchronization ( cb ) . getExchange ( ) ; consumer . submitExchange ( exchange ) ; }", "answer": "org . junit . Assert . assertThat ( failures , org . hamcrest . Matchers . is ( files . length ) )"}
{"focal": "getQuery ( ) { return query ; }", "testMethod": "testDatePropertyGreaterThanOrEqualTo ( ) { stub ( mockResolver . getField ( \"created\" , AttributeFormat . DATE , false ) ) . toReturn ( \"created_date\" ) ; java . lang . String expectedQuery = \"<sp>created_date:[<sp>1995-11-24T23:59:56.765Z<sp>TO<sp>*<sp>]<sp>\" ; org . apache . solr . client . solrj . SolrQuery temporalQuery = toTest . propertyIsGreaterThanOrEqualTo ( Metacard . CREATED , getCannedTime ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( temporalQuery . getQuery ( ) , org . hamcrest . CoreMatchers . is ( expectedQuery ) )", "total": "testDatePropertyGreaterThanOrEqualTo ( ) { stub ( mockResolver . getField ( \"created\" , AttributeFormat . DATE , false ) ) . toReturn ( \"created_date\" ) ; java . lang . String expectedQuery = \"<sp>created_date:[<sp>1995-11-24T23:59:56.765Z<sp>TO<sp>*<sp>]<sp>\" ; org . apache . solr . client . solrj . SolrQuery temporalQuery = toTest . propertyIsGreaterThanOrEqualTo ( Metacard . CREATED , getCannedTime ( ) ) ; \"<AssertPlaceHolder>\" ; } getQuery ( ) { return query ; }", "answer": "org . junit . Assert . assertThat ( temporalQuery . getQuery ( ) , org . hamcrest . CoreMatchers . is ( expectedQuery ) )"}
{"focal": "prepareUpload ( int ) { request . setParameter ( UploadServletParameter . action . name ( ) , UploadServletAction . prepareUpload . name ( ) ) ; com . am . jlfu . fileuploader . json . PrepareUploadJson [ ] prepareUploadJsons = new com . am . jlfu . fileuploader . json . PrepareUploadJson [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { com . am . jlfu . fileuploader . json . PrepareUploadJson j = new com . am . jlfu . fileuploader . json . PrepareUploadJson ( ) ; j . setTempId ( i ) ; j . setFileName ( ( \"file<sp>\" + i ) ) ; j . setSize ( 123456L ) ; prepareUploadJsons [ i ] = j ; } request . setParameter ( UploadServletParameter . newFiles . name ( ) , new com . google . gson . Gson ( ) . toJson ( prepareUploadJsons ) ) ; uploadServlet . handleRequest ( request , response ) ; org . junit . Assert . assertThat ( response . getStatus ( ) , org . hamcrest . CoreMatchers . is ( 200 ) ) ; java . util . HashMap < java . lang . String , java . lang . String > fromJson = new com . google . gson . Gson ( ) . fromJson ( response . getContentAsString ( ) , new com . google . gson . reflect . TypeToken < java . util . Map < java . lang . String , java . lang . String > > ( ) { } . getType ( ) ) ; return fromJson ; }", "testMethod": "prepareUploadMulti ( ) { java . util . Map < java . lang . String , java . lang . String > prepareUpload = prepareUpload ( 10 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( prepareUpload . size ( ) , org . hamcrest . CoreMatchers . is ( 10 ) )", "total": "prepareUploadMulti ( ) { java . util . Map < java . lang . String , java . lang . String > prepareUpload = prepareUpload ( 10 ) ; \"<AssertPlaceHolder>\" ; } prepareUpload ( int ) { request . setParameter ( UploadServletParameter . action . name ( ) , UploadServletAction . prepareUpload . name ( ) ) ; com . am . jlfu . fileuploader . json . PrepareUploadJson [ ] prepareUploadJsons = new com . am . jlfu . fileuploader . json . PrepareUploadJson [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { com . am . jlfu . fileuploader . json . PrepareUploadJson j = new com . am . jlfu . fileuploader . json . PrepareUploadJson ( ) ; j . setTempId ( i ) ; j . setFileName ( ( \"file<sp>\" + i ) ) ; j . setSize ( 123456L ) ; prepareUploadJsons [ i ] = j ; } request . setParameter ( UploadServletParameter . newFiles . name ( ) , new com . google . gson . Gson ( ) . toJson ( prepareUploadJsons ) ) ; uploadServlet . handleRequest ( request , response ) ; org . junit . Assert . assertThat ( response . getStatus ( ) , org . hamcrest . CoreMatchers . is ( 200 ) ) ; java . util . HashMap < java . lang . String , java . lang . String > fromJson = new com . google . gson . Gson ( ) . fromJson ( response . getContentAsString ( ) , new com . google . gson . reflect . TypeToken < java . util . Map < java . lang . String , java . lang . String > > ( ) { } . getType ( ) ) ; return fromJson ; }", "answer": "org . junit . Assert . assertThat ( prepareUpload . size ( ) , org . hamcrest . CoreMatchers . is ( 10 ) )"}
{"focal": "toRfc3164SyslogMessage ( ) { java . io . StringWriter sw = new java . io . StringWriter ( ( ( msg ) == null ? 32 : ( msg . size ( ) ) + 32 ) ) ; try { toRfc3164SyslogMessage ( sw ) ; } catch ( java . io . IOException e ) { throw new java . lang . IllegalStateException ( e ) ; } return sw . toString ( ) ; }", "testMethod": "testRfc3164Format ( ) { java . util . Calendar cal = java . util . Calendar . getInstance ( ) ; cal . setTimeZone ( java . util . TimeZone . getDefault ( ) ) ; cal . set ( 2013 , Calendar . DECEMBER , 5 , 10 , 30 , 5 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; System . out . println ( SyslogMessage . rfc3339DateFormat . format ( cal . getTime ( ) ) ) ; System . out . println ( cal . getTimeInMillis ( ) ) ; com . cloudbees . syslog . SyslogMessage message = new com . cloudbees . syslog . SyslogMessage ( ) . withTimestamp ( cal . getTimeInMillis ( ) ) . withAppName ( \"my_app\" ) . withHostname ( \"myserver.example.com\" ) . withFacility ( Facility . USER ) . withSeverity ( Severity . INFORMATIONAL ) . withTimestamp ( cal . getTimeInMillis ( ) ) . withMsg ( \"a<sp>syslog<sp>message\" ) ; java . lang . String actual = message . toRfc3164SyslogMessage ( ) ; java . lang . String expected = \"<14>Dec<sp>05<sp>10:30:05<sp>myserver.example.com<sp>my_app:<sp>a<sp>syslog<sp>message\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "testRfc3164Format ( ) { java . util . Calendar cal = java . util . Calendar . getInstance ( ) ; cal . setTimeZone ( java . util . TimeZone . getDefault ( ) ) ; cal . set ( 2013 , Calendar . DECEMBER , 5 , 10 , 30 , 5 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; System . out . println ( SyslogMessage . rfc3339DateFormat . format ( cal . getTime ( ) ) ) ; System . out . println ( cal . getTimeInMillis ( ) ) ; com . cloudbees . syslog . SyslogMessage message = new com . cloudbees . syslog . SyslogMessage ( ) . withTimestamp ( cal . getTimeInMillis ( ) ) . withAppName ( \"my_app\" ) . withHostname ( \"myserver.example.com\" ) . withFacility ( Facility . USER ) . withSeverity ( Severity . INFORMATIONAL ) . withTimestamp ( cal . getTimeInMillis ( ) ) . withMsg ( \"a<sp>syslog<sp>message\" ) ; java . lang . String actual = message . toRfc3164SyslogMessage ( ) ; java . lang . String expected = \"<14>Dec<sp>05<sp>10:30:05<sp>myserver.example.com<sp>my_app:<sp>a<sp>syslog<sp>message\" ; \"<AssertPlaceHolder>\" ; } toRfc3164SyslogMessage ( ) { java . io . StringWriter sw = new java . io . StringWriter ( ( ( msg ) == null ? 32 : ( msg . size ( ) ) + 32 ) ) ; try { toRfc3164SyslogMessage ( sw ) ; } catch ( java . io . IOException e ) { throw new java . lang . IllegalStateException ( e ) ; } return sw . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "getExceptions ( ) { java . util . Set < org . libreplan . business . calendars . entities . CalendarException > exceptionDays = new java . util . HashSet ( ) ; exceptionDays . addAll ( exceptions ) ; if ( ( getParent ( ) ) != null ) { for ( org . libreplan . business . calendars . entities . CalendarException exceptionDay : getParent ( ) . getExceptions ( ) ) { if ( ! ( isExceptionDayAlreadyInExceptions ( exceptionDay ) ) ) { exceptionDays . add ( exceptionDay ) ; } } } return java . util . Collections . unmodifiableSet ( exceptionDays ) ; }", "testMethod": "testRemoveExceptionDay ( ) { org . libreplan . business . calendars . entities . BaseCalendar calendar = org . libreplan . business . test . calendars . entities . BaseCalendarTest . createChristmasCalendar ( ) ; calendar . removeExceptionDay ( org . libreplan . business . test . calendars . entities . BaseCalendarTest . CHRISTMAS_DAY_LOCAL_DATE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( calendar . getExceptions ( ) . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 0 ) )", "total": "testRemoveExceptionDay ( ) { org . libreplan . business . calendars . entities . BaseCalendar calendar = org . libreplan . business . test . calendars . entities . BaseCalendarTest . createChristmasCalendar ( ) ; calendar . removeExceptionDay ( org . libreplan . business . test . calendars . entities . BaseCalendarTest . CHRISTMAS_DAY_LOCAL_DATE ) ; \"<AssertPlaceHolder>\" ; } getExceptions ( ) { java . util . Set < org . libreplan . business . calendars . entities . CalendarException > exceptionDays = new java . util . HashSet ( ) ; exceptionDays . addAll ( exceptions ) ; if ( ( getParent ( ) ) != null ) { for ( org . libreplan . business . calendars . entities . CalendarException exceptionDay : getParent ( ) . getExceptions ( ) ) { if ( ! ( isExceptionDayAlreadyInExceptions ( exceptionDay ) ) ) { exceptionDays . add ( exceptionDay ) ; } } } return java . util . Collections . unmodifiableSet ( exceptionDays ) ; }", "answer": "org . junit . Assert . assertThat ( calendar . getExceptions ( ) . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 0 ) )"}
{"focal": "hasThrownException ( ) { return new org . neo4j . index . impl . lucene . HasThrownException ( ) ; }", "testMethod": "deleteAndCommitShouldBePublishedToOtherTransaction2 ( ) { org . neo4j . index . impl . lucene . WorkThread firstTx = createWorker ( ) ; org . neo4j . index . impl . lucene . WorkThread secondTx = createWorker ( ) ; firstTx . beginTransaction ( ) ; firstTx . waitForCommandToComplete ( ) ; secondTx . beginTransaction ( ) ; secondTx . waitForCommandToComplete ( ) ; firstTx . createNodeAndIndexBy ( key , \"some<sp>value\" ) ; firstTx . waitForCommandToComplete ( ) ; secondTx . createNodeAndIndexBy ( key , \"some<sp>other<sp>value\" ) ; secondTx . waitForCommandToComplete ( ) ; firstTx . deleteIndex ( ) ; firstTx . waitForCommandToComplete ( ) ; firstTx . commit ( ) ; firstTx . waitForCommandToComplete ( ) ; secondTx . queryIndex ( key , \"some<sp>other<sp>value\" ) ; secondTx . waitForCommandToComplete ( ) ; \"<AssertPlaceHolder>\" ; secondTx . rollback ( ) ; secondTx . waitForCommandToComplete ( ) ; rollbackTx ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( secondTx , org . neo4j . index . impl . lucene . HasThrownException . hasThrownException ( ) )", "total": "deleteAndCommitShouldBePublishedToOtherTransaction2 ( ) { org . neo4j . index . impl . lucene . WorkThread firstTx = createWorker ( ) ; org . neo4j . index . impl . lucene . WorkThread secondTx = createWorker ( ) ; firstTx . beginTransaction ( ) ; firstTx . waitForCommandToComplete ( ) ; secondTx . beginTransaction ( ) ; secondTx . waitForCommandToComplete ( ) ; firstTx . createNodeAndIndexBy ( key , \"some<sp>value\" ) ; firstTx . waitForCommandToComplete ( ) ; secondTx . createNodeAndIndexBy ( key , \"some<sp>other<sp>value\" ) ; secondTx . waitForCommandToComplete ( ) ; firstTx . deleteIndex ( ) ; firstTx . waitForCommandToComplete ( ) ; firstTx . commit ( ) ; firstTx . waitForCommandToComplete ( ) ; secondTx . queryIndex ( key , \"some<sp>other<sp>value\" ) ; secondTx . waitForCommandToComplete ( ) ; \"<AssertPlaceHolder>\" ; secondTx . rollback ( ) ; secondTx . waitForCommandToComplete ( ) ; rollbackTx ( ) ; } hasThrownException ( ) { return new org . neo4j . index . impl . lucene . HasThrownException ( ) ; }", "answer": "org . junit . Assert . assertThat ( secondTx , org . neo4j . index . impl . lucene . HasThrownException . hasThrownException ( ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "shouldHaveCorrectName ( ) { com . oracle . bedrock . runtime . docker . DockerContainer container = new com . oracle . bedrock . runtime . docker . DockerContainer ( \"foo\" , com . oracle . bedrock . OptionsByType . empty ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( container . getName ( ) , org . hamcrest . CoreMatchers . is ( \"foo\" ) )", "total": "shouldHaveCorrectName ( ) { com . oracle . bedrock . runtime . docker . DockerContainer container = new com . oracle . bedrock . runtime . docker . DockerContainer ( \"foo\" , com . oracle . bedrock . OptionsByType . empty ( ) ) ; \"<AssertPlaceHolder>\" ; } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( container . getName ( ) , org . hamcrest . CoreMatchers . is ( \"foo\" ) )"}
{"focal": "getLines ( ) { return lines ; }", "testMethod": "fillLinesWithIgnoredOffsetAndLength ( ) { com . sap . hcp . cf . logging . common . converter . LineWriter lines = new com . sap . hcp . cf . logging . common . converter . LineWriter ( ) ; lines . write ( \"first<sp>line\" , 5 , 100 ) ; lines . write ( \"second<sp>line\" , 5 , 110 ) ; lines . close ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( lines . getLines ( ) , org . hamcrest . Matchers . contains ( \"first<sp>line\" , \"second<sp>line\" ) )", "total": "fillLinesWithIgnoredOffsetAndLength ( ) { com . sap . hcp . cf . logging . common . converter . LineWriter lines = new com . sap . hcp . cf . logging . common . converter . LineWriter ( ) ; lines . write ( \"first<sp>line\" , 5 , 100 ) ; lines . write ( \"second<sp>line\" , 5 , 110 ) ; lines . close ( ) ; \"<AssertPlaceHolder>\" ; } getLines ( ) { return lines ; }", "answer": "org . junit . Assert . assertThat ( lines . getLines ( ) , org . hamcrest . Matchers . contains ( \"first<sp>line\" , \"second<sp>line\" ) )"}
{"focal": "equalTo ( java . lang . Class ) { return getRawType ( ) . equals ( type ) ; }", "testMethod": "Sorted_Equal ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . sorted ( 1 , 1 , 2 , 2 ) , org . javersion . core . DiffTest . sorted ( 1 , 1 , 2 , 2 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . sorted ( ) ) )", "total": "Sorted_Equal ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . sorted ( 1 , 1 , 2 , 2 ) , org . javersion . core . DiffTest . sorted ( 1 , 1 , 2 , 2 ) ) ; \"<AssertPlaceHolder>\" ; } equalTo ( java . lang . Class ) { return getRawType ( ) . equals ( type ) ; }", "answer": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . sorted ( ) ) )"}
{"focal": "error ( ) { return new org . terasoluna . gfw . common . message . ResultMessages ( ERROR ) ; }", "testMethod": "testResolveExceptionCode_other_exception_match_realclass ( ) { java . util . LinkedHashMap < java . lang . String , java . lang . String > exceptionMappings = new java . util . LinkedHashMap < java . lang . String , java . lang . String > ( ) ; exceptionMappings . put ( \"BusinessException\" , \"bus001\" ) ; testTarget . setExceptionMappings ( exceptionMappings ) ; java . lang . String actualExceptionCode = testTarget . resolveExceptionCode ( new org . terasoluna . gfw . common . exception . BusinessException ( org . terasoluna . gfw . common . message . ResultMessages . error ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualExceptionCode , org . hamcrest . CoreMatchers . is ( \"bus001\" ) )", "total": "testResolveExceptionCode_other_exception_match_realclass ( ) { java . util . LinkedHashMap < java . lang . String , java . lang . String > exceptionMappings = new java . util . LinkedHashMap < java . lang . String , java . lang . String > ( ) ; exceptionMappings . put ( \"BusinessException\" , \"bus001\" ) ; testTarget . setExceptionMappings ( exceptionMappings ) ; java . lang . String actualExceptionCode = testTarget . resolveExceptionCode ( new org . terasoluna . gfw . common . exception . BusinessException ( org . terasoluna . gfw . common . message . ResultMessages . error ( ) ) ) ; \"<AssertPlaceHolder>\" ; } error ( ) { return new org . terasoluna . gfw . common . message . ResultMessages ( ERROR ) ; }", "answer": "org . junit . Assert . assertThat ( actualExceptionCode , org . hamcrest . CoreMatchers . is ( \"bus001\" ) )"}
{"focal": "validate ( ) { try { org . apache . commons . lang . Validate . notEmpty ( this . lowerNw , \"lower_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwNode , \"lower_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwPort , \"lower_nw_port<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNw , \"upper_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwNode , \"upper_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwPort , \"upper_nw_port<sp>is<sp>empty\" ) ; return true ; } catch ( java . lang . IllegalArgumentException ex ) { org . o3project . odenos . component . linklayerizer . LinkLayerizerBoundary . log . warn ( ex . getMessage ( ) , ex ) ; return false ; } }", "testMethod": "testValidateFalseNull ( ) { target = new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . validate ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testValidateFalseNull ( ) { target = new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( null ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { try { org . apache . commons . lang . Validate . notEmpty ( this . lowerNw , \"lower_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwNode , \"lower_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwPort , \"lower_nw_port<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNw , \"upper_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwNode , \"upper_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwPort , \"upper_nw_port<sp>is<sp>empty\" ) ; return true ; } catch ( java . lang . IllegalArgumentException ex ) { org . o3project . odenos . component . linklayerizer . LinkLayerizerBoundary . log . warn ( ex . getMessage ( ) , ex ) ; return false ; } }", "answer": "org . junit . Assert . assertThat ( target . validate ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getMaxConcurrency ( ) { return maxConcurrency ; }", "testMethod": "customMaxConcurrency ( ) { int customMaxConcurrency = 1 ; org . mule . runtime . core . api . construct . Flow customFlow = org . mule . runtime . core . api . construct . Flow . builder ( org . mule . runtime . core . internal . construct . DefaultFlowTestCase . FLOW_NAME , muleContext ) . source ( directInboundMessageSource ) . processors ( getSensingNullMessageProcessor ( ) ) . maxConcurrency ( customMaxConcurrency ) . build ( ) ; try { customFlow . initialise ( ) ; customFlow . start ( ) ; \"<AssertPlaceHolder>\" ; verify ( muleContext . getSchedulerService ( ) ) . ioScheduler ( eq ( muleContext . getSchedulerBaseConfig ( ) . withName ( ( ( ( flow . getName ( ) ) + \".\" ) + ( org . mule . runtime . core . internal . construct . BLOCKING . name ( ) ) ) ) ) ) ; customFlow . stop ( ) ; } finally { customFlow . dispose ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( customFlow . getMaxConcurrency ( ) , org . hamcrest . CoreMatchers . equalTo ( customMaxConcurrency ) )", "total": "customMaxConcurrency ( ) { int customMaxConcurrency = 1 ; org . mule . runtime . core . api . construct . Flow customFlow = org . mule . runtime . core . api . construct . Flow . builder ( org . mule . runtime . core . internal . construct . DefaultFlowTestCase . FLOW_NAME , muleContext ) . source ( directInboundMessageSource ) . processors ( getSensingNullMessageProcessor ( ) ) . maxConcurrency ( customMaxConcurrency ) . build ( ) ; try { customFlow . initialise ( ) ; customFlow . start ( ) ; \"<AssertPlaceHolder>\" ; verify ( muleContext . getSchedulerService ( ) ) . ioScheduler ( eq ( muleContext . getSchedulerBaseConfig ( ) . withName ( ( ( ( flow . getName ( ) ) + \".\" ) + ( org . mule . runtime . core . internal . construct . BLOCKING . name ( ) ) ) ) ) ) ; customFlow . stop ( ) ; } finally { customFlow . dispose ( ) ; } } getMaxConcurrency ( ) { return maxConcurrency ; }", "answer": "org . junit . Assert . assertThat ( customFlow . getMaxConcurrency ( ) , org . hamcrest . CoreMatchers . equalTo ( customMaxConcurrency ) )"}
{"focal": "exists ( ) { return new org . hamcrest . BaseMatcher < java . io . File > ( ) { @ com . asakusafw . operation . tools . directio . Override public boolean matches ( java . lang . Object item ) { return ( ( java . io . File ) ( item ) ) . exists ( ) ; } @ com . asakusafw . operation . tools . directio . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"exists\" ) ; } } ; }", "testMethod": "spi ( ) { com . asakusafw . testdriver . core . TestToolRepository repo = new com . asakusafw . testdriver . core . TestToolRepository ( getClass ( ) . getClassLoader ( ) ) ; java . io . File file = temp . newFile ( \"example.html\" ) ; file . delete ( ) ; com . asakusafw . testdriver . core . DifferenceSinkFactory factory = repo . getDifferenceSinkFactory ( file . toURI ( ) ) ; try ( com . asakusafw . testdriver . core . DifferenceSink sink = factory . createSink ( com . asakusafw . testdriver . html . HtmlDifferenceSinkProviderTest . SIMPLE , new com . asakusafw . testdriver . core . TestContext . Empty ( ) ) ) { com . asakusafw . testdriver . excel . Simple expected = new com . asakusafw . testdriver . excel . Simple ( ) ; expected . text = \"expected\" ; com . asakusafw . testdriver . excel . Simple actual = new com . asakusafw . testdriver . excel . Simple ( ) ; actual . text = \"actual\" ; sink . put ( new com . asakusafw . testdriver . core . Difference ( com . asakusafw . testdriver . html . HtmlDifferenceSinkProviderTest . SIMPLE . toReflection ( expected ) , com . asakusafw . testdriver . html . HtmlDifferenceSinkProviderTest . SIMPLE . toReflection ( actual ) , \"testing\" ) ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( file . exists ( ) , is ( true ) )", "total": "spi ( ) { com . asakusafw . testdriver . core . TestToolRepository repo = new com . asakusafw . testdriver . core . TestToolRepository ( getClass ( ) . getClassLoader ( ) ) ; java . io . File file = temp . newFile ( \"example.html\" ) ; file . delete ( ) ; com . asakusafw . testdriver . core . DifferenceSinkFactory factory = repo . getDifferenceSinkFactory ( file . toURI ( ) ) ; try ( com . asakusafw . testdriver . core . DifferenceSink sink = factory . createSink ( com . asakusafw . testdriver . html . HtmlDifferenceSinkProviderTest . SIMPLE , new com . asakusafw . testdriver . core . TestContext . Empty ( ) ) ) { com . asakusafw . testdriver . excel . Simple expected = new com . asakusafw . testdriver . excel . Simple ( ) ; expected . text = \"expected\" ; com . asakusafw . testdriver . excel . Simple actual = new com . asakusafw . testdriver . excel . Simple ( ) ; actual . text = \"actual\" ; sink . put ( new com . asakusafw . testdriver . core . Difference ( com . asakusafw . testdriver . html . HtmlDifferenceSinkProviderTest . SIMPLE . toReflection ( expected ) , com . asakusafw . testdriver . html . HtmlDifferenceSinkProviderTest . SIMPLE . toReflection ( actual ) , \"testing\" ) ) ; } \"<AssertPlaceHolder>\" ; } exists ( ) { return new org . hamcrest . BaseMatcher < java . io . File > ( ) { @ com . asakusafw . operation . tools . directio . Override public boolean matches ( java . lang . Object item ) { return ( ( java . io . File ) ( item ) ) . exists ( ) ; } @ com . asakusafw . operation . tools . directio . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"exists\" ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( file . exists ( ) , is ( true ) )"}
{"focal": "is ( java . lang . String ) { return org . tessell . generators . css . JavaKeywords . keywords . contains ( keyword ) ; }", "testMethod": "testPressKeyCodesFiresNoChange ( ) { box . type ( \"as\" ) ; final int [ ] changes = new int [ ] { 0 } ; box . addValueChangeHandler ( new com . google . gwt . event . logical . shared . ValueChangeHandler < java . lang . String > ( ) { public void onValueChange ( com . google . gwt . event . logical . shared . ValueChangeEvent < java . lang . String > event ) { ( changes [ 0 ] ) ++ ; } } ) ; box . press ( \"df\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( changes [ 0 ] , org . hamcrest . Matchers . is ( 0 ) )", "total": "testPressKeyCodesFiresNoChange ( ) { box . type ( \"as\" ) ; final int [ ] changes = new int [ ] { 0 } ; box . addValueChangeHandler ( new com . google . gwt . event . logical . shared . ValueChangeHandler < java . lang . String > ( ) { public void onValueChange ( com . google . gwt . event . logical . shared . ValueChangeEvent < java . lang . String > event ) { ( changes [ 0 ] ) ++ ; } } ) ; box . press ( \"df\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { return org . tessell . generators . css . JavaKeywords . keywords . contains ( keyword ) ; }", "answer": "org . junit . Assert . assertThat ( changes [ 0 ] , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "getName ( ) { return \"CUSTOM\" ; }", "testMethod": "checkProperSquash ( ) { final java . net . URI newRepo = java . net . URI . create ( \"git://master@squash-repo/myfile3.txt\" 0 ) ; final org . uberfire . java . nio . fs . jgit . JGitFileSystem fs = ( ( org . uberfire . java . nio . fs . jgit . JGitFileSystem ) ( provider . newFileSystem ( newRepo , org . uberfire . java . nio . fs . jgit . EMPTY_ENV ) ) ) ; final org . uberfire . java . nio . file . Path generalPath = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/\" ) ) ; final org . uberfire . java . nio . file . Path path = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/myfile1.txt\" ) ) ; final org . uberfire . java . nio . file . Path path2 = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/myfile2.txt\" ) ) ; final org . uberfire . java . nio . file . Path path3 = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/myfile3.txt\" ) ) ; final java . io . OutputStream aStream = provider . newOutputStream ( path ) ; aStream . write ( \"my<sp>cool<sp>content\" . getBytes ( ) ) ; aStream . close ( ) ; final org . eclipse . jgit . revwalk . RevCommit commit = ( ( org . uberfire . java . nio . fs . jgit . util . GitImpl ) ( fs . getGit ( ) ) ) . _log ( ) . add ( fs . getGit ( ) . getRef ( \"master\" ) . getObjectId ( ) ) . setMaxCount ( 1 ) . call ( ) . iterator ( ) . next ( ) ; final java . io . OutputStream bStream = provider . newOutputStream ( path2 ) ; bStream . write ( \"my<sp>cool<sp>content\" . getBytes ( ) ) ; bStream . close ( ) ; final java . io . OutputStream cStream = provider . newOutputStream ( path3 ) ; cStream . write ( \"my<sp>cool<sp>content\" . getBytes ( ) ) ; cStream . close ( ) ; final org . uberfire . java . nio . base . version . VersionRecord record = makeVersionRecord ( \"aparedes\" , \"aparedes@redhat.com\" , \"squashing!\" , new java . util . Date ( ) , commit . getName ( ) ) ; final org . uberfire . java . nio . base . options . SquashOption squashOption = new org . uberfire . java . nio . base . options . SquashOption ( record ) ; provider . setAttribute ( generalPath , SquashOption . SQUASH_ATTR , squashOption ) ; int commitsCount = 0 ; for ( org . eclipse . jgit . revwalk . RevCommit com : ( ( org . uberfire . java . nio . fs . jgit . util . GitImpl ) ( fs . getGit ( ) ) ) . _log ( ) . all ( ) . call ( ) ) { commitsCount ++ ; System . out . println ( ( ( ( com . getName ( ) ) + \"<sp>-<sp>\" ) + ( com . getFullMessage ( ) ) ) ) ; } \"<AssertPlaceHolder>\" . isEqualTo ( 2 ) ; }", "assertLine": "org . junit . Assert . assertThat ( commitsCount )", "total": "checkProperSquash ( ) { final java . net . URI newRepo = java . net . URI . create ( \"git://master@squash-repo/myfile3.txt\" 0 ) ; final org . uberfire . java . nio . fs . jgit . JGitFileSystem fs = ( ( org . uberfire . java . nio . fs . jgit . JGitFileSystem ) ( provider . newFileSystem ( newRepo , org . uberfire . java . nio . fs . jgit . EMPTY_ENV ) ) ) ; final org . uberfire . java . nio . file . Path generalPath = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/\" ) ) ; final org . uberfire . java . nio . file . Path path = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/myfile1.txt\" ) ) ; final org . uberfire . java . nio . file . Path path2 = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/myfile2.txt\" ) ) ; final org . uberfire . java . nio . file . Path path3 = provider . getPath ( java . net . URI . create ( \"git://master@squash-repo/myfile3.txt\" ) ) ; final java . io . OutputStream aStream = provider . newOutputStream ( path ) ; aStream . write ( \"my<sp>cool<sp>content\" . getBytes ( ) ) ; aStream . close ( ) ; final org . eclipse . jgit . revwalk . RevCommit commit = ( ( org . uberfire . java . nio . fs . jgit . util . GitImpl ) ( fs . getGit ( ) ) ) . _log ( ) . add ( fs . getGit ( ) . getRef ( \"master\" ) . getObjectId ( ) ) . setMaxCount ( 1 ) . call ( ) . iterator ( ) . next ( ) ; final java . io . OutputStream bStream = provider . newOutputStream ( path2 ) ; bStream . write ( \"my<sp>cool<sp>content\" . getBytes ( ) ) ; bStream . close ( ) ; final java . io . OutputStream cStream = provider . newOutputStream ( path3 ) ; cStream . write ( \"my<sp>cool<sp>content\" . getBytes ( ) ) ; cStream . close ( ) ; final org . uberfire . java . nio . base . version . VersionRecord record = makeVersionRecord ( \"aparedes\" , \"aparedes@redhat.com\" , \"squashing!\" , new java . util . Date ( ) , commit . getName ( ) ) ; final org . uberfire . java . nio . base . options . SquashOption squashOption = new org . uberfire . java . nio . base . options . SquashOption ( record ) ; provider . setAttribute ( generalPath , SquashOption . SQUASH_ATTR , squashOption ) ; int commitsCount = 0 ; for ( org . eclipse . jgit . revwalk . RevCommit com : ( ( org . uberfire . java . nio . fs . jgit . util . GitImpl ) ( fs . getGit ( ) ) ) . _log ( ) . all ( ) . call ( ) ) { commitsCount ++ ; System . out . println ( ( ( ( com . getName ( ) ) + \"<sp>-<sp>\" ) + ( com . getFullMessage ( ) ) ) ) ; } \"<AssertPlaceHolder>\" . isEqualTo ( 2 ) ; } getName ( ) { return \"CUSTOM\" ; }", "answer": "org . junit . Assert . assertThat ( commitsCount )"}
{"focal": "of ( int ) { return org . batfish . datamodel . IntegerSpace . builder ( ) . including ( com . google . common . collect . Range . singleton ( value ) ) . build ( ) ; }", "testMethod": "testReverseFlow ( ) { org . batfish . datamodel . flow . Trace forwardTrace = new org . batfish . datamodel . flow . Trace ( ACCEPTED , com . google . common . collect . ImmutableList . of ( ) ) ; org . batfish . datamodel . flow . TraceAndReverseFlow forwardTarf = new org . batfish . datamodel . flow . TraceAndReverseFlow ( forwardTrace , org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . REVERSE_FLOW ) ; org . batfish . datamodel . flow . Trace reverseTrace = new org . batfish . datamodel . flow . Trace ( DENIED_IN , com . google . common . collect . ImmutableList . of ( ) ) ; org . batfish . datamodel . flow . TraceAndReverseFlow reverseTarf = new org . batfish . datamodel . flow . TraceAndReverseFlow ( reverseTrace , null ) ; org . batfish . common . plugin . TracerouteEngine tracerouteEngine = org . batfish . question . traceroute . MockTracerouteEngine . forFlows ( com . google . common . collect . ImmutableMap . of ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , com . google . common . collect . ImmutableList . of ( forwardTarf ) , org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . REVERSE_FLOW , com . google . common . collect . ImmutableList . of ( reverseTarf ) ) ) ; java . util . List < org . batfish . datamodel . flow . BidirectionalTrace > bidirectionalTraces = org . batfish . question . traceroute . BidirectionalTracerouteAnswerer . computeBidirectionalTraces ( com . google . common . collect . ImmutableSet . of ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW ) , tracerouteEngine , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( bidirectionalTraces , org . hamcrest . Matchers . contains ( new org . batfish . datamodel . flow . BidirectionalTrace ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , forwardTrace , com . google . common . collect . ImmutableSet . of ( ) , org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . REVERSE_FLOW , reverseTrace ) ) )", "total": "testReverseFlow ( ) { org . batfish . datamodel . flow . Trace forwardTrace = new org . batfish . datamodel . flow . Trace ( ACCEPTED , com . google . common . collect . ImmutableList . of ( ) ) ; org . batfish . datamodel . flow . TraceAndReverseFlow forwardTarf = new org . batfish . datamodel . flow . TraceAndReverseFlow ( forwardTrace , org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . REVERSE_FLOW ) ; org . batfish . datamodel . flow . Trace reverseTrace = new org . batfish . datamodel . flow . Trace ( DENIED_IN , com . google . common . collect . ImmutableList . of ( ) ) ; org . batfish . datamodel . flow . TraceAndReverseFlow reverseTarf = new org . batfish . datamodel . flow . TraceAndReverseFlow ( reverseTrace , null ) ; org . batfish . common . plugin . TracerouteEngine tracerouteEngine = org . batfish . question . traceroute . MockTracerouteEngine . forFlows ( com . google . common . collect . ImmutableMap . of ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , com . google . common . collect . ImmutableList . of ( forwardTarf ) , org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . REVERSE_FLOW , com . google . common . collect . ImmutableList . of ( reverseTarf ) ) ) ; java . util . List < org . batfish . datamodel . flow . BidirectionalTrace > bidirectionalTraces = org . batfish . question . traceroute . BidirectionalTracerouteAnswerer . computeBidirectionalTraces ( com . google . common . collect . ImmutableSet . of ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW ) , tracerouteEngine , false ) ; \"<AssertPlaceHolder>\" ; } of ( int ) { return org . batfish . datamodel . IntegerSpace . builder ( ) . including ( com . google . common . collect . Range . singleton ( value ) ) . build ( ) ; }", "answer": "org . junit . Assert . assertThat ( bidirectionalTraces , org . hamcrest . Matchers . contains ( new org . batfish . datamodel . flow . BidirectionalTrace ( org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . FORWARD_FLOW , forwardTrace , com . google . common . collect . ImmutableSet . of ( ) , org . batfish . question . traceroute . BidirectionalTracerouteAnswererTest . REVERSE_FLOW , reverseTrace ) ) )"}
{"focal": "getBranchCode ( ) { return org . iban4j . IbanUtil . getBranchCode ( value ) ; }", "testMethod": "ibanShouldReturnValidBranchCode ( ) { org . iban4j . Iban iban = new org . iban4j . Iban . Builder ( ) . countryCode ( CountryCode . AD ) . bankCode ( \"0001\" ) . branchCode ( \"2030\" ) . accountNumber ( \"200359100100\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( iban . getBranchCode ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"2030\" ) ) )", "total": "ibanShouldReturnValidBranchCode ( ) { org . iban4j . Iban iban = new org . iban4j . Iban . Builder ( ) . countryCode ( CountryCode . AD ) . bankCode ( \"0001\" ) . branchCode ( \"2030\" ) . accountNumber ( \"200359100100\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getBranchCode ( ) { return org . iban4j . IbanUtil . getBranchCode ( value ) ; }", "answer": "org . junit . Assert . assertThat ( iban . getBranchCode ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"2030\" ) ) )"}
{"focal": "isNoOutput ( ) { return noOutput ; }", "testMethod": "applyDefaultAlwaysCorrectsNoOutputForBuildIn ( ) { com . github . timm . cucumber . generate . Plugin plugin = new com . github . timm . cucumber . generate . Plugin ( ) ; plugin . setName ( \"json\" ) ; plugin . setNoOutput ( true ) ; plugin . applyDefaults ( new java . io . File ( \"path/to/output\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( plugin . isNoOutput ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "applyDefaultAlwaysCorrectsNoOutputForBuildIn ( ) { com . github . timm . cucumber . generate . Plugin plugin = new com . github . timm . cucumber . generate . Plugin ( ) ; plugin . setName ( \"json\" ) ; plugin . setNoOutput ( true ) ; plugin . applyDefaults ( new java . io . File ( \"path/to/output\" ) ) ; \"<AssertPlaceHolder>\" ; } isNoOutput ( ) { return noOutput ; }", "answer": "org . junit . Assert . assertThat ( plugin . isNoOutput ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "assembleFrom ( org . mitre . oauth2 . model . OAuth2RefreshTokenEntity , org . mitre . openid . connect . model . UserInfo , java . util . Set ) { java . util . Map < java . lang . String , java . lang . Object > result = newLinkedHashMap ( ) ; org . springframework . security . oauth2 . provider . OAuth2Authentication authentication = refreshToken . getAuthenticationHolder ( ) . getAuthentication ( ) ; result . put ( org . mitre . oauth2 . service . impl . ACTIVE , true ) ; java . util . Set < java . lang . String > scopes = com . google . common . collect . Sets . intersection ( authScopes , authentication . getOAuth2Request ( ) . getScope ( ) ) ; result . put ( org . mitre . oauth2 . service . impl . SCOPE , com . google . common . base . Joiner . on ( org . mitre . oauth2 . service . impl . SCOPE_SEPARATOR ) . join ( scopes ) ) ; if ( ( refreshToken . getExpiration ( ) ) != null ) { try { result . put ( org . mitre . oauth2 . service . impl . EXPIRES_AT , dateFormat . valueToString ( refreshToken . getExpiration ( ) ) ) ; result . put ( org . mitre . oauth2 . service . impl . EXP , ( ( refreshToken . getExpiration ( ) . getTime ( ) ) / 1000L ) ) ; } catch ( java . text . ParseException e ) { org . mitre . oauth2 . service . impl . DefaultIntrospectionResultAssembler . logger . error ( \"Parse<sp>exception<sp>in<sp>token<sp>introspection\" , e ) ; } } if ( userInfo != null ) { result . put ( org . mitre . oauth2 . service . impl . SUB , userInfo . getSub ( ) ) ; } else { result . put ( org . mitre . oauth2 . service . impl . SUB , authentication . getName ( ) ) ; } if ( ( authentication . getUserAuthentication ( ) ) != null ) { result . put ( org . mitre . oauth2 . service . impl . USER_ID , authentication . getUserAuthentication ( ) . getName ( ) ) ; } result . put ( org . mitre . oauth2 . service . impl . CLIENT_ID , authentication . getOAuth2Request ( ) . getClientId ( ) ) ; return result ; }", "testMethod": "shouldAssembleExpectedResultForAccessToken_withPermissions ( ) { org . mitre . oauth2 . model . OAuth2AccessTokenEntity accessToken = accessToken ( new java . util . Date ( ( 123 * 1000L ) ) , scopes ( \"resource_set_id\" 2 , \"bar\" ) , permissions ( permission ( 1L , \"resource_set_id\" 2 , \"bar\" ) ) , \"Bearer\" , oauth2AuthenticationWithUser ( oauth2Request ( \"clientId\" ) , \"name\" ) ) ; org . mitre . openid . connect . model . UserInfo userInfo = userInfo ( \"sub\" ) ; java . util . Set < java . lang . String > authScopes = scopes ( \"resource_set_id\" 2 , \"bar\" , \"baz\" ) ; java . util . Map < java . lang . String , java . lang . Object > result = assembler . assembleFrom ( accessToken , userInfo , authScopes ) ; java . util . Map < java . lang . String , java . lang . Object > expected = new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"sub\" , \"sub\" ) . put ( \"exp\" , 123L ) . put ( \"expires_at\" , org . mitre . oauth2 . service . impl . TestDefaultIntrospectionResultAssembler . dateFormat . valueToString ( new java . util . Date ( ( 123 * 1000L ) ) ) ) . put ( \"resource_set_id\" 6 , new com . google . common . collect . ImmutableSet . Builder < > ( ) . add ( new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"resource_set_id\" , \"resource_set_id\" 3 ) . put ( \"resource_set_id\" 5 , new com . google . common . collect . ImmutableSet . Builder < > ( ) . add ( \"bar\" ) . add ( \"resource_set_id\" 2 ) . build ( ) ) . build ( ) ) . build ( ) ) . put ( \"resource_set_id\" 4 , Boolean . TRUE ) . put ( \"user_id\" , \"name\" ) . put ( \"resource_set_id\" 0 , \"clientId\" ) . put ( \"resource_set_id\" 1 , \"Bearer\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "shouldAssembleExpectedResultForAccessToken_withPermissions ( ) { org . mitre . oauth2 . model . OAuth2AccessTokenEntity accessToken = accessToken ( new java . util . Date ( ( 123 * 1000L ) ) , scopes ( \"resource_set_id\" 2 , \"bar\" ) , permissions ( permission ( 1L , \"resource_set_id\" 2 , \"bar\" ) ) , \"Bearer\" , oauth2AuthenticationWithUser ( oauth2Request ( \"clientId\" ) , \"name\" ) ) ; org . mitre . openid . connect . model . UserInfo userInfo = userInfo ( \"sub\" ) ; java . util . Set < java . lang . String > authScopes = scopes ( \"resource_set_id\" 2 , \"bar\" , \"baz\" ) ; java . util . Map < java . lang . String , java . lang . Object > result = assembler . assembleFrom ( accessToken , userInfo , authScopes ) ; java . util . Map < java . lang . String , java . lang . Object > expected = new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"sub\" , \"sub\" ) . put ( \"exp\" , 123L ) . put ( \"expires_at\" , org . mitre . oauth2 . service . impl . TestDefaultIntrospectionResultAssembler . dateFormat . valueToString ( new java . util . Date ( ( 123 * 1000L ) ) ) ) . put ( \"resource_set_id\" 6 , new com . google . common . collect . ImmutableSet . Builder < > ( ) . add ( new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"resource_set_id\" , \"resource_set_id\" 3 ) . put ( \"resource_set_id\" 5 , new com . google . common . collect . ImmutableSet . Builder < > ( ) . add ( \"bar\" ) . add ( \"resource_set_id\" 2 ) . build ( ) ) . build ( ) ) . build ( ) ) . put ( \"resource_set_id\" 4 , Boolean . TRUE ) . put ( \"user_id\" , \"name\" ) . put ( \"resource_set_id\" 0 , \"clientId\" ) . put ( \"resource_set_id\" 1 , \"Bearer\" ) . build ( ) ; \"<AssertPlaceHolder>\" ; } assembleFrom ( org . mitre . oauth2 . model . OAuth2RefreshTokenEntity , org . mitre . openid . connect . model . UserInfo , java . util . Set ) { java . util . Map < java . lang . String , java . lang . Object > result = newLinkedHashMap ( ) ; org . springframework . security . oauth2 . provider . OAuth2Authentication authentication = refreshToken . getAuthenticationHolder ( ) . getAuthentication ( ) ; result . put ( org . mitre . oauth2 . service . impl . ACTIVE , true ) ; java . util . Set < java . lang . String > scopes = com . google . common . collect . Sets . intersection ( authScopes , authentication . getOAuth2Request ( ) . getScope ( ) ) ; result . put ( org . mitre . oauth2 . service . impl . SCOPE , com . google . common . base . Joiner . on ( org . mitre . oauth2 . service . impl . SCOPE_SEPARATOR ) . join ( scopes ) ) ; if ( ( refreshToken . getExpiration ( ) ) != null ) { try { result . put ( org . mitre . oauth2 . service . impl . EXPIRES_AT , dateFormat . valueToString ( refreshToken . getExpiration ( ) ) ) ; result . put ( org . mitre . oauth2 . service . impl . EXP , ( ( refreshToken . getExpiration ( ) . getTime ( ) ) / 1000L ) ) ; } catch ( java . text . ParseException e ) { org . mitre . oauth2 . service . impl . DefaultIntrospectionResultAssembler . logger . error ( \"Parse<sp>exception<sp>in<sp>token<sp>introspection\" , e ) ; } } if ( userInfo != null ) { result . put ( org . mitre . oauth2 . service . impl . SUB , userInfo . getSub ( ) ) ; } else { result . put ( org . mitre . oauth2 . service . impl . SUB , authentication . getName ( ) ) ; } if ( ( authentication . getUserAuthentication ( ) ) != null ) { result . put ( org . mitre . oauth2 . service . impl . USER_ID , authentication . getUserAuthentication ( ) . getName ( ) ) ; } result . put ( org . mitre . oauth2 . service . impl . CLIENT_ID , authentication . getOAuth2Request ( ) . getClientId ( ) ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "needKeep ( ) { return tokenType . needKeep ( ) ; }", "testMethod": "testNeedKeep02 ( ) { java . lang . String tokenName = \"aaa\" ; org . terasoluna . gfw . web . token . transaction . TransactionTokenType tokenType = TransactionTokenType . BEGIN ; org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo info = new org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo ( tokenName , tokenType ) ; boolean output = info . needKeep ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( output , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testNeedKeep02 ( ) { java . lang . String tokenName = \"aaa\" ; org . terasoluna . gfw . web . token . transaction . TransactionTokenType tokenType = TransactionTokenType . BEGIN ; org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo info = new org . terasoluna . gfw . web . token . transaction . TransactionTokenInfo ( tokenName , tokenType ) ; boolean output = info . needKeep ( ) ; \"<AssertPlaceHolder>\" ; } needKeep ( ) { return tokenType . needKeep ( ) ; }", "answer": "org . junit . Assert . assertThat ( output , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isAllowed ( ) { return allowed ; }", "testMethod": "givenResourceDisallowed_whenIsAllowed_thenReturnsFalse ( ) { com . brandwatch . robots . cli . Result result = new com . brandwatch . robots . cli . Result ( com . brandwatch . robots . cli . ResultTest . VALID_RESOURCE , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . isAllowed ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "givenResourceDisallowed_whenIsAllowed_thenReturnsFalse ( ) { com . brandwatch . robots . cli . Result result = new com . brandwatch . robots . cli . Result ( com . brandwatch . robots . cli . ResultTest . VALID_RESOURCE , false ) ; \"<AssertPlaceHolder>\" ; } isAllowed ( ) { return allowed ; }", "answer": "org . junit . Assert . assertThat ( result . isAllowed ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "get ( com . hotels . bdp . circustrain . s3mapreducecp . ConfigurationVariable ) { return get ( var . getName ( ) , var . defaultValue ( ) ) ; }", "testMethod": "unpartitionedTableReplicateAvroSchemaOverride ( ) { helper . createManagedUnpartitionedTable ( toUri ( sourceWarehouseUri , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . SOURCE_MANAGED_UNPARTITIONED_TABLE ) ) ; com . hotels . bdp . circustrain . integration . CircusTrainHdfsHdfsIntegrationTest . LOG . info ( \">>>><sp>Table<sp>{}<sp>\" , sourceCatalog . client ( ) . getTable ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . SOURCE_MANAGED_UNPARTITIONED_TABLE ) ) ; java . nio . file . Path sourceAvroSchemaPath = java . nio . file . Paths . get ( ( ( sourceWarehouseUri . toString ( ) ) + \"/avro-schema-file.test\" ) ) ; java . nio . file . Files . createDirectories ( sourceAvroSchemaPath ) ; java . lang . String avroSchemaBaseUrl = sourceAvroSchemaPath . toString ( ) ; org . apache . hadoop . hive . metastore . api . Table sourceTable = sourceCatalog . client ( ) . getTable ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . SOURCE_MANAGED_UNPARTITIONED_TABLE ) ; sourceTable . putToParameters ( \"avro.schema.url\" , avroSchemaBaseUrl ) ; sourceCatalog . client ( ) . alter_table ( sourceTable . getDbName ( ) , sourceTable . getTableName ( ) , sourceTable ) ; exit . expectSystemExitWithStatus ( 0 ) ; java . io . File config = dataFolder . getFile ( \"unpartitioned-single-table-avro-schema-override.yml\" ) ; com . hotels . bdp . circustrain . common . test . base . CircusTrainRunner runner = com . hotels . bdp . circustrain . common . test . base . CircusTrainRunner . builder ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , sourceWarehouseUri , replicaWarehouseUri , housekeepingDbLocation ) . sourceMetaStore ( sourceCatalog . getThriftConnectionUri ( ) , sourceCatalog . connectionURL ( ) , sourceCatalog . driverClassName ( ) ) . replicaMetaStore ( replicaCatalog . getThriftConnectionUri ( ) ) . build ( ) ; exit . checkAssertionAfterwards ( new org . junit . contrib . java . lang . system . Assertion ( ) { @ com . hotels . bdp . circustrain . integration . Override public void checkAssertion ( ) throws com . hotels . bdp . circustrain . integration . Exception { org . apache . hadoop . hive . metastore . api . Table replicaHiveTable = replicaCatalog . client ( ) . getTable ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . CircusTrainHdfsHdfsIntegrationTest . TARGET_UNPARTITIONED_MANAGED_TABLE ) ; java . lang . String expectedReplicaSchemaUrl = ( replicaWarehouseUri . toURI ( ) . toString ( ) ) + \"ct_database-override/\" ; java . lang . String transformedAvroUrl = replicaHiveTable . getParameters ( ) . get ( \"avro.schema.url\" ) ; \"<AssertPlaceHolder>\" ; } } ) ; runner . run ( config . getAbsolutePath ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( transformedAvroUrl , org . hamcrest . CoreMatchers . startsWith ( expectedReplicaSchemaUrl ) )", "total": "unpartitionedTableReplicateAvroSchemaOverride ( ) { helper . createManagedUnpartitionedTable ( toUri ( sourceWarehouseUri , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . SOURCE_MANAGED_UNPARTITIONED_TABLE ) ) ; com . hotels . bdp . circustrain . integration . CircusTrainHdfsHdfsIntegrationTest . LOG . info ( \">>>><sp>Table<sp>{}<sp>\" , sourceCatalog . client ( ) . getTable ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . SOURCE_MANAGED_UNPARTITIONED_TABLE ) ) ; java . nio . file . Path sourceAvroSchemaPath = java . nio . file . Paths . get ( ( ( sourceWarehouseUri . toString ( ) ) + \"/avro-schema-file.test\" ) ) ; java . nio . file . Files . createDirectories ( sourceAvroSchemaPath ) ; java . lang . String avroSchemaBaseUrl = sourceAvroSchemaPath . toString ( ) ; org . apache . hadoop . hive . metastore . api . Table sourceTable = sourceCatalog . client ( ) . getTable ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . IntegrationTestHelper . SOURCE_MANAGED_UNPARTITIONED_TABLE ) ; sourceTable . putToParameters ( \"avro.schema.url\" , avroSchemaBaseUrl ) ; sourceCatalog . client ( ) . alter_table ( sourceTable . getDbName ( ) , sourceTable . getTableName ( ) , sourceTable ) ; exit . expectSystemExitWithStatus ( 0 ) ; java . io . File config = dataFolder . getFile ( \"unpartitioned-single-table-avro-schema-override.yml\" ) ; com . hotels . bdp . circustrain . common . test . base . CircusTrainRunner runner = com . hotels . bdp . circustrain . common . test . base . CircusTrainRunner . builder ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , sourceWarehouseUri , replicaWarehouseUri , housekeepingDbLocation ) . sourceMetaStore ( sourceCatalog . getThriftConnectionUri ( ) , sourceCatalog . connectionURL ( ) , sourceCatalog . driverClassName ( ) ) . replicaMetaStore ( replicaCatalog . getThriftConnectionUri ( ) ) . build ( ) ; exit . checkAssertionAfterwards ( new org . junit . contrib . java . lang . system . Assertion ( ) { @ com . hotels . bdp . circustrain . integration . Override public void checkAssertion ( ) throws com . hotels . bdp . circustrain . integration . Exception { org . apache . hadoop . hive . metastore . api . Table replicaHiveTable = replicaCatalog . client ( ) . getTable ( com . hotels . bdp . circustrain . integration . IntegrationTestHelper . DATABASE , com . hotels . bdp . circustrain . integration . CircusTrainHdfsHdfsIntegrationTest . TARGET_UNPARTITIONED_MANAGED_TABLE ) ; java . lang . String expectedReplicaSchemaUrl = ( replicaWarehouseUri . toURI ( ) . toString ( ) ) + \"ct_database-override/\" ; java . lang . String transformedAvroUrl = replicaHiveTable . getParameters ( ) . get ( \"avro.schema.url\" ) ; \"<AssertPlaceHolder>\" ; } } ) ; runner . run ( config . getAbsolutePath ( ) ) ; } get ( com . hotels . bdp . circustrain . s3mapreducecp . ConfigurationVariable ) { return get ( var . getName ( ) , var . defaultValue ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( transformedAvroUrl , org . hamcrest . CoreMatchers . startsWith ( expectedReplicaSchemaUrl ) )"}
{"focal": "getOrNull ( ) { return null ; }", "testMethod": "getOrNull_A$ ( ) { java . lang . String value = \"vvv\" ; com . m3 . scalaflavor4j . Some < java . lang . String > target = new com . m3 . scalaflavor4j . Some < java . lang . String > ( value ) ; java . lang . String actual = target . getOrNull ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"vvv\" ) ) )", "total": "getOrNull_A$ ( ) { java . lang . String value = \"vvv\" ; com . m3 . scalaflavor4j . Some < java . lang . String > target = new com . m3 . scalaflavor4j . Some < java . lang . String > ( value ) ; java . lang . String actual = target . getOrNull ( ) ; \"<AssertPlaceHolder>\" ; } getOrNull ( ) { return null ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"vvv\" ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testInterfaceIpAddress ( ) { defaultIsisInterface . setInterfaceIpAddress ( ip4Address ) ; resultIPv4Addr = defaultIsisInterface . interfaceIpAddress ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultIPv4Addr , org . hamcrest . CoreMatchers . is ( ip4Address ) )", "total": "testInterfaceIpAddress ( ) { defaultIsisInterface . setInterfaceIpAddress ( ip4Address ) ; resultIPv4Addr = defaultIsisInterface . interfaceIpAddress ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( resultIPv4Addr , org . hamcrest . CoreMatchers . is ( ip4Address ) )"}
{"focal": "validate ( ) { return true ; }", "testMethod": "validate_returnTrue ( ) { boolean isValid = request . validate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )", "total": "validate_returnTrue ( ) { boolean isValid = request . validate ( ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { return true ; }", "answer": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )"}
{"focal": "apply ( java . lang . String ) { System . out . println ( ( v1 + v1 ) ) ; }", "testMethod": "getOrElse_A$Function0_defined ( ) { int result = com . m3 . scalaflavor4j . Option . apply ( \"foo\" ) . map ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( java . lang . String str ) { return str . length ( ) ; } } ) . getOrElse ( new com . m3 . scalaflavor4j . F0 < java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( ) { return 0 ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 3 ) ) )", "total": "getOrElse_A$Function0_defined ( ) { int result = com . m3 . scalaflavor4j . Option . apply ( \"foo\" ) . map ( new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( java . lang . String str ) { return str . length ( ) ; } } ) . getOrElse ( new com . m3 . scalaflavor4j . F0 < java . lang . Integer > ( ) { public com . m3 . scalaflavor4j . Integer apply ( ) { return 0 ; } } ) ; \"<AssertPlaceHolder>\" ; } apply ( java . lang . String ) { System . out . println ( ( v1 + v1 ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 3 ) ) )"}
{"focal": "databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "testMethod": "no_exception_should_be_thrown_if_set_contains_none_unique_elements ( ) { redis . clients . jedis . Jedis jedis = new redis . clients . jedis . Jedis ( \"localhost\" , 6379 ) ; com . lordofthejars . nosqlunit . redis . RedisOperation redisOperation = new com . lordofthejars . nosqlunit . redis . RedisOperation ( jedis ) ; redisOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . redis . integration . WhenComparingRedisDataset . INSERT_SET_DATA . getBytes ( ) ) ) ; boolean isExpectedData = redisOperation . databaseIs ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . redis . integration . WhenComparingRedisDataset . INSERT_SET_DATA_WITH_REPEAT_ELEMENTS . getBytes ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isExpectedData , org . hamcrest . CoreMatchers . is ( true ) )", "total": "no_exception_should_be_thrown_if_set_contains_none_unique_elements ( ) { redis . clients . jedis . Jedis jedis = new redis . clients . jedis . Jedis ( \"localhost\" , 6379 ) ; com . lordofthejars . nosqlunit . redis . RedisOperation redisOperation = new com . lordofthejars . nosqlunit . redis . RedisOperation ( jedis ) ; redisOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . redis . integration . WhenComparingRedisDataset . INSERT_SET_DATA . getBytes ( ) ) ) ; boolean isExpectedData = redisOperation . databaseIs ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . redis . integration . WhenComparingRedisDataset . INSERT_SET_DATA_WITH_REPEAT_ELEMENTS . getBytes ( ) ) ) ; \"<AssertPlaceHolder>\" ; } databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "answer": "org . junit . Assert . assertThat ( isExpectedData , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getMaximumBondOrder ( org . openscience . cdk . interfaces . IAtom ) { org . openscience . cdk . interfaces . IBond . Order max = null ; for ( org . openscience . cdk . interfaces . IBond bond : bonds ( ) ) { if ( ! ( bond . contains ( atom ) ) ) continue ; if ( ( max == null ) || ( ( bond . getOrder ( ) . numeric ( ) ) > ( max . numeric ( ) ) ) ) { max = bond . getOrder ( ) ; } } if ( max == null ) { if ( ! ( contains ( atom ) ) ) throw new org . openscience . cdk . exception . NoSuchAtomException ( \"Atom<sp>does<sp>not<sp>belong<sp>to<sp>this<sp>container!\" ) ; if ( ( ( atom . getImplicitHydrogenCount ( ) ) != null ) && ( ( atom . getImplicitHydrogenCount ( ) ) > 0 ) ) max = org . openscience . cdk . interfaces . IBond . Order . SINGLE ; else max = org . openscience . cdk . interfaces . IBond . Order . UNSET ; } return max ; }", "testMethod": "testGetMaxBondOrderNoSuchAtom ( ) { org . openscience . cdk . interfaces . IAtomContainer container = ( ( org . openscience . cdk . interfaces . IAtomContainer ) ( newChemObject ( ) ) ) ; org . openscience . cdk . interfaces . IChemObjectBuilder builder = container . getBuilder ( ) ; org . openscience . cdk . interfaces . IAtom a1 = builder . newAtom ( ) ; org . openscience . cdk . interfaces . IAtom a2 = builder . newAtom ( ) ; container . addAtom ( a1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( container . getMaximumBondOrder ( a2 ) , org . hamcrest . CoreMatchers . is ( IBond . Order . UNSET ) )", "total": "testGetMaxBondOrderNoSuchAtom ( ) { org . openscience . cdk . interfaces . IAtomContainer container = ( ( org . openscience . cdk . interfaces . IAtomContainer ) ( newChemObject ( ) ) ) ; org . openscience . cdk . interfaces . IChemObjectBuilder builder = container . getBuilder ( ) ; org . openscience . cdk . interfaces . IAtom a1 = builder . newAtom ( ) ; org . openscience . cdk . interfaces . IAtom a2 = builder . newAtom ( ) ; container . addAtom ( a1 ) ; \"<AssertPlaceHolder>\" ; } getMaximumBondOrder ( org . openscience . cdk . interfaces . IAtom ) { org . openscience . cdk . interfaces . IBond . Order max = null ; for ( org . openscience . cdk . interfaces . IBond bond : bonds ( ) ) { if ( ! ( bond . contains ( atom ) ) ) continue ; if ( ( max == null ) || ( ( bond . getOrder ( ) . numeric ( ) ) > ( max . numeric ( ) ) ) ) { max = bond . getOrder ( ) ; } } if ( max == null ) { if ( ! ( contains ( atom ) ) ) throw new org . openscience . cdk . exception . NoSuchAtomException ( \"Atom<sp>does<sp>not<sp>belong<sp>to<sp>this<sp>container!\" ) ; if ( ( ( atom . getImplicitHydrogenCount ( ) ) != null ) && ( ( atom . getImplicitHydrogenCount ( ) ) > 0 ) ) max = org . openscience . cdk . interfaces . IBond . Order . SINGLE ; else max = org . openscience . cdk . interfaces . IBond . Order . UNSET ; } return max ; }", "answer": "org . junit . Assert . assertThat ( container . getMaximumBondOrder ( a2 ) , org . hamcrest . CoreMatchers . is ( IBond . Order . UNSET ) )"}
{"focal": "get ( ) { if ( ( value ) == null ) { synchronized ( this ) { if ( ( value ) == null ) { value = supplier . get ( ) ; } } } return value ; }", "testMethod": "validateTerminationHookInvocationOnTaskSuccess ( ) { com . spotify . flo . context . TestTerminationHookFactory . injectHook ( validTerminationHook ) ; java . util . concurrent . atomic . AtomicInteger status = new java . util . concurrent . atomic . AtomicInteger ( ) ; com . spotify . flo . context . FloRunner . runTask ( FOO_TASK ) . waitAndExit ( status :: set ) ; verify ( validTerminationHook , times ( 1 ) ) . accept ( eq ( 0 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( status . get ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "validateTerminationHookInvocationOnTaskSuccess ( ) { com . spotify . flo . context . TestTerminationHookFactory . injectHook ( validTerminationHook ) ; java . util . concurrent . atomic . AtomicInteger status = new java . util . concurrent . atomic . AtomicInteger ( ) ; com . spotify . flo . context . FloRunner . runTask ( FOO_TASK ) . waitAndExit ( status :: set ) ; verify ( validTerminationHook , times ( 1 ) ) . accept ( eq ( 0 ) ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( ( value ) == null ) { synchronized ( this ) { if ( ( value ) == null ) { value = supplier . get ( ) ; } } } return value ; }", "answer": "org . junit . Assert . assertThat ( status . get ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "notAllowedStrategy ( com . github . kostyasha . yad . DockerSlaveTemplate ) { if ( isNull ( template ) ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Skipping<sp>DockerProvisioningStrategy<sp>because:<sp>template<sp>is<sp>null\" ) ; return true ; } final hudson . slaves . RetentionStrategy retentionStrategy = template . getRetentionStrategy ( ) ; if ( isNull ( retentionStrategy ) ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Skipping<sp>DockerProvisioningStrategy<sp>because:<sp>strategy<sp>is<sp>null<sp>for<sp>{}\" , template ) ; } if ( retentionStrategy instanceof com . github . kostyasha . yad . strategy . DockerOnceRetentionStrategy ) { if ( ( template . getNumExecutors ( ) ) == 1 ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Applying<sp>faster<sp>provisioning<sp>for<sp>single<sp>executor<sp>template<sp>{}\" , template ) ; return false ; } else { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Skipping<sp>DockerProvisioningStrategy<sp>because:<sp>numExecutors<sp>is<sp>{}<sp>for<sp>{}\" , template . getNumExecutors ( ) , template ) ; return true ; } } if ( retentionStrategy instanceof hudson . slaves . RetentionStrategy . Demand ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Applying<sp>faster<sp>provisioning<sp>for<sp>Demand<sp>strategy<sp>for<sp>template<sp>{}\" , template ) ; return false ; } com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . trace ( \"Skipping<sp>YAD<sp>provisioning<sp>for<sp>unknown<sp>mix<sp>of<sp>configuration<sp>for<sp>{}\" , template ) ; return true ; }", "testMethod": "dockerOnceRetention2 ( ) { when ( mockTemplate . getRetentionStrategy ( ) ) . thenReturn ( mockDockerOnce ) ; when ( mockTemplate . getNumExecutors ( ) ) . thenReturn ( 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . github . kostyasha . yad . DockerProvisioningStrategy . notAllowedStrategy ( mockTemplate ) , org . hamcrest . Matchers . is ( true ) )", "total": "dockerOnceRetention2 ( ) { when ( mockTemplate . getRetentionStrategy ( ) ) . thenReturn ( mockDockerOnce ) ; when ( mockTemplate . getNumExecutors ( ) ) . thenReturn ( 2 ) ; \"<AssertPlaceHolder>\" ; } notAllowedStrategy ( com . github . kostyasha . yad . DockerSlaveTemplate ) { if ( isNull ( template ) ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Skipping<sp>DockerProvisioningStrategy<sp>because:<sp>template<sp>is<sp>null\" ) ; return true ; } final hudson . slaves . RetentionStrategy retentionStrategy = template . getRetentionStrategy ( ) ; if ( isNull ( retentionStrategy ) ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Skipping<sp>DockerProvisioningStrategy<sp>because:<sp>strategy<sp>is<sp>null<sp>for<sp>{}\" , template ) ; } if ( retentionStrategy instanceof com . github . kostyasha . yad . strategy . DockerOnceRetentionStrategy ) { if ( ( template . getNumExecutors ( ) ) == 1 ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Applying<sp>faster<sp>provisioning<sp>for<sp>single<sp>executor<sp>template<sp>{}\" , template ) ; return false ; } else { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Skipping<sp>DockerProvisioningStrategy<sp>because:<sp>numExecutors<sp>is<sp>{}<sp>for<sp>{}\" , template . getNumExecutors ( ) , template ) ; return true ; } } if ( retentionStrategy instanceof hudson . slaves . RetentionStrategy . Demand ) { com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . debug ( \"Applying<sp>faster<sp>provisioning<sp>for<sp>Demand<sp>strategy<sp>for<sp>template<sp>{}\" , template ) ; return false ; } com . github . kostyasha . yad . DockerProvisioningStrategy . LOG . trace ( \"Skipping<sp>YAD<sp>provisioning<sp>for<sp>unknown<sp>mix<sp>of<sp>configuration<sp>for<sp>{}\" , template ) ; return true ; }", "answer": "org . junit . Assert . assertThat ( com . github . kostyasha . yad . DockerProvisioningStrategy . notAllowedStrategy ( mockTemplate ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "builder ( ) { return new software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestSupplierClassBuilder ( ) ; }", "testMethod": "testGetShard ( ) { final java . lang . String shardId = java . lang . String . format ( software . amazon . kinesis . leases . KinesisShardDetectorTest . SHARD_ID , 1 ) ; shardDetector . cachedShardMap ( createShardList ( ) ) ; final software . amazon . awssdk . services . kinesis . model . Shard shard = shardDetector . shard ( shardId ) ; \"<AssertPlaceHolder>\" ; verify ( client , never ( ) ) . listShards ( any ( software . amazon . awssdk . services . kinesis . model . ListShardsRequest . class ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( shard , org . hamcrest . CoreMatchers . equalTo ( software . amazon . awssdk . services . kinesis . model . Shard . builder ( ) . shardId ( shardId ) . build ( ) ) )", "total": "testGetShard ( ) { final java . lang . String shardId = java . lang . String . format ( software . amazon . kinesis . leases . KinesisShardDetectorTest . SHARD_ID , 1 ) ; shardDetector . cachedShardMap ( createShardList ( ) ) ; final software . amazon . awssdk . services . kinesis . model . Shard shard = shardDetector . shard ( shardId ) ; \"<AssertPlaceHolder>\" ; verify ( client , never ( ) ) . listShards ( any ( software . amazon . awssdk . services . kinesis . model . ListShardsRequest . class ) ) ; } builder ( ) { return new software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestSupplierClassBuilder ( ) ; }", "answer": "org . junit . Assert . assertThat ( shard , org . hamcrest . CoreMatchers . equalTo ( software . amazon . awssdk . services . kinesis . model . Shard . builder ( ) . shardId ( shardId ) . build ( ) ) )"}
{"focal": "size ( ) { return java . lang . reflect . Array . getLength ( arrayObject ) ; }", "testMethod": "test_hasInValidStringBuilderCode ( ) { org . terasoluna . gfw . common . codelist . Employee e = new org . terasoluna . gfw . common . codelist . Employee ( ) ; e . gender = new java . lang . StringBuilder ( \"G\" ) ; e . lang = new java . lang . StringBuilder ( \"JP\" ) ; java . util . Set < javax . validation . ConstraintViolation < org . terasoluna . gfw . common . codelist . Employee > > result = validator . validate ( e ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "test_hasInValidStringBuilderCode ( ) { org . terasoluna . gfw . common . codelist . Employee e = new org . terasoluna . gfw . common . codelist . Employee ( ) ; e . gender = new java . lang . StringBuilder ( \"G\" ) ; e . lang = new java . lang . StringBuilder ( \"JP\" ) ; java . util . Set < javax . validation . ConstraintViolation < org . terasoluna . gfw . common . codelist . Employee > > result = validator . validate ( e ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return java . lang . reflect . Array . getLength ( arrayObject ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "storeTo_orthogonal ( ) { java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( ResourceProfile . KEY_PREFIX ) + \"testing\" ) , com . asakusafw . windgate . core . resource . MockResourceProvider . class . getName ( ) ) ; java . util . Collection < ? extends com . asakusafw . windgate . core . resource . ResourceProfile > profiles = com . asakusafw . windgate . core . resource . ResourceProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; java . util . Properties restored = new java . util . Properties ( ) ; restored . setProperty ( ( ( ( ( ResourceProfile . KEY_PREFIX ) + \"orthogonal\" ) + ( com . asakusafw . windgate . core . BaseProfile . QUALIFIER ) ) + \"conf\" ) , \"conf\" ) ; for ( com . asakusafw . windgate . core . resource . ResourceProfile profile : profiles ) { profile . storeTo ( restored ) ; } restored . remove ( ( ( ( ( ResourceProfile . KEY_PREFIX ) + \"orthogonal\" ) + ( com . asakusafw . windgate . core . BaseProfile . QUALIFIER ) ) + \"conf\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored , is ( p ) )", "total": "storeTo_orthogonal ( ) { java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( ResourceProfile . KEY_PREFIX ) + \"testing\" ) , com . asakusafw . windgate . core . resource . MockResourceProvider . class . getName ( ) ) ; java . util . Collection < ? extends com . asakusafw . windgate . core . resource . ResourceProfile > profiles = com . asakusafw . windgate . core . resource . ResourceProfile . loadFrom ( p , com . asakusafw . windgate . core . ProfileContext . system ( getClass ( ) . getClassLoader ( ) ) ) ; java . util . Properties restored = new java . util . Properties ( ) ; restored . setProperty ( ( ( ( ( ResourceProfile . KEY_PREFIX ) + \"orthogonal\" ) + ( com . asakusafw . windgate . core . BaseProfile . QUALIFIER ) ) + \"conf\" ) , \"conf\" ) ; for ( com . asakusafw . windgate . core . resource . ResourceProfile profile : profiles ) { profile . storeTo ( restored ) ; } restored . remove ( ( ( ( ( ResourceProfile . KEY_PREFIX ) + \"orthogonal\" ) + ( com . asakusafw . windgate . core . BaseProfile . QUALIFIER ) ) + \"conf\" ) ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( restored , is ( p ) )"}
{"focal": "getTargetNamespaces ( ) { return oracle . kubernetes . operator . Main . getTargetNamespaces ( oracle . kubernetes . operator . Main . tuningAndConfig . get ( \"targetNamespaces\" ) , oracle . kubernetes . operator . Main . operatorNamespace ) ; }", "testMethod": "whenCreatedFromMapWithSingleNamespace_hasSpecifiedValue ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( \"domainNamespaces\" , com . google . common . collect . ImmutableList . of ( \"namespace1\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( values . getTargetNamespaces ( ) , org . hamcrest . Matchers . equalTo ( \"namespace1\" ) )", "total": "whenCreatedFromMapWithSingleNamespace_hasSpecifiedValue ( ) { oracle . kubernetes . operator . helm . HelmOperatorValues values = new oracle . kubernetes . operator . helm . HelmOperatorValues ( com . google . common . collect . ImmutableMap . of ( \"domainNamespaces\" , com . google . common . collect . ImmutableList . of ( \"namespace1\" ) ) ) ; \"<AssertPlaceHolder>\" ; } getTargetNamespaces ( ) { return oracle . kubernetes . operator . Main . getTargetNamespaces ( oracle . kubernetes . operator . Main . tuningAndConfig . get ( \"targetNamespaces\" ) , oracle . kubernetes . operator . Main . operatorNamespace ) ; }", "answer": "org . junit . Assert . assertThat ( values . getTargetNamespaces ( ) , org . hamcrest . Matchers . equalTo ( \"namespace1\" ) )"}
{"focal": "isComposed ( ) { return false ; }", "testMethod": "composed ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( entity . isComposed ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "composed ( ) { \"<AssertPlaceHolder>\" ; } isComposed ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( entity . isComposed ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "containsInAnyOrder ( java . util . Collection ) { @ org . apache . beam . sdk . testing . SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) final java . util . Collection < org . hamcrest . Matcher < ? super T > > matchers = ( ( java . util . Collection ) ( serializableMatchers ) ) ; return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . containsInAnyOrder ( matchers ) ) ; }", "testMethod": "testImmutablityOfOutputOfReadIfRecordReaderObjectsAreMutable ( ) { java . util . List < org . apache . beam . sdk . io . BoundedSource < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > > boundedSourceList = getBoundedSourceList ( org . apache . beam . sdk . io . hadoop . format . ReuseObjectsEmployeeInputFormat . class , org . apache . hadoop . io . Text . class , org . apache . beam . sdk . io . hadoop . format . Employee . class , org . apache . beam . sdk . io . hadoop . WritableCoder . of ( org . apache . hadoop . io . Text . class ) , org . apache . beam . sdk . coders . AvroCoder . of ( org . apache . beam . sdk . io . hadoop . format . Employee . class ) ) ; java . util . List < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > bundleRecords = new java . util . ArrayList ( ) ; for ( org . apache . beam . sdk . io . BoundedSource < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > source : boundedSourceList ) { java . util . List < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > elems = org . apache . beam . sdk . testing . SourceTestUtils . readFromSource ( source , p . getOptions ( ) ) ; bundleRecords . addAll ( elems ) ; } java . util . List < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > referenceRecords = org . apache . beam . sdk . io . hadoop . format . TestEmployeeDataSet . getEmployeeData ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( bundleRecords , org . hamcrest . Matchers . containsInAnyOrder ( referenceRecords . toArray ( ) ) )", "total": "testImmutablityOfOutputOfReadIfRecordReaderObjectsAreMutable ( ) { java . util . List < org . apache . beam . sdk . io . BoundedSource < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > > boundedSourceList = getBoundedSourceList ( org . apache . beam . sdk . io . hadoop . format . ReuseObjectsEmployeeInputFormat . class , org . apache . hadoop . io . Text . class , org . apache . beam . sdk . io . hadoop . format . Employee . class , org . apache . beam . sdk . io . hadoop . WritableCoder . of ( org . apache . hadoop . io . Text . class ) , org . apache . beam . sdk . coders . AvroCoder . of ( org . apache . beam . sdk . io . hadoop . format . Employee . class ) ) ; java . util . List < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > bundleRecords = new java . util . ArrayList ( ) ; for ( org . apache . beam . sdk . io . BoundedSource < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > source : boundedSourceList ) { java . util . List < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > elems = org . apache . beam . sdk . testing . SourceTestUtils . readFromSource ( source , p . getOptions ( ) ) ; bundleRecords . addAll ( elems ) ; } java . util . List < org . apache . beam . sdk . values . KV < org . apache . hadoop . io . Text , org . apache . beam . sdk . io . hadoop . format . Employee > > referenceRecords = org . apache . beam . sdk . io . hadoop . format . TestEmployeeDataSet . getEmployeeData ( ) ; \"<AssertPlaceHolder>\" ; } containsInAnyOrder ( java . util . Collection ) { @ org . apache . beam . sdk . testing . SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) final java . util . Collection < org . hamcrest . Matcher < ? super T > > matchers = ( ( java . util . Collection ) ( serializableMatchers ) ) ; return org . apache . beam . sdk . testing . SerializableMatchers . fromSupplier ( ( ) -> org . hamcrest . Matchers . containsInAnyOrder ( matchers ) ) ; }", "answer": "org . junit . Assert . assertThat ( bundleRecords , org . hamcrest . Matchers . containsInAnyOrder ( referenceRecords . toArray ( ) ) )"}
{"focal": "isEmpty ( ) { return ( org . apache . commons . lang . StringUtils . isBlank ( loanAmount ) ) && ( org . apache . commons . lang . StringUtils . isBlank ( businessActivity ) ) ; }", "testMethod": "shouldNotValidateInstallmentForDueDateAfterDisburseDate ( ) { org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment = installmentBuilder . withInstallment ( 3 ) . withDueDateValue ( \"30-Nov-2010\" ) . withPrincipal ( new org . mifos . framework . util . helpers . Money ( rupee , \"499.9\" ) ) . withInterest ( new org . mifos . framework . util . helpers . Money ( rupee , \"22.1\" ) ) . withFees ( new org . mifos . framework . util . helpers . Money ( rupee , \"0.0\" ) ) . withTotal ( \"522.0\" ) . build ( ) ; java . util . Date dateValue = getDate ( installment , \"30-Sep-2010\" ) ; java . util . List < org . mifos . platform . validations . ErrorEntry > errorEntries = installmentRulesValidator . validateForDisbursementDate ( asList ( installment ) , dateValue ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( errorEntries . isEmpty ( ) , org . hamcrest . core . Is . is ( true ) )", "total": "shouldNotValidateInstallmentForDueDateAfterDisburseDate ( ) { org . mifos . accounts . loan . util . helpers . RepaymentScheduleInstallment installment = installmentBuilder . withInstallment ( 3 ) . withDueDateValue ( \"30-Nov-2010\" ) . withPrincipal ( new org . mifos . framework . util . helpers . Money ( rupee , \"499.9\" ) ) . withInterest ( new org . mifos . framework . util . helpers . Money ( rupee , \"22.1\" ) ) . withFees ( new org . mifos . framework . util . helpers . Money ( rupee , \"0.0\" ) ) . withTotal ( \"522.0\" ) . build ( ) ; java . util . Date dateValue = getDate ( installment , \"30-Sep-2010\" ) ; java . util . List < org . mifos . platform . validations . ErrorEntry > errorEntries = installmentRulesValidator . validateForDisbursementDate ( asList ( installment ) , dateValue ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( org . apache . commons . lang . StringUtils . isBlank ( loanAmount ) ) && ( org . apache . commons . lang . StringUtils . isBlank ( businessActivity ) ) ; }", "answer": "org . junit . Assert . assertThat ( errorEntries . isEmpty ( ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "is ( java . lang . reflect . Type ) { return org . apache . calcite . linq4j . tree . Primitive . PRIMITIVE_MAP . containsKey ( type ) ; }", "testMethod": "testRun ( ) { final org . apache . calcite . tools . RelBuilder builder = org . apache . calcite . tools . RelBuilder . create ( org . apache . calcite . test . RelBuilderTest . config ( ) . build ( ) ) ; org . apache . calcite . rel . RelNode root = builder . scan ( \"EMP\" ) . filter ( builder . equals ( builder . field ( \"DEPTNO\" ) , builder . literal ( 20 ) ) ) . build ( ) ; try ( java . sql . PreparedStatement preparedStatement = org . apache . calcite . tools . RelRunners . run ( root ) ) { java . lang . String s = org . apache . calcite . test . CalciteAssert . toString ( preparedStatement . executeQuery ( ) ) ; final java . lang . String result = \"\" + ( ( ( ( \"EMPNO=7369;<sp>ENAME=SMITH;<sp>JOB=CLERK;<sp>MGR=7902;<sp>HIREDATE=1980-12-17;<sp>SAL=800.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" + \"EMPNO=7566;<sp>ENAME=JONES;<sp>JOB=MANAGER;<sp>MGR=7839;<sp>HIREDATE=1981-02-04;<sp>SAL=2975.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) + \"EMPNO=7788;<sp>ENAME=SCOTT;<sp>JOB=ANALYST;<sp>MGR=7566;<sp>HIREDATE=1987-04-19;<sp>SAL=3000.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) + \"EMPNO=7876;<sp>ENAME=ADAMS;<sp>JOB=CLERK;<sp>MGR=7788;<sp>HIREDATE=1987-05-23;<sp>SAL=1100.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) + \"EMPNO=7902;<sp>ENAME=FORD;<sp>JOB=ANALYST;<sp>MGR=7566;<sp>HIREDATE=1981-12-03;<sp>SAL=3000.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( s , org . hamcrest . CoreMatchers . is ( result ) )", "total": "testRun ( ) { final org . apache . calcite . tools . RelBuilder builder = org . apache . calcite . tools . RelBuilder . create ( org . apache . calcite . test . RelBuilderTest . config ( ) . build ( ) ) ; org . apache . calcite . rel . RelNode root = builder . scan ( \"EMP\" ) . filter ( builder . equals ( builder . field ( \"DEPTNO\" ) , builder . literal ( 20 ) ) ) . build ( ) ; try ( java . sql . PreparedStatement preparedStatement = org . apache . calcite . tools . RelRunners . run ( root ) ) { java . lang . String s = org . apache . calcite . test . CalciteAssert . toString ( preparedStatement . executeQuery ( ) ) ; final java . lang . String result = \"\" + ( ( ( ( \"EMPNO=7369;<sp>ENAME=SMITH;<sp>JOB=CLERK;<sp>MGR=7902;<sp>HIREDATE=1980-12-17;<sp>SAL=800.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" + \"EMPNO=7566;<sp>ENAME=JONES;<sp>JOB=MANAGER;<sp>MGR=7839;<sp>HIREDATE=1981-02-04;<sp>SAL=2975.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) + \"EMPNO=7788;<sp>ENAME=SCOTT;<sp>JOB=ANALYST;<sp>MGR=7566;<sp>HIREDATE=1987-04-19;<sp>SAL=3000.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) + \"EMPNO=7876;<sp>ENAME=ADAMS;<sp>JOB=CLERK;<sp>MGR=7788;<sp>HIREDATE=1987-05-23;<sp>SAL=1100.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) + \"EMPNO=7902;<sp>ENAME=FORD;<sp>JOB=ANALYST;<sp>MGR=7566;<sp>HIREDATE=1981-12-03;<sp>SAL=3000.00;<sp>COMM=null;<sp>DEPTNO=20\\n\" ) ; \"<AssertPlaceHolder>\" ; } } is ( java . lang . reflect . Type ) { return org . apache . calcite . linq4j . tree . Primitive . PRIMITIVE_MAP . containsKey ( type ) ; }", "answer": "org . junit . Assert . assertThat ( s , org . hamcrest . CoreMatchers . is ( result ) )"}
{"focal": "getModelClass ( ) { return type ; }", "testMethod": "simple ( ) { com . asakusafw . testdriver . model . DefaultDataModelDefinition < com . asakusafw . testdriver . testing . model . Simple > def = new com . asakusafw . testdriver . model . DefaultDataModelDefinition ( com . asakusafw . testdriver . testing . model . Simple . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( def . getModelClass ( ) , equalTo ( com . asakusafw . testdriver . testing . model . Simple . class ) )", "total": "simple ( ) { com . asakusafw . testdriver . model . DefaultDataModelDefinition < com . asakusafw . testdriver . testing . model . Simple > def = new com . asakusafw . testdriver . model . DefaultDataModelDefinition ( com . asakusafw . testdriver . testing . model . Simple . class ) ; \"<AssertPlaceHolder>\" ; } getModelClass ( ) { return type ; }", "answer": "org . junit . Assert . assertThat ( def . getModelClass ( ) , equalTo ( com . asakusafw . testdriver . testing . model . Simple . class ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "read ( ) { com . asakusafw . runtime . io . json . value . BooleanOptionPropertyAdapter adapter = builder . build ( ) ; com . asakusafw . runtime . value . BooleanOption option = new com . asakusafw . runtime . value . BooleanOption ( ) ; adapter . read ( new com . asakusafw . runtime . io . json . value . MockValue ( true ) , option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( option , is ( new com . asakusafw . runtime . value . BooleanOption ( true ) ) )", "total": "read ( ) { com . asakusafw . runtime . io . json . value . BooleanOptionPropertyAdapter adapter = builder . build ( ) ; com . asakusafw . runtime . value . BooleanOption option = new com . asakusafw . runtime . value . BooleanOption ( ) ; adapter . read ( new com . asakusafw . runtime . io . json . value . MockValue ( true ) , option ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( option , is ( new com . asakusafw . runtime . value . BooleanOption ( true ) ) )"}
{"focal": "getErrorMap ( ) { return errorMap ; }", "testMethod": "verifyParsingWithErrors ( ) { final org . opennms . netmgt . flows . classification . csv . CsvService csvService = new org . opennms . netmgt . flows . classification . internal . csv . CsvServiceImpl ( createNiceMock ( org . opennms . netmgt . flows . classification . internal . validation . RuleValidator . class ) ) ; final org . opennms . netmgt . flows . classification . csv . CsvImportResult csvImportResult = csvService . parseCSV ( new java . io . ByteArrayInputStream ( \"\\n\\n\" . getBytes ( ) ) , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( csvImportResult . getErrorMap ( ) . size ( ) , org . hamcrest . Matchers . is ( 2 ) )", "total": "verifyParsingWithErrors ( ) { final org . opennms . netmgt . flows . classification . csv . CsvService csvService = new org . opennms . netmgt . flows . classification . internal . csv . CsvServiceImpl ( createNiceMock ( org . opennms . netmgt . flows . classification . internal . validation . RuleValidator . class ) ) ; final org . opennms . netmgt . flows . classification . csv . CsvImportResult csvImportResult = csvService . parseCSV ( new java . io . ByteArrayInputStream ( \"\\n\\n\" . getBytes ( ) ) , false ) ; \"<AssertPlaceHolder>\" ; } getErrorMap ( ) { return errorMap ; }", "answer": "org . junit . Assert . assertThat ( csvImportResult . getErrorMap ( ) . size ( ) , org . hamcrest . Matchers . is ( 2 ) )"}
{"focal": "getStatus ( ) { return status ; }", "testMethod": "getStatusReturnsStatus ( ) { final int status = 200 ; final byte [ ] body = new byte [ ] { 1 } ; final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final byte [ ] errorReason = new byte [ ] { } ; final int expectedStatus = status ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = new com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse ( status , body , headerFields , errorReason ) ; int testStatus = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testStatus , org . hamcrest . CoreMatchers . is ( expectedStatus ) )", "total": "getStatusReturnsStatus ( ) { final int status = 200 ; final byte [ ] body = new byte [ ] { 1 } ; final java . util . Map < java . lang . String , java . util . List < java . lang . String > > headerFields = new java . util . HashMap ( ) ; final byte [ ] errorReason = new byte [ ] { } ; final int expectedStatus = status ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = new com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse ( status , body , headerFields , errorReason ) ; int testStatus = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( testStatus , org . hamcrest . CoreMatchers . is ( expectedStatus ) )"}
{"focal": "startsWith ( com . m3 . scalaflavor4j . Seq ) { return false ; }", "testMethod": "startsWith_A$Seq_false ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > that = com . m3 . scalaflavor4j . Seq . apply ( 1 , 4 ) ; boolean actual = seq . startsWith ( that ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "startsWith_A$Seq_false ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > that = com . m3 . scalaflavor4j . Seq . apply ( 1 , 4 ) ; boolean actual = seq . startsWith ( that ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } startsWith ( com . m3 . scalaflavor4j . Seq ) { return false ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "canAcquireIdToken ( com . google . auth . oauth2 . GoogleCredentials ) { final com . spotify . styx . client . GoogleIdTokenAuth idTokenAuth = com . spotify . styx . client . GoogleIdTokenAuth . of ( credentials ) ; final java . lang . String targetAudience = \"http://styx.foo.bar\" ; final java . util . Optional < java . lang . String > token = idTokenAuth . getToken ( targetAudience ) ; final com . google . api . client . googleapis . auth . oauth2 . GoogleIdToken verifiedToken = com . spotify . styx . client . GoogleIdTokenAuthTest . VERIFIER . verify ( token . orElseThrow ( ) ) ; org . junit . Assert . assertThat ( verifiedToken , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . notNullValue ( ) ) ) ; if ( ! ( credentials instanceof com . google . auth . oauth2 . UserCredentials ) ) { org . junit . Assert . assertThat ( verifiedToken . verifyAudience ( com . google . common . collect . ImmutableList . of ( targetAudience ) ) , org . hamcrest . Matchers . is ( true ) ) ; } return true ; }", "testMethod": "testImpersonatedCredentials ( ) { org . junit . Assume . assumeNotNull ( credentials ) ; final com . google . auth . oauth2 . ImpersonatedCredentials impersonatedCredentials = com . google . auth . oauth2 . ImpersonatedCredentials . newBuilder ( ) . setScopes ( com . google . common . collect . ImmutableList . of ( \"https://www.googleapis.com/auth/cloud-platform\" ) ) . setSourceCredentials ( credentials ) . setTargetPrincipal ( \"styx-test-user@styx-oss-test.iam.gserviceaccount.com\" ) . setLifetime ( 300 ) . setDelegates ( com . google . common . collect . ImmutableList . of ( ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . spotify . styx . client . GoogleIdTokenAuthTest . canAcquireIdToken ( impersonatedCredentials ) , org . hamcrest . Matchers . is ( true ) )", "total": "testImpersonatedCredentials ( ) { org . junit . Assume . assumeNotNull ( credentials ) ; final com . google . auth . oauth2 . ImpersonatedCredentials impersonatedCredentials = com . google . auth . oauth2 . ImpersonatedCredentials . newBuilder ( ) . setScopes ( com . google . common . collect . ImmutableList . of ( \"https://www.googleapis.com/auth/cloud-platform\" ) ) . setSourceCredentials ( credentials ) . setTargetPrincipal ( \"styx-test-user@styx-oss-test.iam.gserviceaccount.com\" ) . setLifetime ( 300 ) . setDelegates ( com . google . common . collect . ImmutableList . of ( ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; } canAcquireIdToken ( com . google . auth . oauth2 . GoogleCredentials ) { final com . spotify . styx . client . GoogleIdTokenAuth idTokenAuth = com . spotify . styx . client . GoogleIdTokenAuth . of ( credentials ) ; final java . lang . String targetAudience = \"http://styx.foo.bar\" ; final java . util . Optional < java . lang . String > token = idTokenAuth . getToken ( targetAudience ) ; final com . google . api . client . googleapis . auth . oauth2 . GoogleIdToken verifiedToken = com . spotify . styx . client . GoogleIdTokenAuthTest . VERIFIER . verify ( token . orElseThrow ( ) ) ; org . junit . Assert . assertThat ( verifiedToken , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . notNullValue ( ) ) ) ; if ( ! ( credentials instanceof com . google . auth . oauth2 . UserCredentials ) ) { org . junit . Assert . assertThat ( verifiedToken . verifyAudience ( com . google . common . collect . ImmutableList . of ( targetAudience ) ) , org . hamcrest . Matchers . is ( true ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( com . spotify . styx . client . GoogleIdTokenAuthTest . canAcquireIdToken ( impersonatedCredentials ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "equalTo ( T extends java . lang . Comparable ) { return org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . instantiate ( org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . ComparisonType . EQUAL_TO , value ) ; }", "testMethod": "twoTaskConnectedAndOneIndependentTaskWithTheSameDuration ( ) { givenTwoTaskConnectedAndOneIndependentTask ( 10 , 10 , 20 ) ; java . util . List < org . zkoss . ganttz . data . ITaskFundamentalProperties > criticalPath = buildCalculator ( ) . calculateCriticalPath ( diagramGraphExample ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( criticalPath . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 3 ) )", "total": "twoTaskConnectedAndOneIndependentTaskWithTheSameDuration ( ) { givenTwoTaskConnectedAndOneIndependentTask ( 10 , 10 , 20 ) ; java . util . List < org . zkoss . ganttz . data . ITaskFundamentalProperties > criticalPath = buildCalculator ( ) . calculateCriticalPath ( diagramGraphExample ) ; \"<AssertPlaceHolder>\" ; } equalTo ( T extends java . lang . Comparable ) { return org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . instantiate ( org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . ComparisonType . EQUAL_TO , value ) ; }", "answer": "org . junit . Assert . assertThat ( criticalPath . size ( ) , org . hamcrest . CoreMatchers . equalTo ( 3 ) )"}
{"focal": "getBytes ( ) { return content ; }", "testMethod": "signatureIsMatching ( ) { com . clouway . oauth2 . jws . Pem . Block privateKey = new com . clouway . oauth2 . jws . Pem ( ) . parse ( new java . io . ByteArrayInputStream ( privateKeyPem . getBytes ( ) ) ) ; byte [ ] signatureValue = com . google . common . io . BaseEncoding . base64Url ( ) . decode ( \"WBAzzss3J8Ea6-xxOCVS2OZ2HoqpiLdfCLhIJEevaPck377qTpiM__lHta_S8dSCuTl5FjREqixIiwGrJVJEIkfExUwS5YWekdJRniSKdqLjmXussePaCSgco3reJDqNcRCGiv9DSLH0GfZFdv11Ik5nyaHjNnS4ykEi76guaY8-T3uVFjOH4e2o8Wm0vBbq9hzo9UHdgnsI2BLrzDVoydGWM7uZW8MQNKTuGWY_Ywyj1hilr9rw4yy2FvBe7G-56qaq8--IlVNZ6ocJX2dYhZPqDtZUYwLRqwFyM_F53Kt81I8Qht6HBgH-fgrfbd7Ms67BeLGsupFvuM9sF-hGOQ\" ) ; boolean isSignedWithThatKey = new com . clouway . oauth2 . jws . RsaJwsSignature ( signatureValue ) . verifyWithPrivateKey ( java . lang . String . format ( \"%s.%s\" , \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9\" , \"eyJpc3MiOiJ4eHhAZGV2ZWxvcGVyLmNvbSIsInNjb3BlIjoidGVzdDEgdGVzdDIiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjkwMDIvb2F1dGgyL3Rva2VuIiwiZXhwIjoxNDYxMjM4OTQ4LCJpYXQiOjE0NjEyMzUzNDgsInN1YiI6InVzZXJAZXhhbXBsZS5jb20iLCJwcm4iOiJ1c2VyQGV4YW1wbGUuY29tIn0\" ) . getBytes ( ) , privateKey ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isSignedWithThatKey , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( true ) ) )", "total": "signatureIsMatching ( ) { com . clouway . oauth2 . jws . Pem . Block privateKey = new com . clouway . oauth2 . jws . Pem ( ) . parse ( new java . io . ByteArrayInputStream ( privateKeyPem . getBytes ( ) ) ) ; byte [ ] signatureValue = com . google . common . io . BaseEncoding . base64Url ( ) . decode ( \"WBAzzss3J8Ea6-xxOCVS2OZ2HoqpiLdfCLhIJEevaPck377qTpiM__lHta_S8dSCuTl5FjREqixIiwGrJVJEIkfExUwS5YWekdJRniSKdqLjmXussePaCSgco3reJDqNcRCGiv9DSLH0GfZFdv11Ik5nyaHjNnS4ykEi76guaY8-T3uVFjOH4e2o8Wm0vBbq9hzo9UHdgnsI2BLrzDVoydGWM7uZW8MQNKTuGWY_Ywyj1hilr9rw4yy2FvBe7G-56qaq8--IlVNZ6ocJX2dYhZPqDtZUYwLRqwFyM_F53Kt81I8Qht6HBgH-fgrfbd7Ms67BeLGsupFvuM9sF-hGOQ\" ) ; boolean isSignedWithThatKey = new com . clouway . oauth2 . jws . RsaJwsSignature ( signatureValue ) . verifyWithPrivateKey ( java . lang . String . format ( \"%s.%s\" , \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9\" , \"eyJpc3MiOiJ4eHhAZGV2ZWxvcGVyLmNvbSIsInNjb3BlIjoidGVzdDEgdGVzdDIiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjkwMDIvb2F1dGgyL3Rva2VuIiwiZXhwIjoxNDYxMjM4OTQ4LCJpYXQiOjE0NjEyMzUzNDgsInN1YiI6InVzZXJAZXhhbXBsZS5jb20iLCJwcm4iOiJ1c2VyQGV4YW1wbGUuY29tIn0\" ) . getBytes ( ) , privateKey ) ; \"<AssertPlaceHolder>\" ; } getBytes ( ) { return content ; }", "answer": "org . junit . Assert . assertThat ( isSignedWithThatKey , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( true ) ) )"}
{"focal": "calculateRetreiveSize ( se . diabol . jenkins . pipeline . domain . Component , boolean , int , int ) { int retrieveSize = noOfPipelines ; if ( pagingEnabled && ( ! ( component . isFullScreenView ( ) ) ) ) { retrieveSize = java . lang . Math . min ( ( totalNoOfPipelines - ( ( ( component . getCurrentPage ( ) ) - 1 ) * noOfPipelines ) ) , noOfPipelines ) ; } return retrieveSize ; }", "testMethod": "calculateRetrieveSizeShouldReturnNoOfPipelinesWhenPagingEnabledAndInFullScreen ( ) { se . diabol . jenkins . pipeline . domain . Component component = mock ( se . diabol . jenkins . pipeline . domain . Component . class ) ; when ( component . isFullScreenView ( ) ) . thenReturn ( true ) ; final int numberOfPipelines = 9 ; int retrieveSize = se . diabol . jenkins . pipeline . domain . DownstreamPipeline . calculateRetreiveSize ( component , se . diabol . jenkins . pipeline . domain . DownstreamPipelineTest . PAGING_ENABLED , numberOfPipelines , 10 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( retrieveSize , org . hamcrest . core . Is . is ( numberOfPipelines ) )", "total": "calculateRetrieveSizeShouldReturnNoOfPipelinesWhenPagingEnabledAndInFullScreen ( ) { se . diabol . jenkins . pipeline . domain . Component component = mock ( se . diabol . jenkins . pipeline . domain . Component . class ) ; when ( component . isFullScreenView ( ) ) . thenReturn ( true ) ; final int numberOfPipelines = 9 ; int retrieveSize = se . diabol . jenkins . pipeline . domain . DownstreamPipeline . calculateRetreiveSize ( component , se . diabol . jenkins . pipeline . domain . DownstreamPipelineTest . PAGING_ENABLED , numberOfPipelines , 10 ) ; \"<AssertPlaceHolder>\" ; } calculateRetreiveSize ( se . diabol . jenkins . pipeline . domain . Component , boolean , int , int ) { int retrieveSize = noOfPipelines ; if ( pagingEnabled && ( ! ( component . isFullScreenView ( ) ) ) ) { retrieveSize = java . lang . Math . min ( ( totalNoOfPipelines - ( ( ( component . getCurrentPage ( ) ) - 1 ) * noOfPipelines ) ) , noOfPipelines ) ; } return retrieveSize ; }", "answer": "org . junit . Assert . assertThat ( retrieveSize , org . hamcrest . core . Is . is ( numberOfPipelines ) )"}
{"focal": "findJobRunningStatistics ( java . lang . String ) { if ( \"lastWeek\" . equals ( since ) ) { return statisticManager . findJobRunningStatisticsWeekly ( ) ; } else { return java . util . Collections . emptyList ( ) ; } }", "testMethod": "assertFindJobRunningStatisticsWhenTableIsEmpty ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( repository . findJobRunningStatistics ( new java . util . Date ( ) ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "assertFindJobRunningStatisticsWhenTableIsEmpty ( ) { \"<AssertPlaceHolder>\" ; } findJobRunningStatistics ( java . lang . String ) { if ( \"lastWeek\" . equals ( since ) ) { return statisticManager . findJobRunningStatisticsWeekly ( ) ; } else { return java . util . Collections . emptyList ( ) ; } }", "answer": "org . junit . Assert . assertThat ( repository . findJobRunningStatistics ( new java . util . Date ( ) ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "setSource ( java . net . URI ) { iframe . getState ( ) . setSource ( externalURI . toASCIIString ( ) ) ; }", "testMethod": "shouldMapEdgeWithRoot ( ) { stubEdgeResultSet ( ) ; given ( resultSet . wasNull ( ) ) . willReturn ( true ) ; annis . model . Edge actual = generator . mapEdge ( resultSet , tableAccessStrategy ) ; annis . model . Edge expected = createDefaultEdge ( ) ; expected . setSource ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "shouldMapEdgeWithRoot ( ) { stubEdgeResultSet ( ) ; given ( resultSet . wasNull ( ) ) . willReturn ( true ) ; annis . model . Edge actual = generator . mapEdge ( resultSet , tableAccessStrategy ) ; annis . model . Edge expected = createDefaultEdge ( ) ; expected . setSource ( null ) ; \"<AssertPlaceHolder>\" ; } setSource ( java . net . URI ) { iframe . getState ( ) . setSource ( externalURI . toASCIIString ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "isLongString ( ) { return longString ; }", "testMethod": "longString2 ( ) { org . diirt . support . ca . JCAChannelHandler channel = new org . diirt . support . ca . JCAChannelHandler ( \"test.NAME$\" , dataSource ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( channel . isLongString ( ) , equalTo ( true ) )", "total": "longString2 ( ) { org . diirt . support . ca . JCAChannelHandler channel = new org . diirt . support . ca . JCAChannelHandler ( \"test.NAME$\" , dataSource ) ; \"<AssertPlaceHolder>\" ; } isLongString ( ) { return longString ; }", "answer": "org . junit . Assert . assertThat ( channel . isLongString ( ) , equalTo ( true ) )"}
{"focal": "allows ( org . jenkinsci . plugins . postbuildscript . model . PostBuildItem , boolean ) { java . util . Optional < hudson . model . Result > result = java . util . Optional . ofNullable ( build . getResult ( ) ) ; return ( result . isPresent ( ) ) && ( item . shouldBeExecuted ( result . get ( ) . toString ( ) ) ) ; }", "testMethod": "allowsRunningOnSlaveWhenBuiltStrIsDefined ( ) { given ( build . getBuiltOnStr ( ) ) . willReturn ( \"builtOnStr\" ) ; given ( item . shouldRunOnSlave ( ) ) . willReturn ( true ) ; boolean actual = roleRule . allows ( item , true ) ; \"<AssertPlaceHolder>\" ; verify ( item , never ( ) ) . shouldRunOnMaster ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( true ) )", "total": "allowsRunningOnSlaveWhenBuiltStrIsDefined ( ) { given ( build . getBuiltOnStr ( ) ) . willReturn ( \"builtOnStr\" ) ; given ( item . shouldRunOnSlave ( ) ) . willReturn ( true ) ; boolean actual = roleRule . allows ( item , true ) ; \"<AssertPlaceHolder>\" ; verify ( item , never ( ) ) . shouldRunOnMaster ( ) ; } allows ( org . jenkinsci . plugins . postbuildscript . model . PostBuildItem , boolean ) { java . util . Optional < hudson . model . Result > result = java . util . Optional . ofNullable ( build . getResult ( ) ) ; return ( result . isPresent ( ) ) && ( item . shouldBeExecuted ( result . get ( ) . toString ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "insert ( int ) { node = treeInsert ( node , insertKey ) ; if ( ( node ) != null ) { return \"success\" ; } else { return \"fail\" ; } }", "testMethod": "duplicateKeyTest ( ) { bst . insert ( 10 ) ; bst . insert ( 5 ) ; bst . insert ( 13 ) ; java . lang . String result = bst . insert ( 10 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( \"fail\" ) )", "total": "duplicateKeyTest ( ) { bst . insert ( 10 ) ; bst . insert ( 5 ) ; bst . insert ( 13 ) ; java . lang . String result = bst . insert ( 10 ) ; \"<AssertPlaceHolder>\" ; } insert ( int ) { node = treeInsert ( node , insertKey ) ; if ( ( node ) != null ) { return \"success\" ; } else { return \"fail\" ; } }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( \"fail\" ) )"}
{"focal": "getCustomerList ( ) { return customerList ; }", "testMethod": "youngestCustomer ( ) { java . util . List < common . test . tool . entity . Customer > customerList = this . mall . getCustomerList ( ) ; java . util . Comparator < common . test . tool . entity . Customer > comparator = null ; java . util . Optional < common . test . tool . entity . Customer > youngestCustomer = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( youngestCustomer . get ( ) , org . hamcrest . Matchers . is ( customerList . get ( 8 ) ) )", "total": "youngestCustomer ( ) { java . util . List < common . test . tool . entity . Customer > customerList = this . mall . getCustomerList ( ) ; java . util . Comparator < common . test . tool . entity . Customer > comparator = null ; java . util . Optional < common . test . tool . entity . Customer > youngestCustomer = null ; \"<AssertPlaceHolder>\" ; } getCustomerList ( ) { return customerList ; }", "answer": "org . junit . Assert . assertThat ( youngestCustomer . get ( ) , org . hamcrest . Matchers . is ( customerList . get ( 8 ) ) )"}
{"focal": "simplify ( ) { com . google . common . collect . ImmutableList . Builder < org . batfish . datamodel . routing_policy . statement . Statement > simpleStatements = com . google . common . collect . ImmutableList . builder ( ) ; for ( org . batfish . datamodel . routing_policy . statement . Statement statement : _statements ) { simpleStatements . addAll ( statement . simplify ( ) ) ; } org . batfish . datamodel . routing_policy . RoutingPolicy simple = new org . batfish . datamodel . routing_policy . RoutingPolicy ( _name , _owner ) ; simple . setStatements ( simpleStatements . build ( ) ) ; return simple ; }", "testMethod": "simplifySingleStatement ( ) { org . batfish . datamodel . routing_policy . expr . Disjunction single = new org . batfish . datamodel . routing_policy . expr . Disjunction ( com . google . common . collect . ImmutableList . of ( org . batfish . datamodel . routing_policy . expr . BooleanExprs . CALL_EXPR_CONTEXT ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( single . simplify ( ) , org . hamcrest . Matchers . is ( org . batfish . datamodel . routing_policy . expr . BooleanExprs . CALL_EXPR_CONTEXT ) )", "total": "simplifySingleStatement ( ) { org . batfish . datamodel . routing_policy . expr . Disjunction single = new org . batfish . datamodel . routing_policy . expr . Disjunction ( com . google . common . collect . ImmutableList . of ( org . batfish . datamodel . routing_policy . expr . BooleanExprs . CALL_EXPR_CONTEXT ) ) ; \"<AssertPlaceHolder>\" ; } simplify ( ) { com . google . common . collect . ImmutableList . Builder < org . batfish . datamodel . routing_policy . statement . Statement > simpleStatements = com . google . common . collect . ImmutableList . builder ( ) ; for ( org . batfish . datamodel . routing_policy . statement . Statement statement : _statements ) { simpleStatements . addAll ( statement . simplify ( ) ) ; } org . batfish . datamodel . routing_policy . RoutingPolicy simple = new org . batfish . datamodel . routing_policy . RoutingPolicy ( _name , _owner ) ; simple . setStatements ( simpleStatements . build ( ) ) ; return simple ; }", "answer": "org . junit . Assert . assertThat ( single . simplify ( ) , org . hamcrest . Matchers . is ( org . batfish . datamodel . routing_policy . expr . BooleanExprs . CALL_EXPR_CONTEXT ) )"}
{"focal": "size ( ) { return map . size ( ) ; }", "testMethod": "testLoadApplicantContext ( ) { java . lang . String expression = loadExpression ( \"applicant.feel\" ) ; java . util . Map applicant = ( ( java . util . Map ) ( org . kie . dmn . feel . lang . examples . ExamplesTest . feel . evaluate ( expression ) ) ) ; System . out . println ( printContext ( applicant ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( applicant . size ( ) , org . hamcrest . CoreMatchers . is ( 5 ) )", "total": "testLoadApplicantContext ( ) { java . lang . String expression = loadExpression ( \"applicant.feel\" ) ; java . util . Map applicant = ( ( java . util . Map ) ( org . kie . dmn . feel . lang . examples . ExamplesTest . feel . evaluate ( expression ) ) ) ; System . out . println ( printContext ( applicant ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return map . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( applicant . size ( ) , org . hamcrest . CoreMatchers . is ( 5 ) )"}
{"focal": "parse ( java . lang . String ) { return gson . fromJson ( json , org . kairosdb . client . testUtils . MetricParser . listType ) ; }", "testMethod": "test_MultipleMetricsWithRelativeTimes ( ) { java . lang . String json = com . google . common . io . Resources . toString ( com . google . common . io . Resources . getResource ( \"query_multiple_metrics_relative_times.json\" ) , Charsets . UTF_8 ) ; org . kairosdb . client . builder . QueryBuilder builder = org . kairosdb . client . builder . QueryBuilder . getInstance ( ) ; builder . setCacheTime ( 2000 ) . setStart ( 3 , TimeUnit . WEEKS ) . setEnd ( 2 , TimeUnit . DAYS ) ; builder . addMetric ( \"metric1\" ) . addTag ( \"foo\" , \"bar\" ) . addTag ( \"larry\" , \"moe\" ) . addAggregator ( org . kairosdb . client . builder . AggregatorFactory . createMaxAggregator ( 1 , TimeUnit . DAYS ) ) ; builder . addMetric ( \"metric2\" ) . addTag ( \"curly\" , \"joe\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( parser . parse ( builder . build ( ) ) , org . hamcrest . CoreMatchers . equalTo ( parser . parse ( json ) ) )", "total": "test_MultipleMetricsWithRelativeTimes ( ) { java . lang . String json = com . google . common . io . Resources . toString ( com . google . common . io . Resources . getResource ( \"query_multiple_metrics_relative_times.json\" ) , Charsets . UTF_8 ) ; org . kairosdb . client . builder . QueryBuilder builder = org . kairosdb . client . builder . QueryBuilder . getInstance ( ) ; builder . setCacheTime ( 2000 ) . setStart ( 3 , TimeUnit . WEEKS ) . setEnd ( 2 , TimeUnit . DAYS ) ; builder . addMetric ( \"metric1\" ) . addTag ( \"foo\" , \"bar\" ) . addTag ( \"larry\" , \"moe\" ) . addAggregator ( org . kairosdb . client . builder . AggregatorFactory . createMaxAggregator ( 1 , TimeUnit . DAYS ) ) ; builder . addMetric ( \"metric2\" ) . addTag ( \"curly\" , \"joe\" ) ; \"<AssertPlaceHolder>\" ; } parse ( java . lang . String ) { return gson . fromJson ( json , org . kairosdb . client . testUtils . MetricParser . listType ) ; }", "answer": "org . junit . Assert . assertThat ( parser . parse ( builder . build ( ) ) , org . hamcrest . CoreMatchers . equalTo ( parser . parse ( json ) ) )"}
{"focal": "write ( java . io . OutputStream ) { writeContentDisposition ( out ) ; writeName ( out ) ; writeExtraHeaderIfNotNull ( out ) ; writeCRLF ( out ) ; writeContentTypeIfNotNull ( out ) ; writeCRLF ( out ) ; writeContent ( out ) ; writeCRLF ( out ) ; }", "testMethod": "shouldWriteExpectedOutput ( ) { java . lang . String contentString = \"test<sp>test<sp>test\" ; byte [ ] content = contentString . getBytes ( ) ; final java . io . InputStream in = new java . io . ByteArrayInputStream ( content ) ; com . navercorp . volleyextensions . volleyer . multipart . AbstractPart mock = com . navercorp . volleyextensions . volleyer . multipart . AbstractPartTest . createPartWithInputStream ( name , in ) ; java . io . ByteArrayOutputStream out = new java . io . ByteArrayOutputStream ( ) ; com . navercorp . volleyextensions . volleyer . multipart . Part part = new com . navercorp . volleyextensions . volleyer . multipart . AbstractPartTest . TestPart ( name , mock ) ; java . lang . String expected = ( ( ( \"Content-Disposition:<sp>form-data;<sp>name=\\\"\" + ( name ) ) + \"\\\"\\r\\n\\r\\n\" ) + contentString ) + \"\\r\\n\" ; part . write ( out ) ; byte [ ] result = out . toByteArray ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( new java . lang . String ( result ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "shouldWriteExpectedOutput ( ) { java . lang . String contentString = \"test<sp>test<sp>test\" ; byte [ ] content = contentString . getBytes ( ) ; final java . io . InputStream in = new java . io . ByteArrayInputStream ( content ) ; com . navercorp . volleyextensions . volleyer . multipart . AbstractPart mock = com . navercorp . volleyextensions . volleyer . multipart . AbstractPartTest . createPartWithInputStream ( name , in ) ; java . io . ByteArrayOutputStream out = new java . io . ByteArrayOutputStream ( ) ; com . navercorp . volleyextensions . volleyer . multipart . Part part = new com . navercorp . volleyextensions . volleyer . multipart . AbstractPartTest . TestPart ( name , mock ) ; java . lang . String expected = ( ( ( \"Content-Disposition:<sp>form-data;<sp>name=\\\"\" + ( name ) ) + \"\\\"\\r\\n\\r\\n\" ) + contentString ) + \"\\r\\n\" ; part . write ( out ) ; byte [ ] result = out . toByteArray ( ) ; \"<AssertPlaceHolder>\" ; } write ( java . io . OutputStream ) { writeContentDisposition ( out ) ; writeName ( out ) ; writeExtraHeaderIfNotNull ( out ) ; writeCRLF ( out ) ; writeContentTypeIfNotNull ( out ) ; writeCRLF ( out ) ; writeContent ( out ) ; writeCRLF ( out ) ; }", "answer": "org . junit . Assert . assertThat ( new java . lang . String ( result ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "size ( ) { return selected . size ( ) ; }", "testMethod": "testClusteringDataMining ( ) { final org . carrot2 . core . ProcessingResult processingResult = cluster ( org . carrot2 . core . test . SampleDocumentData . DOCUMENTS_DATA_MINING ) ; final java . util . Collection < org . carrot2 . core . Cluster > clusters = processingResult . getClusters ( ) ; \"<AssertPlaceHolder>\" . isGreaterThan ( 0 ) ; }", "assertLine": "org . junit . Assert . assertThat ( clusters . size ( ) )", "total": "testClusteringDataMining ( ) { final org . carrot2 . core . ProcessingResult processingResult = cluster ( org . carrot2 . core . test . SampleDocumentData . DOCUMENTS_DATA_MINING ) ; final java . util . Collection < org . carrot2 . core . Cluster > clusters = processingResult . getClusters ( ) ; \"<AssertPlaceHolder>\" . isGreaterThan ( 0 ) ; } size ( ) { return selected . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( clusters . size ( ) )"}
{"focal": "getStatus ( ) { return status ; }", "testMethod": "sendReturnsStatusCodeOnBadStatusException ( com . microsoft . azure . sdk . iot . service . transport . http . HttpConnection , java . net . URL ) { final com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod . POST ; final byte [ ] body = new byte [ 0 ] ; final int badStatus = 404 ; final int expectedStatus = badStatus ; new tests . unit . com . microsoft . azure . sdk . iot . service . transport . http . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"http\" ; mockConn . connect ( ) ; result = new java . io . IOException ( ) ; mockConn . getResponseStatus ( ) ; result = badStatus ; } } ; com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest request = new com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest ( mockUrl , httpsMethod , body ) ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = request . send ( ) ; int testStatus = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testStatus , org . hamcrest . CoreMatchers . is ( expectedStatus ) )", "total": "sendReturnsStatusCodeOnBadStatusException ( com . microsoft . azure . sdk . iot . service . transport . http . HttpConnection , java . net . URL ) { final com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod httpsMethod = com . microsoft . azure . sdk . iot . service . transport . http . HttpMethod . POST ; final byte [ ] body = new byte [ 0 ] ; final int badStatus = 404 ; final int expectedStatus = badStatus ; new tests . unit . com . microsoft . azure . sdk . iot . service . transport . http . NonStrictExpectations ( ) { { mockUrl . getProtocol ( ) ; result = \"http\" ; mockConn . connect ( ) ; result = new java . io . IOException ( ) ; mockConn . getResponseStatus ( ) ; result = badStatus ; } } ; com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest request = new com . microsoft . azure . sdk . iot . service . transport . http . HttpRequest ( mockUrl , httpsMethod , body ) ; com . microsoft . azure . sdk . iot . service . transport . http . HttpResponse response = request . send ( ) ; int testStatus = response . getStatus ( ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( testStatus , org . hamcrest . CoreMatchers . is ( expectedStatus ) )"}
{"focal": "isProtected ( java . lang . String ) { return ( methodSignature != null ) && ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"protected\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ; }", "testMethod": "isProtected_A$String_StringIsNull ( ) { java . lang . String methodSignature = null ; boolean actual = org . junithelper . core . util . AccessModifierDetector . isProtected ( methodSignature ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isProtected_A$String_StringIsNull ( ) { java . lang . String methodSignature = null ; boolean actual = org . junithelper . core . util . AccessModifierDetector . isProtected ( methodSignature ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } isProtected ( java . lang . String ) { return ( methodSignature != null ) && ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"protected\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "isEnabled ( ) { return ( caseActivityInstanceState ) == ( org . camunda . bpm . engine . impl . history . event . ENABLED . getStateCode ( ) ) ; }", "testMethod": "reenableCaseExecutionDisabledTenantCheck ( ) { caseService . disableCaseExecution ( caseExecutionId ) ; identityService . setAuthentication ( \"user\" , null , null ) ; processEngineConfiguration . setTenantCheckEnabled ( false ) ; caseService . reenableCaseExecution ( caseExecutionId ) ; identityService . clearAuthentication ( ) ; org . camunda . bpm . engine . runtime . CaseExecution caseExecution = getCaseExecution ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( caseExecution . isEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "reenableCaseExecutionDisabledTenantCheck ( ) { caseService . disableCaseExecution ( caseExecutionId ) ; identityService . setAuthentication ( \"user\" , null , null ) ; processEngineConfiguration . setTenantCheckEnabled ( false ) ; caseService . reenableCaseExecution ( caseExecutionId ) ; identityService . clearAuthentication ( ) ; org . camunda . bpm . engine . runtime . CaseExecution caseExecution = getCaseExecution ( ) ; \"<AssertPlaceHolder>\" ; } isEnabled ( ) { return ( caseActivityInstanceState ) == ( org . camunda . bpm . engine . impl . history . event . ENABLED . getStateCode ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( caseExecution . isEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getRepository ( ) { return repository ; }", "testMethod": "findOneByDataset_should_return_null_when_no_preparation_use_dataset ( ) { final java . lang . String dataSetId = \"789b61f3128a9bc24a684\" ; final org . talend . dataprep . api . preparation . Preparation prep1 = new org . talend . dataprep . api . preparation . Preparation ( ) ; prep1 . setDataSetId ( \"other_dataset\" ) ; final org . talend . dataprep . api . preparation . Preparation prep2 = new org . talend . dataprep . api . preparation . Preparation ( ) ; prep2 . setDataSetId ( \"other_dataset\" ) ; getRepository ( ) . add ( prep1 ) ; getRepository ( ) . add ( prep2 ) ; final boolean result = getRepository ( ) . exist ( org . talend . dataprep . api . preparation . Preparation . class , eq ( \"dataSetId\" , dataSetId ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )", "total": "findOneByDataset_should_return_null_when_no_preparation_use_dataset ( ) { final java . lang . String dataSetId = \"789b61f3128a9bc24a684\" ; final org . talend . dataprep . api . preparation . Preparation prep1 = new org . talend . dataprep . api . preparation . Preparation ( ) ; prep1 . setDataSetId ( \"other_dataset\" ) ; final org . talend . dataprep . api . preparation . Preparation prep2 = new org . talend . dataprep . api . preparation . Preparation ( ) ; prep2 . setDataSetId ( \"other_dataset\" ) ; getRepository ( ) . add ( prep1 ) ; getRepository ( ) . add ( prep2 ) ; final boolean result = getRepository ( ) . exist ( org . talend . dataprep . api . preparation . Preparation . class , eq ( \"dataSetId\" , dataSetId ) ) ; \"<AssertPlaceHolder>\" ; } getRepository ( ) { return repository ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getEssentialsDataFolder ( ) { if ( ( essentials ) != null ) { return essentials . getDataFolder ( ) ; } return null ; }", "testMethod": "shouldReturnEssentialsDataFolder ( ) { com . earth2me . essentials . Essentials ess = mock ( com . earth2me . essentials . Essentials . class ) ; java . io . File essDataFolder = new java . io . File ( \"test/data-folder\" ) ; fr . xephi . authme . ReflectionTestUtils . setField ( org . bukkit . plugin . java . JavaPlugin . class , ess , \"dataFolder\" , essDataFolder ) ; org . bukkit . plugin . PluginManager pluginManager = mock ( org . bukkit . plugin . PluginManager . class ) ; fr . xephi . authme . service . PluginHookServiceTest . setPluginAvailable ( pluginManager , fr . xephi . authme . service . PluginHookServiceTest . ESSENTIALS , ess ) ; fr . xephi . authme . service . PluginHookService pluginHookService = new fr . xephi . authme . service . PluginHookService ( pluginManager ) ; java . io . File dataFolder = pluginHookService . getEssentialsDataFolder ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dataFolder , org . hamcrest . Matchers . equalTo ( essDataFolder ) )", "total": "shouldReturnEssentialsDataFolder ( ) { com . earth2me . essentials . Essentials ess = mock ( com . earth2me . essentials . Essentials . class ) ; java . io . File essDataFolder = new java . io . File ( \"test/data-folder\" ) ; fr . xephi . authme . ReflectionTestUtils . setField ( org . bukkit . plugin . java . JavaPlugin . class , ess , \"dataFolder\" , essDataFolder ) ; org . bukkit . plugin . PluginManager pluginManager = mock ( org . bukkit . plugin . PluginManager . class ) ; fr . xephi . authme . service . PluginHookServiceTest . setPluginAvailable ( pluginManager , fr . xephi . authme . service . PluginHookServiceTest . ESSENTIALS , ess ) ; fr . xephi . authme . service . PluginHookService pluginHookService = new fr . xephi . authme . service . PluginHookService ( pluginManager ) ; java . io . File dataFolder = pluginHookService . getEssentialsDataFolder ( ) ; \"<AssertPlaceHolder>\" ; } getEssentialsDataFolder ( ) { if ( ( essentials ) != null ) { return essentials . getDataFolder ( ) ; } return null ; }", "answer": "org . junit . Assert . assertThat ( dataFolder , org . hamcrest . Matchers . equalTo ( essDataFolder ) )"}
{"focal": "write ( java . lang . Object , org . bson . conversions . Bson ) { ( ( org . bson . Document ) ( bson ) ) . put ( \"firstName\" , person . getFirstName ( ) ) ; }", "testMethod": "writesInterfaceBackedEnumsToSimpleNameByDefault ( ) { org . bson . Document document = new org . bson . Document ( ) ; org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . DocWithInterfacedEnum source = new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . DocWithInterfacedEnum ( ) ; source . property = org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . InterfacedEnum . INSTANCE ; converter . write ( source , document ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . hasEntrySatisfying ( \"_class\" , ( __ ) -> { } ) . hasEntrySatisfying ( \"property\" , ( value ) -> InterfacedEnum . INSTANCE . name ( ) . equals ( value ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( document )", "total": "writesInterfaceBackedEnumsToSimpleNameByDefault ( ) { org . bson . Document document = new org . bson . Document ( ) ; org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . DocWithInterfacedEnum source = new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . DocWithInterfacedEnum ( ) ; source . property = org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . InterfacedEnum . INSTANCE ; converter . write ( source , document ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . hasEntrySatisfying ( \"_class\" , ( __ ) -> { } ) . hasEntrySatisfying ( \"property\" , ( value ) -> InterfacedEnum . INSTANCE . name ( ) . equals ( value ) ) ; } write ( java . lang . Object , org . bson . conversions . Bson ) { ( ( org . bson . Document ) ( bson ) ) . put ( \"firstName\" , person . getFirstName ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( document )"}
{"focal": "from ( java . lang . String ) { if ( ! ( variant . startsWith ( \"historic-\" ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Variant<sp>does<sp>not<sp>start<sp>with<sp>\\\"historic-\\\"new-year-strategy\" 1 + variant ) ) ; } java . lang . String [ ] parts = variant . substring ( 9 ) . split ( \"new-year-strategy\" 0 ) ; if ( ( parts . length ) == 0 ) { throw new java . lang . IllegalArgumentException ( \"Invalid<sp>variant<sp>description.\" ) ; } net . time4j . history . internal . HistoricVariant hv = net . time4j . history . internal . HistoricVariant . valueOf ( parts [ 0 ] ) ; net . time4j . history . ChronoHistory history ; int startIndex = 2 ; switch ( hv ) { case PROLEPTIC_GREGORIAN : return net . time4j . history . ChronoHistory . PROLEPTIC_GREGORIAN ; case PROLEPTIC_JULIAN : return net . time4j . history . ChronoHistory . PROLEPTIC_JULIAN ; case PROLEPTIC_BYZANTINE : return net . time4j . history . ChronoHistory . PROLEPTIC_BYZANTINE ; case SWEDEN : history = net . time4j . history . ChronoHistory . ofSweden ( ) ; startIndex = 1 ; break ; case INTRODUCTION_ON_1582_10_15 : if ( ! ( net . time4j . history . ChronoHistory . getGregorianCutOverDate ( parts , variant ) . equals ( net . time4j . PlainDate . of ( 1582 , 10 , 15 ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Inconsistent<sp>cutover<sp>date:<sp>\" + variant ) ) ; } history = net . time4j . history . ChronoHistory . ofFirstGregorianReform ( ) ; break ; case SINGLE_CUTOVER_DATE : net . time4j . PlainDate cutover = net . time4j . history . ChronoHistory . getGregorianCutOverDate ( parts , variant ) ; history = net . time4j . history . ChronoHistory . ofGregorianReform ( cutover ) ; break ; default : throw new java . lang . UnsupportedOperationException ( hv . name ( ) ) ; } java . lang . String [ ] a = parts [ startIndex ] . split ( \"=\" ) ; if ( a [ 0 ] . equals ( \"ancient-julian-leap-years\" ) ) { java . lang . String ajly = a [ 1 ] . substring ( 1 , ( ( a [ 1 ] . length ( ) ) - 1 ) ) ; if ( ! ( ajly . isEmpty ( ) ) ) { java . lang . String [ ] nums = ajly . split ( \"new-year-strategy\" 3 ) ; int [ ] bcYears = new int [ nums . length ] ; for ( int i = 0 ; i < ( nums . length ) ; i ++ ) { bcYears [ i ] = 1 - ( java . lang . Integer . parseInt ( nums [ i ] ) ) ; } history = history . with ( net . time4j . history . AncientJulianLeapYears . of ( bcYears ) ) ; } } java . lang . String [ ] b = parts [ ( startIndex + 1 ) ] . split ( \"=\" ) ; if ( b [ 0 ] . equals ( \"new-year-strategy\" ) ) { java . lang . String desc = b [ 1 ] . substring ( 1 , ( ( b [ 1 ] . length ( ) ) - 1 ) ) ; java . lang . String [ ] rules = desc . split ( \"new-year-strategy\" 3 ) ; net . time4j . history . NewYearStrategy nys = null ; for ( int i = 0 ; i < ( rules . length ) ; i ++ ) { java . lang . String [ ] rule = rules [ i ] . split ( \"->\" ) ; net . time4j . history . NewYearRule nyr = net . time4j . history . NewYearRule . valueOf ( rule [ 0 ] ) ; int annoDomini = ( ( rule . length ) == 2 ) ? java . lang . Integer . parseInt ( rule [ 1 ] ) : Integer . MAX_VALUE ; if ( nys == null ) { if ( ( nyr == ( NewYearRule . BEGIN_OF_JANUARY ) ) && ( annoDomini == 567 ) ) { continue ; } nys = nyr . until ( annoDomini ) ; } else { nys = nys . and ( nyr . until ( annoDomini ) ) ; } } history = history . with ( nys ) ; } java . lang . String [ ] c = parts [ ( startIndex + 2 ) ] . split ( \"=\" ) ; if ( c [ 0 ] . equals ( \"new-year-strategy\" 2 ) ) { java . lang . String desc = c [ 1 ] . substring ( 1 , ( ( c [ 1 ] . length ( ) ) - 1 ) ) ; if ( ! ( desc . equals ( \"default\" ) ) ) { java . lang . String [ ] prefs = desc . split ( \"new-year-strategy\" 3 ) ; try { net . time4j . history . HistoricEra era = net . time4j . history . HistoricEra . valueOf ( prefs [ 0 ] . substring ( 5 ) ) ; net . time4j . PlainDate start = net . time4j . format . expert . Iso8601Format . parseDate ( prefs [ 1 ] . substring ( 7 ) ) ; net . time4j . PlainDate end = net . time4j . format . expert . Iso8601Format . parseDate ( prefs [ 2 ] . substring ( 5 ) ) ; switch ( era ) { case HISPANIC : history = history . with ( net . time4j", "testMethod": "variantProlepticByzantine ( ) { net . time4j . history . ChronoHistory history = ChronoHistory . PROLEPTIC_BYZANTINE ; \"<AssertPlaceHolder>\" ; System . out . println ( history . getVariant ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . history . ChronoHistory . from ( history . getVariant ( ) ) , org . hamcrest . CoreMatchers . is ( history ) )", "total": "variantProlepticByzantine ( ) { net . time4j . history . ChronoHistory history = ChronoHistory . PROLEPTIC_BYZANTINE ; \"<AssertPlaceHolder>\" ; System . out . println ( history . getVariant ( ) ) ; } from ( java . lang . String ) { if ( ! ( variant . startsWith ( \"historic-\" ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Variant<sp>does<sp>not<sp>start<sp>with<sp>\\\"historic-\\\"new-year-strategy\" 1 + variant ) ) ; } java . lang . String [ ] parts = variant . substring ( 9 ) . split ( \"new-year-strategy\" 0 ) ; if ( ( parts . length ) == 0 ) { throw new java . lang . IllegalArgumentException ( \"Invalid<sp>variant<sp>description.\" ) ; } net . time4j . history . internal . HistoricVariant hv = net . time4j . history . internal . HistoricVariant . valueOf ( parts [ 0 ] ) ; net . time4j . history . ChronoHistory history ; int startIndex = 2 ; switch ( hv ) { case PROLEPTIC_GREGORIAN : return net . time4j . history . ChronoHistory . PROLEPTIC_GREGORIAN ; case PROLEPTIC_JULIAN : return net . time4j . history . ChronoHistory . PROLEPTIC_JULIAN ; case PROLEPTIC_BYZANTINE : return net . time4j . history . ChronoHistory . PROLEPTIC_BYZANTINE ; case SWEDEN : history = net . time4j . history . ChronoHistory . ofSweden ( ) ; startIndex = 1 ; break ; case INTRODUCTION_ON_1582_10_15 : if ( ! ( net . time4j . history . ChronoHistory . getGregorianCutOverDate ( parts , variant ) . equals ( net . time4j . PlainDate . of ( 1582 , 10 , 15 ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( \"Inconsistent<sp>cutover<sp>date:<sp>\" + variant ) ) ; } history = net . time4j . history . ChronoHistory . ofFirstGregorianReform ( ) ; break ; case SINGLE_CUTOVER_DATE : net . time4j . PlainDate cutover = net . time4j . history . ChronoHistory . getGregorianCutOverDate ( parts , variant ) ; history = net . time4j . history . ChronoHistory . ofGregorianReform ( cutover ) ; break ; default : throw new java . lang . UnsupportedOperationException ( hv . name ( ) ) ; } java . lang . String [ ] a = parts [ startIndex ] . split ( \"=\" ) ; if ( a [ 0 ] . equals ( \"ancient-julian-leap-years\" ) ) { java . lang . String ajly = a [ 1 ] . substring ( 1 , ( ( a [ 1 ] . length ( ) ) - 1 ) ) ; if ( ! ( ajly . isEmpty ( ) ) ) { java . lang . String [ ] nums = ajly . split ( \"new-year-strategy\" 3 ) ; int [ ] bcYears = new int [ nums . length ] ; for ( int i = 0 ; i < ( nums . length ) ; i ++ ) { bcYears [ i ] = 1 - ( java . lang . Integer . parseInt ( nums [ i ] ) ) ; } history = history . with ( net . time4j . history . AncientJulianLeapYears . of ( bcYears ) ) ; } } java . lang . String [ ] b = parts [ ( startIndex + 1 ) ] . split ( \"=\" ) ; if ( b [ 0 ] . equals ( \"new-year-strategy\" ) ) { java . lang . String desc = b [ 1 ] . substring ( 1 , ( ( b [ 1 ] . length ( ) ) - 1 ) ) ; java . lang . String [ ] rules = desc . split ( \"new-year-strategy\" 3 ) ; net . time4j . history . NewYearStrategy nys = null ; for ( int i = 0 ; i < ( rules . length ) ; i ++ ) { java . lang . String [ ] rule = rules [ i ] . split ( \"->\" ) ; net . time4j . history . NewYearRule nyr = net . time4j . history . NewYearRule . valueOf ( rule [ 0 ] ) ; int annoDomini = ( ( rule . length ) == 2 ) ? java . lang . Integer . parseInt ( rule [ 1 ] ) : Integer . MAX_VALUE ; if ( nys == null ) { if ( ( nyr == ( NewYearRule . BEGIN_OF_JANUARY ) ) && ( annoDomini == 567 ) ) { continue ; } nys = nyr . until ( annoDomini ) ; } else { nys = nys . and ( nyr . until ( annoDomini ) ) ; } } history = history . with ( nys ) ; } java . lang . String [ ] c = parts [ ( startIndex + 2 ) ] . split ( \"=\" ) ; if ( c [ 0 ] . equals ( \"new-year-strategy\" 2 ) ) { java . lang . String desc = c [ 1 ] . substring ( 1 , ( ( c [ 1 ] . length ( ) ) - 1 ) ) ; if ( ! ( desc . equals ( \"default\" ) ) ) { java . lang . String [ ] prefs = desc . split ( \"new-year-strategy\" 3 ) ; try { net . time4j . history . HistoricEra era = net . time4j . history . HistoricEra . valueOf ( prefs [ 0 ] . substring ( 5 ) ) ; net . time4j . PlainDate start = net . time4j . format . expert . Iso8601Format . parseDate ( prefs [ 1 ] . substring ( 7 ) ) ; net . time4j . PlainDate end = net . time4j . format . expert . Iso8601Format . parseDate ( prefs [ 2 ] . substring ( 5 ) ) ; switch ( era ) { case HISPANIC : history = history . with ( net . time4j", "answer": "org . junit . Assert . assertThat ( net . time4j . history . ChronoHistory . from ( history . getVariant ( ) ) , org . hamcrest . CoreMatchers . is ( history ) )"}
{"focal": "lookup ( com . facebook . buck . util . hashing . FileHashLoader , com . facebook . buck . core . sourcepath . resolver . SourcePathResolver , com . google . common . collect . ImmutableSet ) { com . google . common . collect . ImmutableSet . Builder < java . lang . String > interestingPathsBuilder = new com . google . common . collect . ImmutableSet . Builder < > ( ) ; for ( com . facebook . buck . util . types . Pair < ? , int [ ] > entry : entries ) { for ( int hashIndex : entry . getSecond ( ) ) { interestingPathsBuilder . add ( inputs . get ( hashes . get ( hashIndex ) . getFirst ( ) ) ) ; } } com . google . common . collect . ImmutableSet < java . lang . String > interestingPaths = interestingPathsBuilder . build ( ) ; com . google . common . collect . ImmutableListMultimap < java . lang . String , com . facebook . buck . core . sourcepath . SourcePath > mappedUniverse = com . facebook . buck . core . build . engine . manifest . Manifest . index ( universe , ( path ) -> sourcePathToManifestHeader ( path , resolver ) , interestingPaths :: contains ) ; for ( com . facebook . buck . util . types . Pair < com . facebook . buck . core . rulekey . RuleKey , int [ ] > entry : entries ) { if ( hashesMatch ( fileHashLoader , resolver , mappedUniverse , entry . getSecond ( ) ) ) { return java . util . Optional . of ( entry . getFirst ( ) ) ; } } return java . util . Optional . empty ( ) ; }", "testMethod": "lookupMissingHeader ( ) { com . facebook . buck . core . rulekey . RuleKey key = new com . facebook . buck . core . rulekey . RuleKey ( \"aa\" ) ; com . facebook . buck . core . sourcepath . SourcePath input = com . facebook . buck . core . sourcepath . FakeSourcePath . of ( \"input.h\" ) ; com . facebook . buck . core . build . engine . manifest . Manifest manifest = com . facebook . buck . core . build . engine . manifest . ManifestUtil . fromMap ( new com . facebook . buck . core . rulekey . RuleKey ( \"cc\" ) , com . google . common . collect . ImmutableMap . of ( key , com . google . common . collect . ImmutableMap . of ( com . facebook . buck . core . build . engine . manifest . ManifestTest . RESOLVER . getRelativePath ( input ) . toString ( ) , com . google . common . hash . HashCode . fromInt ( 1 ) ) ) ) ; com . facebook . buck . util . cache . FileHashCache fileHashCache = new com . facebook . buck . testutil . FakeFileHashCache ( com . google . common . collect . ImmutableMap . of ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( manifest . lookup ( fileHashCache , com . facebook . buck . core . build . engine . manifest . ManifestTest . RESOLVER , com . google . common . collect . ImmutableSet . of ( input ) ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . empty ( ) ) )", "total": "lookupMissingHeader ( ) { com . facebook . buck . core . rulekey . RuleKey key = new com . facebook . buck . core . rulekey . RuleKey ( \"aa\" ) ; com . facebook . buck . core . sourcepath . SourcePath input = com . facebook . buck . core . sourcepath . FakeSourcePath . of ( \"input.h\" ) ; com . facebook . buck . core . build . engine . manifest . Manifest manifest = com . facebook . buck . core . build . engine . manifest . ManifestUtil . fromMap ( new com . facebook . buck . core . rulekey . RuleKey ( \"cc\" ) , com . google . common . collect . ImmutableMap . of ( key , com . google . common . collect . ImmutableMap . of ( com . facebook . buck . core . build . engine . manifest . ManifestTest . RESOLVER . getRelativePath ( input ) . toString ( ) , com . google . common . hash . HashCode . fromInt ( 1 ) ) ) ) ; com . facebook . buck . util . cache . FileHashCache fileHashCache = new com . facebook . buck . testutil . FakeFileHashCache ( com . google . common . collect . ImmutableMap . of ( ) ) ; \"<AssertPlaceHolder>\" ; } lookup ( com . facebook . buck . util . hashing . FileHashLoader , com . facebook . buck . core . sourcepath . resolver . SourcePathResolver , com . google . common . collect . ImmutableSet ) { com . google . common . collect . ImmutableSet . Builder < java . lang . String > interestingPathsBuilder = new com . google . common . collect . ImmutableSet . Builder < > ( ) ; for ( com . facebook . buck . util . types . Pair < ? , int [ ] > entry : entries ) { for ( int hashIndex : entry . getSecond ( ) ) { interestingPathsBuilder . add ( inputs . get ( hashes . get ( hashIndex ) . getFirst ( ) ) ) ; } } com . google . common . collect . ImmutableSet < java . lang . String > interestingPaths = interestingPathsBuilder . build ( ) ; com . google . common . collect . ImmutableListMultimap < java . lang . String , com . facebook . buck . core . sourcepath . SourcePath > mappedUniverse = com . facebook . buck . core . build . engine . manifest . Manifest . index ( universe , ( path ) -> sourcePathToManifestHeader ( path , resolver ) , interestingPaths :: contains ) ; for ( com . facebook . buck . util . types . Pair < com . facebook . buck . core . rulekey . RuleKey , int [ ] > entry : entries ) { if ( hashesMatch ( fileHashLoader , resolver , mappedUniverse , entry . getSecond ( ) ) ) { return java . util . Optional . of ( entry . getFirst ( ) ) ; } } return java . util . Optional . empty ( ) ; }", "answer": "org . junit . Assert . assertThat ( manifest . lookup ( fileHashCache , com . facebook . buck . core . build . engine . manifest . ManifestTest . RESOLVER , com . google . common . collect . ImmutableSet . of ( input ) ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . empty ( ) ) )"}
{"focal": "ofSIUnits ( long , int ) { if ( ( seconds == 0 ) && ( fraction == 0 ) ) { return net . time4j . MachineTime . UTC_ZERO ; } return new net . time4j . MachineTime ( seconds , fraction , UTC ) ; }", "testMethod": "getRealDurationOfMomentInterval ( ) { net . time4j . Moment m1 = net . time4j . Moment . of ( 1278028823 , TimeScale . UTC ) ; net . time4j . Moment m2 = net . time4j . Moment . of ( 1278028826 , 1 , TimeScale . UTC ) ; net . time4j . MachineTime < net . time4j . SI > duration = net . time4j . range . MomentInterval . between ( m1 , m2 ) . getRealDuration ( ) ; net . time4j . MachineTime < net . time4j . SI > expected = net . time4j . MachineTime . ofSIUnits ( 3L , 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( duration , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "getRealDurationOfMomentInterval ( ) { net . time4j . Moment m1 = net . time4j . Moment . of ( 1278028823 , TimeScale . UTC ) ; net . time4j . Moment m2 = net . time4j . Moment . of ( 1278028826 , 1 , TimeScale . UTC ) ; net . time4j . MachineTime < net . time4j . SI > duration = net . time4j . range . MomentInterval . between ( m1 , m2 ) . getRealDuration ( ) ; net . time4j . MachineTime < net . time4j . SI > expected = net . time4j . MachineTime . ofSIUnits ( 3L , 1 ) ; \"<AssertPlaceHolder>\" ; } ofSIUnits ( long , int ) { if ( ( seconds == 0 ) && ( fraction == 0 ) ) { return net . time4j . MachineTime . UTC_ZERO ; } return new net . time4j . MachineTime ( seconds , fraction , UTC ) ; }", "answer": "org . junit . Assert . assertThat ( duration , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getCacheMaxSizeRecords ( ) { return cacheMaxSizeRecords ; }", "testMethod": "givenZeroValue_whenSetCacheMaxSizeRecords_thenValueIsStored ( ) { final long validCacheMaxSizeRecords = 0 ; config . setCacheMaxSizeRecords ( validCacheMaxSizeRecords ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( config . getCacheMaxSizeRecords ( ) , org . hamcrest . CoreMatchers . equalTo ( validCacheMaxSizeRecords ) )", "total": "givenZeroValue_whenSetCacheMaxSizeRecords_thenValueIsStored ( ) { final long validCacheMaxSizeRecords = 0 ; config . setCacheMaxSizeRecords ( validCacheMaxSizeRecords ) ; \"<AssertPlaceHolder>\" ; } getCacheMaxSizeRecords ( ) { return cacheMaxSizeRecords ; }", "answer": "org . junit . Assert . assertThat ( config . getCacheMaxSizeRecords ( ) , org . hamcrest . CoreMatchers . equalTo ( validCacheMaxSizeRecords ) )"}
{"focal": "render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "testMethod": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>input<sp>|<sp>ceil<sp>}}\" , \"5\" , \"{<sp>\\\"input\\\":<sp>4.6<sp>}\" } , new java . lang . String [ ] { \"{{<sp>'4.3'<sp>|<sp>ceil<sp>}}\" , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>price<sp>|<sp>ceil<sp>}}\" , \"5\" , \"{<sp>\\\"price\\\":<sp>4.6<sp>}\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( test [ 2 ] ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "total": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{{<sp>input<sp>|<sp>ceil<sp>}}\" , \"5\" , \"{<sp>\\\"input\\\":<sp>4.6<sp>}\" } , new java . lang . String [ ] { \"{{<sp>'4.3'<sp>|<sp>ceil<sp>}}\" , \"5\" , \"{}\" } , new java . lang . String [ ] { \"{{<sp>price<sp>|<sp>ceil<sp>}}\" , \"5\" , \"{<sp>\\\"price\\\":<sp>4.6<sp>}\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( test [ 2 ] ) ) ; \"<AssertPlaceHolder>\" ; } } render ( java . util . Map ) { if ( this . protectionSettings . isRenderTimeLimited ( ) ) { return render ( variables , liqp . Executors . newSingleThreadExecutor ( ) , true ) ; } else { if ( ( this . templateSize ) > ( this . protectionSettings . maxTemplateSizeBytes ) ) { throw new java . lang . RuntimeException ( ( ( \"template<sp>exceeds<sp>\" + ( this . protectionSettings . maxTemplateSizeBytes ) ) + \"<sp>bytes\" ) ) ; } return renderUnguarded ( variables ) ; } }", "answer": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )"}
{"focal": "verify ( org . mockserver . client . HttpRequest [ ] ) { if ( ( ( httpRequests == null ) || ( ( httpRequests . length ) == 0 ) ) || ( ( httpRequests [ 0 ] ) == null ) ) { throw new java . lang . IllegalArgumentException ( \"verify(HttpRequest...)<sp>requires<sp>a<sp>non<sp>null<sp>non<sp>empty<sp>array<sp>of<sp>HttpRequest<sp>objects\" ) ; } org . mockserver . verify . VerificationSequence verificationSequence = new org . mockserver . verify . VerificationSequence ( ) . withRequests ( httpRequests ) ; java . lang . String result = sendRequest ( request ( ) . withMethod ( \"PUT\" ) . withPath ( calculatePath ( \"verifySequence\" ) ) . withBody ( verificationSequenceSerializer . serialize ( verificationSequence ) , StandardCharsets . UTF_8 ) ) . getBodyAsString ( ) ; if ( ( result != null ) && ( ! ( result . isEmpty ( ) ) ) ) { throw new java . lang . AssertionError ( result ) ; } return clientClass . cast ( this ) ; }", "testMethod": "shouldPassVerificationSequenceWithNoRequest ( ) { org . mockserver . filters . MockServerEventLog logFilter = new org . mockserver . filters . MockServerEventLog ( mockLogFormatter , org . mockserver . filters . LogFilterRequestLogEntryVerificationSequenceTest . scheduler ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"one\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"multi\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"three\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"multi\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"four\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( logFilter . verify ( new org . mockserver . verify . VerificationSequence ( ) . withRequests ( ) ) , org . hamcrest . CoreMatchers . is ( \"\" ) )", "total": "shouldPassVerificationSequenceWithNoRequest ( ) { org . mockserver . filters . MockServerEventLog logFilter = new org . mockserver . filters . MockServerEventLog ( mockLogFormatter , org . mockserver . filters . LogFilterRequestLogEntryVerificationSequenceTest . scheduler ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"one\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"multi\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"three\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"multi\" ) ) ) ; logFilter . add ( new org . mockserver . log . model . RequestLogEntry ( request ( \"four\" ) ) ) ; \"<AssertPlaceHolder>\" ; } verify ( org . mockserver . client . HttpRequest [ ] ) { if ( ( ( httpRequests == null ) || ( ( httpRequests . length ) == 0 ) ) || ( ( httpRequests [ 0 ] ) == null ) ) { throw new java . lang . IllegalArgumentException ( \"verify(HttpRequest...)<sp>requires<sp>a<sp>non<sp>null<sp>non<sp>empty<sp>array<sp>of<sp>HttpRequest<sp>objects\" ) ; } org . mockserver . verify . VerificationSequence verificationSequence = new org . mockserver . verify . VerificationSequence ( ) . withRequests ( httpRequests ) ; java . lang . String result = sendRequest ( request ( ) . withMethod ( \"PUT\" ) . withPath ( calculatePath ( \"verifySequence\" ) ) . withBody ( verificationSequenceSerializer . serialize ( verificationSequence ) , StandardCharsets . UTF_8 ) ) . getBodyAsString ( ) ; if ( ( result != null ) && ( ! ( result . isEmpty ( ) ) ) ) { throw new java . lang . AssertionError ( result ) ; } return clientClass . cast ( this ) ; }", "answer": "org . junit . Assert . assertThat ( logFilter . verify ( new org . mockserver . verify . VerificationSequence ( ) . withRequests ( ) ) , org . hamcrest . CoreMatchers . is ( \"\" ) )"}
{"focal": "validate ( com . hotels . bdp . circustrain . metrics . conf . Graphite ) { if ( graphite == null ) { graphite = new com . hotels . bdp . circustrain . metrics . conf . Graphite ( ) ; } com . hotels . bdp . circustrain . metrics . conf . Graphite validated = loader . load ( graphite . getConfig ( ) ) ; if ( ( graphite . getHost ( ) ) != null ) { validated . setHost ( graphite . getHost ( ) ) ; } if ( ( graphite . getPrefix ( ) ) != null ) { validated . setPrefix ( graphite . getPrefix ( ) ) ; } if ( ( graphite . getNamespace ( ) ) != null ) { validated . setNamespace ( graphite . getNamespace ( ) ) ; } validated . init ( ) ; if ( validated . isEnabled ( ) ) { if ( ( ( ( validated . getHost ( ) ) == null ) || ( ( validated . getPrefix ( ) ) == null ) ) || ( ( validated . getNamespace ( ) ) == null ) ) { throw new com . hotels . bdp . circustrain . api . CircusTrainException ( java . lang . String . format ( \"Missing<sp>graphite<sp>configuration<sp>property:<sp>host[%s],<sp>prefix[%s],<sp>namespace[%s]\" , validated . getHost ( ) , validated . getPrefix ( ) , validated . getNamespace ( ) ) ) ; } } return new com . hotels . bdp . circustrain . metrics . conf . ValidatedGraphite ( validated ) ; }", "testMethod": "nullTableLocation ( ) { replicaTable . setTableLocation ( null ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . circustrain . api . conf . TableReplication > > violations = validator . validate ( tableReplication ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "nullTableLocation ( ) { replicaTable . setTableLocation ( null ) ; java . util . Set < javax . validation . ConstraintViolation < com . hotels . bdp . circustrain . api . conf . TableReplication > > violations = validator . validate ( tableReplication ) ; \"<AssertPlaceHolder>\" ; } validate ( com . hotels . bdp . circustrain . metrics . conf . Graphite ) { if ( graphite == null ) { graphite = new com . hotels . bdp . circustrain . metrics . conf . Graphite ( ) ; } com . hotels . bdp . circustrain . metrics . conf . Graphite validated = loader . load ( graphite . getConfig ( ) ) ; if ( ( graphite . getHost ( ) ) != null ) { validated . setHost ( graphite . getHost ( ) ) ; } if ( ( graphite . getPrefix ( ) ) != null ) { validated . setPrefix ( graphite . getPrefix ( ) ) ; } if ( ( graphite . getNamespace ( ) ) != null ) { validated . setNamespace ( graphite . getNamespace ( ) ) ; } validated . init ( ) ; if ( validated . isEnabled ( ) ) { if ( ( ( ( validated . getHost ( ) ) == null ) || ( ( validated . getPrefix ( ) ) == null ) ) || ( ( validated . getNamespace ( ) ) == null ) ) { throw new com . hotels . bdp . circustrain . api . CircusTrainException ( java . lang . String . format ( \"Missing<sp>graphite<sp>configuration<sp>property:<sp>host[%s],<sp>prefix[%s],<sp>namespace[%s]\" , validated . getHost ( ) , validated . getPrefix ( ) , validated . getNamespace ( ) ) ) ; } } return new com . hotels . bdp . circustrain . metrics . conf . ValidatedGraphite ( validated ) ; }", "answer": "org . junit . Assert . assertThat ( violations . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getCommandPrefix ( com . facebook . buck . core . sourcepath . resolver . SourcePathResolver ) { return com . google . common . collect . ImmutableList . of ( ) ; }", "testMethod": "pathSourcePath ( ) { com . facebook . buck . core . rules . BuildRuleResolver resolver = new com . facebook . buck . core . rules . resolver . impl . TestActionGraphBuilder ( ) ; com . facebook . buck . core . sourcepath . resolver . SourcePathResolver pathResolver = com . facebook . buck . core . sourcepath . resolver . impl . DefaultSourcePathResolver . from ( new com . facebook . buck . core . rules . SourcePathRuleFinder ( resolver ) ) ; com . facebook . buck . io . filesystem . ProjectFilesystem filesystem = new com . facebook . buck . io . filesystem . impl . FakeProjectFilesystem ( ) ; com . facebook . buck . core . sourcepath . SourcePath path = com . facebook . buck . core . sourcepath . PathSourcePath . of ( filesystem , java . nio . file . Paths . get ( \"output\" ) ) ; com . facebook . buck . core . toolchain . tool . impl . CommandTool tool = new com . facebook . buck . core . toolchain . tool . impl . CommandTool . Builder ( ) . addArg ( com . facebook . buck . rules . args . SourcePathArg . of ( path ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tool . getCommandPrefix ( pathResolver ) , org . hamcrest . Matchers . contains ( pathResolver . getAbsolutePath ( path ) . toString ( ) ) )", "total": "pathSourcePath ( ) { com . facebook . buck . core . rules . BuildRuleResolver resolver = new com . facebook . buck . core . rules . resolver . impl . TestActionGraphBuilder ( ) ; com . facebook . buck . core . sourcepath . resolver . SourcePathResolver pathResolver = com . facebook . buck . core . sourcepath . resolver . impl . DefaultSourcePathResolver . from ( new com . facebook . buck . core . rules . SourcePathRuleFinder ( resolver ) ) ; com . facebook . buck . io . filesystem . ProjectFilesystem filesystem = new com . facebook . buck . io . filesystem . impl . FakeProjectFilesystem ( ) ; com . facebook . buck . core . sourcepath . SourcePath path = com . facebook . buck . core . sourcepath . PathSourcePath . of ( filesystem , java . nio . file . Paths . get ( \"output\" ) ) ; com . facebook . buck . core . toolchain . tool . impl . CommandTool tool = new com . facebook . buck . core . toolchain . tool . impl . CommandTool . Builder ( ) . addArg ( com . facebook . buck . rules . args . SourcePathArg . of ( path ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; } getCommandPrefix ( com . facebook . buck . core . sourcepath . resolver . SourcePathResolver ) { return com . google . common . collect . ImmutableList . of ( ) ; }", "answer": "org . junit . Assert . assertThat ( tool . getCommandPrefix ( pathResolver ) , org . hamcrest . Matchers . contains ( pathResolver . getAbsolutePath ( path ) . toString ( ) ) )"}
{"focal": "create ( com . github . mygreen . supercsv . annotation . constraint . CsvNumberMax , java . util . Optional , com . github . mygreen . supercsv . builder . FieldAccessor , com . github . mygreen . supercsv . cellprocessor . format . TextFormatter , com . github . mygreen . supercsv . builder . Configuration ) { @ com . github . mygreen . supercsv . cellprocessor . constraint . SuppressWarnings ( \"unchecked\" ) final com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > typeFormatter = ( ( com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > ) ( formatter ) ) ; final N max ; try { max = typeFormatter . parse ( anno . value ( ) ) ; } catch ( com . github . mygreen . supercsv . cellprocessor . format . TextParseException e ) { throw new com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException ( anno , com . github . mygreen . supercsv . localization . MessageBuilder . create ( \"anno.attr.invalidType\" ) . var ( \"property\" , field . getNameWithClass ( ) ) . varWithAnno ( \"anno\" , anno . annotationType ( ) ) . var ( \"attrName\" , \"value\" ) . var ( \"attrValue\" , anno . value ( ) ) . varWithClass ( \"type\" , field . getType ( ) ) . var ( \"pattern\" , typeFormatter . getPattern ( ) . orElseGet ( null ) ) . format ( true ) , e ) ; } final com . github . mygreen . supercsv . cellprocessor . constraint . NumberMax < N > processor = next . map ( ( n ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter , n ) ) . orElseGet ( ( ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter ) ) ; processor . setValidationMessage ( anno . message ( ) ) ; return java . util . Optional . of ( processor ) ; }", "testMethod": "testCreate_attrMinMax_wrong ( ) { com . github . mygreen . supercsv . builder . FieldAccessor field = getFieldAccessor ( com . github . mygreen . supercsv . cellprocessor . constraint . LengthBetweenFactoryTest . ErrorCsv . class , \"col_min_max_wrong\" , comparator ) ; com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder builder = ( ( com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder ) ( builderResolver . resolve ( java . lang . String . class ) ) ) ; com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < java . lang . String > formatter = builder . getFormatter ( field , config ) ; com . github . mygreen . supercsv . annotation . constraint . CsvLengthBetween anno = field . getAnnotationsByGroup ( com . github . mygreen . supercsv . annotation . constraint . CsvLengthBetween . class , groupEmpty ) . get ( 0 ) ; try { factory . create ( anno , java . util . Optional . empty ( ) , field , formatter , config ) ; org . junit . Assert . fail ( ) ; } catch ( java . lang . Exception e ) { \"<AssertPlaceHolder>\" . isInstanceOf ( com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException . class ) . hasMessage ( \"'%s'<sp><sp>@CsvLengthBetween<sp><sp>'min'<sp>10<sp>'max'<sp>5\" , field . getNameWithClass ( ) ) ; } }", "assertLine": "org . junit . Assert . assertThat ( e )", "total": "testCreate_attrMinMax_wrong ( ) { com . github . mygreen . supercsv . builder . FieldAccessor field = getFieldAccessor ( com . github . mygreen . supercsv . cellprocessor . constraint . LengthBetweenFactoryTest . ErrorCsv . class , \"col_min_max_wrong\" , comparator ) ; com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder builder = ( ( com . github . mygreen . supercsv . builder . standard . StringProcessorBuilder ) ( builderResolver . resolve ( java . lang . String . class ) ) ) ; com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < java . lang . String > formatter = builder . getFormatter ( field , config ) ; com . github . mygreen . supercsv . annotation . constraint . CsvLengthBetween anno = field . getAnnotationsByGroup ( com . github . mygreen . supercsv . annotation . constraint . CsvLengthBetween . class , groupEmpty ) . get ( 0 ) ; try { factory . create ( anno , java . util . Optional . empty ( ) , field , formatter , config ) ; org . junit . Assert . fail ( ) ; } catch ( java . lang . Exception e ) { \"<AssertPlaceHolder>\" . isInstanceOf ( com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException . class ) . hasMessage ( \"'%s'<sp><sp>@CsvLengthBetween<sp><sp>'min'<sp>10<sp>'max'<sp>5\" , field . getNameWithClass ( ) ) ; } } create ( com . github . mygreen . supercsv . annotation . constraint . CsvNumberMax , java . util . Optional , com . github . mygreen . supercsv . builder . FieldAccessor , com . github . mygreen . supercsv . cellprocessor . format . TextFormatter , com . github . mygreen . supercsv . builder . Configuration ) { @ com . github . mygreen . supercsv . cellprocessor . constraint . SuppressWarnings ( \"unchecked\" ) final com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > typeFormatter = ( ( com . github . mygreen . supercsv . cellprocessor . format . TextFormatter < N > ) ( formatter ) ) ; final N max ; try { max = typeFormatter . parse ( anno . value ( ) ) ; } catch ( com . github . mygreen . supercsv . cellprocessor . format . TextParseException e ) { throw new com . github . mygreen . supercsv . exception . SuperCsvInvalidAnnotationException ( anno , com . github . mygreen . supercsv . localization . MessageBuilder . create ( \"anno.attr.invalidType\" ) . var ( \"property\" , field . getNameWithClass ( ) ) . varWithAnno ( \"anno\" , anno . annotationType ( ) ) . var ( \"attrName\" , \"value\" ) . var ( \"attrValue\" , anno . value ( ) ) . varWithClass ( \"type\" , field . getType ( ) ) . var ( \"pattern\" , typeFormatter . getPattern ( ) . orElseGet ( null ) ) . format ( true ) , e ) ; } final com . github . mygreen . supercsv . cellprocessor . constraint . NumberMax < N > processor = next . map ( ( n ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter , n ) ) . orElseGet ( ( ) -> new NumberMax < com . github . mygreen . supercsv . cellprocessor . constraint . N > ( max , anno . inclusive ( ) , typeFormatter ) ) ; processor . setValidationMessage ( anno . message ( ) ) ; return java . util . Optional . of ( processor ) ; }", "answer": "org . junit . Assert . assertThat ( e )"}
{"focal": "date ( java . lang . String ) { try { return org . easyrec . store . dao . plugin . impl . LogEntryDAOMysqlImplTest . DATE_FORMAT . parse ( date ) ; } catch ( java . text . ParseException e ) { org . junit . Assert . fail ( \"Could<sp>not<sp>parse<sp>date!\" ) ; return null ; } }", "testMethod": "getComputationDurationForDate_shouldReturnZeroIfEmptyTable ( ) { logEntryDAO . deleteLogEntries ( ) ; long milliseconds = logEntryDAO . getComputationDurationForDate ( org . easyrec . store . dao . plugin . impl . LogEntryDAOMysqlImplTest . date ( \"2011-02-23<sp>00:00:01\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( milliseconds , is ( 0L ) )", "total": "getComputationDurationForDate_shouldReturnZeroIfEmptyTable ( ) { logEntryDAO . deleteLogEntries ( ) ; long milliseconds = logEntryDAO . getComputationDurationForDate ( org . easyrec . store . dao . plugin . impl . LogEntryDAOMysqlImplTest . date ( \"2011-02-23<sp>00:00:01\" ) ) ; \"<AssertPlaceHolder>\" ; } date ( java . lang . String ) { try { return org . easyrec . store . dao . plugin . impl . LogEntryDAOMysqlImplTest . DATE_FORMAT . parse ( date ) ; } catch ( java . text . ParseException e ) { org . junit . Assert . fail ( \"Could<sp>not<sp>parse<sp>date!\" ) ; return null ; } }", "answer": "org . junit . Assert . assertThat ( milliseconds , is ( 0L ) )"}
{"focal": "getStubHttpServerPort ( ) { if ( ! ( this . started ) ) { throw new java . lang . IllegalStateException ( \"The<sp>stub<sp>http<sp>server<sp>hasn't<sp>been<sp>started<sp>yet.\" ) ; } return server . getPort ( ) ; }", "testMethod": "getStubHttpServerPort ( ) { final net . jadler . stubbing . server . StubHttpServer server = mock ( net . jadler . stubbing . server . StubHttpServer . class ) ; when ( server . getPort ( ) ) . thenReturn ( net . jadler . JadlerMockerTest . PORT ) ; final net . jadler . stubbing . server . StubHttpServerManager serverManager = new net . jadler . JadlerMocker ( server ) ; serverManager . start ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serverManager . getStubHttpServerPort ( ) , org . hamcrest . Matchers . is ( net . jadler . JadlerMockerTest . PORT ) )", "total": "getStubHttpServerPort ( ) { final net . jadler . stubbing . server . StubHttpServer server = mock ( net . jadler . stubbing . server . StubHttpServer . class ) ; when ( server . getPort ( ) ) . thenReturn ( net . jadler . JadlerMockerTest . PORT ) ; final net . jadler . stubbing . server . StubHttpServerManager serverManager = new net . jadler . JadlerMocker ( server ) ; serverManager . start ( ) ; \"<AssertPlaceHolder>\" ; } getStubHttpServerPort ( ) { if ( ! ( this . started ) ) { throw new java . lang . IllegalStateException ( \"The<sp>stub<sp>http<sp>server<sp>hasn't<sp>been<sp>started<sp>yet.\" ) ; } return server . getPort ( ) ; }", "answer": "org . junit . Assert . assertThat ( serverManager . getStubHttpServerPort ( ) , org . hamcrest . Matchers . is ( net . jadler . JadlerMockerTest . PORT ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } else if ( obj instanceof net . time4j . clock . AdjustableClock ) { net . time4j . clock . AdjustableClock that = ( ( net . time4j . clock . AdjustableClock ) ( obj ) ) ; return ( ( ( this . source . equals ( that . source ) ) && ( ( this . offsetAmount ) == ( that . offsetAmount ) ) ) && ( ( this . offsetUnit ) == ( that . offsetUnit ) ) ) && ( ( this . pulse ) == ( that . pulse ) ) ; } else { return false ; } }", "testMethod": "roundTripOfZonalDateTime ( ) { net . time4j . ZonalDateTime zdt = Moment . UNIX_EPOCH . inZonalView ( \"Europe/Berlin\" ) ; java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutputStream oos = new java . io . ObjectOutputStream ( baos ) ; zdt . write ( oos ) ; byte [ ] data = baos . toByteArray ( ) ; oos . close ( ) ; java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( data ) ; java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( bais ) ; net . time4j . ZonalDateTime ser = net . time4j . ZonalDateTime . read ( ois ) ; ois . close ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( zdt . equals ( ser ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "roundTripOfZonalDateTime ( ) { net . time4j . ZonalDateTime zdt = Moment . UNIX_EPOCH . inZonalView ( \"Europe/Berlin\" ) ; java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutputStream oos = new java . io . ObjectOutputStream ( baos ) ; zdt . write ( oos ) ; byte [ ] data = baos . toByteArray ( ) ; oos . close ( ) ; java . io . ByteArrayInputStream bais = new java . io . ByteArrayInputStream ( data ) ; java . io . ObjectInputStream ois = new java . io . ObjectInputStream ( bais ) ; net . time4j . ZonalDateTime ser = net . time4j . ZonalDateTime . read ( ois ) ; ois . close ( ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } else if ( obj instanceof net . time4j . clock . AdjustableClock ) { net . time4j . clock . AdjustableClock that = ( ( net . time4j . clock . AdjustableClock ) ( obj ) ) ; return ( ( ( this . source . equals ( that . source ) ) && ( ( this . offsetAmount ) == ( that . offsetAmount ) ) ) && ( ( this . offsetUnit ) == ( that . offsetUnit ) ) ) && ( ( this . pulse ) == ( that . pulse ) ) ; } else { return false ; } }", "answer": "org . junit . Assert . assertThat ( zdt . equals ( ser ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "setPageNumber ( int ) { super . setPageNumber ( pageNumber ) ; context . setPageNumbers ( getPageNumber ( ) , getNumberOfPages ( ) ) ; }", "testMethod": "testConfigure ( ) { org . pentaho . reporting . engine . classic . core . modules . gui . base . PreviewPane reportPane = mock ( org . pentaho . reporting . engine . classic . core . modules . gui . base . PreviewPane . class ) ; boolean result = plugin . configure ( reportPane ) ; verify ( reportPane ) . setPageNumber ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )", "total": "testConfigure ( ) { org . pentaho . reporting . engine . classic . core . modules . gui . base . PreviewPane reportPane = mock ( org . pentaho . reporting . engine . classic . core . modules . gui . base . PreviewPane . class ) ; boolean result = plugin . configure ( reportPane ) ; verify ( reportPane ) . setPageNumber ( 1 ) ; \"<AssertPlaceHolder>\" ; } setPageNumber ( int ) { super . setPageNumber ( pageNumber ) ; context . setPageNumbers ( getPageNumber ( ) , getNumberOfPages ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )"}
{"focal": "add ( ru . szhernovoy . storages . User ) { this . storage . add ( user ) ; user . setId ( ( ++ ( id ) ) ) ; return user ; }", "testMethod": "whenAddUserToStorageThatContainsIt ( ) { ru . szhernovoy . storage . User userFirst = new ru . szhernovoy . storage . User ( \"Sergey\" ) ; ru . szhernovoy . storage . UserStorage myStorage = new ru . szhernovoy . storage . UserStorage ( ) ; boolean result = myStorage . add ( userFirst ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( true ) )", "total": "whenAddUserToStorageThatContainsIt ( ) { ru . szhernovoy . storage . User userFirst = new ru . szhernovoy . storage . User ( \"Sergey\" ) ; ru . szhernovoy . storage . UserStorage myStorage = new ru . szhernovoy . storage . UserStorage ( ) ; boolean result = myStorage . add ( userFirst ) ; \"<AssertPlaceHolder>\" ; } add ( ru . szhernovoy . storages . User ) { this . storage . add ( user ) ; user . setId ( ( ++ ( id ) ) ) ; return user ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "findClasses ( ) { return findClasses ( null ) ; }", "testMethod": "findsClassesFromZip ( ) { com . poolik . classfinder . ClassFinder classFinder = new com . poolik . classfinder . ClassFinder ( ) . add ( createZipTo ( new java . io . File ( getTestFolder ( ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( classFinder . findClasses ( ) . size ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "findsClassesFromZip ( ) { com . poolik . classfinder . ClassFinder classFinder = new com . poolik . classfinder . ClassFinder ( ) . add ( createZipTo ( new java . io . File ( getTestFolder ( ) ) ) ) ; \"<AssertPlaceHolder>\" ; } findClasses ( ) { return findClasses ( null ) ; }", "answer": "org . junit . Assert . assertThat ( classFinder . findClasses ( ) . size ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "testMethod": "shouldPersistWorkflows ( ) { com . spotify . styx . model . Workflow workflow = com . spotify . styx . model . Workflow . create ( \"test\" , com . spotify . styx . storage . FULL_WORKFLOW_CONFIGURATION ) ; storage . store ( workflow ) ; java . util . Optional < com . spotify . styx . model . Workflow > retrieved = storage . workflow ( workflow . id ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( retrieved , org . hamcrest . Matchers . is ( java . util . Optional . of ( workflow ) ) )", "total": "shouldPersistWorkflows ( ) { com . spotify . styx . model . Workflow workflow = com . spotify . styx . model . Workflow . create ( \"test\" , com . spotify . styx . storage . FULL_WORKFLOW_CONFIGURATION ) ; storage . store ( workflow ) ; java . util . Optional < com . spotify . styx . model . Workflow > retrieved = storage . workflow ( workflow . id ( ) ) ; \"<AssertPlaceHolder>\" ; } is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( retrieved , org . hamcrest . Matchers . is ( java . util . Optional . of ( workflow ) ) )"}
{"focal": "fetchCount ( ) { return ( statistics . getEntityFetchCount ( ) ) - ( fetches ) ; }", "testMethod": "artistCreditReferenceDoesNotHitDatabase ( ) { fm . last . musicbrainz . data . model . Release release = ( ( fm . last . musicbrainz . data . model . Release ) ( session . load ( fm . last . musicbrainz . data . model . Release . class , 5 ) ) ) ; fm . last . musicbrainz . data . model . ArtistCredit credit = release . getArtistCredit ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fetchCount ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "artistCreditReferenceDoesNotHitDatabase ( ) { fm . last . musicbrainz . data . model . Release release = ( ( fm . last . musicbrainz . data . model . Release ) ( session . load ( fm . last . musicbrainz . data . model . Release . class , 5 ) ) ) ; fm . last . musicbrainz . data . model . ArtistCredit credit = release . getArtistCredit ( ) ; \"<AssertPlaceHolder>\" ; } fetchCount ( ) { return ( statistics . getEntityFetchCount ( ) ) - ( fetches ) ; }", "answer": "org . junit . Assert . assertThat ( fetchCount ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "isAllowLateRegistration ( ) { return allowLateRegistration ; }", "testMethod": "allowLateRegistration_setToTrueMixedCase ( ) { eventBusService . init ( com . google . common . collect . ImmutableMap . of ( EventBusServiceDefault . KEY_ALLOW_LATE_REGISTRATION , \"TrUe\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( eventBusService . isAllowLateRegistration ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "allowLateRegistration_setToTrueMixedCase ( ) { eventBusService . init ( com . google . common . collect . ImmutableMap . of ( EventBusServiceDefault . KEY_ALLOW_LATE_REGISTRATION , \"TrUe\" ) ) ; \"<AssertPlaceHolder>\" ; } isAllowLateRegistration ( ) { return allowLateRegistration ; }", "answer": "org . junit . Assert . assertThat ( eventBusService . isAllowLateRegistration ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "nextKeyValue ( ) { if ( ( key ) == null ) { key = new org . apache . hadoop . io . LongWritable ( ) ; } key . set ( pos ) ; if ( ( value ) == null ) { value = new org . apache . hadoop . io . Text ( ) ; } if ( ( pos ) >= ( end ) ) { key = null ; value = null ; org . apache . crunch . io . text . csv . CSVRecordReader . LOGGER . info ( \"End<sp>of<sp>split<sp>reached,<sp>ending<sp>processing.<sp>Total<sp>records<sp>read<sp>for<sp>this<sp>split:<sp>{}\" , totalRecordsRead ) ; close ( ) ; return false ; } final int newSize = csvLineReader . readCSVLine ( value ) ; if ( newSize == 0 ) { org . apache . crunch . io . text . csv . CSVRecordReader . LOGGER . info ( \"End<sp>of<sp>file<sp>reached.<sp>Ending<sp>processing.<sp>Total<sp>records<sp>read<sp>for<sp>this<sp>split:<sp>{}\" , totalRecordsRead ) ; return false ; } pos += newSize ; ( totalRecordsRead ) ++ ; return true ; }", "testMethod": "nextKeyValue_noRecord_emptyPartition ( ) { when ( consumer . poll ( anyLong ( ) ) ) . thenReturn ( new org . apache . kafka . clients . consumer . ConsumerRecords ( java . util . Collections . < org . apache . kafka . common . TopicPartition , java . util . List < org . apache . kafka . clients . consumer . ConsumerRecord < java . lang . String , java . lang . String > > > emptyMap ( ) ) ) ; when ( consumer . beginningOffsets ( java . util . Collections . singletonList ( topicPartition ) ) ) . thenReturn ( java . util . Collections . singletonMap ( topicPartition , endOffset ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( reader . nextKeyValue ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "nextKeyValue_noRecord_emptyPartition ( ) { when ( consumer . poll ( anyLong ( ) ) ) . thenReturn ( new org . apache . kafka . clients . consumer . ConsumerRecords ( java . util . Collections . < org . apache . kafka . common . TopicPartition , java . util . List < org . apache . kafka . clients . consumer . ConsumerRecord < java . lang . String , java . lang . String > > > emptyMap ( ) ) ) ; when ( consumer . beginningOffsets ( java . util . Collections . singletonList ( topicPartition ) ) ) . thenReturn ( java . util . Collections . singletonMap ( topicPartition , endOffset ) ) ; \"<AssertPlaceHolder>\" ; } nextKeyValue ( ) { if ( ( key ) == null ) { key = new org . apache . hadoop . io . LongWritable ( ) ; } key . set ( pos ) ; if ( ( value ) == null ) { value = new org . apache . hadoop . io . Text ( ) ; } if ( ( pos ) >= ( end ) ) { key = null ; value = null ; org . apache . crunch . io . text . csv . CSVRecordReader . LOGGER . info ( \"End<sp>of<sp>split<sp>reached,<sp>ending<sp>processing.<sp>Total<sp>records<sp>read<sp>for<sp>this<sp>split:<sp>{}\" , totalRecordsRead ) ; close ( ) ; return false ; } final int newSize = csvLineReader . readCSVLine ( value ) ; if ( newSize == 0 ) { org . apache . crunch . io . text . csv . CSVRecordReader . LOGGER . info ( \"End<sp>of<sp>file<sp>reached.<sp>Ending<sp>processing.<sp>Total<sp>records<sp>read<sp>for<sp>this<sp>split:<sp>{}\" , totalRecordsRead ) ; return false ; } pos += newSize ; ( totalRecordsRead ) ++ ; return true ; }", "answer": "org . junit . Assert . assertThat ( reader . nextKeyValue ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "next ( ) { try { java . lang . Object object = input . readObject ( ) ; next = type . cast ( object ) ; canGet = true ; return true ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . io . IOException ( e ) ; } catch ( java . io . EOFException e ) { next = null ; canGet = true ; return false ; } catch ( java . io . OptionalDataException e ) { if ( e . eof ) { next = null ; canGet = true ; return false ; } throw e ; } }", "testMethod": "large ( ) { int count = 10000 ; for ( int i = 0 ; i < count ; i ++ ) { put ( 100 ) ; put ( 300 ) ; put ( 200 ) ; put ( 400 ) ; } com . asakusafw . utils . io . Source < org . apache . hadoop . io . IntWritable > results = sort ( ) ; for ( int value : new int [ ] { 100 , 200 , 300 , 400 } ) { for ( int i = 0 ; i < count ; i ++ ) { check ( results , value ) ; } } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results . next ( ) , is ( false ) )", "total": "large ( ) { int count = 10000 ; for ( int i = 0 ; i < count ; i ++ ) { put ( 100 ) ; put ( 300 ) ; put ( 200 ) ; put ( 400 ) ; } com . asakusafw . utils . io . Source < org . apache . hadoop . io . IntWritable > results = sort ( ) ; for ( int value : new int [ ] { 100 , 200 , 300 , 400 } ) { for ( int i = 0 ; i < count ; i ++ ) { check ( results , value ) ; } } \"<AssertPlaceHolder>\" ; } next ( ) { try { java . lang . Object object = input . readObject ( ) ; next = type . cast ( object ) ; canGet = true ; return true ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . io . IOException ( e ) ; } catch ( java . io . EOFException e ) { next = null ; canGet = true ; return false ; } catch ( java . io . OptionalDataException e ) { if ( e . eof ) { next = null ; canGet = true ; return false ; } throw e ; } }", "answer": "org . junit . Assert . assertThat ( results . next ( ) , is ( false ) )"}
{"focal": "allKeysIn ( org . eclipse . equinox . p2 . repository . artifact . IArtifactRepository ) { org . eclipse . equinox . p2 . query . IQueryResult < org . eclipse . equinox . p2 . metadata . IArtifactKey > queryResult = repository . query ( org . eclipse . tycho . repository . testutil . ArtifactRepositoryTestUtils . ANY_ARTIFACT_KEY_QUERY , null ) ; return queryResult . toUnmodifiableSet ( ) ; }", "testMethod": "testPersistEmptyRepository ( ) { java . io . File repoDir = tempManager . newFolder ( \"targetDir\" ) ; subject = org . eclipse . tycho . repository . module . ModuleArtifactRepository . createInstance ( null , repoDir ) ; org . eclipse . equinox . p2 . repository . artifact . IArtifactRepository result = loadRepositoryViaAgent ( repoDir ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allKeysIn ( result ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "testPersistEmptyRepository ( ) { java . io . File repoDir = tempManager . newFolder ( \"targetDir\" ) ; subject = org . eclipse . tycho . repository . module . ModuleArtifactRepository . createInstance ( null , repoDir ) ; org . eclipse . equinox . p2 . repository . artifact . IArtifactRepository result = loadRepositoryViaAgent ( repoDir ) ; \"<AssertPlaceHolder>\" ; } allKeysIn ( org . eclipse . equinox . p2 . repository . artifact . IArtifactRepository ) { org . eclipse . equinox . p2 . query . IQueryResult < org . eclipse . equinox . p2 . metadata . IArtifactKey > queryResult = repository . query ( org . eclipse . tycho . repository . testutil . ArtifactRepositoryTestUtils . ANY_ARTIFACT_KEY_QUERY , null ) ; return queryResult . toUnmodifiableSet ( ) ; }", "answer": "org . junit . Assert . assertThat ( allKeysIn ( result ) . size ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "toString ( ) { return java . text . MessageFormat . format ( \"[{0}]<sp>{1}\" , name ( ) , getDescription ( ) ) ; }", "testMethod": "symlink_self ( ) { java . io . File f1 = touch ( \"a/file1\" , 50 ) ; java . io . File f2 = touch ( \"b/file2\" , 50 ) ; java . io . File f3 = link ( \"c/link\" , f1 , 50 ) ; org . junit . Assume . assumeThat ( f1 . delete ( ) , is ( true ) ) ; f3 . renameTo ( f1 ) ; com . asakusafw . operation . tools . hadoop . fs . Clean c = createService ( 100 ) ; c . run ( args ( 0 , \"-r\" , path ( \"*\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( f2 . toString ( ) , f2 . exists ( ) , is ( false ) )", "total": "symlink_self ( ) { java . io . File f1 = touch ( \"a/file1\" , 50 ) ; java . io . File f2 = touch ( \"b/file2\" , 50 ) ; java . io . File f3 = link ( \"c/link\" , f1 , 50 ) ; org . junit . Assume . assumeThat ( f1 . delete ( ) , is ( true ) ) ; f3 . renameTo ( f1 ) ; com . asakusafw . operation . tools . hadoop . fs . Clean c = createService ( 100 ) ; c . run ( args ( 0 , \"-r\" , path ( \"*\" ) ) ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return java . text . MessageFormat . format ( \"[{0}]<sp>{1}\" , name ( ) , getDescription ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( f2 . toString ( ) , f2 . exists ( ) , is ( false ) )"}
{"focal": "isValidChecksum ( ) { return checksumValid ; }", "testMethod": "testChecksumInvalid ( ) { org . apache . commons . io . FileUtils . writeStringToFile ( checksumPath . toFile ( ) , \"test\" , StandardCharsets . UTF_8 ) ; org . codice . ddf . configuration . migration . MigrationZipFile migrationZipFile = new org . codice . ddf . configuration . migration . MigrationZipFile ( zipPath , keyPath , checksumPath ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( migrationZipFile . isValidChecksum ( ) , org . hamcrest . Matchers . equalTo ( false ) )", "total": "testChecksumInvalid ( ) { org . apache . commons . io . FileUtils . writeStringToFile ( checksumPath . toFile ( ) , \"test\" , StandardCharsets . UTF_8 ) ; org . codice . ddf . configuration . migration . MigrationZipFile migrationZipFile = new org . codice . ddf . configuration . migration . MigrationZipFile ( zipPath , keyPath , checksumPath ) ; \"<AssertPlaceHolder>\" ; } isValidChecksum ( ) { return checksumValid ; }", "answer": "org . junit . Assert . assertThat ( migrationZipFile . isValidChecksum ( ) , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "isEmpty ( ) { return ( this . size ( ) ) == 0 ; }", "testMethod": "fetchAllEventsOfAnUnexistingAlmanachs ( ) { java . util . Collection < com . stratelia . webactiv . almanach . model . EventDetail > allEvents = eventDAO . findAllEvents ( \"almanach1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allEvents . isEmpty ( ) , is ( true ) )", "total": "fetchAllEventsOfAnUnexistingAlmanachs ( ) { java . util . Collection < com . stratelia . webactiv . almanach . model . EventDetail > allEvents = eventDAO . findAllEvents ( \"almanach1\" ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { return ( this . size ( ) ) == 0 ; }", "answer": "org . junit . Assert . assertThat ( allEvents . isEmpty ( ) , is ( true ) )"}
{"focal": "getMdc ( ) { return mdc ; }", "testMethod": "mdcIsSnapshotInTime ( ) { java . util . Map < java . lang . String , java . lang . String > mdc = new java . util . HashMap ( ) ; mdc . put ( \"key\" , \"value1\" ) ; java . util . Map < java . lang . String , java . lang . String > mdcAtStart = new java . util . HashMap ( mdc ) ; uk . org . lidalia . slf4jtest . LoggingEvent event = new uk . org . lidalia . slf4jtest . LoggingEvent ( level , mdc , message ) ; mdc . put ( \"key\" , \"value2\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( event . getMdc ( ) , org . hamcrest . core . Is . is ( mdcAtStart ) )", "total": "mdcIsSnapshotInTime ( ) { java . util . Map < java . lang . String , java . lang . String > mdc = new java . util . HashMap ( ) ; mdc . put ( \"key\" , \"value1\" ) ; java . util . Map < java . lang . String , java . lang . String > mdcAtStart = new java . util . HashMap ( mdc ) ; uk . org . lidalia . slf4jtest . LoggingEvent event = new uk . org . lidalia . slf4jtest . LoggingEvent ( level , mdc , message ) ; mdc . put ( \"key\" , \"value2\" ) ; \"<AssertPlaceHolder>\" ; } getMdc ( ) { return mdc ; }", "answer": "org . junit . Assert . assertThat ( event . getMdc ( ) , org . hamcrest . core . Is . is ( mdcAtStart ) )"}
{"focal": "is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "testMethod": "invokeAnyWithTimeoutShouldPropagateContext ( ) { final java . util . concurrent . Callable < java . lang . String > callable = TEST_KEY :: get ; final java . lang . String result = io . grpc . Context . current ( ) . withValue ( com . spotify . styx . util . TEST_KEY , \"foobar\" ) . call ( ( ) -> sut . invokeAny ( java . util . List . of ( callable ) , 30 , com . spotify . styx . util . SECONDS ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( \"foobar\" ) )", "total": "invokeAnyWithTimeoutShouldPropagateContext ( ) { final java . util . concurrent . Callable < java . lang . String > callable = TEST_KEY :: get ; final java . lang . String result = io . grpc . Context . current ( ) . withValue ( com . spotify . styx . util . TEST_KEY , \"foobar\" ) . call ( ( ) -> sut . invokeAny ( java . util . List . of ( callable ) , 30 , com . spotify . styx . util . SECONDS ) ) ; \"<AssertPlaceHolder>\" ; } is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( \"foobar\" ) )"}
{"focal": "stream ( net . time4j . Duration ) { if ( ( this . isEmpty ( ) ) && ( duration . isPositive ( ) ) ) { return java . util . stream . Stream . empty ( ) ; } net . time4j . range . DateInterval interval = this . toCanonical ( ) ; net . time4j . PlainDate start = interval . getStartAsCalendarDate ( ) ; net . time4j . PlainDate end = interval . getEndAsCalendarDate ( ) ; if ( ( start == null ) || ( end == null ) ) { throw new java . lang . IllegalStateException ( \"Streaming<sp>is<sp>not<sp>supported<sp>for<sp>infinite<sp>intervals.\" ) ; } return net . time4j . range . DateInterval . stream ( duration , start , end ) ; }", "testMethod": "stream3 ( ) { net . time4j . PlainTime start = net . time4j . PlainTime . of ( 15 , 0 ) ; net . time4j . PlainTime end = net . time4j . PlainTime . of ( 20 , 0 ) ; net . time4j . range . ClockInterval interval = net . time4j . range . ClockInterval . between ( start , end ) ; net . time4j . Duration < net . time4j . ClockUnit > duration = net . time4j . Duration . of ( 5 , ClockUnit . HOURS ) ; java . util . List < net . time4j . PlainTime > result = interval . stream ( duration ) . parallel ( ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Collections . singletonList ( start ) ) )", "total": "stream3 ( ) { net . time4j . PlainTime start = net . time4j . PlainTime . of ( 15 , 0 ) ; net . time4j . PlainTime end = net . time4j . PlainTime . of ( 20 , 0 ) ; net . time4j . range . ClockInterval interval = net . time4j . range . ClockInterval . between ( start , end ) ; net . time4j . Duration < net . time4j . ClockUnit > duration = net . time4j . Duration . of ( 5 , ClockUnit . HOURS ) ; java . util . List < net . time4j . PlainTime > result = interval . stream ( duration ) . parallel ( ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" ; } stream ( net . time4j . Duration ) { if ( ( this . isEmpty ( ) ) && ( duration . isPositive ( ) ) ) { return java . util . stream . Stream . empty ( ) ; } net . time4j . range . DateInterval interval = this . toCanonical ( ) ; net . time4j . PlainDate start = interval . getStartAsCalendarDate ( ) ; net . time4j . PlainDate end = interval . getEndAsCalendarDate ( ) ; if ( ( start == null ) || ( end == null ) ) { throw new java . lang . IllegalStateException ( \"Streaming<sp>is<sp>not<sp>supported<sp>for<sp>infinite<sp>intervals.\" ) ; } return net . time4j . range . DateInterval . stream ( duration , start , end ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( java . util . Collections . singletonList ( start ) ) )"}
{"focal": "create ( java . lang . String , java . lang . String ) { com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo attr = new com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo ( ) ; attr . name = name ; attr . value = value ; return attr ; }", "testMethod": "testCreate ( ) { java . util . Optional < com . gh . mygreen . xlsmapper . fieldaccessor . PositionSetter > positionSetter = setterFactory . create ( com . gh . mygreen . xlsmapper . fieldaccessor . PositionSetterFactoryTest . NotPosition . SampleRecord . class , \"test\" ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( positionSetter )", "total": "testCreate ( ) { java . util . Optional < com . gh . mygreen . xlsmapper . fieldaccessor . PositionSetter > positionSetter = setterFactory . create ( com . gh . mygreen . xlsmapper . fieldaccessor . PositionSetterFactoryTest . NotPosition . SampleRecord . class , \"test\" ) ; \"<AssertPlaceHolder>\" . isEmpty ( ) ; } create ( java . lang . String , java . lang . String ) { com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo attr = new com . gh . mygreen . xlsmapper . xml . bind . AnnotationInfo . AttributeInfo ( ) ; attr . name = name ; attr . value = value ; return attr ; }", "answer": "org . junit . Assert . assertThat ( positionSetter )"}
{"focal": "calculateAveragePercentageUsedBy ( org . apache . storm . scheduler . resource . normalization . NormalizedResources , double , double ) { int skippedResourceTypes = 0 ; double total = 0.0 ; if ( usedMemoryMb > totalMemoryMb ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalMemoryMb != 0.0 ) { total += usedMemoryMb / totalMemoryMb ; } else { skippedResourceTypes ++ ; } double totalCpu = getTotalCpu ( ) ; if ( ( used . getTotalCpu ( ) ) > ( getTotalCpu ( ) ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalCpu != 0.0 ) { total += ( used . getTotalCpu ( ) ) / ( getTotalCpu ( ) ) ; } else { skippedResourceTypes ++ ; } if ( ( used . otherResources . length ) > ( otherResources . length ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } for ( int i = 0 ; i < ( otherResources . length ) ; i ++ ) { double totalValue = otherResources [ i ] ; double usedValue ; if ( i >= ( used . otherResources . length ) ) { usedValue = 0.0 ; } else { usedValue = used . otherResources [ i ] ; } if ( usedValue > totalValue ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalValue == 0.0 ) { skippedResourceTypes ++ ; continue ; } total += usedValue / totalValue ; } int divisor = ( 2 + ( otherResources . length ) ) - skippedResourceTypes ; if ( divisor == 0 ) { return 100.0 ; } else { return ( total * 100.0 ) / divisor ; } }", "testMethod": "testCalculateAvgUsageWithNoResourcesInTotal ( ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources resources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; org . apache . storm . scheduler . resource . normalization . NormalizedResources usedResources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; double avg = resources . calculateAveragePercentageUsedBy ( usedResources , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( avg , org . hamcrest . CoreMatchers . is ( 100.0 ) )", "total": "testCalculateAvgUsageWithNoResourcesInTotal ( ) { org . apache . storm . scheduler . resource . normalization . NormalizedResources resources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; org . apache . storm . scheduler . resource . normalization . NormalizedResources usedResources = new org . apache . storm . scheduler . resource . normalization . NormalizedResources ( normalize ( java . util . Collections . emptyMap ( ) ) ) ; double avg = resources . calculateAveragePercentageUsedBy ( usedResources , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; } calculateAveragePercentageUsedBy ( org . apache . storm . scheduler . resource . normalization . NormalizedResources , double , double ) { int skippedResourceTypes = 0 ; double total = 0.0 ; if ( usedMemoryMb > totalMemoryMb ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalMemoryMb != 0.0 ) { total += usedMemoryMb / totalMemoryMb ; } else { skippedResourceTypes ++ ; } double totalCpu = getTotalCpu ( ) ; if ( ( used . getTotalCpu ( ) ) > ( getTotalCpu ( ) ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalCpu != 0.0 ) { total += ( used . getTotalCpu ( ) ) / ( getTotalCpu ( ) ) ; } else { skippedResourceTypes ++ ; } if ( ( used . otherResources . length ) > ( otherResources . length ) ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } for ( int i = 0 ; i < ( otherResources . length ) ; i ++ ) { double totalValue = otherResources [ i ] ; double usedValue ; if ( i >= ( used . otherResources . length ) ) { usedValue = 0.0 ; } else { usedValue = used . otherResources [ i ] ; } if ( usedValue > totalValue ) { throwBecauseUsedIsNotSubsetOfTotal ( used , totalMemoryMb , usedMemoryMb ) ; } if ( totalValue == 0.0 ) { skippedResourceTypes ++ ; continue ; } total += usedValue / totalValue ; } int divisor = ( 2 + ( otherResources . length ) ) - skippedResourceTypes ; if ( divisor == 0 ) { return 100.0 ; } else { return ( total * 100.0 ) / divisor ; } }", "answer": "org . junit . Assert . assertThat ( avg , org . hamcrest . CoreMatchers . is ( 100.0 ) )"}
{"focal": "contains ( java . lang . Object ) { return data . contains ( o ) ; }", "testMethod": "testSearchForExtensionTwoDeepReferenceWithoutType ( ) { ca . uhn . fhir . jpa . dao . r4 . SearchParameter siblingSp = new ca . uhn . fhir . jpa . dao . r4 . SearchParameter ( ) ; siblingSp . addBase ( \"Patient\" ) ; siblingSp . setCode ( \"foobar\" ) ; siblingSp . setType ( org . hl7 . fhir . r4 . model . Enumerations . SearchParamType . REFERENCE ) ; siblingSp . setTitle ( \"FooBar\" ) ; siblingSp . setExpression ( \"Patient.extension('http://acme.org/foo').extension('http://acme.org/bar')\" ) ; siblingSp . setXpathUsage ( org . hl7 . fhir . r4 . model . SearchParameter . XPathUsageType . NORMAL ) ; siblingSp . setStatus ( org . hl7 . fhir . r4 . model . Enumerations . PublicationStatus . ACTIVE ) ; mySearchParameterDao . create ( siblingSp , mySrd ) ; mySearchParamRegistry . forceRefresh ( ) ; ca . uhn . fhir . jpa . dao . r4 . Appointment apt = new ca . uhn . fhir . jpa . dao . r4 . Appointment ( ) ; apt . setStatus ( AppointmentStatus . ARRIVED ) ; org . hl7 . fhir . instance . model . api . IIdType aptId = myAppointmentDao . create ( apt ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . dao . r4 . Patient patient = new ca . uhn . fhir . jpa . dao . r4 . Patient ( ) ; patient . addName ( ) . setFamily ( \"P2\" ) ; ca . uhn . fhir . jpa . dao . r4 . Extension extParent = patient . addExtension ( ) . setUrl ( \"http://acme.org/foo\" ) ; extParent . addExtension ( ) . setUrl ( \"http://acme.org/bar\" ) . setValue ( new ca . uhn . fhir . jpa . dao . r4 . Reference ( aptId . getValue ( ) ) ) ; org . hl7 . fhir . instance . model . api . IIdType p2id = myPatientDao . create ( patient ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . searchparam . SearchParameterMap map ; ca . uhn . fhir . rest . api . server . IBundleProvider results ; java . util . List < java . lang . String > foundResources ; map = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; map . add ( \"foobar\" , new ca . uhn . fhir . jpa . dao . r4 . ReferenceParam ( aptId . getValue ( ) ) ) ; results = myPatientDao . search ( map ) ; foundResources = toUnqualifiedVersionlessIdValues ( results ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( foundResources , contains ( p2id . getValue ( ) ) )", "total": "testSearchForExtensionTwoDeepReferenceWithoutType ( ) { ca . uhn . fhir . jpa . dao . r4 . SearchParameter siblingSp = new ca . uhn . fhir . jpa . dao . r4 . SearchParameter ( ) ; siblingSp . addBase ( \"Patient\" ) ; siblingSp . setCode ( \"foobar\" ) ; siblingSp . setType ( org . hl7 . fhir . r4 . model . Enumerations . SearchParamType . REFERENCE ) ; siblingSp . setTitle ( \"FooBar\" ) ; siblingSp . setExpression ( \"Patient.extension('http://acme.org/foo').extension('http://acme.org/bar')\" ) ; siblingSp . setXpathUsage ( org . hl7 . fhir . r4 . model . SearchParameter . XPathUsageType . NORMAL ) ; siblingSp . setStatus ( org . hl7 . fhir . r4 . model . Enumerations . PublicationStatus . ACTIVE ) ; mySearchParameterDao . create ( siblingSp , mySrd ) ; mySearchParamRegistry . forceRefresh ( ) ; ca . uhn . fhir . jpa . dao . r4 . Appointment apt = new ca . uhn . fhir . jpa . dao . r4 . Appointment ( ) ; apt . setStatus ( AppointmentStatus . ARRIVED ) ; org . hl7 . fhir . instance . model . api . IIdType aptId = myAppointmentDao . create ( apt ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . dao . r4 . Patient patient = new ca . uhn . fhir . jpa . dao . r4 . Patient ( ) ; patient . addName ( ) . setFamily ( \"P2\" ) ; ca . uhn . fhir . jpa . dao . r4 . Extension extParent = patient . addExtension ( ) . setUrl ( \"http://acme.org/foo\" ) ; extParent . addExtension ( ) . setUrl ( \"http://acme.org/bar\" ) . setValue ( new ca . uhn . fhir . jpa . dao . r4 . Reference ( aptId . getValue ( ) ) ) ; org . hl7 . fhir . instance . model . api . IIdType p2id = myPatientDao . create ( patient ) . getId ( ) . toUnqualifiedVersionless ( ) ; ca . uhn . fhir . jpa . searchparam . SearchParameterMap map ; ca . uhn . fhir . rest . api . server . IBundleProvider results ; java . util . List < java . lang . String > foundResources ; map = new ca . uhn . fhir . jpa . searchparam . SearchParameterMap ( ) ; map . add ( \"foobar\" , new ca . uhn . fhir . jpa . dao . r4 . ReferenceParam ( aptId . getValue ( ) ) ) ; results = myPatientDao . search ( map ) ; foundResources = toUnqualifiedVersionlessIdValues ( results ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . Object ) { return data . contains ( o ) ; }", "answer": "org . junit . Assert . assertThat ( foundResources , contains ( p2id . getValue ( ) ) )"}
{"focal": "getInteger ( ) { return integer ; }", "testMethod": "shouldInvokeMethod ( ) { ch . jalu . injector . utils . ReflectionsTestClass testClass = new ch . jalu . injector . utils . ReflectionsTestClass ( \"\" , 123 ) ; java . lang . reflect . Method method = ch . jalu . injector . utils . ReflectionUtilsTest . getMethod ( \"setIntegerField\" , ch . jalu . injector . utils . Integer . class ) ; ch . jalu . injector . utils . ReflectionUtils . invokeMethod ( method , testClass , 144 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testClass . getInteger ( ) , org . hamcrest . Matchers . equalTo ( 144 ) )", "total": "shouldInvokeMethod ( ) { ch . jalu . injector . utils . ReflectionsTestClass testClass = new ch . jalu . injector . utils . ReflectionsTestClass ( \"\" , 123 ) ; java . lang . reflect . Method method = ch . jalu . injector . utils . ReflectionUtilsTest . getMethod ( \"setIntegerField\" , ch . jalu . injector . utils . Integer . class ) ; ch . jalu . injector . utils . ReflectionUtils . invokeMethod ( method , testClass , 144 ) ; \"<AssertPlaceHolder>\" ; } getInteger ( ) { return integer ; }", "answer": "org . junit . Assert . assertThat ( testClass . getInteger ( ) , org . hamcrest . Matchers . equalTo ( 144 ) )"}
{"focal": "detect ( java . lang . String ) { for ( org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType type : org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType . values ( ) ) { if ( content . startsWith ( type . getPrefix ( ) ) ) { return type ; } } return org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType . UNDEFINED ; }", "testMethod": "dockerMessageShouldBeDetected ( ) { java . lang . String content = ( MessageType . DOCKER . getPrefix ( ) ) + ( org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageTypeTest . SOME_TEXT ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType . detect ( content ) , org . hamcrest . CoreMatchers . is ( MessageType . DOCKER ) )", "total": "dockerMessageShouldBeDetected ( ) { java . lang . String content = ( MessageType . DOCKER . getPrefix ( ) ) + ( org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageTypeTest . SOME_TEXT ) ; \"<AssertPlaceHolder>\" ; } detect ( java . lang . String ) { for ( org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType type : org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType . values ( ) ) { if ( content . startsWith ( type . getPrefix ( ) ) ) { return type ; } } return org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType . UNDEFINED ; }", "answer": "org . junit . Assert . assertThat ( org . eclipse . che . ide . ext . runner . client . tabs . console . panel . MessageType . detect ( content ) , org . hamcrest . CoreMatchers . is ( MessageType . DOCKER ) )"}
{"focal": "properties ( ) { return java . util . Collections . unmodifiableSet ( properties ) ; }", "testMethod": "shouldGetPresentationModelChangeSupportMethodIgnored ( ) { org . robobinding . codegen . presentationmodel . PresentationModelInfo result = processJavaFileOf ( org . robobinding . codegen . presentationmodel . processor . GetPresentationModelChangeSupportIgnored . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . properties ( ) . size ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "shouldGetPresentationModelChangeSupportMethodIgnored ( ) { org . robobinding . codegen . presentationmodel . PresentationModelInfo result = processJavaFileOf ( org . robobinding . codegen . presentationmodel . processor . GetPresentationModelChangeSupportIgnored . class ) ; \"<AssertPlaceHolder>\" ; } properties ( ) { return java . util . Collections . unmodifiableSet ( properties ) ; }", "answer": "org . junit . Assert . assertThat ( result . properties ( ) . size ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "testUpdateDocumentWithoutContentOnNewLanguage ( ) { org . silverpeas . core . contribution . attachment . model . SimpleDocument document = new org . silverpeas . core . contribution . attachment . model . SimpleDocument ( new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( DOCUMENT_ID , INSTANCE_ID ) , \"18\" , 10 , false , new org . silverpeas . core . contribution . attachment . model . SimpleAttachment ( \"test.pdf\" , \"fr\" , \"fileName\" 2 , \"fileName\" 3 , 500L , org . silverpeas . util . MimeTypes . PDF_MIME_TYPE , USER_ID_IN_TEST , creationDate , null ) ) ; org . silverpeas . core . contribution . attachment . AttachmentService service = mock ( org . silverpeas . core . contribution . attachment . AttachmentService . class ) ; when ( service . searchDocumentById ( eq ( new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( DOCUMENT_ID ) ) , anyString ( ) ) ) . thenReturn ( document ) ; getTestResources ( ) . setAttachmentService ( service ) ; com . sun . jersey . multipart . FormDataMultiPart form = new com . sun . jersey . multipart . FormDataMultiPart ( ) ; form . field ( \"fileName\" , \"/Shared/marketing/my_test_document.txt\" ) ; form . field ( \"fileName\" 0 , \"fileName\" 1 ) ; form . field ( \"fileTitle\" , \"Upload<sp>test\" ) ; form . field ( \"fileDescription\" , \"This<sp>test<sp>is<sp>trying<sp>to<sp>simulate<sp>the<sp>update<sp>of<sp>a<sp>content\" ) ; com . sun . jersey . api . client . WebResource webResource = resource ( ) ; try { webResource . path ( ( ( ( RESOURCE_PATH ) + ( DOCUMENT_ID ) ) + \"/test.pdf\" ) ) . header ( org . silverpeas . core . contribution . attachment . web . HTTP_SESSIONKEY , getSessionKey ( ) ) . accept ( javax . ws . rs . core . MediaType . APPLICATION_JSON_TYPE ) . type ( javax . ws . rs . core . MediaType . MULTIPART_FORM_DATA ) . post ( org . silverpeas . core . contribution . attachment . web . SimpleDocumentEntity . class , form ) ; } catch ( final com . sun . jersey . api . client . UniformInterfaceException ex ) { final int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; final int preconditionFailed = Status . PRECONDITION_FAILED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( preconditionFailed ) )", "total": "testUpdateDocumentWithoutContentOnNewLanguage ( ) { org . silverpeas . core . contribution . attachment . model . SimpleDocument document = new org . silverpeas . core . contribution . attachment . model . SimpleDocument ( new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( DOCUMENT_ID , INSTANCE_ID ) , \"18\" , 10 , false , new org . silverpeas . core . contribution . attachment . model . SimpleAttachment ( \"test.pdf\" , \"fr\" , \"fileName\" 2 , \"fileName\" 3 , 500L , org . silverpeas . util . MimeTypes . PDF_MIME_TYPE , USER_ID_IN_TEST , creationDate , null ) ) ; org . silverpeas . core . contribution . attachment . AttachmentService service = mock ( org . silverpeas . core . contribution . attachment . AttachmentService . class ) ; when ( service . searchDocumentById ( eq ( new org . silverpeas . core . contribution . attachment . model . SimpleDocumentPK ( DOCUMENT_ID ) ) , anyString ( ) ) ) . thenReturn ( document ) ; getTestResources ( ) . setAttachmentService ( service ) ; com . sun . jersey . multipart . FormDataMultiPart form = new com . sun . jersey . multipart . FormDataMultiPart ( ) ; form . field ( \"fileName\" , \"/Shared/marketing/my_test_document.txt\" ) ; form . field ( \"fileName\" 0 , \"fileName\" 1 ) ; form . field ( \"fileTitle\" , \"Upload<sp>test\" ) ; form . field ( \"fileDescription\" , \"This<sp>test<sp>is<sp>trying<sp>to<sp>simulate<sp>the<sp>update<sp>of<sp>a<sp>content\" ) ; com . sun . jersey . api . client . WebResource webResource = resource ( ) ; try { webResource . path ( ( ( ( RESOURCE_PATH ) + ( DOCUMENT_ID ) ) + \"/test.pdf\" ) ) . header ( org . silverpeas . core . contribution . attachment . web . HTTP_SESSIONKEY , getSessionKey ( ) ) . accept ( javax . ws . rs . core . MediaType . APPLICATION_JSON_TYPE ) . type ( javax . ws . rs . core . MediaType . MULTIPART_FORM_DATA ) . post ( org . silverpeas . core . contribution . attachment . web . SimpleDocumentEntity . class , form ) ; } catch ( final com . sun . jersey . api . client . UniformInterfaceException ex ) { final int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; final int preconditionFailed = Status . PRECONDITION_FAILED . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( preconditionFailed ) )"}
{"focal": "size ( ) { return sizeInList ; }", "testMethod": "multiple ( ) { com . asakusafw . yaess . core . JobScheduler instance = create ( \"parallel.default\" , \"1\" ) ; java . util . List < com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock > jobs = new java . util . ArrayList ( ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"b\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"c\" ) ) ; instance . execute ( PhaseMonitor . NULL , com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . CONTEXT , jobs , JobScheduler . STRICT ) ; java . util . Set < java . lang . String > rest = collectRest ( jobs ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( rest . size ( ) , is ( 0 ) )", "total": "multiple ( ) { com . asakusafw . yaess . core . JobScheduler instance = create ( \"parallel.default\" , \"1\" ) ; java . util . List < com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock > jobs = new java . util . ArrayList ( ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"a\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"b\" ) ) ; jobs . add ( new com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . Mock ( \"c\" ) ) ; instance . execute ( PhaseMonitor . NULL , com . asakusafw . yaess . paralleljob . ParallelJobSchedulerTest . CONTEXT , jobs , JobScheduler . STRICT ) ; java . util . Set < java . lang . String > rest = collectRest ( jobs ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return sizeInList ; }", "answer": "org . junit . Assert . assertThat ( rest . size ( ) , is ( 0 ) )"}
{"focal": "validate ( ) { return true ; }", "testMethod": "validate_returnFalse ( ) { boolean isValid = meterValue . validate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( false ) )", "total": "validate_returnFalse ( ) { boolean isValid = meterValue . validate ( ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { return true ; }", "answer": "org . junit . Assert . assertThat ( isValid , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getProperty ( java . lang . Object , java . lang . String ) { org . apache . commons . lang3 . Validate . notNull ( bean , \"bean<sp>can't<sp>be<sp>null!\" ) ; org . apache . commons . lang3 . Validate . notBlank ( propertyName , \"propertyName<sp>can't<sp>be<sp>blank!\" ) ; return com . feilong . core . bean . PropertyValueObtainer . obtain ( bean , propertyName ) ; }", "testMethod": "testGetBean ( ) { com . feilong . store . member . User user = new com . feilong . store . member . User ( ) ; user . setId ( 5L ) ; user . setDate ( new java . util . Date ( ) ) ; java . lang . Long id = com . feilong . core . bean . PropertyUtil . getProperty ( user , \"id\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( id , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . equalTo ( 5L ) ) )", "total": "testGetBean ( ) { com . feilong . store . member . User user = new com . feilong . store . member . User ( ) ; user . setId ( 5L ) ; user . setDate ( new java . util . Date ( ) ) ; java . lang . Long id = com . feilong . core . bean . PropertyUtil . getProperty ( user , \"id\" ) ; \"<AssertPlaceHolder>\" ; } getProperty ( java . lang . Object , java . lang . String ) { org . apache . commons . lang3 . Validate . notNull ( bean , \"bean<sp>can't<sp>be<sp>null!\" ) ; org . apache . commons . lang3 . Validate . notBlank ( propertyName , \"propertyName<sp>can't<sp>be<sp>blank!\" ) ; return com . feilong . core . bean . PropertyValueObtainer . obtain ( bean , propertyName ) ; }", "answer": "org . junit . Assert . assertThat ( id , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . equalTo ( 5L ) ) )"}
{"focal": "hasSize ( int ) { return new com . github . msemys . esjc . matcher . IteratorSizeMatcher ( size ) ; }", "testMethod": "iteratesStreamEventsFromStartToEndWithLargeBatchSize ( ) { final java . lang . String stream = generateStreamName ( ) ; eventstore . appendToStream ( stream , ExpectedVersion . NO_STREAM , newTestEvents ( 10 ) ) . join ( ) ; java . util . Iterator < com . github . msemys . esjc . ResolvedEvent > iterator = eventstore . iterateStreamEventsForward ( stream , StreamPosition . START , 20 , false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( iterator , hasSize ( 10 ) )", "total": "iteratesStreamEventsFromStartToEndWithLargeBatchSize ( ) { final java . lang . String stream = generateStreamName ( ) ; eventstore . appendToStream ( stream , ExpectedVersion . NO_STREAM , newTestEvents ( 10 ) ) . join ( ) ; java . util . Iterator < com . github . msemys . esjc . ResolvedEvent > iterator = eventstore . iterateStreamEventsForward ( stream , StreamPosition . START , 20 , false ) ; \"<AssertPlaceHolder>\" ; } hasSize ( int ) { return new com . github . msemys . esjc . matcher . IteratorSizeMatcher ( size ) ; }", "answer": "org . junit . Assert . assertThat ( iterator , hasSize ( 10 ) )"}
{"focal": "isVerificationRequired ( org . bukkit . entity . Player ) { final java . lang . String name = player . getName ( ) ; return ( ( ( canSendMail ) && ( ! ( isPlayerVerified ( name ) ) ) ) && ( permissionsManager . hasPermission ( player , PlayerPermission . VERIFICATION_CODE ) ) ) && ( hasEmail ( name ) ) ; }", "testMethod": "shouldNotRequireVerificationForMissingPermission ( ) { org . bukkit . entity . Player player = fr . xephi . authme . data . VerificationCodeManagerTest . mockPlayerWithName ( \"ILoveTests\" ) ; given ( permissionsManager . hasPermission ( player , PlayerPermission . VERIFICATION_CODE ) ) . willReturn ( false ) ; fr . xephi . authme . data . VerificationCodeManager codeManager = createCodeManager ( ) ; boolean result = codeManager . isVerificationRequired ( player ) ; \"<AssertPlaceHolder>\" ; verify ( permissionsManager ) . hasPermission ( player , PlayerPermission . VERIFICATION_CODE ) ; verifyZeroInteractions ( dataSource ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )", "total": "shouldNotRequireVerificationForMissingPermission ( ) { org . bukkit . entity . Player player = fr . xephi . authme . data . VerificationCodeManagerTest . mockPlayerWithName ( \"ILoveTests\" ) ; given ( permissionsManager . hasPermission ( player , PlayerPermission . VERIFICATION_CODE ) ) . willReturn ( false ) ; fr . xephi . authme . data . VerificationCodeManager codeManager = createCodeManager ( ) ; boolean result = codeManager . isVerificationRequired ( player ) ; \"<AssertPlaceHolder>\" ; verify ( permissionsManager ) . hasPermission ( player , PlayerPermission . VERIFICATION_CODE ) ; verifyZeroInteractions ( dataSource ) ; } isVerificationRequired ( org . bukkit . entity . Player ) { final java . lang . String name = player . getName ( ) ; return ( ( ( canSendMail ) && ( ! ( isPlayerVerified ( name ) ) ) ) && ( permissionsManager . hasPermission ( player , PlayerPermission . VERIFICATION_CODE ) ) ) && ( hasEmail ( name ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "read ( java . lang . Class , org . bson . conversions . Bson ) { return ( ( S ) ( person ) ) ; }", "testMethod": "convertsMapKeyUsingCustomConverterForAndBackwards ( ) { org . springframework . data . mongodb . core . convert . MappingMongoConverter converter = new org . springframework . data . mongodb . core . convert . MappingMongoConverter ( resolver , mappingContext ) ; converter . setCustomConversions ( new org . springframework . data . mongodb . core . convert . MongoCustomConversions ( org . springframework . data . mongodb . core . convert . Arrays . asList ( new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . FooBarEnumToStringConverter ( ) , new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . StringToFooNumConverter ( ) ) ) ) ; converter . afterPropertiesSet ( ) ; org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey source = new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey ( ) ; source . map = new org . springframework . data . mongodb . core . convert . HashMap < org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey . FooBarEnum , java . lang . String > ( ) ; source . map . put ( org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey . FooBarEnum . FOO , \"wohoo\" ) ; org . bson . Document target = new org . bson . Document ( ) ; converter . write ( source , target ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( converter . read ( org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey . class , target ) . map , is ( source . map ) )", "total": "convertsMapKeyUsingCustomConverterForAndBackwards ( ) { org . springframework . data . mongodb . core . convert . MappingMongoConverter converter = new org . springframework . data . mongodb . core . convert . MappingMongoConverter ( resolver , mappingContext ) ; converter . setCustomConversions ( new org . springframework . data . mongodb . core . convert . MongoCustomConversions ( org . springframework . data . mongodb . core . convert . Arrays . asList ( new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . FooBarEnumToStringConverter ( ) , new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . StringToFooNumConverter ( ) ) ) ) ; converter . afterPropertiesSet ( ) ; org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey source = new org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey ( ) ; source . map = new org . springframework . data . mongodb . core . convert . HashMap < org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey . FooBarEnum , java . lang . String > ( ) ; source . map . put ( org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey . FooBarEnum . FOO , \"wohoo\" ) ; org . bson . Document target = new org . bson . Document ( ) ; converter . write ( source , target ) ; \"<AssertPlaceHolder>\" ; } read ( java . lang . Class , org . bson . conversions . Bson ) { return ( ( S ) ( person ) ) ; }", "answer": "org . junit . Assert . assertThat ( converter . read ( org . springframework . data . mongodb . core . convert . MappingMongoConverterUnitTests . ClassWithMapUsingEnumAsKey . class , target ) . map , is ( source . map ) )"}
{"focal": "databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "testMethod": "data_should_be_compared_between_expected_and_current_data ( ) { org . infinispan . manager . EmbeddedCacheManager defaultEmbeddedInstance = com . lordofthejars . nosqlunit . infinispan . EmbeddedInfinispanInstancesFactory . getInstance ( ) . getDefaultEmbeddedInstance ( ) ; com . lordofthejars . nosqlunit . infinispan . InfinispanOperation infinispanOperation = new com . lordofthejars . nosqlunit . infinispan . InfinispanOperation ( defaultEmbeddedInstance . getCache ( ) ) ; infinispanOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . WhenEmbeddedInfinispanOperationsAreRequired . SIMPLE_DATA . getBytes ( ) ) ) ; boolean sameDataset = infinispanOperation . databaseIs ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . WhenEmbeddedInfinispanOperationsAreRequired . SIMPLE_DATA . getBytes ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sameDataset , org . hamcrest . CoreMatchers . is ( true ) )", "total": "data_should_be_compared_between_expected_and_current_data ( ) { org . infinispan . manager . EmbeddedCacheManager defaultEmbeddedInstance = com . lordofthejars . nosqlunit . infinispan . EmbeddedInfinispanInstancesFactory . getInstance ( ) . getDefaultEmbeddedInstance ( ) ; com . lordofthejars . nosqlunit . infinispan . InfinispanOperation infinispanOperation = new com . lordofthejars . nosqlunit . infinispan . InfinispanOperation ( defaultEmbeddedInstance . getCache ( ) ) ; infinispanOperation . insert ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . WhenEmbeddedInfinispanOperationsAreRequired . SIMPLE_DATA . getBytes ( ) ) ) ; boolean sameDataset = infinispanOperation . databaseIs ( new java . io . ByteArrayInputStream ( com . lordofthejars . nosqlunit . infinispan . WhenEmbeddedInfinispanOperationsAreRequired . SIMPLE_DATA . getBytes ( ) ) ) ; \"<AssertPlaceHolder>\" ; } databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "answer": "org . junit . Assert . assertThat ( sameDataset , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "size ( ) { return locationPks . size ( ) ; }", "testMethod": "matchTimeOnlyTestOpenEndedIntervalRangeBefore ( ) { org . dcm4che3 . data . Attributes testAttrs = new org . dcm4che3 . data . Attributes ( ) ; java . lang . String tmString = \"121211.000-\" ; java . util . List < org . dcm4chee . archive . entity . Study > studies = createTimeRangeQuery ( testAttrs , tmString ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( studies . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "matchTimeOnlyTestOpenEndedIntervalRangeBefore ( ) { org . dcm4che3 . data . Attributes testAttrs = new org . dcm4che3 . data . Attributes ( ) ; java . lang . String tmString = \"121211.000-\" ; java . util . List < org . dcm4chee . archive . entity . Study > studies = createTimeRangeQuery ( testAttrs , tmString ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return locationPks . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( studies . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "write ( T ) { if ( ( ( serializer ) != null ) && ( ( value == null ) || ( serializer . canSerialize ( value . getClass ( ) ) ) ) ) { return java . nio . ByteBuffer . wrap ( serializer . serialize ( value ) ) ; } if ( value instanceof byte [ ] ) { return java . nio . ByteBuffer . wrap ( ( ( byte [ ] ) ( value ) ) ) ; } if ( value instanceof java . nio . ByteBuffer ) { return ( ( java . nio . ByteBuffer ) ( value ) ) ; } throw new java . lang . IllegalStateException ( java . lang . String . format ( \"Cannot<sp>serialize<sp>value<sp>of<sp>type<sp>%s<sp>without<sp>a<sp>serializer\" , value . getClass ( ) ) ) ; }", "testMethod": "shouldWrapByteArrayForAbsentSerializer ( ) { org . springframework . data . redis . serializer . DefaultRedisElementWriter < java . lang . Object > writer = new org . springframework . data . redis . serializer . DefaultRedisElementWriter ( null ) ; byte [ ] input = new byte [ ] { 1 , 2 , 3 } ; java . nio . ByteBuffer result = writer . write ( input ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . array ( ) , is ( equalTo ( input ) ) )", "total": "shouldWrapByteArrayForAbsentSerializer ( ) { org . springframework . data . redis . serializer . DefaultRedisElementWriter < java . lang . Object > writer = new org . springframework . data . redis . serializer . DefaultRedisElementWriter ( null ) ; byte [ ] input = new byte [ ] { 1 , 2 , 3 } ; java . nio . ByteBuffer result = writer . write ( input ) ; \"<AssertPlaceHolder>\" ; } write ( T ) { if ( ( ( serializer ) != null ) && ( ( value == null ) || ( serializer . canSerialize ( value . getClass ( ) ) ) ) ) { return java . nio . ByteBuffer . wrap ( serializer . serialize ( value ) ) ; } if ( value instanceof byte [ ] ) { return java . nio . ByteBuffer . wrap ( ( ( byte [ ] ) ( value ) ) ) ; } if ( value instanceof java . nio . ByteBuffer ) { return ( ( java . nio . ByteBuffer ) ( value ) ) ; } throw new java . lang . IllegalStateException ( java . lang . String . format ( \"Cannot<sp>serialize<sp>value<sp>of<sp>type<sp>%s<sp>without<sp>a<sp>serializer\" , value . getClass ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( result . array ( ) , is ( equalTo ( input ) ) )"}
{"focal": "onTraditionalTimeLine ( ) { net . time4j . range . SimpleInterval < java . util . Date > expected = net . time4j . range . SimpleInterval . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) ; org . junit . Assert . assertThat ( net . time4j . range . SimpleInterval . onTraditionalTimeLine ( ) . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) , org . hamcrest . CoreMatchers . is ( expected ) ) ; }", "testMethod": "onTraditionalTimeLine ( ) { net . time4j . range . SimpleInterval < java . util . Date > expected = net . time4j . range . SimpleInterval . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . range . SimpleInterval . onTraditionalTimeLine ( ) . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "onTraditionalTimeLine ( ) { net . time4j . range . SimpleInterval < java . util . Date > expected = net . time4j . range . SimpleInterval . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) ; \"<AssertPlaceHolder>\" ; } onTraditionalTimeLine ( ) { net . time4j . range . SimpleInterval < java . util . Date > expected = net . time4j . range . SimpleInterval . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) ; org . junit . Assert . assertThat ( net . time4j . range . SimpleInterval . onTraditionalTimeLine ( ) . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) , org . hamcrest . CoreMatchers . is ( expected ) ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . range . SimpleInterval . onTraditionalTimeLine ( ) . between ( new java . util . Date ( 2L ) , new java . util . Date ( 27L ) ) , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "toImmutableList ( ) { return collect ( com . google . common . collect . ImmutableList . toImmutableList ( ) ) ; }", "testMethod": "testParseReturnsAllCompilationUnits ( ) { initCompiler ( com . google . common . collect . ImmutableMap . of ( \"Foo.java\" , \"public<sp>class<sp>Foo<sp>{<sp>}\" , \"Bar.java\" , \"public<sp>class<sp>Bar<sp>{<sp>}\" , \"Baz.java\" , \"public<sp>class<sp>Baz<sp>{<sp>}\" ) ) ; java . lang . Iterable < ? extends com . sun . source . tree . CompilationUnitTree > compilationUnits = testCompiler . parse ( ) ; java . util . List < java . lang . String > fileNames = com . facebook . buck . util . RichStream . from ( compilationUnits ) . map ( ( compilationUnit ) -> java . nio . file . Paths . get ( compilationUnit . getSourceFile ( ) . getName ( ) ) . getFileName ( ) . toString ( ) ) . toImmutableList ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fileNames , org . hamcrest . Matchers . contains ( \"Foo.java\" , \"Bar.java\" , \"Baz.java\" ) )", "total": "testParseReturnsAllCompilationUnits ( ) { initCompiler ( com . google . common . collect . ImmutableMap . of ( \"Foo.java\" , \"public<sp>class<sp>Foo<sp>{<sp>}\" , \"Bar.java\" , \"public<sp>class<sp>Bar<sp>{<sp>}\" , \"Baz.java\" , \"public<sp>class<sp>Baz<sp>{<sp>}\" ) ) ; java . lang . Iterable < ? extends com . sun . source . tree . CompilationUnitTree > compilationUnits = testCompiler . parse ( ) ; java . util . List < java . lang . String > fileNames = com . facebook . buck . util . RichStream . from ( compilationUnits ) . map ( ( compilationUnit ) -> java . nio . file . Paths . get ( compilationUnit . getSourceFile ( ) . getName ( ) ) . getFileName ( ) . toString ( ) ) . toImmutableList ( ) ; \"<AssertPlaceHolder>\" ; } toImmutableList ( ) { return collect ( com . google . common . collect . ImmutableList . toImmutableList ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( fileNames , org . hamcrest . Matchers . contains ( \"Foo.java\" , \"Bar.java\" , \"Baz.java\" ) )"}
{"focal": "getMyText ( ) { return myText ; }", "testMethod": "text ( ) { model . setMyText ( new com . google . appengine . api . datastore . Text ( \"aaa\" ) ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model2 . getMyText ( ) , org . hamcrest . CoreMatchers . is ( new com . google . appengine . api . datastore . Text ( \"aaa\" ) ) )", "total": "text ( ) { model . setMyText ( new com . google . appengine . api . datastore . Text ( \"aaa\" ) ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; } getMyText ( ) { return myText ; }", "answer": "org . junit . Assert . assertThat ( model2 . getMyText ( ) , org . hamcrest . CoreMatchers . is ( new com . google . appengine . api . datastore . Text ( \"aaa\" ) ) )"}
{"focal": "is ( java . lang . annotation . Annotation ) { return is ( AnnotationDescription . ForLoadedAnnotation . of ( annotation ) ) ; }", "testMethod": "testNotMatchesRight ( ) { when ( left . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( false ) ; when ( right . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( true ) ; net . bytebuddy . agent . builder . AgentBuilder . RawMatcher rawMatcher = new net . bytebuddy . agent . builder . AgentBuilder . RawMatcher . Disjunction ( left , right ) ; \"<AssertPlaceHolder>\" ; verify ( left ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( left ) ; verify ( right ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( right ) ; }", "assertLine": "org . junit . Assert . assertThat ( rawMatcher . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testNotMatchesRight ( ) { when ( left . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( false ) ; when ( right . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( true ) ; net . bytebuddy . agent . builder . AgentBuilder . RawMatcher rawMatcher = new net . bytebuddy . agent . builder . AgentBuilder . RawMatcher . Disjunction ( left , right ) ; \"<AssertPlaceHolder>\" ; verify ( left ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( left ) ; verify ( right ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( right ) ; } is ( java . lang . annotation . Annotation ) { return is ( AnnotationDescription . ForLoadedAnnotation . of ( annotation ) ) ; }", "answer": "org . junit . Assert . assertThat ( rawMatcher . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherDisjunctionTest . Foo . class , protectionDomain ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "get ( ) { return org . apache . shardingsphere . transaction . core . TransactionTypeHolder . CONTEXT . get ( ) ; }", "testMethod": "assertGetWithSetValue ( ) { org . apache . shardingsphere . transaction . core . TransactionTypeHolder . set ( TransactionType . XA ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . apache . shardingsphere . transaction . core . TransactionTypeHolder . get ( ) , org . hamcrest . CoreMatchers . is ( TransactionType . XA ) )", "total": "assertGetWithSetValue ( ) { org . apache . shardingsphere . transaction . core . TransactionTypeHolder . set ( TransactionType . XA ) ; \"<AssertPlaceHolder>\" ; } get ( ) { return org . apache . shardingsphere . transaction . core . TransactionTypeHolder . CONTEXT . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . apache . shardingsphere . transaction . core . TransactionTypeHolder . get ( ) , org . hamcrest . CoreMatchers . is ( TransactionType . XA ) )"}
{"focal": "getBytes ( int , byte [ ] , int , int ) { int count = java . lang . Math . min ( len , ( ( size ) - index ) ) ; if ( ( data ) == null ) { java . nio . ByteBuffer dup = buf . duplicate ( ) ; dup . position ( index ) ; dup . get ( dst , off , count ) ; } else { java . lang . System . arraycopy ( data , index , dst , off , count ) ; } return count ; }", "testMethod": "testGetBytesLength ( ) { final zmq . Msg msg = initMsg ( ) ; final byte [ ] dst = new byte [ 5 ] ; msg . getBytes ( 2 , dst , 0 , 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dst , org . hamcrest . CoreMatchers . is ( new byte [ ] { 2 , 3 , 0 , 0 , 0 } ) )", "total": "testGetBytesLength ( ) { final zmq . Msg msg = initMsg ( ) ; final byte [ ] dst = new byte [ 5 ] ; msg . getBytes ( 2 , dst , 0 , 2 ) ; \"<AssertPlaceHolder>\" ; } getBytes ( int , byte [ ] , int , int ) { int count = java . lang . Math . min ( len , ( ( size ) - index ) ) ; if ( ( data ) == null ) { java . nio . ByteBuffer dup = buf . duplicate ( ) ; dup . position ( index ) ; dup . get ( dst , off , count ) ; } else { java . lang . System . arraycopy ( data , index , dst , off , count ) ; } return count ; }", "answer": "org . junit . Assert . assertThat ( dst , org . hamcrest . CoreMatchers . is ( new byte [ ] { 2 , 3 , 0 , 0 , 0 } ) )"}
{"focal": "maximalRectangle ( char [ ] [ ] ) { int max = 0 ; for ( int i = 0 ; i < ( matrix . length ) ; i ++ ) { int [ ] heights = getHistogram ( matrix , i ) ; System . out . println ( ( \"calc<sp>:\" + ( java . util . Arrays . toString ( heights ) ) ) ) ; max = java . lang . Math . max ( max , largestRectangleInHistogram ( heights ) ) ; System . out . println ( ( \"sub<sp>max<sp>:\" + ( largestRectangleInHistogram ( heights ) ) ) ) ; } return max ; }", "testMethod": "test ( ) { char [ ] [ ] matrix = new char [ ] [ ] { new char [ ] { '1' , '0' , '1' , '0' , '0' } , new char [ ] { '1' , '0' , '1' , '1' , '1' } , new char [ ] { '1' , '1' , '1' , '1' , '1' } , new char [ ] { '1' , '0' , '0' , '1' , '0' } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( maximalRectangle ( matrix ) , org . hamcrest . Matchers . is ( 6 ) )", "total": "test ( ) { char [ ] [ ] matrix = new char [ ] [ ] { new char [ ] { '1' , '0' , '1' , '0' , '0' } , new char [ ] { '1' , '0' , '1' , '1' , '1' } , new char [ ] { '1' , '1' , '1' , '1' , '1' } , new char [ ] { '1' , '0' , '0' , '1' , '0' } } ; \"<AssertPlaceHolder>\" ; } maximalRectangle ( char [ ] [ ] ) { int max = 0 ; for ( int i = 0 ; i < ( matrix . length ) ; i ++ ) { int [ ] heights = getHistogram ( matrix , i ) ; System . out . println ( ( \"calc<sp>:\" + ( java . util . Arrays . toString ( heights ) ) ) ) ; max = java . lang . Math . max ( max , largestRectangleInHistogram ( heights ) ) ; System . out . println ( ( \"sub<sp>max<sp>:\" + ( largestRectangleInHistogram ( heights ) ) ) ) ; } return max ; }", "answer": "org . junit . Assert . assertThat ( maximalRectangle ( matrix ) , org . hamcrest . Matchers . is ( 6 ) )"}
{"focal": "isComposed ( ) { return false ; }", "testMethod": "nonComposed ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( entity . isComposed ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "nonComposed ( ) { \"<AssertPlaceHolder>\" ; } isComposed ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( entity . isComposed ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "getRecipient ( ) { org . jscep . transport . request . GetCaCertRequest req = new org . jscep . transport . request . GetCaCertRequest ( ) ; org . jscep . transport . Transport transport = getTransport ( getURL ( ) ) ; java . security . cert . CertStore store = transport . sendRequest ( req , new org . jscep . transport . response . GetCaCertResponseHandler ( ) ) ; java . util . Collection < ? extends java . security . cert . Certificate > certs = store . getCertificates ( null ) ; if ( ( certs . size ( ) ) > 0 ) { return ( ( java . security . cert . X509Certificate ) ( certs . iterator ( ) . next ( ) ) ) ; } else { return null ; } }", "testMethod": "getNextCaCertificateGood ( ) { org . jscep . transport . request . GetNextCaCertRequest req = new org . jscep . transport . request . GetNextCaCertRequest ( goodIdentifier ) ; org . jscep . transport . Transport transport = getTransport ( getURL ( ) ) ; java . security . cert . CertStore certs = transport . sendRequest ( req , new org . jscep . transport . response . GetNextCaCertResponseHandler ( getRecipient ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( certs . getCertificates ( null ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "getNextCaCertificateGood ( ) { org . jscep . transport . request . GetNextCaCertRequest req = new org . jscep . transport . request . GetNextCaCertRequest ( goodIdentifier ) ; org . jscep . transport . Transport transport = getTransport ( getURL ( ) ) ; java . security . cert . CertStore certs = transport . sendRequest ( req , new org . jscep . transport . response . GetNextCaCertResponseHandler ( getRecipient ( ) ) ) ; \"<AssertPlaceHolder>\" ; } getRecipient ( ) { org . jscep . transport . request . GetCaCertRequest req = new org . jscep . transport . request . GetCaCertRequest ( ) ; org . jscep . transport . Transport transport = getTransport ( getURL ( ) ) ; java . security . cert . CertStore store = transport . sendRequest ( req , new org . jscep . transport . response . GetCaCertResponseHandler ( ) ) ; java . util . Collection < ? extends java . security . cert . Certificate > certs = store . getCertificates ( null ) ; if ( ( certs . size ( ) ) > 0 ) { return ( ( java . security . cert . X509Certificate ) ( certs . iterator ( ) . next ( ) ) ) ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( certs . getCertificates ( null ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "findList ( ) { org . tests . model . basic . ResetBasicData . reset ( ) ; io . ebean . EbeanServer server = io . ebean . Ebean . getDefaultServer ( ) ; io . ebean . Query < org . tests . model . basic . Customer > query = server . find ( org . tests . model . basic . Customer . class ) . where ( ) . startsWith ( \"name\" , \"Rob\" ) . query ( ) ; try ( io . ebean . Transaction transaction = server . beginTransaction ( ) ) { java . util . List < org . tests . model . basic . Customer > customers = server . extended ( ) . findList ( query , transaction ) ; assertThat ( customers ) . isNotEmpty ( ) ; transaction . commit ( ) ; } }", "testMethod": "testForeignKeyColumn ( ) { org . tests . model . basic . ResetBasicData . reset ( ) ; java . lang . String rs = \"select<sp>c.id,<sp>c.name,<sp>c.billing_address_id,<sp>c.updtime<sp>\" + ( \"from<sp>o_customer<sp>c<sp>\" + \"order<sp>by<sp>c.id\" ) ; io . ebean . RawSql rawSql = io . ebean . RawSqlBuilder . parse ( rs ) . create ( ) ; java . util . List < org . tests . model . basic . Customer > customers = io . ebean . Ebean . find ( org . tests . model . basic . Customer . class ) . setRawSql ( rawSql ) . findList ( ) ; \"<AssertPlaceHolder>\" . isNotEmpty ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( customers )", "total": "testForeignKeyColumn ( ) { org . tests . model . basic . ResetBasicData . reset ( ) ; java . lang . String rs = \"select<sp>c.id,<sp>c.name,<sp>c.billing_address_id,<sp>c.updtime<sp>\" + ( \"from<sp>o_customer<sp>c<sp>\" + \"order<sp>by<sp>c.id\" ) ; io . ebean . RawSql rawSql = io . ebean . RawSqlBuilder . parse ( rs ) . create ( ) ; java . util . List < org . tests . model . basic . Customer > customers = io . ebean . Ebean . find ( org . tests . model . basic . Customer . class ) . setRawSql ( rawSql ) . findList ( ) ; \"<AssertPlaceHolder>\" . isNotEmpty ( ) ; } findList ( ) { org . tests . model . basic . ResetBasicData . reset ( ) ; io . ebean . EbeanServer server = io . ebean . Ebean . getDefaultServer ( ) ; io . ebean . Query < org . tests . model . basic . Customer > query = server . find ( org . tests . model . basic . Customer . class ) . where ( ) . startsWith ( \"name\" , \"Rob\" ) . query ( ) ; try ( io . ebean . Transaction transaction = server . beginTransaction ( ) ) { java . util . List < org . tests . model . basic . Customer > customers = server . extended ( ) . findList ( query , transaction ) ; assertThat ( customers ) . isNotEmpty ( ) ; transaction . commit ( ) ; } }", "answer": "org . junit . Assert . assertThat ( customers )"}
{"focal": "set ( T ) { if ( ( insertedElement ) != null ) { insertedElement . set ( value ) ; } else { backingList . add ( listIndex , value ) ; insertedElement = new de . fxnn . util . ExistingListElement ( backingList , listIndex ) ; } }", "testMethod": "testSetElementByIndex ( ) { java . util . List < java . lang . Integer > givenList = com . google . common . collect . Lists . newArrayList ( 1 , 2 , 3 ) ; de . fxnn . util . ListElement . elementAt ( givenList , 1 ) . set ( 42 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( givenList . get ( 1 ) , is ( 42 ) )", "total": "testSetElementByIndex ( ) { java . util . List < java . lang . Integer > givenList = com . google . common . collect . Lists . newArrayList ( 1 , 2 , 3 ) ; de . fxnn . util . ListElement . elementAt ( givenList , 1 ) . set ( 42 ) ; \"<AssertPlaceHolder>\" ; } set ( T ) { if ( ( insertedElement ) != null ) { insertedElement . set ( value ) ; } else { backingList . add ( listIndex , value ) ; insertedElement = new de . fxnn . util . ExistingListElement ( backingList , listIndex ) ; } }", "answer": "org . junit . Assert . assertThat ( givenList . get ( 1 ) , is ( 42 ) )"}
{"focal": "size ( ) { return variable . values ( ) . size ( ) ; }", "testMethod": "moveAllRatingsOfANonExistingContribution ( ) { org . silverpeas . core . persistence . Transaction . performInOne ( ( ) -> { org . silverpeas . core . contribution . rating . model . ContributionRatingPK pk = new org . silverpeas . core . contribution . rating . model . ContributionRatingPK ( \"365\" , \"Todo12\" , \"Publication\" ) ; repository . moveAllRatingsOfAContribution ( pk , \"Todo100\" ) ; return null ; } ) ; java . util . List < org . silverpeas . core . contribution . rating . model . Rating > ratings = org . silverpeas . core . contribution . rating . model . RatingFinder . getSomeByQuery ( \"from<sp>Rating<sp>where<sp>instanceId<sp>=<sp>'Todo100'\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ratings . size ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "moveAllRatingsOfANonExistingContribution ( ) { org . silverpeas . core . persistence . Transaction . performInOne ( ( ) -> { org . silverpeas . core . contribution . rating . model . ContributionRatingPK pk = new org . silverpeas . core . contribution . rating . model . ContributionRatingPK ( \"365\" , \"Todo12\" , \"Publication\" ) ; repository . moveAllRatingsOfAContribution ( pk , \"Todo100\" ) ; return null ; } ) ; java . util . List < org . silverpeas . core . contribution . rating . model . Rating > ratings = org . silverpeas . core . contribution . rating . model . RatingFinder . getSomeByQuery ( \"from<sp>Rating<sp>where<sp>instanceId<sp>=<sp>'Todo100'\" ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return variable . values ( ) . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( ratings . size ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "result ( ) { if ( ( flow ) != null ) { flow . completeIfRequired ( ) ; } return new com . hotels . plunger . Data ( getSinkFields ( ) , java . util . Collections . unmodifiableList ( output ) ) ; }", "testMethod": "prefix ( ) { cascading . pipe . Pipe dump = new com . hotels . plunger . Dump ( \"prefix\" , plunger . newPipe ( com . hotels . plunger . DumpTest . INPUT_DATA ) , printStreamSupplier , com . hotels . plunger . DumpTest . FIELDS ) ; com . hotels . plunger . Bucket bucket = plunger . newBucket ( com . hotels . plunger . DumpTest . FIELDS , dump ) ; com . hotels . plunger . Data result = bucket . result ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . InOrder inOrder = inOrder ( mockPrintStream ) ; inOrder . verify ( mockPrintStream ) . append ( \"prefix\" ) ; inOrder . verify ( mockPrintStream ) . append ( \"A\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\t' ) ; inOrder . verify ( mockPrintStream ) . append ( \"B\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\n' ) ; inOrder . verify ( mockPrintStream ) . append ( \"prefix\" ) ; inOrder . verify ( mockPrintStream ) . append ( \"one\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\t' ) ; inOrder . verify ( mockPrintStream ) . append ( \"1\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\n' ) ; inOrder . verify ( mockPrintStream ) . append ( \"prefix\" ) ; inOrder . verify ( mockPrintStream ) . append ( \"two\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\t' ) ; inOrder . verify ( mockPrintStream ) . append ( \"2\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\n' ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( com . hotels . plunger . DumpTest . INPUT_DATA ) )", "total": "prefix ( ) { cascading . pipe . Pipe dump = new com . hotels . plunger . Dump ( \"prefix\" , plunger . newPipe ( com . hotels . plunger . DumpTest . INPUT_DATA ) , printStreamSupplier , com . hotels . plunger . DumpTest . FIELDS ) ; com . hotels . plunger . Bucket bucket = plunger . newBucket ( com . hotels . plunger . DumpTest . FIELDS , dump ) ; com . hotels . plunger . Data result = bucket . result ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . InOrder inOrder = inOrder ( mockPrintStream ) ; inOrder . verify ( mockPrintStream ) . append ( \"prefix\" ) ; inOrder . verify ( mockPrintStream ) . append ( \"A\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\t' ) ; inOrder . verify ( mockPrintStream ) . append ( \"B\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\n' ) ; inOrder . verify ( mockPrintStream ) . append ( \"prefix\" ) ; inOrder . verify ( mockPrintStream ) . append ( \"one\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\t' ) ; inOrder . verify ( mockPrintStream ) . append ( \"1\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\n' ) ; inOrder . verify ( mockPrintStream ) . append ( \"prefix\" ) ; inOrder . verify ( mockPrintStream ) . append ( \"two\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\t' ) ; inOrder . verify ( mockPrintStream ) . append ( \"2\" ) ; inOrder . verify ( mockPrintStream ) . append ( '\\n' ) ; } result ( ) { if ( ( flow ) != null ) { flow . completeIfRequired ( ) ; } return new com . hotels . plunger . Data ( getSinkFields ( ) , java . util . Collections . unmodifiableList ( output ) ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( com . hotels . plunger . DumpTest . INPUT_DATA ) )"}
{"focal": "get ( java . lang . String ) { org . o3project . odenos . remoteobject . message . Response resp = this . sendRequest ( Request . Method . GET , path , org . o3project . odenos . core . logging . message . LogMessage . getSavedTxid ( ) , null ) ; if ( resp . isError ( \"GET\" ) ) { org . o3project . odenos . remoteobject . RemoteObjectIF . log . error ( \"GET<sp>failed:{}\" , resp . statusCode ) ; } return resp ; }", "testMethod": "testAddPath ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow target = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow ( ) ; target . addPath ( \"Link\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . path . get ( 0 ) , org . hamcrest . CoreMatchers . is ( \"Link\" ) )", "total": "testAddPath ( ) { org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow target = new org . o3project . odenos . core . component . network . flow . ofpflow . OFPFlow ( ) ; target . addPath ( \"Link\" ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . String ) { org . o3project . odenos . remoteobject . message . Response resp = this . sendRequest ( Request . Method . GET , path , org . o3project . odenos . core . logging . message . LogMessage . getSavedTxid ( ) , null ) ; if ( resp . isError ( \"GET\" ) ) { org . o3project . odenos . remoteobject . RemoteObjectIF . log . error ( \"GET<sp>failed:{}\" , resp . statusCode ) ; } return resp ; }", "answer": "org . junit . Assert . assertThat ( target . path . get ( 0 ) , org . hamcrest . CoreMatchers . is ( \"Link\" ) )"}
{"focal": "getDuedate ( ) { return duedate ; }", "testMethod": "shouldScheduleToNow ( ) { testRule . deploy ( PROCESS ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE ) ; runtimeService . startProcessInstanceByKey ( PROCESS_KEY ) ; java . lang . String taskId = taskService . createTaskQuery ( ) . singleResult ( ) . getId ( ) ; taskService . complete ( taskId ) ; engineConfiguration . setHistoryCleanupBatchSize ( 3 ) ; engineConfiguration . initHistoryCleanup ( ) ; java . util . Date removalTime = org . apache . commons . lang3 . time . DateUtils . addDays ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE , 5 ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( removalTime ) ; runHistoryCleanup ( ) ; org . camunda . bpm . engine . runtime . Job job = historyService . findHistoryCleanupJobs ( ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( job . getDuedate ( ) , org . hamcrest . core . Is . is ( removalTime ) )", "total": "shouldScheduleToNow ( ) { testRule . deploy ( PROCESS ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE ) ; runtimeService . startProcessInstanceByKey ( PROCESS_KEY ) ; java . lang . String taskId = taskService . createTaskQuery ( ) . singleResult ( ) . getId ( ) ; taskService . complete ( taskId ) ; engineConfiguration . setHistoryCleanupBatchSize ( 3 ) ; engineConfiguration . initHistoryCleanup ( ) ; java . util . Date removalTime = org . apache . commons . lang3 . time . DateUtils . addDays ( org . camunda . bpm . engine . test . api . history . removaltime . cleanup . END_DATE , 5 ) ; org . camunda . bpm . engine . impl . util . ClockUtil . setCurrentTime ( removalTime ) ; runHistoryCleanup ( ) ; org . camunda . bpm . engine . runtime . Job job = historyService . findHistoryCleanupJobs ( ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; } getDuedate ( ) { return duedate ; }", "answer": "org . junit . Assert . assertThat ( job . getDuedate ( ) , org . hamcrest . core . Is . is ( removalTime ) )"}
{"focal": "get_partitions_by_names ( java . lang . String , java . lang . String , java . util . List ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = databaseMappingService . databaseMapping ( db_name ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > partitions = mapping . getClient ( ) . get_partitions_by_names ( mapping . transformInboundDatabaseName ( db_name ) , tbl_name , names ) ; return mapping . transformOutboundPartitions ( partitions ) ; }", "testMethod": "get_partitions_by_names ( ) { java . util . List < org . apache . hadoop . hive . metastore . api . Partition > partitions = com . google . common . collect . Lists . newArrayList ( ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > outbound = com . google . common . collect . Lists . newArrayList ( ) ; java . util . List < java . lang . String > names = com . google . common . collect . Lists . newArrayList ( ) ; when ( primaryMapping . transformInboundDatabaseName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ) . thenReturn ( \"inbound\" ) ; when ( primaryClient . get_partitions_by_names ( \"inbound\" , \"table\" , names ) ) . thenReturn ( partitions ) ; when ( primaryMapping . transformOutboundPartitions ( partitions ) ) . thenReturn ( outbound ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > result = handler . get_partitions_by_names ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P , \"table\" , names ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping , never ( ) ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )", "total": "get_partitions_by_names ( ) { java . util . List < org . apache . hadoop . hive . metastore . api . Partition > partitions = com . google . common . collect . Lists . newArrayList ( ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > outbound = com . google . common . collect . Lists . newArrayList ( ) ; java . util . List < java . lang . String > names = com . google . common . collect . Lists . newArrayList ( ) ; when ( primaryMapping . transformInboundDatabaseName ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ) . thenReturn ( \"inbound\" ) ; when ( primaryClient . get_partitions_by_names ( \"inbound\" , \"table\" , names ) ) . thenReturn ( partitions ) ; when ( primaryMapping . transformOutboundPartitions ( partitions ) ) . thenReturn ( outbound ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > result = handler . get_partitions_by_names ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P , \"table\" , names ) ; \"<AssertPlaceHolder>\" ; verify ( primaryMapping , never ( ) ) . checkWritePermissions ( com . hotels . bdp . waggledance . server . FederatedHMSHandlerTest . DB_P ) ; } get_partitions_by_names ( java . lang . String , java . lang . String , java . util . List ) { com . hotels . bdp . waggledance . mapping . model . DatabaseMapping mapping = databaseMappingService . databaseMapping ( db_name ) ; java . util . List < org . apache . hadoop . hive . metastore . api . Partition > partitions = mapping . getClient ( ) . get_partitions_by_names ( mapping . transformInboundDatabaseName ( db_name ) , tbl_name , names ) ; return mapping . transformOutboundPartitions ( partitions ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( outbound ) )"}
{"focal": "getStatus ( ) { return status ; }", "testMethod": "setStatus_enumValue_statusIsAccepted ( ) { eu . chargetime . ocpp . model . core . RegistrationStatus status = eu . chargetime . ocpp . model . core . RegistrationStatus . Accepted ; confirmation . setStatus ( status ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( confirmation . getStatus ( ) , org . hamcrest . CoreMatchers . equalTo ( status ) )", "total": "setStatus_enumValue_statusIsAccepted ( ) { eu . chargetime . ocpp . model . core . RegistrationStatus status = eu . chargetime . ocpp . model . core . RegistrationStatus . Accepted ; confirmation . setStatus ( status ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( confirmation . getStatus ( ) , org . hamcrest . CoreMatchers . equalTo ( status ) )"}
{"focal": "is ( java . lang . String ) { return org . sonatype . nexus . rapture . PasswordPlaceholder . VALUE . equals ( value ) ; }", "testMethod": "completeSuffix ( ) { final com . google . common . collect . Range < java . lang . Long > fullContent = parser . parseRangeSpec ( \"bytes=0-\" , 10L ) . get ( 0 ) ; final com . google . common . collect . Range < java . lang . Long > fullSuffix = parser . parseRangeSpec ( \"bytes=-10\" , 10L ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fullSuffix , org . hamcrest . Matchers . is ( fullContent ) )", "total": "completeSuffix ( ) { final com . google . common . collect . Range < java . lang . Long > fullContent = parser . parseRangeSpec ( \"bytes=0-\" , 10L ) . get ( 0 ) ; final com . google . common . collect . Range < java . lang . Long > fullSuffix = parser . parseRangeSpec ( \"bytes=-10\" , 10L ) . get ( 0 ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { return org . sonatype . nexus . rapture . PasswordPlaceholder . VALUE . equals ( value ) ; }", "answer": "org . junit . Assert . assertThat ( fullSuffix , org . hamcrest . Matchers . is ( fullContent ) )"}
{"focal": "between ( net . time4j . range . Boundary , net . time4j . range . Boundary ) { return new net . time4j . range . ClockInterval ( start , end ) ; }", "testMethod": "containsTemporalLeftEdgeClosed ( ) { net . time4j . PlainTime start = net . time4j . PlainTime . of ( 14 , 45 ) ; net . time4j . PlainTime end = net . time4j . PlainTime . of ( 21 , 30 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( net . time4j . range . ClockInterval . between ( start , end ) . contains ( start ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "containsTemporalLeftEdgeClosed ( ) { net . time4j . PlainTime start = net . time4j . PlainTime . of ( 14 , 45 ) ; net . time4j . PlainTime end = net . time4j . PlainTime . of ( 21 , 30 ) ; \"<AssertPlaceHolder>\" ; } between ( net . time4j . range . Boundary , net . time4j . range . Boundary ) { return new net . time4j . range . ClockInterval ( start , end ) ; }", "answer": "org . junit . Assert . assertThat ( net . time4j . range . ClockInterval . between ( start , end ) . contains ( start ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "checkPayloadAndContentType ( com . spotify . apollo . Response ) { org . junit . Assert . assertThat ( response . payload ( ) . get ( ) . utf8 ( ) , org . hamcrest . CoreMatchers . equalTo ( \"{\\\"x\\\":3}\" ) ) ; com . spotify . apollo . route . JsonSerializerMiddlewaresTest . checkContentType ( response ) ; }", "testMethod": "shouldJsonSerializeResponseSync ( ) { com . spotify . apollo . route . Middleware < com . spotify . apollo . route . SyncHandler < com . spotify . apollo . Response < com . spotify . apollo . route . JsonSerializerMiddlewaresTest . TestBean > > , com . spotify . apollo . route . AsyncHandler < com . spotify . apollo . Response < okio . ByteString > > > sync = com . spotify . apollo . route . JsonSerializerMiddlewares . jsonSerializeResponseSync ( com . spotify . apollo . route . JsonSerializerMiddlewaresTest . WRITER ) ; com . spotify . apollo . Response < okio . ByteString > response = sync . apply ( ( rq ) -> com . spotify . apollo . Response . forStatus ( Status . CONFLICT ) . withPayload ( new com . spotify . apollo . route . TestBean ( ) ) ) . invoke ( null ) . toCompletableFuture ( ) . get ( ) ; com . spotify . apollo . route . JsonSerializerMiddlewaresTest . checkPayloadAndContentType ( response ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . status ( ) , org . hamcrest . CoreMatchers . equalTo ( Status . CONFLICT ) )", "total": "shouldJsonSerializeResponseSync ( ) { com . spotify . apollo . route . Middleware < com . spotify . apollo . route . SyncHandler < com . spotify . apollo . Response < com . spotify . apollo . route . JsonSerializerMiddlewaresTest . TestBean > > , com . spotify . apollo . route . AsyncHandler < com . spotify . apollo . Response < okio . ByteString > > > sync = com . spotify . apollo . route . JsonSerializerMiddlewares . jsonSerializeResponseSync ( com . spotify . apollo . route . JsonSerializerMiddlewaresTest . WRITER ) ; com . spotify . apollo . Response < okio . ByteString > response = sync . apply ( ( rq ) -> com . spotify . apollo . Response . forStatus ( Status . CONFLICT ) . withPayload ( new com . spotify . apollo . route . TestBean ( ) ) ) . invoke ( null ) . toCompletableFuture ( ) . get ( ) ; com . spotify . apollo . route . JsonSerializerMiddlewaresTest . checkPayloadAndContentType ( response ) ; \"<AssertPlaceHolder>\" ; } checkPayloadAndContentType ( com . spotify . apollo . Response ) { org . junit . Assert . assertThat ( response . payload ( ) . get ( ) . utf8 ( ) , org . hamcrest . CoreMatchers . equalTo ( \"{\\\"x\\\":3}\" ) ) ; com . spotify . apollo . route . JsonSerializerMiddlewaresTest . checkContentType ( response ) ; }", "answer": "org . junit . Assert . assertThat ( response . status ( ) , org . hamcrest . CoreMatchers . equalTo ( Status . CONFLICT ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "__A$Enumeration ( ) { java . util . Enumeration < java . lang . Object > e = new java . util . StringTokenizer ( \"<sp><sp>\" ) ; com . m3 . scalaflavor4j . Seq < java . lang . Object > seq = com . m3 . scalaflavor4j . Seq . apply ( e ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( seq . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 3 ) ) )", "total": "__A$Enumeration ( ) { java . util . Enumeration < java . lang . Object > e = new java . util . StringTokenizer ( \"<sp><sp>\" ) ; com . m3 . scalaflavor4j . Seq < java . lang . Object > seq = com . m3 . scalaflavor4j . Seq . apply ( e ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( seq . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 3 ) ) )"}
{"focal": "getValue ( int , int ) { java . lang . String key = keys . get ( column ) ; if ( row == 0 ) { return key ; } int currentRow = row - 1 ; if ( ( mappings . get ( key ) . size ( ) ) > currentRow ) { return mappings . get ( key ) . get ( currentRow ) ; } else { return null ; } }", "testMethod": "testStatusWithSummary ( ) { java . util . Collection < org . springframework . cloud . deployer . admin . rest . resource . AppStatusResource > data = new java . util . ArrayList ( ) ; data . add ( appStatusResource1 ) ; data . add ( appStatusResource2 ) ; data . add ( appStatusResource3 ) ; org . springframework . hateoas . PagedResources . PageMetadata metadata = new org . springframework . hateoas . PagedResources . PageMetadata ( data . size ( ) , 1 , data . size ( ) , 1 ) ; org . springframework . hateoas . PagedResources < org . springframework . cloud . deployer . admin . rest . resource . AppStatusResource > result = new org . springframework . hateoas . PagedResources ( data , metadata ) ; when ( runtimeOperations . status ( ) ) . thenReturn ( result ) ; java . lang . Object [ ] [ ] expected = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"1\" , \"deployed\" , \"2\" } , new java . lang . String [ ] { \"2\" , \"undeployed\" , \"0\" } , new java . lang . String [ ] { \"3\" , \"failed\" , \"0\" } } ; org . springframework . shell . table . TableModel model = runtimeCommands . list ( true , null ) . getModel ( ) ; for ( int row = 0 ; row < ( expected . length ) ; row ++ ) { for ( int col = 0 ; col < ( expected [ row ] . length ) ; col ++ ) { \"<AssertPlaceHolder>\" ; } } }", "assertLine": "org . junit . Assert . assertThat ( java . lang . String . valueOf ( model . getValue ( ( row + 1 ) , col ) ) , org . hamcrest . Matchers . is ( expected [ row ] [ col ] ) )", "total": "testStatusWithSummary ( ) { java . util . Collection < org . springframework . cloud . deployer . admin . rest . resource . AppStatusResource > data = new java . util . ArrayList ( ) ; data . add ( appStatusResource1 ) ; data . add ( appStatusResource2 ) ; data . add ( appStatusResource3 ) ; org . springframework . hateoas . PagedResources . PageMetadata metadata = new org . springframework . hateoas . PagedResources . PageMetadata ( data . size ( ) , 1 , data . size ( ) , 1 ) ; org . springframework . hateoas . PagedResources < org . springframework . cloud . deployer . admin . rest . resource . AppStatusResource > result = new org . springframework . hateoas . PagedResources ( data , metadata ) ; when ( runtimeOperations . status ( ) ) . thenReturn ( result ) ; java . lang . Object [ ] [ ] expected = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"1\" , \"deployed\" , \"2\" } , new java . lang . String [ ] { \"2\" , \"undeployed\" , \"0\" } , new java . lang . String [ ] { \"3\" , \"failed\" , \"0\" } } ; org . springframework . shell . table . TableModel model = runtimeCommands . list ( true , null ) . getModel ( ) ; for ( int row = 0 ; row < ( expected . length ) ; row ++ ) { for ( int col = 0 ; col < ( expected [ row ] . length ) ; col ++ ) { \"<AssertPlaceHolder>\" ; } } } getValue ( int , int ) { java . lang . String key = keys . get ( column ) ; if ( row == 0 ) { return key ; } int currentRow = row - 1 ; if ( ( mappings . get ( key ) . size ( ) ) > currentRow ) { return mappings . get ( key ) . get ( currentRow ) ; } else { return null ; } }", "answer": "org . junit . Assert . assertThat ( java . lang . String . valueOf ( model . getValue ( ( row + 1 ) , col ) ) , org . hamcrest . Matchers . is ( expected [ row ] [ col ] ) )"}
{"focal": "toParameterMap ( ) { java . util . Map < java . lang . String , java . lang . Object > parameters = new java . util . HashMap ( ) ; parameters . put ( \"name\" , this . name ) ; parameters . put ( \"latitude\" , this . latitude ) ; parameters . put ( \"longitude\" , this . longitude ) ; return parameters ; }", "testMethod": "findByPointShouldWorkWhenConvertedToNative ( ) { org . neo4j . driver . v1 . Driver driver = sessionFactory . unwrap ( org . neo4j . driver . v1 . Driver . class ) ; try ( org . neo4j . driver . v1 . Session session = driver . session ( ) ; org . neo4j . driver . v1 . Transaction transaction = session . beginTransaction ( ) ) { for ( org . springframework . data . neo4j . nativetypes . SpatialConversionTests . ParamHolder useNativePoints : java . util . Arrays . asList ( org . springframework . data . neo4j . nativetypes . SpatialConversionTests . NEO_HQ , org . springframework . data . neo4j . nativetypes . SpatialConversionTests . CLARION ) ) { transaction . run ( \"CREATE<sp>(n:SpatialDomain<sp>{name:<sp>$name,<sp>sdnPoint:<sp>point({latitude:<sp>$latitude,<sp>longitude:<sp>$longitude})})\" , useNativePoints . toParameterMap ( ) ) ; } transaction . run ( \"CREATE<sp>(n:SpatialDomain<sp>{name:<sp>$name,<sp>latitude:<sp>$latitude,<sp>longitude:<sp>$longitude})\" , org . springframework . data . neo4j . nativetypes . SpatialConversionTests . MINC . toParameterMap ( ) ) ; transaction . success ( ) ; } java . util . List < org . springframework . data . neo4j . nativetypes . SpatialDomain > result = repository . findBySdnPointNear ( new org . springframework . data . geo . Distance ( ( 60.0 / 1000.0 ) , org . springframework . data . geo . Metrics . KILOMETERS ) , new org . springframework . data . geo . Point ( 55.611883 , 12.994608 ) ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . extracting ( SpatialDomain :: getName ) . containsExactlyInAnyOrder ( \"Neo4j<sp>HQ\" , \"Minc\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( result )", "total": "findByPointShouldWorkWhenConvertedToNative ( ) { org . neo4j . driver . v1 . Driver driver = sessionFactory . unwrap ( org . neo4j . driver . v1 . Driver . class ) ; try ( org . neo4j . driver . v1 . Session session = driver . session ( ) ; org . neo4j . driver . v1 . Transaction transaction = session . beginTransaction ( ) ) { for ( org . springframework . data . neo4j . nativetypes . SpatialConversionTests . ParamHolder useNativePoints : java . util . Arrays . asList ( org . springframework . data . neo4j . nativetypes . SpatialConversionTests . NEO_HQ , org . springframework . data . neo4j . nativetypes . SpatialConversionTests . CLARION ) ) { transaction . run ( \"CREATE<sp>(n:SpatialDomain<sp>{name:<sp>$name,<sp>sdnPoint:<sp>point({latitude:<sp>$latitude,<sp>longitude:<sp>$longitude})})\" , useNativePoints . toParameterMap ( ) ) ; } transaction . run ( \"CREATE<sp>(n:SpatialDomain<sp>{name:<sp>$name,<sp>latitude:<sp>$latitude,<sp>longitude:<sp>$longitude})\" , org . springframework . data . neo4j . nativetypes . SpatialConversionTests . MINC . toParameterMap ( ) ) ; transaction . success ( ) ; } java . util . List < org . springframework . data . neo4j . nativetypes . SpatialDomain > result = repository . findBySdnPointNear ( new org . springframework . data . geo . Distance ( ( 60.0 / 1000.0 ) , org . springframework . data . geo . Metrics . KILOMETERS ) , new org . springframework . data . geo . Point ( 55.611883 , 12.994608 ) ) ; \"<AssertPlaceHolder>\" . hasSize ( 2 ) . extracting ( SpatialDomain :: getName ) . containsExactlyInAnyOrder ( \"Neo4j<sp>HQ\" , \"Minc\" ) ; } toParameterMap ( ) { java . util . Map < java . lang . String , java . lang . Object > parameters = new java . util . HashMap ( ) ; parameters . put ( \"name\" , this . name ) ; parameters . put ( \"latitude\" , this . latitude ) ; parameters . put ( \"longitude\" , this . longitude ) ; return parameters ; }", "answer": "org . junit . Assert . assertThat ( result )"}
{"focal": "lookup ( org . onlab . packet . MacAddress ) { return neighborList . get ( isisNeighborMac ) ; }", "testMethod": "testIfResourceIsNotFound ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . net . resource . DiscreteResource res2 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"b\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sut . lookup ( res2 . id ( ) ) , org . hamcrest . Matchers . is ( java . util . Optional . empty ( ) ) )", "total": "testIfResourceIsNotFound ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . net . resource . DiscreteResource res2 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"b\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources sut = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; \"<AssertPlaceHolder>\" ; } lookup ( org . onlab . packet . MacAddress ) { return neighborList . get ( isisNeighborMac ) ; }", "answer": "org . junit . Assert . assertThat ( sut . lookup ( res2 . id ( ) ) , org . hamcrest . Matchers . is ( java . util . Optional . empty ( ) ) )"}
{"focal": "hasProperties ( ) { return ( ( properties ) != null ) && ( ! ( properties . isEmpty ( ) ) ) ; }", "testMethod": "shouldHaveProperties ( ) { entry . getProperties ( ) . put ( \"mykey\" , \"myvalue\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( entry . hasProperties ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( true ) ) )", "total": "shouldHaveProperties ( ) { entry . getProperties ( ) . put ( \"mykey\" , \"myvalue\" ) ; \"<AssertPlaceHolder>\" ; } hasProperties ( ) { return ( ( properties ) != null ) && ( ! ( properties . isEmpty ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( entry . hasProperties ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( true ) ) )"}
{"focal": "isEnabled ( ) { return ( ( ( incrementalSerialSuffix ) != null ) || ( ( suffix ) != null ) ) || ( ( override ) != null ) ; }", "testMethod": "testRelocationsWithGroupInvalid ( ) { final java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( RelocationState . DEPENDENCY_RELOCATIONS ) + \"oldGroupId:oldA@:newA\" ) , \"\" ) ; final org . commonjava . maven . ext . core . state . RelocationState state = new org . commonjava . maven . ext . core . state . RelocationState ( p ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( state . isEnabled ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "testRelocationsWithGroupInvalid ( ) { final java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( ( ( RelocationState . DEPENDENCY_RELOCATIONS ) + \"oldGroupId:oldA@:newA\" ) , \"\" ) ; final org . commonjava . maven . ext . core . state . RelocationState state = new org . commonjava . maven . ext . core . state . RelocationState ( p ) ; \"<AssertPlaceHolder>\" ; } isEnabled ( ) { return ( ( ( incrementalSerialSuffix ) != null ) || ( ( suffix ) != null ) ) || ( ( override ) != null ) ; }", "answer": "org . junit . Assert . assertThat ( state . isEnabled ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "getPutIntoPlay ( ) { return putIntoPlay ; }", "testMethod": "GIVEN_the_batch_size_is_greater_than_available_stories_to_play_WHEN_the_iteration_is_run_THEN_the_number_of_stories_put_into_play_matches_available_stories ( ) { int storiesAvailableToPlay = ( batchSize ) - 1 ; iterationResult . run ( storiesAvailableToPlay ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( iterationResult . getPutIntoPlay ( ) , is ( storiesAvailableToPlay ) )", "total": "GIVEN_the_batch_size_is_greater_than_available_stories_to_play_WHEN_the_iteration_is_run_THEN_the_number_of_stories_put_into_play_matches_available_stories ( ) { int storiesAvailableToPlay = ( batchSize ) - 1 ; iterationResult . run ( storiesAvailableToPlay ) ; \"<AssertPlaceHolder>\" ; } getPutIntoPlay ( ) { return putIntoPlay ; }", "answer": "org . junit . Assert . assertThat ( iterationResult . getPutIntoPlay ( ) , is ( storiesAvailableToPlay ) )"}
{"focal": "getAccessToken ( ) { return configuration . getAccessToken ( ) ; }", "testMethod": "ignoresIntermediateAccessTokenStatusChanges ( ) { final java . lang . String accessToken = \"mock<sp>token\" ; profile . setAccessTokenStatus ( OAuth2Profile . AccessTokenStatus . WAITING_FOR_AUTHORIZATION ) ; java . lang . Runnable simulatedAccessTokenRetrieval = new java . lang . Runnable ( ) { public void run ( ) { try { java . lang . Thread . sleep ( 50 ) ; profile . setAccessTokenStatus ( OAuth2Profile . AccessTokenStatus . WAITING_FOR_AUTHORIZATION ) ; java . lang . Thread . sleep ( 10 ) ; } catch ( java . lang . InterruptedException ignore ) { } profile . applyRetrievedAccessToken ( accessToken ) ; } } ; new java . lang . Thread ( simulatedAccessTokenRetrieval ) . start ( ) ; profile . waitForAccessTokenStatus ( OAuth2Profile . AccessTokenStatus . RETRIEVED_FROM_SERVER , 1000 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( profile . getAccessToken ( ) , org . hamcrest . core . Is . is ( accessToken ) )", "total": "ignoresIntermediateAccessTokenStatusChanges ( ) { final java . lang . String accessToken = \"mock<sp>token\" ; profile . setAccessTokenStatus ( OAuth2Profile . AccessTokenStatus . WAITING_FOR_AUTHORIZATION ) ; java . lang . Runnable simulatedAccessTokenRetrieval = new java . lang . Runnable ( ) { public void run ( ) { try { java . lang . Thread . sleep ( 50 ) ; profile . setAccessTokenStatus ( OAuth2Profile . AccessTokenStatus . WAITING_FOR_AUTHORIZATION ) ; java . lang . Thread . sleep ( 10 ) ; } catch ( java . lang . InterruptedException ignore ) { } profile . applyRetrievedAccessToken ( accessToken ) ; } } ; new java . lang . Thread ( simulatedAccessTokenRetrieval ) . start ( ) ; profile . waitForAccessTokenStatus ( OAuth2Profile . AccessTokenStatus . RETRIEVED_FROM_SERVER , 1000 ) ; \"<AssertPlaceHolder>\" ; } getAccessToken ( ) { return configuration . getAccessToken ( ) ; }", "answer": "org . junit . Assert . assertThat ( profile . getAccessToken ( ) , org . hamcrest . core . Is . is ( accessToken ) )"}
{"focal": "get ( uk . gov . pay . adminusers . model . PaymentType ) { java . lang . String apiKey = ( paymentType == ( DIRECT_DEBIT ) ) ? configuration . getDirectDebitApiKey ( ) : configuration . getCardApiKey ( ) ; return new uk . gov . service . notify . NotificationClient ( apiKey , configuration . getNotificationBaseURL ( ) , null ) ; }", "testMethod": "shouldCreateAUser_Successfully ( ) { java . lang . String username = randomUuid ( ) ; com . google . common . collect . ImmutableMap < java . lang . Object , java . lang . Object > userPayload = com . google . common . collect . ImmutableMap . builder ( ) . put ( \"admin\" 0 , username ) . put ( \"admin\" 8 , ( ( \"user-\" + username ) + \"admin\" 6 ) ) . put ( \"telephone_number\" , \"admin\" 5 ) . put ( \"otp_key\" , \"34f34\" ) . put ( \"role_name\" , \"admin\" ) . build ( ) ; io . restassured . response . ValidatableResponse response = givenSetup ( ) . when ( ) . body ( mapper . writeValueAsString ( userPayload ) ) . contentType ( io . restassured . http . ContentType . JSON ) . accept ( io . restassured . http . ContentType . JSON ) . post ( uk . gov . pay . adminusers . resources . USERS_RESOURCE_URL ) . then ( ) ; java . lang . String externalId = response . extract ( ) . path ( \"admin\" 1 ) ; response . statusCode ( 201 ) . body ( \"admin\" 3 , org . hamcrest . Matchers . nullValue ( ) ) . body ( \"admin\" 1 , org . hamcrest . core . Is . is ( externalId ) ) . body ( \"admin\" 0 , org . hamcrest . core . Is . is ( username ) ) . body ( \"admin\" 4 , org . hamcrest . Matchers . nullValue ( ) ) . body ( \"admin\" 8 , org . hamcrest . core . Is . is ( ( ( \"user-\" + username ) + \"admin\" 6 ) ) ) . body ( \"service_roles\" , org . hamcrest . Matchers . hasSize ( 0 ) ) . body ( \"telephone_number\" , org . hamcrest . core . Is . is ( \"admin\" 5 ) ) . body ( \"otp_key\" , org . hamcrest . core . Is . is ( \"34f34\" ) ) . body ( \"admin\" 2 , org . hamcrest . core . Is . is ( 0 ) ) . body ( \"disabled\" , org . hamcrest . core . Is . is ( false ) ) ; response . body ( \"admin\" 9 , org . hamcrest . Matchers . hasSize ( 1 ) ) . body ( \"disabled\" 0 , org . hamcrest . core . Is . is ( ( \"admin\" 7 + externalId ) ) ) . body ( \"disabled\" 1 , org . hamcrest . core . Is . is ( \"GET\" ) ) . body ( \"_links[0].rel\" , org . hamcrest . core . Is . is ( \"disabled\" 2 ) ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > userByExternalId = databaseHelper . findUserByExternalId ( externalId ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > servicesAssociatedToUser = databaseHelper . findUserServicesByUserId ( ( ( java . lang . Integer ) ( userByExternalId . get ( 0 ) . get ( \"admin\" 3 ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( servicesAssociatedToUser . size ( ) , org . hamcrest . core . Is . is ( 0 ) )", "total": "shouldCreateAUser_Successfully ( ) { java . lang . String username = randomUuid ( ) ; com . google . common . collect . ImmutableMap < java . lang . Object , java . lang . Object > userPayload = com . google . common . collect . ImmutableMap . builder ( ) . put ( \"admin\" 0 , username ) . put ( \"admin\" 8 , ( ( \"user-\" + username ) + \"admin\" 6 ) ) . put ( \"telephone_number\" , \"admin\" 5 ) . put ( \"otp_key\" , \"34f34\" ) . put ( \"role_name\" , \"admin\" ) . build ( ) ; io . restassured . response . ValidatableResponse response = givenSetup ( ) . when ( ) . body ( mapper . writeValueAsString ( userPayload ) ) . contentType ( io . restassured . http . ContentType . JSON ) . accept ( io . restassured . http . ContentType . JSON ) . post ( uk . gov . pay . adminusers . resources . USERS_RESOURCE_URL ) . then ( ) ; java . lang . String externalId = response . extract ( ) . path ( \"admin\" 1 ) ; response . statusCode ( 201 ) . body ( \"admin\" 3 , org . hamcrest . Matchers . nullValue ( ) ) . body ( \"admin\" 1 , org . hamcrest . core . Is . is ( externalId ) ) . body ( \"admin\" 0 , org . hamcrest . core . Is . is ( username ) ) . body ( \"admin\" 4 , org . hamcrest . Matchers . nullValue ( ) ) . body ( \"admin\" 8 , org . hamcrest . core . Is . is ( ( ( \"user-\" + username ) + \"admin\" 6 ) ) ) . body ( \"service_roles\" , org . hamcrest . Matchers . hasSize ( 0 ) ) . body ( \"telephone_number\" , org . hamcrest . core . Is . is ( \"admin\" 5 ) ) . body ( \"otp_key\" , org . hamcrest . core . Is . is ( \"34f34\" ) ) . body ( \"admin\" 2 , org . hamcrest . core . Is . is ( 0 ) ) . body ( \"disabled\" , org . hamcrest . core . Is . is ( false ) ) ; response . body ( \"admin\" 9 , org . hamcrest . Matchers . hasSize ( 1 ) ) . body ( \"disabled\" 0 , org . hamcrest . core . Is . is ( ( \"admin\" 7 + externalId ) ) ) . body ( \"disabled\" 1 , org . hamcrest . core . Is . is ( \"GET\" ) ) . body ( \"_links[0].rel\" , org . hamcrest . core . Is . is ( \"disabled\" 2 ) ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > userByExternalId = databaseHelper . findUserByExternalId ( externalId ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > servicesAssociatedToUser = databaseHelper . findUserServicesByUserId ( ( ( java . lang . Integer ) ( userByExternalId . get ( 0 ) . get ( \"admin\" 3 ) ) ) ) ; \"<AssertPlaceHolder>\" ; } get ( uk . gov . pay . adminusers . model . PaymentType ) { java . lang . String apiKey = ( paymentType == ( DIRECT_DEBIT ) ) ? configuration . getDirectDebitApiKey ( ) : configuration . getCardApiKey ( ) ; return new uk . gov . service . notify . NotificationClient ( apiKey , configuration . getNotificationBaseURL ( ) , null ) ; }", "answer": "org . junit . Assert . assertThat ( servicesAssociatedToUser . size ( ) , org . hamcrest . core . Is . is ( 0 ) )"}
{"focal": "get ( java . lang . Class ) { if ( featureClass == null ) { return null ; } T feature = ( ( T ) ( features . get ( featureClass ) ) ) ; if ( ( feature == null ) && ( featureClass . isInstance ( this ) ) ) { feature = ( ( T ) ( this ) ) ; } return feature ; }", "testMethod": "shouldWorkAsAnOption ( ) { com . oracle . bedrock . runtime . remote . options . Deployment deployment = com . oracle . bedrock . runtime . remote . java . options . JavaDeployment . automatic ( ) ; com . oracle . bedrock . OptionsByType optionsByType = com . oracle . bedrock . OptionsByType . of ( deployment ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( optionsByType . get ( com . oracle . bedrock . runtime . remote . options . Deployment . class ) , org . hamcrest . CoreMatchers . is ( deployment ) )", "total": "shouldWorkAsAnOption ( ) { com . oracle . bedrock . runtime . remote . options . Deployment deployment = com . oracle . bedrock . runtime . remote . java . options . JavaDeployment . automatic ( ) ; com . oracle . bedrock . OptionsByType optionsByType = com . oracle . bedrock . OptionsByType . of ( deployment ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . Class ) { if ( featureClass == null ) { return null ; } T feature = ( ( T ) ( features . get ( featureClass ) ) ) ; if ( ( feature == null ) && ( featureClass . isInstance ( this ) ) ) { feature = ( ( T ) ( this ) ) ; } return feature ; }", "answer": "org . junit . Assert . assertThat ( optionsByType . get ( com . oracle . bedrock . runtime . remote . options . Deployment . class ) , org . hamcrest . CoreMatchers . is ( deployment ) )"}
{"focal": "empty ( ) { org . geotools . geometry . jts . ReferencedEnvelope3D bbox = new org . geotools . geometry . jts . ReferencedEnvelope3D ( ) ; org . junit . Assert . assertNull ( bbox . getCoordinateReferenceSystem ( ) ) ; org . geotools . geometry . jts . ReferencedEnvelope3D australia = new org . geotools . geometry . jts . ReferencedEnvelope3D ( org . geotools . referencing . crs . DefaultGeographicCRS . WGS84_3D ) ; australia . include ( 40 , 110 , 0 ) ; australia . include ( 10 , 150 , 10 ) ; bbox . include ( australia ) ; org . junit . Assert . assertEquals ( australia . getCoordinateReferenceSystem ( ) , bbox . getCoordinateReferenceSystem ( ) ) ; org . junit . Assert . assertEquals ( 0 , bbox . getMinZ ( ) , 0.0 ) ; org . junit . Assert . assertEquals ( 10 , bbox . getMaxZ ( ) , 0.0 ) ; }", "testMethod": "testNestedRenderingTransform ( ) { java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; builder . append ( \"transform:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 2 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>data:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 8 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 9 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 0 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 2 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 5 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 1 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 3 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>minObservations:<sp>2\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>maxObservationDistance:<sp>15\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>pixelsPerCell:<sp>8\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 1 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 3 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 6 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>-<sp>5\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 0 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 7 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"\" ) ; java . util . List < org . yaml . snakeyaml . error . MarkedYAMLException > errors = validate ( builder . toString ( ) , Collections . EMPTY_LIST ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( errors , org . hamcrest . Matchers . empty ( ) )", "total": "testNestedRenderingTransform ( ) { java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; builder . append ( \"transform:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 2 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>data:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 8 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 9 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 0 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 2 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 5 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 1 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 3 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>minObservations:<sp>2\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>maxObservationDistance:<sp>15\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>pixelsPerCell:<sp>8\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 1 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 3 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 6 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>-<sp>5\" ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>queryBuffer:<sp>40\" 0 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"<sp>params:\" 7 ) . append ( \"<sp>queryBuffer:<sp>40\" 4 ) . append ( \"\" ) ; java . util . List < org . yaml . snakeyaml . error . MarkedYAMLException > errors = validate ( builder . toString ( ) , Collections . EMPTY_LIST ) ; \"<AssertPlaceHolder>\" ; } empty ( ) { org . geotools . geometry . jts . ReferencedEnvelope3D bbox = new org . geotools . geometry . jts . ReferencedEnvelope3D ( ) ; org . junit . Assert . assertNull ( bbox . getCoordinateReferenceSystem ( ) ) ; org . geotools . geometry . jts . ReferencedEnvelope3D australia = new org . geotools . geometry . jts . ReferencedEnvelope3D ( org . geotools . referencing . crs . DefaultGeographicCRS . WGS84_3D ) ; australia . include ( 40 , 110 , 0 ) ; australia . include ( 10 , 150 , 10 ) ; bbox . include ( australia ) ; org . junit . Assert . assertEquals ( australia . getCoordinateReferenceSystem ( ) , bbox . getCoordinateReferenceSystem ( ) ) ; org . junit . Assert . assertEquals ( 0 , bbox . getMinZ ( ) , 0.0 ) ; org . junit . Assert . assertEquals ( 10 , bbox . getMaxZ ( ) , 0.0 ) ; }", "answer": "org . junit . Assert . assertThat ( errors , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getStatusCode ( ) { return statusCode ; }", "testMethod": "routeForAnonymoumsMethodReferenceWithContext ( ) { ninja . Context context = mock ( ninja . Context . class ) ; when ( context . getParameterAsInteger ( \"status\" ) ) . thenReturn ( 206 ) ; ninja . Route route = router . getRouteFor ( \"GET\" , \"/anonymous_method_ref_context\" ) ; ninja . Result result = route . getFilterChain ( ) . next ( context ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . getStatusCode ( ) , org . hamcrest . CoreMatchers . is ( 206 ) )", "total": "routeForAnonymoumsMethodReferenceWithContext ( ) { ninja . Context context = mock ( ninja . Context . class ) ; when ( context . getParameterAsInteger ( \"status\" ) ) . thenReturn ( 206 ) ; ninja . Route route = router . getRouteFor ( \"GET\" , \"/anonymous_method_ref_context\" ) ; ninja . Result result = route . getFilterChain ( ) . next ( context ) ; \"<AssertPlaceHolder>\" ; } getStatusCode ( ) { return statusCode ; }", "answer": "org . junit . Assert . assertThat ( result . getStatusCode ( ) , org . hamcrest . CoreMatchers . is ( 206 ) )"}
{"focal": "asKeyList ( ) { query . setKeysOnly ( ) ; java . util . List < com . google . appengine . api . datastore . Entity > entityList = asEntityList ( ) ; java . util . List < com . google . appengine . api . datastore . Key > ret = new java . util . ArrayList < com . google . appengine . api . datastore . Key > ( entityList . size ( ) ) ; for ( com . google . appengine . api . datastore . Entity e : entityList ) { ret . add ( e . getKey ( ) ) ; } return ret ; }", "testMethod": "asKeyList ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . DatastoreUtil . put ( ds , null , new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . ModelQuery < org . slim3 . datastore . model . Hoge > query = new org . slim3 . datastore . ModelQuery < org . slim3 . datastore . model . Hoge > ( ds , meta ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . asKeyList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( key ) ) )", "total": "asKeyList ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . DatastoreUtil . put ( ds , null , new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . ModelQuery < org . slim3 . datastore . model . Hoge > query = new org . slim3 . datastore . ModelQuery < org . slim3 . datastore . model . Hoge > ( ds , meta ) ; \"<AssertPlaceHolder>\" ; } asKeyList ( ) { query . setKeysOnly ( ) ; java . util . List < com . google . appengine . api . datastore . Entity > entityList = asEntityList ( ) ; java . util . List < com . google . appengine . api . datastore . Key > ret = new java . util . ArrayList < com . google . appengine . api . datastore . Key > ( entityList . size ( ) ) ; for ( com . google . appengine . api . datastore . Entity e : entityList ) { ret . add ( e . getKey ( ) ) ; } return ret ; }", "answer": "org . junit . Assert . assertThat ( query . asKeyList ( ) , org . hamcrest . CoreMatchers . is ( java . util . Arrays . asList ( key ) ) )"}
{"focal": "error ( ) { return new org . terasoluna . gfw . common . message . ResultMessages ( ERROR ) ; }", "testMethod": "testResolveExceptionCode_other_exception_match_parentclass ( ) { java . util . LinkedHashMap < java . lang . String , java . lang . String > exceptionMappings = new java . util . LinkedHashMap < java . lang . String , java . lang . String > ( ) ; exceptionMappings . put ( \"RuntimeException\" , \"runtime001\" ) ; testTarget . setExceptionMappings ( exceptionMappings ) ; java . lang . String actualExceptionCode = testTarget . resolveExceptionCode ( new org . terasoluna . gfw . common . exception . BusinessException ( org . terasoluna . gfw . common . message . ResultMessages . error ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualExceptionCode , org . hamcrest . CoreMatchers . is ( \"runtime001\" ) )", "total": "testResolveExceptionCode_other_exception_match_parentclass ( ) { java . util . LinkedHashMap < java . lang . String , java . lang . String > exceptionMappings = new java . util . LinkedHashMap < java . lang . String , java . lang . String > ( ) ; exceptionMappings . put ( \"RuntimeException\" , \"runtime001\" ) ; testTarget . setExceptionMappings ( exceptionMappings ) ; java . lang . String actualExceptionCode = testTarget . resolveExceptionCode ( new org . terasoluna . gfw . common . exception . BusinessException ( org . terasoluna . gfw . common . message . ResultMessages . error ( ) ) ) ; \"<AssertPlaceHolder>\" ; } error ( ) { return new org . terasoluna . gfw . common . message . ResultMessages ( ERROR ) ; }", "answer": "org . junit . Assert . assertThat ( actualExceptionCode , org . hamcrest . CoreMatchers . is ( \"runtime001\" ) )"}
{"focal": "getColumnDefaultValue ( java . sql . DatabaseMetaData , java . lang . String , java . lang . String ) { try ( java . sql . ResultSet rs = metaData . getColumns ( null , null , tableName , columnName ) ) { if ( ! ( rs . next ( ) ) ) { throw new java . lang . IllegalStateException ( ( ( \"Did<sp>not<sp>find<sp>meta<sp>data<sp>for<sp>column<sp>'\" + columnName ) + \"'<sp>while<sp>checking<sp>its<sp>default<sp>value\" ) ) ; } return rs . getObject ( \"COLUMN_DEF\" ) ; } }", "testMethod": "shouldGetDefaultValue ( ) { java . lang . String tableName = \"data\" ; java . lang . String columnName = \"category\" ; java . sql . ResultSet resultSet = mock ( java . sql . ResultSet . class ) ; given ( resultSet . getObject ( \"COLUMN_DEF\" ) ) . willReturn ( \"Literature\" ) ; given ( resultSet . next ( ) ) . willReturn ( true ) ; java . sql . DatabaseMetaData metaData = mock ( java . sql . DatabaseMetaData . class ) ; given ( metaData . getColumns ( null , null , tableName , columnName ) ) . willReturn ( resultSet ) ; java . lang . Object defaultValue = fr . xephi . authme . datasource . SqlDataSourceUtils . getColumnDefaultValue ( metaData , tableName , columnName ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( defaultValue , org . hamcrest . Matchers . equalTo ( \"Literature\" ) )", "total": "shouldGetDefaultValue ( ) { java . lang . String tableName = \"data\" ; java . lang . String columnName = \"category\" ; java . sql . ResultSet resultSet = mock ( java . sql . ResultSet . class ) ; given ( resultSet . getObject ( \"COLUMN_DEF\" ) ) . willReturn ( \"Literature\" ) ; given ( resultSet . next ( ) ) . willReturn ( true ) ; java . sql . DatabaseMetaData metaData = mock ( java . sql . DatabaseMetaData . class ) ; given ( metaData . getColumns ( null , null , tableName , columnName ) ) . willReturn ( resultSet ) ; java . lang . Object defaultValue = fr . xephi . authme . datasource . SqlDataSourceUtils . getColumnDefaultValue ( metaData , tableName , columnName ) ; \"<AssertPlaceHolder>\" ; } getColumnDefaultValue ( java . sql . DatabaseMetaData , java . lang . String , java . lang . String ) { try ( java . sql . ResultSet rs = metaData . getColumns ( null , null , tableName , columnName ) ) { if ( ! ( rs . next ( ) ) ) { throw new java . lang . IllegalStateException ( ( ( \"Did<sp>not<sp>find<sp>meta<sp>data<sp>for<sp>column<sp>'\" + columnName ) + \"'<sp>while<sp>checking<sp>its<sp>default<sp>value\" ) ) ; } return rs . getObject ( \"COLUMN_DEF\" ) ; } }", "answer": "org . junit . Assert . assertThat ( defaultValue , org . hamcrest . Matchers . equalTo ( \"Literature\" ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldExcludeAllPrimitiveFields ( ) { java . lang . String expectedResult = \"{\\\"order\\\":<sp>{}}\" ; br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"nykolas<sp>lima\" ) , 15.0 , \"gift<sp>bags,<sp>please\" ) ; serialization . from ( order ) . excludeAll ( ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldExcludeAllPrimitiveFields ( ) { java . lang . String expectedResult = \"{\\\"order\\\":<sp>{}}\" ; br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"nykolas<sp>lima\" ) , 15.0 , \"gift<sp>bags,<sp>please\" ) ; serialization . from ( order ) . excludeAll ( ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "getServer ( ) { com . allanbank . mongodb . client . state . Server server = myMainKey ; if ( server != null ) { return server ; } return myCluster . getServers ( ) . get ( 0 ) ; }", "testMethod": "testGetServerName ( ) { final com . allanbank . mongodb . MongoClientConfiguration config = new com . allanbank . mongodb . MongoClientConfiguration ( ) ; final com . allanbank . mongodb . client . state . Cluster cluster = new com . allanbank . mongodb . client . state . Cluster ( config , com . allanbank . mongodb . client . ClusterType . SHARDED ) ; final com . allanbank . mongodb . client . state . Server server = cluster . add ( \"localhost:27017\" ) ; final com . allanbank . mongodb . client . connection . Connection mockConnection = createMock ( com . allanbank . mongodb . client . connection . Connection . class ) ; final com . allanbank . mongodb . client . state . ServerSelector mockSelector = createMock ( com . allanbank . mongodb . client . state . ServerSelector . class ) ; final com . allanbank . mongodb . client . connection . proxy . ProxiedConnectionFactory mockFactory = createMock ( com . allanbank . mongodb . client . connection . proxy . ProxiedConnectionFactory . class ) ; final org . easymock . Capture < java . beans . PropertyChangeListener > listener = new org . easymock . Capture < java . beans . PropertyChangeListener > ( ) ; mockConnection . addPropertyChangeListener ( capture ( listener ) ) ; expectLastCall ( ) ; replay ( mockConnection , mockSelector , mockFactory ) ; final com . allanbank . mongodb . client . connection . sharded . ShardedConnection conn = new com . allanbank . mongodb . client . connection . sharded . ShardedConnection ( mockConnection , server , cluster , mockSelector , mockFactory , config ) ; \"<AssertPlaceHolder>\" ; verify ( mockConnection , mockSelector , mockFactory ) ; reset ( mockConnection , mockSelector , mockFactory ) ; mockConnection . removePropertyChangeListener ( listener . getValue ( ) ) ; expectLastCall ( ) ; mockConnection . close ( ) ; replay ( mockConnection , mockSelector , mockFactory ) ; conn . close ( ) ; verify ( mockConnection , mockSelector , mockFactory ) ; }", "assertLine": "org . junit . Assert . assertThat ( conn . getServer ( ) , org . hamcrest . Matchers . is ( server ) )", "total": "testGetServerName ( ) { final com . allanbank . mongodb . MongoClientConfiguration config = new com . allanbank . mongodb . MongoClientConfiguration ( ) ; final com . allanbank . mongodb . client . state . Cluster cluster = new com . allanbank . mongodb . client . state . Cluster ( config , com . allanbank . mongodb . client . ClusterType . SHARDED ) ; final com . allanbank . mongodb . client . state . Server server = cluster . add ( \"localhost:27017\" ) ; final com . allanbank . mongodb . client . connection . Connection mockConnection = createMock ( com . allanbank . mongodb . client . connection . Connection . class ) ; final com . allanbank . mongodb . client . state . ServerSelector mockSelector = createMock ( com . allanbank . mongodb . client . state . ServerSelector . class ) ; final com . allanbank . mongodb . client . connection . proxy . ProxiedConnectionFactory mockFactory = createMock ( com . allanbank . mongodb . client . connection . proxy . ProxiedConnectionFactory . class ) ; final org . easymock . Capture < java . beans . PropertyChangeListener > listener = new org . easymock . Capture < java . beans . PropertyChangeListener > ( ) ; mockConnection . addPropertyChangeListener ( capture ( listener ) ) ; expectLastCall ( ) ; replay ( mockConnection , mockSelector , mockFactory ) ; final com . allanbank . mongodb . client . connection . sharded . ShardedConnection conn = new com . allanbank . mongodb . client . connection . sharded . ShardedConnection ( mockConnection , server , cluster , mockSelector , mockFactory , config ) ; \"<AssertPlaceHolder>\" ; verify ( mockConnection , mockSelector , mockFactory ) ; reset ( mockConnection , mockSelector , mockFactory ) ; mockConnection . removePropertyChangeListener ( listener . getValue ( ) ) ; expectLastCall ( ) ; mockConnection . close ( ) ; replay ( mockConnection , mockSelector , mockFactory ) ; conn . close ( ) ; verify ( mockConnection , mockSelector , mockFactory ) ; } getServer ( ) { com . allanbank . mongodb . client . state . Server server = myMainKey ; if ( server != null ) { return server ; } return myCluster . getServers ( ) . get ( 0 ) ; }", "answer": "org . junit . Assert . assertThat ( conn . getServer ( ) , org . hamcrest . Matchers . is ( server ) )"}
{"focal": "read ( com . asakusafw . runtime . io . ModelInput ) { return com . asakusafw . runtime . io . json . JsonFormatTest . read ( inputs , ( d ) -> d . object ) ; }", "testMethod": "read_empty_file ( ) { com . asakusafw . runtime . io . json . JsonFormat < com . asakusafw . runtime . io . json . JsonFormatTest . Data > format = reader ( ( r , d ) -> d . object = r . readString ( ) ) . build ( ) ; try ( com . asakusafw . runtime . io . ModelInput < com . asakusafw . runtime . io . json . JsonFormatTest . Data > in = format . open ( \"<testing>\" , input ( \"//<sp>comment<sp>only\" ) , com . asakusafw . runtime . io . json . JsonFormatTest . IOPTS ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( com . asakusafw . runtime . io . json . JsonFormatTest . read ( in ) , empty ( ) )", "total": "read_empty_file ( ) { com . asakusafw . runtime . io . json . JsonFormat < com . asakusafw . runtime . io . json . JsonFormatTest . Data > format = reader ( ( r , d ) -> d . object = r . readString ( ) ) . build ( ) ; try ( com . asakusafw . runtime . io . ModelInput < com . asakusafw . runtime . io . json . JsonFormatTest . Data > in = format . open ( \"<testing>\" , input ( \"//<sp>comment<sp>only\" ) , com . asakusafw . runtime . io . json . JsonFormatTest . IOPTS ) ) { \"<AssertPlaceHolder>\" ; } } read ( com . asakusafw . runtime . io . ModelInput ) { return com . asakusafw . runtime . io . json . JsonFormatTest . read ( inputs , ( d ) -> d . object ) ; }", "answer": "org . junit . Assert . assertThat ( com . asakusafw . runtime . io . json . JsonFormatTest . read ( in ) , empty ( ) )"}
{"focal": "size ( ) { assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Animal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Mammal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Lion . class ) ) . hasSize ( 5 ) ; }", "testMethod": "forAccountWithMandate ( ) { org . estatio . module . financial . dom . FinancialAccount account = BankAccount_enum . PoisonNl . findUsing ( serviceRegistry ) ; final org . estatio . module . financial . dom . BankAccount bankAccount = ( ( org . estatio . module . financial . dom . BankAccount ) ( account ) ) ; java . util . List < org . estatio . module . bankmandate . dom . BankMandate > mandates = bankMandateRepository . findBankMandatesFor ( bankAccount ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mandates . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "forAccountWithMandate ( ) { org . estatio . module . financial . dom . FinancialAccount account = BankAccount_enum . PoisonNl . findUsing ( serviceRegistry ) ; final org . estatio . module . financial . dom . BankAccount bankAccount = ( ( org . estatio . module . financial . dom . BankAccount ) ( account ) ) ; java . util . List < org . estatio . module . bankmandate . dom . BankMandate > mandates = bankMandateRepository . findBankMandatesFor ( bankAccount ) ; \"<AssertPlaceHolder>\" ; } size ( ) { assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Animal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Mammal . class ) ) . hasSize ( 2 ) ; assertThat ( linkRepository . findAllForClassHierarchy ( org . estatio . module . link . dom . LinkRepository_Test . Lion . class ) ) . hasSize ( 5 ) ; }", "answer": "org . junit . Assert . assertThat ( mandates . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getOrder ( ) { return org . springframework . core . Ordered . HIGHEST_PRECEDENCE ; }", "testMethod": "ensureThatThePriorityIsNotHighestToRunInAsyncMode ( ) { final io . tracee . binding . spring . context . async . PostTpicAsyncBeanPostProcessor postProcessor = new io . tracee . binding . spring . context . async . PostTpicAsyncBeanPostProcessor ( mock ( java . util . concurrent . Executor . class ) , backend ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( postProcessor . getOrder ( ) , org . hamcrest . Matchers . is ( 0 ) )", "total": "ensureThatThePriorityIsNotHighestToRunInAsyncMode ( ) { final io . tracee . binding . spring . context . async . PostTpicAsyncBeanPostProcessor postProcessor = new io . tracee . binding . spring . context . async . PostTpicAsyncBeanPostProcessor ( mock ( java . util . concurrent . Executor . class ) , backend ) ; \"<AssertPlaceHolder>\" ; } getOrder ( ) { return org . springframework . core . Ordered . HIGHEST_PRECEDENCE ; }", "answer": "org . junit . Assert . assertThat ( postProcessor . getOrder ( ) , org . hamcrest . Matchers . is ( 0 ) )"}
{"focal": "equivalentTo ( org . nem . core . test . Collection ) { return new org . nem . core . test . IsEquivalent ( collection ) ; }", "testMethod": "getMultisigEmbeddableTypesReturnsAllExpectedTypes ( ) { final org . nem . core . model . Collection < java . lang . Integer > expectedTypes = org . nem . core . model . Arrays . asList ( TransactionTypes . TRANSFER , TransactionTypes . IMPORTANCE_TRANSFER , TransactionTypes . MULTISIG_AGGREGATE_MODIFICATION , TransactionTypes . PROVISION_NAMESPACE , TransactionTypes . MOSAIC_DEFINITION_CREATION , TransactionTypes . MOSAIC_SUPPLY_CHANGE ) ; final org . nem . core . model . Collection < java . lang . Integer > types = org . nem . core . model . TransactionTypes . getMultisigEmbeddableTypes ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( types , org . nem . core . test . IsEquivalent . equivalentTo ( expectedTypes ) )", "total": "getMultisigEmbeddableTypesReturnsAllExpectedTypes ( ) { final org . nem . core . model . Collection < java . lang . Integer > expectedTypes = org . nem . core . model . Arrays . asList ( TransactionTypes . TRANSFER , TransactionTypes . IMPORTANCE_TRANSFER , TransactionTypes . MULTISIG_AGGREGATE_MODIFICATION , TransactionTypes . PROVISION_NAMESPACE , TransactionTypes . MOSAIC_DEFINITION_CREATION , TransactionTypes . MOSAIC_SUPPLY_CHANGE ) ; final org . nem . core . model . Collection < java . lang . Integer > types = org . nem . core . model . TransactionTypes . getMultisigEmbeddableTypes ( ) ; \"<AssertPlaceHolder>\" ; } equivalentTo ( org . nem . core . test . Collection ) { return new org . nem . core . test . IsEquivalent ( collection ) ; }", "answer": "org . junit . Assert . assertThat ( types , org . nem . core . test . IsEquivalent . equivalentTo ( expectedTypes ) )"}
{"focal": "doOptimizedLeftDataSourceAssertions ( org . meridor . perspective . sql . impl . DataSourceTask ) { org . meridor . perspective . sql . impl . parser . DataSource optimizedDataSource = dataSourceTask . getDataSource ( ) ; org . junit . Assert . assertThat ( optimizedDataSource . getType ( ) , equalTo ( org . meridor . perspective . sql . impl . PARENT ) ) ; org . junit . Assert . assertThat ( optimizedDataSource . getLeftDataSource ( ) . isPresent ( ) , is ( true ) ) ; return optimizedDataSource . getLeftDataSource ( ) . get ( ) ; }", "testMethod": "testTableScanStrategySimpleFetch ( ) { org . meridor . perspective . sql . impl . parser . DataSource leftDataSource = new org . meridor . perspective . sql . impl . parser . DataSource ( PROJECTS ) ; queryParser . setSelectQueryAware ( new org . meridor . perspective . sql . impl . MockSelectQueryAware ( ) { { getSelectionMap ( ) . put ( org . meridor . perspective . sql . impl . PROJECT_NAME , new org . meridor . perspective . sql . impl . ColumnExpression ( PROJECT_NAME , PROJECTS ) ) ; setDataSource ( leftDataSource ) ; getTableAliases ( ) . put ( org . meridor . perspective . sql . impl . PROJECTS , org . meridor . perspective . sql . impl . PROJECTS ) ; } } ) ; org . meridor . perspective . sql . impl . List < org . meridor . perspective . sql . impl . Task > tasks = new org . meridor . perspective . sql . impl . ArrayList ( plan ( ) ) ; org . meridor . perspective . sql . impl . DataSourceTask dataSourceTask = doCommonTaskAssertions ( tasks ) ; org . meridor . perspective . sql . impl . parser . DataSource optimizedLeftDataSource = doOptimizedLeftDataSourceAssertions ( dataSourceTask ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( optimizedLeftDataSource , equalTo ( leftDataSource ) )", "total": "testTableScanStrategySimpleFetch ( ) { org . meridor . perspective . sql . impl . parser . DataSource leftDataSource = new org . meridor . perspective . sql . impl . parser . DataSource ( PROJECTS ) ; queryParser . setSelectQueryAware ( new org . meridor . perspective . sql . impl . MockSelectQueryAware ( ) { { getSelectionMap ( ) . put ( org . meridor . perspective . sql . impl . PROJECT_NAME , new org . meridor . perspective . sql . impl . ColumnExpression ( PROJECT_NAME , PROJECTS ) ) ; setDataSource ( leftDataSource ) ; getTableAliases ( ) . put ( org . meridor . perspective . sql . impl . PROJECTS , org . meridor . perspective . sql . impl . PROJECTS ) ; } } ) ; org . meridor . perspective . sql . impl . List < org . meridor . perspective . sql . impl . Task > tasks = new org . meridor . perspective . sql . impl . ArrayList ( plan ( ) ) ; org . meridor . perspective . sql . impl . DataSourceTask dataSourceTask = doCommonTaskAssertions ( tasks ) ; org . meridor . perspective . sql . impl . parser . DataSource optimizedLeftDataSource = doOptimizedLeftDataSourceAssertions ( dataSourceTask ) ; \"<AssertPlaceHolder>\" ; } doOptimizedLeftDataSourceAssertions ( org . meridor . perspective . sql . impl . DataSourceTask ) { org . meridor . perspective . sql . impl . parser . DataSource optimizedDataSource = dataSourceTask . getDataSource ( ) ; org . junit . Assert . assertThat ( optimizedDataSource . getType ( ) , equalTo ( org . meridor . perspective . sql . impl . PARENT ) ) ; org . junit . Assert . assertThat ( optimizedDataSource . getLeftDataSource ( ) . isPresent ( ) , is ( true ) ) ; return optimizedDataSource . getLeftDataSource ( ) . get ( ) ; }", "answer": "org . junit . Assert . assertThat ( optimizedLeftDataSource , equalTo ( leftDataSource ) )"}
{"focal": "getTargetDirectory ( ) { return targetDirectory ; }", "testMethod": "shouldReturnNormalizedTargetDirectory ( ) { uut = new com . github . bmsantos . compiler . cola . provider . CommandLineColaProvider ( toOSPath ( \"target/test-classes\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( uut . getTargetDirectory ( ) , org . hamcrest . CoreMatchers . is ( targetDirectory ) )", "total": "shouldReturnNormalizedTargetDirectory ( ) { uut = new com . github . bmsantos . compiler . cola . provider . CommandLineColaProvider ( toOSPath ( \"target/test-classes\" ) ) ; \"<AssertPlaceHolder>\" ; } getTargetDirectory ( ) { return targetDirectory ; }", "answer": "org . junit . Assert . assertThat ( uut . getTargetDirectory ( ) , org . hamcrest . CoreMatchers . is ( targetDirectory ) )"}
{"focal": "unwrapSourceFromCacheDataSource ( fr . xephi . authme . datasource . DataSource ) { if ( dataSource instanceof fr . xephi . authme . datasource . CacheDataSource ) { try { java . lang . reflect . Field source = fr . xephi . authme . datasource . CacheDataSource . class . getDeclaredField ( \"source\" ) ; source . setAccessible ( true ) ; return ( ( fr . xephi . authme . datasource . DataSource ) ( source . get ( dataSource ) ) ) ; } catch ( java . lang . NoSuchFieldException | java . lang . IllegalAccessException e ) { fr . xephi . authme . ConsoleLogger . logException ( \"Could<sp>not<sp>get<sp>source<sp>of<sp>CacheDataSource:\" , e ) ; return null ; } } return dataSource ; }", "testMethod": "shouldUnwrapCacheDataSource ( ) { fr . xephi . authme . datasource . DataSource source = mock ( fr . xephi . authme . datasource . DataSource . class ) ; fr . xephi . authme . data . auth . PlayerCache playerCache = mock ( fr . xephi . authme . data . auth . PlayerCache . class ) ; fr . xephi . authme . datasource . CacheDataSource cacheDataSource = new fr . xephi . authme . datasource . CacheDataSource ( source , playerCache ) ; fr . xephi . authme . datasource . DataSource result = fr . xephi . authme . command . executable . authme . debug . DebugSectionUtils . unwrapSourceFromCacheDataSource ( cacheDataSource ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( source ) )", "total": "shouldUnwrapCacheDataSource ( ) { fr . xephi . authme . datasource . DataSource source = mock ( fr . xephi . authme . datasource . DataSource . class ) ; fr . xephi . authme . data . auth . PlayerCache playerCache = mock ( fr . xephi . authme . data . auth . PlayerCache . class ) ; fr . xephi . authme . datasource . CacheDataSource cacheDataSource = new fr . xephi . authme . datasource . CacheDataSource ( source , playerCache ) ; fr . xephi . authme . datasource . DataSource result = fr . xephi . authme . command . executable . authme . debug . DebugSectionUtils . unwrapSourceFromCacheDataSource ( cacheDataSource ) ; \"<AssertPlaceHolder>\" ; } unwrapSourceFromCacheDataSource ( fr . xephi . authme . datasource . DataSource ) { if ( dataSource instanceof fr . xephi . authme . datasource . CacheDataSource ) { try { java . lang . reflect . Field source = fr . xephi . authme . datasource . CacheDataSource . class . getDeclaredField ( \"source\" ) ; source . setAccessible ( true ) ; return ( ( fr . xephi . authme . datasource . DataSource ) ( source . get ( dataSource ) ) ) ; } catch ( java . lang . NoSuchFieldException | java . lang . IllegalAccessException e ) { fr . xephi . authme . ConsoleLogger . logException ( \"Could<sp>not<sp>get<sp>source<sp>of<sp>CacheDataSource:\" , e ) ; return null ; } } return dataSource ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( source ) )"}
{"focal": "contains ( java . lang . String ) { return backing . containsKey ( name ) ; }", "testMethod": "computeComponentPathNameOnly ( ) { org . sonatype . nexus . repository . storage . Asset asset = createAsset ( \"name/name.jar\" ) ; org . sonatype . nexus . repository . storage . Component component = new org . sonatype . nexus . repository . storage . DefaultComponent ( ) ; component . name ( \"name\" ) ; java . util . List < java . lang . String > path = generator . computeComponentPath ( asset , component ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( path , contains ( component . name ( ) ) )", "total": "computeComponentPathNameOnly ( ) { org . sonatype . nexus . repository . storage . Asset asset = createAsset ( \"name/name.jar\" ) ; org . sonatype . nexus . repository . storage . Component component = new org . sonatype . nexus . repository . storage . DefaultComponent ( ) ; component . name ( \"name\" ) ; java . util . List < java . lang . String > path = generator . computeComponentPath ( asset , component ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . String ) { return backing . containsKey ( name ) ; }", "answer": "org . junit . Assert . assertThat ( path , contains ( component . name ( ) ) )"}
{"focal": "getPacketBytes ( ) { return packetBytes ; }", "testMethod": "testGetPacketBytes ( ) { target . packetBytes = packetBytes ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getPacketBytes ( ) , org . hamcrest . CoreMatchers . is ( packetBytes ) )", "total": "testGetPacketBytes ( ) { target . packetBytes = packetBytes ; \"<AssertPlaceHolder>\" ; } getPacketBytes ( ) { return packetBytes ; }", "answer": "org . junit . Assert . assertThat ( target . getPacketBytes ( ) , org . hamcrest . CoreMatchers . is ( packetBytes ) )"}
{"focal": "sendMessage ( tech . aroma . application . service . SendMessageRequest ) { checkThat ( request ) . is ( notNull ( ) ) ; checkTokenIsValid ( request . applicationToken ) ; if ( ! ( request . applicationToken . isSetApplicationId ( ) ) ) { tech . aroma . application . service . ApplicationToken newToken = getAdditionalTokenInfo ( request . applicationToken ) ; request . setApplicationToken ( newToken ) ; } return delegate . sendMessage ( request ) ; }", "testMethod": "testSendMessage ( ) { tech . aroma . application . service . SendMessageResponse result = instance . sendMessage ( request ) ; \"<AssertPlaceHolder>\" ; verify ( delegate ) . sendMessage ( request ) ; verify ( authenticationService ) . verifyToken ( expectedVerifyRequest ) ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( response ) )", "total": "testSendMessage ( ) { tech . aroma . application . service . SendMessageResponse result = instance . sendMessage ( request ) ; \"<AssertPlaceHolder>\" ; verify ( delegate ) . sendMessage ( request ) ; verify ( authenticationService ) . verifyToken ( expectedVerifyRequest ) ; } sendMessage ( tech . aroma . application . service . SendMessageRequest ) { checkThat ( request ) . is ( notNull ( ) ) ; checkTokenIsValid ( request . applicationToken ) ; if ( ! ( request . applicationToken . isSetApplicationId ( ) ) ) { tech . aroma . application . service . ApplicationToken newToken = getAdditionalTokenInfo ( request . applicationToken ) ; request . setApplicationToken ( newToken ) ; } return delegate . sendMessage ( request ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( response ) )"}
{"focal": "build ( ) { checkState ( ( ( _networkId ) != null ) , \"Missing<sp>networkId\" ) ; checkState ( ( ( _snapshotId ) != null ) , \"Missing<sp>snapshotId\" ) ; checkState ( ( ( _workType ) != null ) , \"Missing<sp>workType\" ) ; return new org . batfish . coordinator . WorkDetails ( _networkId , _snapshotId , _isDifferential , _workType , _referenceSnapshotId , _analysisId , _questionId ) ; }", "testMethod": "testGetRoutingPolicyForIsp ( ) { org . batfish . datamodel . NetworkFactory nf = new org . batfish . datamodel . NetworkFactory ( ) ; org . batfish . datamodel . Configuration isp = nf . configurationBuilder ( ) . setConfigurationFormat ( ConfigurationFormat . CISCO_IOS ) . setHostname ( \"fakeIsp\" ) . build ( ) ; org . batfish . datamodel . routing_policy . RoutingPolicy ispRoutingPolicy = org . batfish . common . util . IspModelingUtils . getRoutingPolicyForIsp ( isp , nf ) ; org . batfish . datamodel . routing_policy . RoutingPolicy expectedRoutingPolicy = nf . routingPolicyBuilder ( ) . setName ( IspModelingUtils . EXPORT_POLICY_ON_ISP ) . setOwner ( isp ) . setStatements ( java . util . Collections . singletonList ( new org . batfish . datamodel . routing_policy . statement . If ( new org . batfish . datamodel . routing_policy . expr . Conjunction ( com . google . common . collect . ImmutableList . of ( new org . batfish . datamodel . routing_policy . expr . MatchProtocol ( org . batfish . datamodel . RoutingProtocol . BGP ) ) ) , com . google . common . collect . ImmutableList . of ( Statements . ReturnTrue . toStaticStatement ( ) ) ) ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ispRoutingPolicy , org . hamcrest . Matchers . equalTo ( expectedRoutingPolicy ) )", "total": "testGetRoutingPolicyForIsp ( ) { org . batfish . datamodel . NetworkFactory nf = new org . batfish . datamodel . NetworkFactory ( ) ; org . batfish . datamodel . Configuration isp = nf . configurationBuilder ( ) . setConfigurationFormat ( ConfigurationFormat . CISCO_IOS ) . setHostname ( \"fakeIsp\" ) . build ( ) ; org . batfish . datamodel . routing_policy . RoutingPolicy ispRoutingPolicy = org . batfish . common . util . IspModelingUtils . getRoutingPolicyForIsp ( isp , nf ) ; org . batfish . datamodel . routing_policy . RoutingPolicy expectedRoutingPolicy = nf . routingPolicyBuilder ( ) . setName ( IspModelingUtils . EXPORT_POLICY_ON_ISP ) . setOwner ( isp ) . setStatements ( java . util . Collections . singletonList ( new org . batfish . datamodel . routing_policy . statement . If ( new org . batfish . datamodel . routing_policy . expr . Conjunction ( com . google . common . collect . ImmutableList . of ( new org . batfish . datamodel . routing_policy . expr . MatchProtocol ( org . batfish . datamodel . RoutingProtocol . BGP ) ) ) , com . google . common . collect . ImmutableList . of ( Statements . ReturnTrue . toStaticStatement ( ) ) ) ) ) . build ( ) ; \"<AssertPlaceHolder>\" ; } build ( ) { checkState ( ( ( _networkId ) != null ) , \"Missing<sp>networkId\" ) ; checkState ( ( ( _snapshotId ) != null ) , \"Missing<sp>snapshotId\" ) ; checkState ( ( ( _workType ) != null ) , \"Missing<sp>workType\" ) ; return new org . batfish . coordinator . WorkDetails ( _networkId , _snapshotId , _isDifferential , _workType , _referenceSnapshotId , _analysisId , _questionId ) ; }", "answer": "org . junit . Assert . assertThat ( ispRoutingPolicy , org . hamcrest . Matchers . equalTo ( expectedRoutingPolicy ) )"}
{"focal": "getReplicaCount ( java . lang . String ) { return getReplicaCountFor ( getCluster ( clusterName ) ) ; }", "testMethod": "afterReplicaCountSetForCluster_canReadIt ( ) { configureCluster ( \"cluster1\" ) . withReplicas ( 5 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( domain . getReplicaCount ( \"cluster1\" ) , org . hamcrest . Matchers . equalTo ( 5 ) )", "total": "afterReplicaCountSetForCluster_canReadIt ( ) { configureCluster ( \"cluster1\" ) . withReplicas ( 5 ) ; \"<AssertPlaceHolder>\" ; } getReplicaCount ( java . lang . String ) { return getReplicaCountFor ( getCluster ( clusterName ) ) ; }", "answer": "org . junit . Assert . assertThat ( domain . getReplicaCount ( \"cluster1\" ) , org . hamcrest . Matchers . equalTo ( 5 ) )"}
{"focal": "hasEnoughNodes ( ) { return ( interpreter . minNodes ( ) ) <= ( polygon . size ( ) ) ; }", "testMethod": "hasEnoughNodes_AREA_false ( ) { polygon . clear ( ) ; touchview . setInterpretationType ( InterpretationType . AREA ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( touchview . hasEnoughNodes ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "hasEnoughNodes_AREA_false ( ) { polygon . clear ( ) ; touchview . setInterpretationType ( InterpretationType . AREA ) ; \"<AssertPlaceHolder>\" ; } hasEnoughNodes ( ) { return ( interpreter . minNodes ( ) ) <= ( polygon . size ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( touchview . hasEnoughNodes ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getLocation ( ) { return location ; }", "testMethod": "getLocation_returnOutlet ( ) { eu . chargetime . ocpp . model . core . Location expected = eu . chargetime . ocpp . model . core . Location . Outlet ; eu . chargetime . ocpp . model . core . Location location = sampledValue . getLocation ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( location , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "getLocation_returnOutlet ( ) { eu . chargetime . ocpp . model . core . Location expected = eu . chargetime . ocpp . model . core . Location . Outlet ; eu . chargetime . ocpp . model . core . Location location = sampledValue . getLocation ( ) ; \"<AssertPlaceHolder>\" ; } getLocation ( ) { return location ; }", "answer": "org . junit . Assert . assertThat ( location , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "getBalance ( ) { return balance ; }", "testMethod": "testReverse ( ) { org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > sourceAccount = new org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( ) ; org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > targetAccount = new org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( ) ; org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > memoAccount = new org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( ) ; testObject = new org . multibit . mbm . client . domain . model . accounting . rules . MemoPostingRule < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( memoAccount ) ; targetAccount . addPostingRule ( testObject ) ; org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry sourceEntry = EntryFactory . INSTANCE . buildDefaultEntry ( sourceAccount , ( - 10L ) ) ; org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry targetEntry = EntryFactory . INSTANCE . buildDefaultEntry ( targetAccount , 10L ) ; org . multibit . mbm . client . domain . model . accounting . rules . Transaction < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > transaction = new org . multibit . mbm . client . domain . model . accounting . rules . Transaction < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( sourceEntry , targetEntry ) ; transaction . commit ( ) ; testObject . reverse ( targetEntry ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( memoAccount . getBalance ( ) , org . hamcrest . CoreMatchers . equalTo ( 0L ) )", "total": "testReverse ( ) { org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > sourceAccount = new org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( ) ; org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > targetAccount = new org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( ) ; org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > memoAccount = new org . multibit . mbm . client . domain . model . accounting . rules . Account < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( ) ; testObject = new org . multibit . mbm . client . domain . model . accounting . rules . MemoPostingRule < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( memoAccount ) ; targetAccount . addPostingRule ( testObject ) ; org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry sourceEntry = EntryFactory . INSTANCE . buildDefaultEntry ( sourceAccount , ( - 10L ) ) ; org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry targetEntry = EntryFactory . INSTANCE . buildDefaultEntry ( targetAccount , 10L ) ; org . multibit . mbm . client . domain . model . accounting . rules . Transaction < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > transaction = new org . multibit . mbm . client . domain . model . accounting . rules . Transaction < org . multibit . mbm . client . domain . model . accounting . rules . DefaultEntry > ( sourceEntry , targetEntry ) ; transaction . commit ( ) ; testObject . reverse ( targetEntry ) ; \"<AssertPlaceHolder>\" ; } getBalance ( ) { return balance ; }", "answer": "org . junit . Assert . assertThat ( memoAccount . getBalance ( ) , org . hamcrest . CoreMatchers . equalTo ( 0L ) )"}
{"focal": "equalTo ( T extends java . lang . Comparable ) { return org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . instantiate ( org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . ComparisonType . EQUAL_TO , value ) ; }", "testMethod": "removingANodeWithChildrenRemovesTheChildren ( ) { org . zkoss . ganttz . util . MutableTreeModel < org . zkoss . ganttz . util . MutableTreeModelTest . Prueba > model = org . zkoss . ganttz . util . MutableTreeModel . create ( org . zkoss . ganttz . util . MutableTreeModelTest . Prueba . class ) ; org . zkoss . ganttz . util . MutableTreeModelTest . Prueba parent = new org . zkoss . ganttz . util . MutableTreeModelTest . Prueba ( ) ; model . add ( model . getRoot ( ) , parent ) ; org . zkoss . ganttz . util . MutableTreeModelTest . Prueba grandson = new org . zkoss . ganttz . util . MutableTreeModelTest . Prueba ( ) ; model . add ( parent , grandson ) ; model . remove ( parent ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model . getPath ( parent , grandson ) . length , org . hamcrest . CoreMatchers . equalTo ( 0 ) )", "total": "removingANodeWithChildrenRemovesTheChildren ( ) { org . zkoss . ganttz . util . MutableTreeModel < org . zkoss . ganttz . util . MutableTreeModelTest . Prueba > model = org . zkoss . ganttz . util . MutableTreeModel . create ( org . zkoss . ganttz . util . MutableTreeModelTest . Prueba . class ) ; org . zkoss . ganttz . util . MutableTreeModelTest . Prueba parent = new org . zkoss . ganttz . util . MutableTreeModelTest . Prueba ( ) ; model . add ( model . getRoot ( ) , parent ) ; org . zkoss . ganttz . util . MutableTreeModelTest . Prueba grandson = new org . zkoss . ganttz . util . MutableTreeModelTest . Prueba ( ) ; model . add ( parent , grandson ) ; model . remove ( parent ) ; \"<AssertPlaceHolder>\" ; } equalTo ( T extends java . lang . Comparable ) { return org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . instantiate ( org . zkoss . ganttz . data . constraint . ConstraintOnComparableValues . ComparisonType . EQUAL_TO , value ) ; }", "answer": "org . junit . Assert . assertThat ( model . getPath ( parent , grandson ) . length , org . hamcrest . CoreMatchers . equalTo ( 0 ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "shouldReturnPersoonsLijst ( ) { org . apache . commons . chain . Context context = new org . apache . commons . chain . impl . ContextBase ( ) ; context . put ( ContextParameterNames . AANTAL_THREADS , 2 ) ; context . put ( ContextParameterNames . AANTAL_PERSOONSLIJSTEN , 10 ) ; context . put ( ContextParameterNames . BSNLIJST , java . util . Arrays . asList ( 100000001 , 100000002 , 100000003 , 123456789 , 234567891 ) ) ; bevragingStap . execute ( context ) ; java . util . List < nl . bzk . brp . bevraging . commands . BevraagInfo > average = ( ( java . util . List ) ( context . get ( ContextParameterNames . TASK_INFO_LIJST ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( average . size ( ) , org . hamcrest . Matchers . is ( 5 ) )", "total": "shouldReturnPersoonsLijst ( ) { org . apache . commons . chain . Context context = new org . apache . commons . chain . impl . ContextBase ( ) ; context . put ( ContextParameterNames . AANTAL_THREADS , 2 ) ; context . put ( ContextParameterNames . AANTAL_PERSOONSLIJSTEN , 10 ) ; context . put ( ContextParameterNames . BSNLIJST , java . util . Arrays . asList ( 100000001 , 100000002 , 100000003 , 123456789 , 234567891 ) ) ; bevragingStap . execute ( context ) ; java . util . List < nl . bzk . brp . bevraging . commands . BevraagInfo > average = ( ( java . util . List ) ( context . get ( ContextParameterNames . TASK_INFO_LIJST ) ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( average . size ( ) , org . hamcrest . Matchers . is ( 5 ) )"}
{"focal": "getView ( ) { return view ; }", "testMethod": "viewShouldBeReturned ( ) { org . eclipse . che . ide . ext . runner . client . tabs . templates . TemplatesView widget = ( ( org . eclipse . che . ide . ext . runner . client . tabs . templates . TemplatesView ) ( presenter . getView ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( widget , org . hamcrest . CoreMatchers . equalTo ( view ) )", "total": "viewShouldBeReturned ( ) { org . eclipse . che . ide . ext . runner . client . tabs . templates . TemplatesView widget = ( ( org . eclipse . che . ide . ext . runner . client . tabs . templates . TemplatesView ) ( presenter . getView ( ) ) ) ; \"<AssertPlaceHolder>\" ; } getView ( ) { return view ; }", "answer": "org . junit . Assert . assertThat ( widget , org . hamcrest . CoreMatchers . equalTo ( view ) )"}
{"focal": "getDownloadedPaths ( ) { return downloadedPaths ; }", "testMethod": "recordDownloadsSorted ( ) { final org . commonjava . indy . model . core . StoreType type = org . commonjava . indy . model . core . StoreType . group ; final java . lang . String name = \"test-group\" ; final org . commonjava . indy . folo . model . AffectedStoreRecord record = new org . commonjava . indy . folo . model . AffectedStoreRecord ( new org . commonjava . indy . model . core . StoreKey ( type , name ) ) ; record . add ( \"/path/two\" , StoreEffect . DOWNLOAD ) ; record . add ( \"/path/one\" , StoreEffect . DOWNLOAD ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( record . getDownloadedPaths ( ) . iterator ( ) . next ( ) , org . hamcrest . CoreMatchers . equalTo ( \"/path/one\" ) )", "total": "recordDownloadsSorted ( ) { final org . commonjava . indy . model . core . StoreType type = org . commonjava . indy . model . core . StoreType . group ; final java . lang . String name = \"test-group\" ; final org . commonjava . indy . folo . model . AffectedStoreRecord record = new org . commonjava . indy . folo . model . AffectedStoreRecord ( new org . commonjava . indy . model . core . StoreKey ( type , name ) ) ; record . add ( \"/path/two\" , StoreEffect . DOWNLOAD ) ; record . add ( \"/path/one\" , StoreEffect . DOWNLOAD ) ; \"<AssertPlaceHolder>\" ; } getDownloadedPaths ( ) { return downloadedPaths ; }", "answer": "org . junit . Assert . assertThat ( record . getDownloadedPaths ( ) . iterator ( ) . next ( ) , org . hamcrest . CoreMatchers . equalTo ( \"/path/one\" ) )"}
{"focal": "nullValue ( ) { net . time4j . range . DateInterval interval = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2017 , 1 , 5 ) , net . time4j . PlainDate . of ( 2017 , 3 , 26 ) ) ; interval . withValue ( null ) ; }", "testMethod": "lastBusinessDayNull ( ) { net . time4j . PlainDate date = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2017 , 2 , 4 ) , net . time4j . PlainDate . of ( 2017 , 2 , 5 ) ) . get ( net . time4j . range . HolidayModel . ofSaturdayOrSunday ( ) . lastBusinessDay ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( date , org . hamcrest . CoreMatchers . nullValue ( ) )", "total": "lastBusinessDayNull ( ) { net . time4j . PlainDate date = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2017 , 2 , 4 ) , net . time4j . PlainDate . of ( 2017 , 2 , 5 ) ) . get ( net . time4j . range . HolidayModel . ofSaturdayOrSunday ( ) . lastBusinessDay ( ) ) ; \"<AssertPlaceHolder>\" ; } nullValue ( ) { net . time4j . range . DateInterval interval = net . time4j . range . DateInterval . between ( net . time4j . PlainDate . of ( 2017 , 1 , 5 ) , net . time4j . PlainDate . of ( 2017 , 3 , 26 ) ) ; interval . withValue ( null ) ; }", "answer": "org . junit . Assert . assertThat ( date , org . hamcrest . CoreMatchers . nullValue ( ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "storeTo ( ) { java . util . Properties prop = new java . util . Properties ( ) ; prop . setProperty ( \"mock1\" , com . asakusafw . yaess . core . MockService . class . getName ( ) ) ; java . lang . ClassLoader cl = getClass ( ) . getClassLoader ( ) ; com . asakusafw . yaess . core . ServiceProfile < com . asakusafw . yaess . core . Service > service = com . asakusafw . yaess . core . ServiceProfile . load ( prop , \"mock1\" , com . asakusafw . yaess . core . Service . class , com . asakusafw . yaess . core . ProfileContext . system ( cl ) ) ; java . util . Properties target = new java . util . Properties ( ) ; service . storeTo ( target ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target , is ( prop ) )", "total": "storeTo ( ) { java . util . Properties prop = new java . util . Properties ( ) ; prop . setProperty ( \"mock1\" , com . asakusafw . yaess . core . MockService . class . getName ( ) ) ; java . lang . ClassLoader cl = getClass ( ) . getClassLoader ( ) ; com . asakusafw . yaess . core . ServiceProfile < com . asakusafw . yaess . core . Service > service = com . asakusafw . yaess . core . ServiceProfile . load ( prop , \"mock1\" , com . asakusafw . yaess . core . Service . class , com . asakusafw . yaess . core . ProfileContext . system ( cl ) ) ; java . util . Properties target = new java . util . Properties ( ) ; service . storeTo ( target ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( target , is ( prop ) )"}
{"focal": "is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "testMethod": "whenCharsBefore ( ) { final java . lang . String x = org . apache . isis . viewer . restfulobjects . server . ResourceContext . stripQuotes ( \"<sp>\\\"123\\\"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( x , org . hamcrest . Matchers . is ( \"<sp>\\\"123\\\"\" ) )", "total": "whenCharsBefore ( ) { final java . lang . String x = org . apache . isis . viewer . restfulobjects . server . ResourceContext . stripQuotes ( \"<sp>\\\"123\\\"\" ) ; \"<AssertPlaceHolder>\" ; } is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( x , org . hamcrest . Matchers . is ( \"<sp>\\\"123\\\"\" ) )"}
{"focal": "getExtraCalculationFields ( ) { return expressionPropertyCore . getExtraCalculationFields ( this ) ; }", "testMethod": "testGetExtraCalculationFields ( ) { java . lang . String [ ] expected = new java . lang . String [ ] { \"item\" } ; doReturn ( expected ) . when ( reportPreProcessorCore ) . getExtraCalculationFields ( metaData ) ; java . lang . String [ ] result = metaData . getExtraCalculationFields ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "testGetExtraCalculationFields ( ) { java . lang . String [ ] expected = new java . lang . String [ ] { \"item\" } ; doReturn ( expected ) . when ( reportPreProcessorCore ) . getExtraCalculationFields ( metaData ) ; java . lang . String [ ] result = metaData . getExtraCalculationFields ( ) ; \"<AssertPlaceHolder>\" ; } getExtraCalculationFields ( ) { return expressionPropertyCore . getExtraCalculationFields ( this ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "getChunks ( ) { return com . google . common . collect . ImmutableList . copyOf ( chunks ) ; }", "testMethod": "bigOverflow ( ) { com . facebook . buck . util . ChunkAccumulator accumulator = new com . facebook . buck . util . ChunkAccumulator ( com . google . common . base . Charsets . UTF_8 , 10 ) ; accumulator . append ( \"hello\" ) ; accumulator . append ( \"world\" ) ; accumulator . append ( \"big<sp>chunk\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( accumulator . getChunks ( ) , org . hamcrest . Matchers . contains ( \"big<sp>chunk\" ) )", "total": "bigOverflow ( ) { com . facebook . buck . util . ChunkAccumulator accumulator = new com . facebook . buck . util . ChunkAccumulator ( com . google . common . base . Charsets . UTF_8 , 10 ) ; accumulator . append ( \"hello\" ) ; accumulator . append ( \"world\" ) ; accumulator . append ( \"big<sp>chunk\" ) ; \"<AssertPlaceHolder>\" ; } getChunks ( ) { return com . google . common . collect . ImmutableList . copyOf ( chunks ) ; }", "answer": "org . junit . Assert . assertThat ( accumulator . getChunks ( ) , org . hamcrest . Matchers . contains ( \"big<sp>chunk\" ) )"}
{"focal": "map ( K , V ) { java . util . Map < K , V > map = com . google . common . collect . Maps . newLinkedHashMap ( ) ; map . put ( k , v ) ; return map ; }", "testMethod": "Null_Is_Meaningful_Against_Value ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . map ( 1 , 1 ) , org . javersion . core . DiffTest . map ( 1 , null ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . map ( 1 , null ) ) )", "total": "Null_Is_Meaningful_Against_Value ( ) { java . util . Map < java . lang . Object , java . lang . Object > diff = org . javersion . core . Diff . diff ( org . javersion . core . DiffTest . map ( 1 , 1 ) , org . javersion . core . DiffTest . map ( 1 , null ) ) ; \"<AssertPlaceHolder>\" ; } map ( K , V ) { java . util . Map < K , V > map = com . google . common . collect . Maps . newLinkedHashMap ( ) ; map . put ( k , v ) ; return map ; }", "answer": "org . junit . Assert . assertThat ( diff , org . hamcrest . Matchers . equalTo ( org . javersion . core . DiffTest . map ( 1 , null ) ) )"}
{"focal": "getJMXConnectionURL ( ) { return jmxConnectionURL ; }", "testMethod": "shouldSetURL ( ) { java . lang . String url = \"service:jmx:rmi:///jndi/rmi://localhost:40000/jmxrmi\" ; com . oracle . bedrock . deferred . jmx . DeferredJMXConnector deferred = new com . oracle . bedrock . deferred . jmx . DeferredJMXConnector ( url ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( deferred . getJMXConnectionURL ( ) , org . hamcrest . CoreMatchers . is ( url ) )", "total": "shouldSetURL ( ) { java . lang . String url = \"service:jmx:rmi:///jndi/rmi://localhost:40000/jmxrmi\" ; com . oracle . bedrock . deferred . jmx . DeferredJMXConnector deferred = new com . oracle . bedrock . deferred . jmx . DeferredJMXConnector ( url ) ; \"<AssertPlaceHolder>\" ; } getJMXConnectionURL ( ) { return jmxConnectionURL ; }", "answer": "org . junit . Assert . assertThat ( deferred . getJMXConnectionURL ( ) , org . hamcrest . CoreMatchers . is ( url ) )"}
{"focal": "getPath ( ) { return path ; }", "testMethod": "getFileConfigShouldReturnFileConfigWithGivenPath ( ) { when ( mockEditorConfig . getProperties ( \"path\" ) ) . thenReturn ( java . util . Arrays . < org . editorconfig . core . EditorConfig . OutPair > asList ( ) ) ; final org . eclipse . editorconfig . core . EditorFileConfig fileConfig = editorConfigService . getEditorConfig ( \"path\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fileConfig . getPath ( ) , org . hamcrest . Matchers . is ( \"path\" ) )", "total": "getFileConfigShouldReturnFileConfigWithGivenPath ( ) { when ( mockEditorConfig . getProperties ( \"path\" ) ) . thenReturn ( java . util . Arrays . < org . editorconfig . core . EditorConfig . OutPair > asList ( ) ) ; final org . eclipse . editorconfig . core . EditorFileConfig fileConfig = editorConfigService . getEditorConfig ( \"path\" ) ; \"<AssertPlaceHolder>\" ; } getPath ( ) { return path ; }", "answer": "org . junit . Assert . assertThat ( fileConfig . getPath ( ) , org . hamcrest . Matchers . is ( \"path\" ) )"}
{"focal": "getScope ( ) { return ( scope ) == null ? \"compile\" : scope ; }", "testMethod": "scopeShouldBeReturned ( ) { when ( view . scope . getSelectedIndex ( ) ) . thenReturn ( 1 ) ; when ( view . scope . getValue ( 1 ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . SYSTEM . toString ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( view . scope ) . getSelectedIndex ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( view . getScope ( ) , org . hamcrest . CoreMatchers . is ( org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . SYSTEM ) )", "total": "scopeShouldBeReturned ( ) { when ( view . scope . getSelectedIndex ( ) ) . thenReturn ( 1 ) ; when ( view . scope . getValue ( 1 ) ) . thenReturn ( org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . SYSTEM . toString ( ) ) ; \"<AssertPlaceHolder>\" ; verify ( view . scope ) . getSelectedIndex ( ) ; } getScope ( ) { return ( scope ) == null ? \"compile\" : scope ; }", "answer": "org . junit . Assert . assertThat ( view . getScope ( ) , org . hamcrest . CoreMatchers . is ( org . eclipse . che . ide . ext . runner . client . tabs . properties . panel . SYSTEM ) )"}
{"focal": "createBeanFromAttributeMap ( java . lang . Class , java . util . Map ) { BeanType instance ; try { instance = beanType . newInstance ( ) ; org . apache . commons . beanutils . BeanUtils . populate ( instance , attributeValues ) ; } catch ( java . lang . Exception e ) { org . springframework . util . ReflectionUtils . handleReflectionException ( e ) ; throw new java . lang . IllegalStateException ( \"Should<sp>never<sp>get<sp>here\" ) ; } return instance ; }", "testMethod": "testBuildMapWithIncompleteComlexBeanAndRebuild_shouldBeEqualToOriginalBean ( ) { org . openengsb . core . util . beans . BeanWithComplexAttributes bean = new org . openengsb . core . util . beans . BeanWithComplexAttributes ( new org . openengsb . core . util . beans . CustomStringClass ( \"foo:bar\" ) ) ; java . util . Map < java . lang . String , java . lang . Object > map = org . openengsb . core . util . BeanUtilsExtended . buildObjectAttributeMap ( bean ) ; org . openengsb . core . util . beans . BeanWithComplexAttributes created = org . openengsb . core . util . BeanUtilsExtended . createBeanFromAttributeMap ( org . openengsb . core . util . beans . BeanWithComplexAttributes . class , map ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( created , org . hamcrest . Matchers . is ( bean ) )", "total": "testBuildMapWithIncompleteComlexBeanAndRebuild_shouldBeEqualToOriginalBean ( ) { org . openengsb . core . util . beans . BeanWithComplexAttributes bean = new org . openengsb . core . util . beans . BeanWithComplexAttributes ( new org . openengsb . core . util . beans . CustomStringClass ( \"foo:bar\" ) ) ; java . util . Map < java . lang . String , java . lang . Object > map = org . openengsb . core . util . BeanUtilsExtended . buildObjectAttributeMap ( bean ) ; org . openengsb . core . util . beans . BeanWithComplexAttributes created = org . openengsb . core . util . BeanUtilsExtended . createBeanFromAttributeMap ( org . openengsb . core . util . beans . BeanWithComplexAttributes . class , map ) ; \"<AssertPlaceHolder>\" ; } createBeanFromAttributeMap ( java . lang . Class , java . util . Map ) { BeanType instance ; try { instance = beanType . newInstance ( ) ; org . apache . commons . beanutils . BeanUtils . populate ( instance , attributeValues ) ; } catch ( java . lang . Exception e ) { org . springframework . util . ReflectionUtils . handleReflectionException ( e ) ; throw new java . lang . IllegalStateException ( \"Should<sp>never<sp>get<sp>here\" ) ; } return instance ; }", "answer": "org . junit . Assert . assertThat ( created , org . hamcrest . Matchers . is ( bean ) )"}
{"focal": "empty ( ) { org . geotools . geometry . jts . ReferencedEnvelope3D bbox = new org . geotools . geometry . jts . ReferencedEnvelope3D ( ) ; org . junit . Assert . assertNull ( bbox . getCoordinateReferenceSystem ( ) ) ; org . geotools . geometry . jts . ReferencedEnvelope3D australia = new org . geotools . geometry . jts . ReferencedEnvelope3D ( org . geotools . referencing . crs . DefaultGeographicCRS . WGS84_3D ) ; australia . include ( 40 , 110 , 0 ) ; australia . include ( 10 , 150 , 10 ) ; bbox . include ( australia ) ; org . junit . Assert . assertEquals ( australia . getCoordinateReferenceSystem ( ) , bbox . getCoordinateReferenceSystem ( ) ) ; org . junit . Assert . assertEquals ( 0 , bbox . getMinZ ( ) , 0.0 ) ; org . junit . Assert . assertEquals ( 10 , bbox . getMaxZ ( ) , 0.0 ) ; }", "testMethod": "testPermissiveInVariable ( ) { java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; builder . append ( \"define:<sp>&p\\n\" ) . append ( \"<sp>levels:\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>-10\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>-5\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>0\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>5\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>10\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>levels:\" 3 ) . append ( \"<sp>levels:\" 1 ) . append ( \"transform:\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>name:<sp>ras:Contour\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>levels:\" 0 ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>params:<sp>*p\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>levels:\" 2 ) ; java . util . List < org . yaml . snakeyaml . error . MarkedYAMLException > errors = validate ( builder . toString ( ) , Collections . EMPTY_LIST ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( errors , org . hamcrest . Matchers . empty ( ) )", "total": "testPermissiveInVariable ( ) { java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; builder . append ( \"define:<sp>&p\\n\" ) . append ( \"<sp>levels:\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>-10\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>-5\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>0\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>5\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>-<sp>10\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>levels:\" 3 ) . append ( \"<sp>levels:\" 1 ) . append ( \"transform:\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>name:<sp>ras:Contour\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>levels:\" 0 ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>params:<sp>*p\" ) . append ( \"<sp>levels:\" 1 ) . append ( \"<sp>levels:\" 2 ) ; java . util . List < org . yaml . snakeyaml . error . MarkedYAMLException > errors = validate ( builder . toString ( ) , Collections . EMPTY_LIST ) ; \"<AssertPlaceHolder>\" ; } empty ( ) { org . geotools . geometry . jts . ReferencedEnvelope3D bbox = new org . geotools . geometry . jts . ReferencedEnvelope3D ( ) ; org . junit . Assert . assertNull ( bbox . getCoordinateReferenceSystem ( ) ) ; org . geotools . geometry . jts . ReferencedEnvelope3D australia = new org . geotools . geometry . jts . ReferencedEnvelope3D ( org . geotools . referencing . crs . DefaultGeographicCRS . WGS84_3D ) ; australia . include ( 40 , 110 , 0 ) ; australia . include ( 10 , 150 , 10 ) ; bbox . include ( australia ) ; org . junit . Assert . assertEquals ( australia . getCoordinateReferenceSystem ( ) , bbox . getCoordinateReferenceSystem ( ) ) ; org . junit . Assert . assertEquals ( 0 , bbox . getMinZ ( ) , 0.0 ) ; org . junit . Assert . assertEquals ( 10 , bbox . getMaxZ ( ) , 0.0 ) ; }", "answer": "org . junit . Assert . assertThat ( errors , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "isIncludeTestDependencies ( ) { return includeTestDependencies ; }", "testMethod": "classLoaderModelWithoutIncludeTestDependencies ( ) { D desc = createArtifactDescriptor ( ( ( getArtifactRootFolder ( ) ) + \"/do-not-include-test-dependencies\" ) ) ; org . mule . runtime . module . artifact . api . descriptor . ClassLoaderModel classLoaderModel = desc . getClassLoaderModel ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( classLoaderModel . isIncludeTestDependencies ( ) , org . hamcrest . core . Is . is ( false ) )", "total": "classLoaderModelWithoutIncludeTestDependencies ( ) { D desc = createArtifactDescriptor ( ( ( getArtifactRootFolder ( ) ) + \"/do-not-include-test-dependencies\" ) ) ; org . mule . runtime . module . artifact . api . descriptor . ClassLoaderModel classLoaderModel = desc . getClassLoaderModel ( ) ; \"<AssertPlaceHolder>\" ; } isIncludeTestDependencies ( ) { return includeTestDependencies ; }", "answer": "org . junit . Assert . assertThat ( classLoaderModel . isIncludeTestDependencies ( ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "grep ( java . lang . String , java . lang . String ) { org . junit . Assert . assertThat ( string . matches ( regex ) , org . hamcrest . CoreMatchers . is ( true ) ) ; }", "testMethod": "shouldSerializeDeserializeCorrectly ( ) { final io . confluent . ksql . rest . server . computation . Command command = new io . confluent . ksql . rest . server . computation . Command ( \"test<sp>statement;\" , java . util . Collections . singletonMap ( \"foo\" , \"bar\" ) , java . util . Collections . singletonMap ( \"biz\" , \"baz\" ) ) ; final com . fasterxml . jackson . databind . ObjectMapper mapper = JsonMapper . INSTANCE . mapper ; final java . lang . String serialized = mapper . writeValueAsString ( command ) ; grep ( serialized , \".*\\\"streamsProperties\\\"<sp>*:<sp>*\\\\{<sp>*\\\"foo\\\"<sp>*:<sp>*\\\"bar\\\"<sp>*\\\\}.*\" ) ; grep ( serialized , \".*\\\"statement\\\"<sp>*:<sp>*\\\"test<sp>statement;\\\".*\" ) ; grep ( serialized , \".*\\\"originalProperties\\\"<sp>*:<sp>*\\\\{<sp>*\\\"biz\\\"<sp>*:<sp>*\\\"baz\\\"<sp>*\\\\}.*\" ) ; final io . confluent . ksql . rest . server . computation . Command deserialized = mapper . readValue ( serialized , io . confluent . ksql . rest . server . computation . Command . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( deserialized , org . hamcrest . CoreMatchers . equalTo ( command ) )", "total": "shouldSerializeDeserializeCorrectly ( ) { final io . confluent . ksql . rest . server . computation . Command command = new io . confluent . ksql . rest . server . computation . Command ( \"test<sp>statement;\" , java . util . Collections . singletonMap ( \"foo\" , \"bar\" ) , java . util . Collections . singletonMap ( \"biz\" , \"baz\" ) ) ; final com . fasterxml . jackson . databind . ObjectMapper mapper = JsonMapper . INSTANCE . mapper ; final java . lang . String serialized = mapper . writeValueAsString ( command ) ; grep ( serialized , \".*\\\"streamsProperties\\\"<sp>*:<sp>*\\\\{<sp>*\\\"foo\\\"<sp>*:<sp>*\\\"bar\\\"<sp>*\\\\}.*\" ) ; grep ( serialized , \".*\\\"statement\\\"<sp>*:<sp>*\\\"test<sp>statement;\\\".*\" ) ; grep ( serialized , \".*\\\"originalProperties\\\"<sp>*:<sp>*\\\\{<sp>*\\\"biz\\\"<sp>*:<sp>*\\\"baz\\\"<sp>*\\\\}.*\" ) ; final io . confluent . ksql . rest . server . computation . Command deserialized = mapper . readValue ( serialized , io . confluent . ksql . rest . server . computation . Command . class ) ; \"<AssertPlaceHolder>\" ; } grep ( java . lang . String , java . lang . String ) { org . junit . Assert . assertThat ( string . matches ( regex ) , org . hamcrest . CoreMatchers . is ( true ) ) ; }", "answer": "org . junit . Assert . assertThat ( deserialized , org . hamcrest . CoreMatchers . equalTo ( command ) )"}
{"focal": "isSticky ( ) { return getStyle ( ) . getBooleanStyleProperty ( BandStyleKeys . STICKY , false ) ; }", "testMethod": "testIsSticky ( ) { org . pentaho . reporting . engine . classic . core . DetailsHeader header = new org . pentaho . reporting . engine . classic . core . DetailsHeader ( ) ; header . getStyle ( ) . setBooleanStyleProperty ( BandStyleKeys . STICKY , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( header . isSticky ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )", "total": "testIsSticky ( ) { org . pentaho . reporting . engine . classic . core . DetailsHeader header = new org . pentaho . reporting . engine . classic . core . DetailsHeader ( ) ; header . getStyle ( ) . setBooleanStyleProperty ( BandStyleKeys . STICKY , true ) ; \"<AssertPlaceHolder>\" ; } isSticky ( ) { return getStyle ( ) . getBooleanStyleProperty ( BandStyleKeys . STICKY , false ) ; }", "answer": "org . junit . Assert . assertThat ( header . isSticky ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( true ) ) )"}
{"focal": "hasTree ( java . lang . String ) { return org . apache . calcite . test . Matchers . compose ( org . hamcrest . core . Is . is ( value ) , ( input ) -> { return org . apache . calcite . util . Util . toLinux ( org . apache . calcite . plan . RelOptUtil . toString ( input ) ) ; } ) ; }", "testMethod": "testDistinct ( ) { final org . apache . calcite . tools . RelBuilder builder = org . apache . calcite . tools . RelBuilder . create ( org . apache . calcite . test . RelBuilderTest . config ( ) . build ( ) ) ; org . apache . calcite . rel . RelNode root = builder . scan ( \"EMP\" ) . project ( builder . field ( \"DEPTNO\" ) ) . distinct ( ) . build ( ) ; final java . lang . String expected = \"LogicalAggregate(group=[{0}])\\n\" + ( \"<sp>LogicalProject(DEPTNO=[$7])\\n\" + \"<sp>LogicalTableScan(table=[[scott,<sp>EMP]])\\n\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( root , org . apache . calcite . test . Matchers . hasTree ( expected ) )", "total": "testDistinct ( ) { final org . apache . calcite . tools . RelBuilder builder = org . apache . calcite . tools . RelBuilder . create ( org . apache . calcite . test . RelBuilderTest . config ( ) . build ( ) ) ; org . apache . calcite . rel . RelNode root = builder . scan ( \"EMP\" ) . project ( builder . field ( \"DEPTNO\" ) ) . distinct ( ) . build ( ) ; final java . lang . String expected = \"LogicalAggregate(group=[{0}])\\n\" + ( \"<sp>LogicalProject(DEPTNO=[$7])\\n\" + \"<sp>LogicalTableScan(table=[[scott,<sp>EMP]])\\n\" ) ; \"<AssertPlaceHolder>\" ; } hasTree ( java . lang . String ) { return org . apache . calcite . test . Matchers . compose ( org . hamcrest . core . Is . is ( value ) , ( input ) -> { return org . apache . calcite . util . Util . toLinux ( org . apache . calcite . plan . RelOptUtil . toString ( input ) ) ; } ) ; }", "answer": "org . junit . Assert . assertThat ( root , org . apache . calcite . test . Matchers . hasTree ( expected ) )"}
{"focal": "crossProduct ( org . meridor . perspective . sql . impl . parser . List ) { if ( ( lists == null ) || ( ( lists . size ( ) ) == 0 ) ) { return org . meridor . perspective . sql . impl . parser . Collections . emptyList ( ) ; } if ( ( lists . size ( ) ) == 1 ) { return lists . get ( 0 ) . stream ( ) . map ( Collections :: singletonList ) . collect ( java . util . stream . Collectors . toList ( ) ) ; } if ( ( lists . size ( ) ) == 2 ) { org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < T > > leftRightCrossProduct = new org . meridor . perspective . sql . impl . parser . ArrayList ( ) ; org . meridor . perspective . sql . impl . parser . DataSourceUtils . crossProduct ( new org . meridor . perspective . sql . impl . parser . ArrayList ( lists . get ( 0 ) ) , new org . meridor . perspective . sql . impl . parser . ArrayList ( lists . get ( 1 ) ) , Collections :: singletonList , ( indexesPair , list ) -> leftRightCrossProduct . add ( list ) ) ; return leftRightCrossProduct ; } org . meridor . perspective . sql . impl . parser . List < T > left = new org . meridor . perspective . sql . impl . parser . ArrayList ( lists . get ( 0 ) ) ; org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < T > > rightCrossProduct = org . meridor . perspective . sql . impl . parser . DataSourceUtils . crossProduct ( lists . subList ( 1 , lists . size ( ) ) ) ; org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < T > > ret = new org . meridor . perspective . sql . impl . parser . ArrayList ( ) ; left . forEach ( ( entry ) -> rightCrossProduct . forEach ( ( list ) -> ret . add ( new ArrayList < org . meridor . perspective . sql . impl . parser . T > ( ) { { add ( entry ) ; addAll ( list ) ; } } ) ) ) ; return ret ; }", "testMethod": "testCrossProductSingle ( ) { org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . Collection < java . lang . String > > input = org . meridor . perspective . sql . impl . parser . Collections . singletonList ( org . meridor . perspective . sql . impl . parser . Arrays . asList ( \"1\" , \"2\" ) ) ; org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < java . lang . String > > output = crossProduct ( input ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( output , equalTo ( org . meridor . perspective . sql . impl . parser . Arrays . asList ( org . meridor . perspective . sql . impl . parser . Collections . singletonList ( \"1\" ) , org . meridor . perspective . sql . impl . parser . Collections . singletonList ( \"2\" ) ) ) )", "total": "testCrossProductSingle ( ) { org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . Collection < java . lang . String > > input = org . meridor . perspective . sql . impl . parser . Collections . singletonList ( org . meridor . perspective . sql . impl . parser . Arrays . asList ( \"1\" , \"2\" ) ) ; org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < java . lang . String > > output = crossProduct ( input ) ; \"<AssertPlaceHolder>\" ; } crossProduct ( org . meridor . perspective . sql . impl . parser . List ) { if ( ( lists == null ) || ( ( lists . size ( ) ) == 0 ) ) { return org . meridor . perspective . sql . impl . parser . Collections . emptyList ( ) ; } if ( ( lists . size ( ) ) == 1 ) { return lists . get ( 0 ) . stream ( ) . map ( Collections :: singletonList ) . collect ( java . util . stream . Collectors . toList ( ) ) ; } if ( ( lists . size ( ) ) == 2 ) { org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < T > > leftRightCrossProduct = new org . meridor . perspective . sql . impl . parser . ArrayList ( ) ; org . meridor . perspective . sql . impl . parser . DataSourceUtils . crossProduct ( new org . meridor . perspective . sql . impl . parser . ArrayList ( lists . get ( 0 ) ) , new org . meridor . perspective . sql . impl . parser . ArrayList ( lists . get ( 1 ) ) , Collections :: singletonList , ( indexesPair , list ) -> leftRightCrossProduct . add ( list ) ) ; return leftRightCrossProduct ; } org . meridor . perspective . sql . impl . parser . List < T > left = new org . meridor . perspective . sql . impl . parser . ArrayList ( lists . get ( 0 ) ) ; org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < T > > rightCrossProduct = org . meridor . perspective . sql . impl . parser . DataSourceUtils . crossProduct ( lists . subList ( 1 , lists . size ( ) ) ) ; org . meridor . perspective . sql . impl . parser . List < org . meridor . perspective . sql . impl . parser . List < T > > ret = new org . meridor . perspective . sql . impl . parser . ArrayList ( ) ; left . forEach ( ( entry ) -> rightCrossProduct . forEach ( ( list ) -> ret . add ( new ArrayList < org . meridor . perspective . sql . impl . parser . T > ( ) { { add ( entry ) ; addAll ( list ) ; } } ) ) ) ; return ret ; }", "answer": "org . junit . Assert . assertThat ( output , equalTo ( org . meridor . perspective . sql . impl . parser . Arrays . asList ( org . meridor . perspective . sql . impl . parser . Collections . singletonList ( \"1\" ) , org . meridor . perspective . sql . impl . parser . Collections . singletonList ( \"2\" ) ) ) )"}
{"focal": "comparePassword ( java . lang . String , java . lang . String ) { if ( fr . xephi . authme . security . HashUtils . isValidBcryptHash ( hash ) ) { at . favre . lib . crypto . bcrypt . BCrypt . Result result = at . favre . lib . crypto . bcrypt . BCrypt . verifyer ( ) . verify ( password . getBytes ( fr . xephi . authme . security . crypts . UTF_8 ) , hash . getBytes ( fr . xephi . authme . security . crypts . UTF_8 ) ) ; return result . verified ; } return false ; }", "testMethod": "shouldCheckPassword ( ) { java . lang . String playerName = \"Robert\" ; java . lang . String password = \"someSecretPhrase2983\" ; given ( passwordSecurity . comparePassword ( password , playerName ) ) . willReturn ( true ) ; boolean result = api . checkPassword ( playerName , password ) ; verify ( passwordSecurity ) . comparePassword ( password , playerName ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )", "total": "shouldCheckPassword ( ) { java . lang . String playerName = \"Robert\" ; java . lang . String password = \"someSecretPhrase2983\" ; given ( passwordSecurity . comparePassword ( password , playerName ) ) . willReturn ( true ) ; boolean result = api . checkPassword ( playerName , password ) ; verify ( passwordSecurity ) . comparePassword ( password , playerName ) ; \"<AssertPlaceHolder>\" ; } comparePassword ( java . lang . String , java . lang . String ) { if ( fr . xephi . authme . security . HashUtils . isValidBcryptHash ( hash ) ) { at . favre . lib . crypto . bcrypt . BCrypt . Result result = at . favre . lib . crypto . bcrypt . BCrypt . verifyer ( ) . verify ( password . getBytes ( fr . xephi . authme . security . crypts . UTF_8 ) , hash . getBytes ( fr . xephi . authme . security . crypts . UTF_8 ) ) ; return result . verified ; } return false ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "getValue ( ) { return value ; }", "testMethod": "operationWithInputStreamContentParameterInParameterGroup ( ) { java . lang . String theMessage = \"This<sp>is<sp>an<sp>important<sp>message\" ; java . lang . Object result = flowRunner ( \"operationWithInputStreamContentParam\" ) . withVariable ( \"msg\" , new java . io . ByteArrayInputStream ( theMessage . getBytes ( ) ) ) . run ( ) . getMessage ( ) . getPayload ( ) . getValue ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( theMessage ) )", "total": "operationWithInputStreamContentParameterInParameterGroup ( ) { java . lang . String theMessage = \"This<sp>is<sp>an<sp>important<sp>message\" ; java . lang . Object result = flowRunner ( \"operationWithInputStreamContentParam\" ) . withVariable ( \"msg\" , new java . io . ByteArrayInputStream ( theMessage . getBytes ( ) ) ) . run ( ) . getMessage ( ) . getPayload ( ) . getValue ( ) ; \"<AssertPlaceHolder>\" ; } getValue ( ) { return value ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( theMessage ) )"}
{"focal": "get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "testMethod": "write ( ) { com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; option . modify ( 100 ) ; com . asakusafw . runtime . value . LongOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )", "total": "write ( ) { com . asakusafw . runtime . value . LongOption option = new com . asakusafw . runtime . value . LongOption ( ) ; option . modify ( 100 ) ; com . asakusafw . runtime . value . LongOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "answer": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )"}
{"focal": "onConnectionChangedAddedPre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = true ; } if ( exist ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "testMethod": "testOnConnectionChangedAddedPreWithCncTypeError ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"original\" , \"initializing\" , \"logic_id\" , \"add\" 3 ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"add\" 1 , \"add\" 0 , \"logic_id\" , \"add\" 3 ) ) ; when ( curr . getObjectType ( ) ) . thenReturn ( \"add\" 2 ) ; when ( curr . getConnectionType ( ) ) . thenReturn ( \"OTHER\" ) ; when ( target . getObjectId ( ) ) . thenReturn ( \"ComponentConnectionLogicAndNetwork.LOGIC_ID\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"add\" , prev , curr ) ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( true ) . when ( conversionTable , \"isConnectionType\" , \"AGGREGATED\" ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . onConnectionChangedAddedPre ( msg ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testOnConnectionChangedAddedPreWithCncTypeError ( ) { org . o3project . odenos . core . manager . system . ComponentConnection prev = new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"original\" , \"initializing\" , \"logic_id\" , \"add\" 3 ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . manager . system . ComponentConnectionLogicAndNetwork ( \"obj_id\" , \"add\" 1 , \"add\" 0 , \"logic_id\" , \"add\" 3 ) ) ; when ( curr . getObjectType ( ) ) . thenReturn ( \"add\" 2 ) ; when ( curr . getConnectionType ( ) ) . thenReturn ( \"OTHER\" ) ; when ( target . getObjectId ( ) ) . thenReturn ( \"ComponentConnectionLogicAndNetwork.LOGIC_ID\" ) ; org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged msg = new org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ( \"add\" , prev , curr ) ; org . o3project . odenos . core . component . ConversionTable conversionTable = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . component . ConversionTable ( ) ) ; org . powermock . api . mockito . PowerMockito . doReturn ( true ) . when ( conversionTable , \"isConnectionType\" , \"AGGREGATED\" ) ; org . powermock . api . mockito . PowerMockito . doReturn ( conversionTable ) . when ( target , \"conversionTable\" ) ; \"<AssertPlaceHolder>\" ; } onConnectionChangedAddedPre ( org . o3project . odenos . core . manager . system . event . ComponentConnectionChanged ) { org . o3project . odenos . component . linklayerizer . LinkLayerizer . log . debug ( \"\" ) ; org . o3project . odenos . core . manager . system . ComponentConnection curr = message . curr ( ) ; if ( ! ( ComponentConnectionLogicAndNetwork . TYPE . equals ( curr . getObjectType ( ) ) ) ) { return false ; } java . lang . String logicId = curr . getProperty ( ComponentConnectionLogicAndNetwork . LOGIC_ID ) ; if ( ! ( getObjectId ( ) . equals ( logicId ) ) ) { return false ; } boolean exist = false ; java . lang . String connectionType = curr . getConnectionType ( ) ; switch ( connectionType ) { case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LOWER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . UPPER_NETWORK ) ; break ; case org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK : exist = isConnectionType ( org . o3project . odenos . component . linklayerizer . LinkLayerizer . LAYERIZED_NETWORK ) ; break ; default : exist = true ; } if ( exist ) { java . lang . String status = ComponentConnection . State . ERROR ; curr . setConnectionState ( status ) ; systemMngInterface ( ) . putConnection ( curr ) ; return false ; } return true ; }", "answer": "org . junit . Assert . assertThat ( target . onConnectionChangedAddedPre ( msg ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "size ( ) { return java . lang . reflect . Array . getLength ( arrayObject ) ; }", "testMethod": "test_hasInValidStringCode ( ) { org . terasoluna . gfw . common . codelist . Person p = new org . terasoluna . gfw . common . codelist . Person ( ) ; p . gender = \"G\" ; p . lang = \"JP\" ; java . util . Set < javax . validation . ConstraintViolation < org . terasoluna . gfw . common . codelist . Person > > result = validator . validate ( p ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "test_hasInValidStringCode ( ) { org . terasoluna . gfw . common . codelist . Person p = new org . terasoluna . gfw . common . codelist . Person ( ) ; p . gender = \"G\" ; p . lang = \"JP\" ; java . util . Set < javax . validation . ConstraintViolation < org . terasoluna . gfw . common . codelist . Person > > result = validator . validate ( p ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return java . lang . reflect . Array . getLength ( arrayObject ) ; }", "answer": "org . junit . Assert . assertThat ( result . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "build ( java . util . function . Function [ ] ) { java . lang . reflect . Method builderMethod ; try { builderMethod = destinedClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILDER_METHOD_NAME ) ; } catch ( java . lang . NoSuchMethodException e ) { throw new java . lang . RuntimeException ( e ) ; } java . lang . Object source ; try { source = builderMethod . invoke ( null ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } for ( Map . Entry < java . lang . String , java . lang . Object > setValue : values . entrySet ( ) ) { java . lang . Object argument = getArgument ( setValue ) ; java . lang . reflect . Method mutator = properties . get ( setValue . getKey ( ) ) . stream ( ) . filter ( ( t ) -> org . apache . commons . lang3 . ClassUtils . isAssignable ( argument . getClass ( ) , t . type ) ) . findFirst ( ) . map ( ( a ) -> a . builderMethod ) . orElseThrow ( ( ) -> new java . lang . IllegalStateException ( java . lang . String . format ( \"Unable<sp>to<sp>find<sp>mutator<sp>for<sp>%s<sp>of<sp>type<sp>%s\" , setValue . getKey ( ) , argument . getClass ( ) . getName ( ) ) ) ) ; try { source = mutator . invoke ( source , argument ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } } if ( additionalMutators != null ) { for ( java . util . function . Function < java . lang . Object , java . lang . Object > mutator : additionalMutators ) { source = mutator . apply ( source ) ; } } java . lang . reflect . Method buildMethod ; try { buildMethod = builderClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILD_METHOD_NAME ) ; return buildMethod . invoke ( source ) ; } catch ( java . lang . IllegalAccessException | java . lang . NoSuchMethodException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "testMethod": "testVariantBuildsToSuperType ( ) { software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantBuilder expected = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantBuilder . builder ( ) . intClass ( 10 ) . testEnum ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestEnum . Green ) . variantBuilderName ( \"variant-super\" ) . build ( ) ; software . amazon . kinesis . multilang . config . BuilderDynaBean builderDynaBean = new software . amazon . kinesis . multilang . config . BuilderDynaBean ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class , convertUtilsBean ) ; utilsBean . setProperty ( builderDynaBean , \"class\" , expected . getClass ( ) . getName ( ) ) ; utilsBean . setProperty ( builderDynaBean , \"intClass\" , expected . intClass ) ; utilsBean . setProperty ( builderDynaBean , \"testEnum\" , expected . testEnum ) ; utilsBean . setProperty ( builderDynaBean , \"variantBuilderName\" , expected . variantBuilderName ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface actual = builderDynaBean . build ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )", "total": "testVariantBuildsToSuperType ( ) { software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantBuilder expected = software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestVariantBuilder . builder ( ) . intClass ( 10 ) . testEnum ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestEnum . Green ) . variantBuilderName ( \"variant-super\" ) . build ( ) ; software . amazon . kinesis . multilang . config . BuilderDynaBean builderDynaBean = new software . amazon . kinesis . multilang . config . BuilderDynaBean ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class , convertUtilsBean ) ; utilsBean . setProperty ( builderDynaBean , \"class\" , expected . getClass ( ) . getName ( ) ) ; utilsBean . setProperty ( builderDynaBean , \"intClass\" , expected . intClass ) ; utilsBean . setProperty ( builderDynaBean , \"testEnum\" , expected . testEnum ) ; utilsBean . setProperty ( builderDynaBean , \"variantBuilderName\" , expected . variantBuilderName ) ; software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface actual = builderDynaBean . build ( software . amazon . kinesis . multilang . config . BuilderDynaBeanTest . TestInterface . class ) ; \"<AssertPlaceHolder>\" ; } build ( java . util . function . Function [ ] ) { java . lang . reflect . Method builderMethod ; try { builderMethod = destinedClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILDER_METHOD_NAME ) ; } catch ( java . lang . NoSuchMethodException e ) { throw new java . lang . RuntimeException ( e ) ; } java . lang . Object source ; try { source = builderMethod . invoke ( null ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } for ( Map . Entry < java . lang . String , java . lang . Object > setValue : values . entrySet ( ) ) { java . lang . Object argument = getArgument ( setValue ) ; java . lang . reflect . Method mutator = properties . get ( setValue . getKey ( ) ) . stream ( ) . filter ( ( t ) -> org . apache . commons . lang3 . ClassUtils . isAssignable ( argument . getClass ( ) , t . type ) ) . findFirst ( ) . map ( ( a ) -> a . builderMethod ) . orElseThrow ( ( ) -> new java . lang . IllegalStateException ( java . lang . String . format ( \"Unable<sp>to<sp>find<sp>mutator<sp>for<sp>%s<sp>of<sp>type<sp>%s\" , setValue . getKey ( ) , argument . getClass ( ) . getName ( ) ) ) ) ; try { source = mutator . invoke ( source , argument ) ; } catch ( java . lang . IllegalAccessException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } } if ( additionalMutators != null ) { for ( java . util . function . Function < java . lang . Object , java . lang . Object > mutator : additionalMutators ) { source = mutator . apply ( source ) ; } } java . lang . reflect . Method buildMethod ; try { buildMethod = builderClass . getMethod ( software . amazon . kinesis . multilang . config . DynaBeanBuilderSupport . BUILD_METHOD_NAME ) ; return buildMethod . invoke ( source ) ; } catch ( java . lang . IllegalAccessException | java . lang . NoSuchMethodException | java . lang . reflect . InvocationTargetException e ) { throw new java . lang . RuntimeException ( e ) ; } }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . equalTo ( expected ) )"}
{"focal": "invoke ( ninja . Context , ninja . Result ) { templateEngine . invoke ( context , result ) ; return output . toString ( \"UTF-8\" ) ; }", "testMethod": "customApplicationTemplate ( ) { when ( context . getContextPath ( ) ) . thenReturn ( \"/context\" ) ; when ( context . getAttribute ( \"USER\" , custom . User . class ) ) . thenReturn ( new custom . User ( \"Joe\" ) ) ; when ( templateEngineHelper . getTemplateForResult ( context . getRoute ( ) , result , \".rocker.html\" ) ) . thenReturn ( \"views/application_template.rocker.html\" ) ; java . lang . String out = invoke ( context , result ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( out , org . hamcrest . CoreMatchers . is ( \"Joe\" ) )", "total": "customApplicationTemplate ( ) { when ( context . getContextPath ( ) ) . thenReturn ( \"/context\" ) ; when ( context . getAttribute ( \"USER\" , custom . User . class ) ) . thenReturn ( new custom . User ( \"Joe\" ) ) ; when ( templateEngineHelper . getTemplateForResult ( context . getRoute ( ) , result , \".rocker.html\" ) ) . thenReturn ( \"views/application_template.rocker.html\" ) ; java . lang . String out = invoke ( context , result ) ; \"<AssertPlaceHolder>\" ; } invoke ( ninja . Context , ninja . Result ) { templateEngine . invoke ( context , result ) ; return output . toString ( \"UTF-8\" ) ; }", "answer": "org . junit . Assert . assertThat ( out , org . hamcrest . CoreMatchers . is ( \"Joe\" ) )"}
{"focal": "getMatches ( ) { return matches ; }", "testMethod": "testPutMatches ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node01\" , \"port01\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node02\" , \"port02\" ) ; matches . add ( match1 ) ; matches . add ( match2 ) ; target . putMatches ( matches ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . getMatches ( ) , org . hamcrest . CoreMatchers . is ( matches ) )", "total": "testPutMatches ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node01\" , \"port01\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node02\" , \"port02\" ) ; matches . add ( match1 ) ; matches . add ( match2 ) ; target . putMatches ( matches ) ; \"<AssertPlaceHolder>\" ; } getMatches ( ) { return matches ; }", "answer": "org . junit . Assert . assertThat ( target . getMatches ( ) , org . hamcrest . CoreMatchers . is ( matches ) )"}
{"focal": "validate ( ) { try { org . apache . commons . lang . Validate . notEmpty ( this . lowerNw , \"lower_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwNode , \"lower_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwPort , \"lower_nw_port<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNw , \"upper_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwNode , \"upper_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwPort , \"upper_nw_port<sp>is<sp>empty\" ) ; return true ; } catch ( java . lang . IllegalArgumentException ex ) { org . o3project . odenos . component . linklayerizer . LinkLayerizerBoundary . log . warn ( ex . getMessage ( ) , ex ) ; return false ; } }", "testMethod": "testValidateMatchSuccess ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node01\" , \"port01\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node02\" , \"port02\" ) ; matches . add ( match1 ) ; matches . add ( match2 ) ; target . putMatches ( matches ) ; java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port01\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port02\" ; } } ) ; } } ; target . addEdgeAction ( \"node01\" , actions . get ( 0 ) ) ; target . addEdgeAction ( \"node02\" , actions . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . validate ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testValidateMatchSuccess ( ) { java . util . List < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > matches = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch > ( ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match1 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node01\" , \"port01\" ) ; org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch match2 = new org . o3project . odenos . core . component . network . flow . basic . BasicFlowMatch ( \"node02\" , \"port02\" ) ; matches . add ( match1 ) ; matches . add ( match2 ) ; target . putMatches ( matches ) ; java . util . List < org . o3project . odenos . core . component . network . flow . basic . FlowAction > actions = new java . util . ArrayList < org . o3project . odenos . core . component . network . flow . basic . FlowAction > ( ) { { add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port01\" ; } } ) ; add ( new org . o3project . odenos . core . component . network . flow . basic . FlowActionOutput ( ) { { output = \"port02\" ; } } ) ; } } ; target . addEdgeAction ( \"node01\" , actions . get ( 0 ) ) ; target . addEdgeAction ( \"node02\" , actions . get ( 1 ) ) ; \"<AssertPlaceHolder>\" ; } validate ( ) { try { org . apache . commons . lang . Validate . notEmpty ( this . lowerNw , \"lower_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwNode , \"lower_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . lowerNwPort , \"lower_nw_port<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNw , \"upper_nw<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwNode , \"upper_nw_node<sp>is<sp>empty\" ) ; org . apache . commons . lang . Validate . notEmpty ( this . upperNwPort , \"upper_nw_port<sp>is<sp>empty\" ) ; return true ; } catch ( java . lang . IllegalArgumentException ex ) { org . o3project . odenos . component . linklayerizer . LinkLayerizerBoundary . log . warn ( ex . getMessage ( ) , ex ) ; return false ; } }", "answer": "org . junit . Assert . assertThat ( target . validate ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "equals ( java . lang . Object ) { return super . equals ( o ) ; }", "testMethod": "testEqualsWhenIdsAreEqual ( ) { final org . codice . ddf . configuration . migration . MigrationContextImpl < org . codice . ddf . migration . MigrationReport > context = new org . codice . ddf . configuration . migration . MigrationContextImpl ( report , MIGRATABLE_ID ) ; final org . codice . ddf . configuration . migration . MigrationContextImpl < org . codice . ddf . migration . MigrationReport > context2 = new org . codice . ddf . configuration . migration . MigrationContextImpl ( report , MIGRATABLE_ID ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( context . equals ( context2 ) , org . hamcrest . Matchers . equalTo ( true ) )", "total": "testEqualsWhenIdsAreEqual ( ) { final org . codice . ddf . configuration . migration . MigrationContextImpl < org . codice . ddf . migration . MigrationReport > context = new org . codice . ddf . configuration . migration . MigrationContextImpl ( report , MIGRATABLE_ID ) ; final org . codice . ddf . configuration . migration . MigrationContextImpl < org . codice . ddf . migration . MigrationReport > context2 = new org . codice . ddf . configuration . migration . MigrationContextImpl ( report , MIGRATABLE_ID ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { return super . equals ( o ) ; }", "answer": "org . junit . Assert . assertThat ( context . equals ( context2 ) , org . hamcrest . Matchers . equalTo ( true ) )"}
{"focal": "isDynamic ( ) { return dynamic ; }", "testMethod": "synchronizeClusterSchemas ( ) { final java . lang . String clusterSchemaName = \"SharedClusterSchema\" ; org . pentaho . di . trans . TransMeta transformarion1 = createTransMeta ( ) ; org . pentaho . di . cluster . ClusterSchema clusterSchema1 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createClusterSchema ( clusterSchemaName , true ) ; transformarion1 . setClusterSchemas ( java . util . Collections . singletonList ( clusterSchema1 ) ) ; spoonDelegates . trans . addTransformation ( transformarion1 ) ; org . pentaho . di . trans . TransMeta transformarion2 = createTransMeta ( ) ; org . pentaho . di . cluster . ClusterSchema clusterSchema2 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createClusterSchema ( clusterSchemaName , true ) ; transformarion2 . setClusterSchemas ( java . util . Collections . singletonList ( clusterSchema2 ) ) ; spoonDelegates . trans . addTransformation ( transformarion2 ) ; clusterSchema2 . setDynamic ( true ) ; sharedUtil . synchronizeClusterSchemas ( clusterSchema2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( clusterSchema1 . isDynamic ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "synchronizeClusterSchemas ( ) { final java . lang . String clusterSchemaName = \"SharedClusterSchema\" ; org . pentaho . di . trans . TransMeta transformarion1 = createTransMeta ( ) ; org . pentaho . di . cluster . ClusterSchema clusterSchema1 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createClusterSchema ( clusterSchemaName , true ) ; transformarion1 . setClusterSchemas ( java . util . Collections . singletonList ( clusterSchema1 ) ) ; spoonDelegates . trans . addTransformation ( transformarion1 ) ; org . pentaho . di . trans . TransMeta transformarion2 = createTransMeta ( ) ; org . pentaho . di . cluster . ClusterSchema clusterSchema2 = org . pentaho . di . ui . spoon . SharedObjectSyncUtilTest . createClusterSchema ( clusterSchemaName , true ) ; transformarion2 . setClusterSchemas ( java . util . Collections . singletonList ( clusterSchema2 ) ) ; spoonDelegates . trans . addTransformation ( transformarion2 ) ; clusterSchema2 . setDynamic ( true ) ; sharedUtil . synchronizeClusterSchemas ( clusterSchema2 ) ; \"<AssertPlaceHolder>\" ; } isDynamic ( ) { return dynamic ; }", "answer": "org . junit . Assert . assertThat ( clusterSchema1 . isDynamic ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "_1 ( ) { return _1 ; }", "testMethod": "_1_A$ ( ) { java . lang . String _1 = \"foo\" ; java . lang . Integer _2 = 123 ; java . lang . Long _3 = 456L ; com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > target = com . m3 . scalaflavor4j . Tuple3 . apply ( _1 , _2 , _3 ) ; java . lang . String actual = target . _1 ( ) ; java . lang . String expected = \"foo\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "_1_A$ ( ) { java . lang . String _1 = \"foo\" ; java . lang . Integer _2 = 123 ; java . lang . Long _3 = 456L ; com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > target = com . m3 . scalaflavor4j . Tuple3 . apply ( _1 , _2 , _3 ) ; java . lang . String actual = target . _1 ( ) ; java . lang . String expected = \"foo\" ; \"<AssertPlaceHolder>\" ; } _1 ( ) { return _1 ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldUseCollectionConverterWhenItExists ( ) { java . lang . String expectedResult = \"[\\\"testing\\\"]\" ; serialization . withoutRoot ( ) . from ( new br . com . caelum . vraptor . serialization . gson . GsonJSONSerializationTest . MyCollection ( ) ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldUseCollectionConverterWhenItExists ( ) { java . lang . String expectedResult = \"[\\\"testing\\\"]\" ; serialization . withoutRoot ( ) . from ( new br . com . caelum . vraptor . serialization . gson . GsonJSONSerializationTest . MyCollection ( ) ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "is ( java . lang . String ) { com . xebia . incubator . xebium . SeleniumDriverFixture . LOG . info ( ( ( \"Obtain<sp>result<sp>from<sp>|<sp>\" + command ) + \"<sp>|\" ) ) ; return is ( command , new java . lang . String [ ] { } ) ; }", "testMethod": "shouldMatchWithoutRegularExpression ( ) { given ( commandProcessor . doCommand ( anyString ( ) , isA ( java . lang . String [ ] . class ) ) ) . willReturn ( \"Di<sp>9<sp>november<sp>2010.<sp>Het<sp>laatste<sp>nieuws<sp>het<sp>eerst<sp>op<sp>nu.nl\" ) ; final boolean result = seleniumDriverFixture . doOnWith ( \"verifyText\" , \"//*[@id='masthead']/div/h1\" , \"*Het<sp>laatste<sp>nieuws<sp>het<sp>eerst<sp>op<sp>nu.nl\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )", "total": "shouldMatchWithoutRegularExpression ( ) { given ( commandProcessor . doCommand ( anyString ( ) , isA ( java . lang . String [ ] . class ) ) ) . willReturn ( \"Di<sp>9<sp>november<sp>2010.<sp>Het<sp>laatste<sp>nieuws<sp>het<sp>eerst<sp>op<sp>nu.nl\" ) ; final boolean result = seleniumDriverFixture . doOnWith ( \"verifyText\" , \"//*[@id='masthead']/div/h1\" , \"*Het<sp>laatste<sp>nieuws<sp>het<sp>eerst<sp>op<sp>nu.nl\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . xebia . incubator . xebium . SeleniumDriverFixture . LOG . info ( ( ( \"Obtain<sp>result<sp>from<sp>|<sp>\" + command ) + \"<sp>|\" ) ) ; return is ( command , new java . lang . String [ ] { } ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "supports ( net . ripe . db . whois . update . domain . PreparedUpdate ) { return ( update . getAction ( ) . equals ( Action . CREATE ) ) && ( ( update . getType ( ) . equals ( ObjectType . ROUTE ) ) || ( update . getType ( ) . equals ( ObjectType . ROUTE6 ) ) ) ; }", "testMethod": "supports_autnum_create ( ) { when ( update . getAction ( ) ) . thenReturn ( Action . CREATE ) ; when ( update . getType ( ) ) . thenReturn ( ObjectType . AUT_NUM ) ; final boolean supported = subject . supports ( update ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( supported , org . hamcrest . core . Is . is ( true ) )", "total": "supports_autnum_create ( ) { when ( update . getAction ( ) ) . thenReturn ( Action . CREATE ) ; when ( update . getType ( ) ) . thenReturn ( ObjectType . AUT_NUM ) ; final boolean supported = subject . supports ( update ) ; \"<AssertPlaceHolder>\" ; } supports ( net . ripe . db . whois . update . domain . PreparedUpdate ) { return ( update . getAction ( ) . equals ( Action . CREATE ) ) && ( ( update . getType ( ) . equals ( ObjectType . ROUTE ) ) || ( update . getType ( ) . equals ( ObjectType . ROUTE6 ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( supported , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getText ( ) { return stb . getText ( ) ; }", "testMethod": "testNumericNonShiftKeys ( ) { org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"enabledTextElement\" ) ) ; element . clear ( ) ; java . lang . String numericLineCharsNonShifted = \"`1234567890-=[]\\\\;,.\\'/42\" ; element . sendKeys ( numericLineCharsNonShifted ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( element . getText ( ) , org . hamcrest . Matchers . is ( numericLineCharsNonShifted ) )", "total": "testNumericNonShiftKeys ( ) { org . openqa . selenium . WebElement element = driver . findElement ( org . openqa . selenium . By . id ( \"enabledTextElement\" ) ) ; element . clear ( ) ; java . lang . String numericLineCharsNonShifted = \"`1234567890-=[]\\\\;,.\\'/42\" ; element . sendKeys ( numericLineCharsNonShifted ) ; \"<AssertPlaceHolder>\" ; } getText ( ) { return stb . getText ( ) ; }", "answer": "org . junit . Assert . assertThat ( element . getText ( ) , org . hamcrest . Matchers . is ( numericLineCharsNonShifted ) )"}
{"focal": "is ( java . lang . annotation . Annotation ) { return is ( AnnotationDescription . ForLoadedAnnotation . of ( annotation ) ) ; }", "testMethod": "testNotMatchesLeft ( ) { when ( left . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( true ) ; when ( right . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( false ) ; net . bytebuddy . agent . builder . AgentBuilder . RawMatcher rawMatcher = new net . bytebuddy . agent . builder . AgentBuilder . RawMatcher . Conjunction ( left , right ) ; \"<AssertPlaceHolder>\" ; verify ( left ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( left ) ; verify ( right ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( right ) ; }", "assertLine": "org . junit . Assert . assertThat ( rawMatcher . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testNotMatchesLeft ( ) { when ( left . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( true ) ; when ( right . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ) . thenReturn ( false ) ; net . bytebuddy . agent . builder . AgentBuilder . RawMatcher rawMatcher = new net . bytebuddy . agent . builder . AgentBuilder . RawMatcher . Conjunction ( left , right ) ; \"<AssertPlaceHolder>\" ; verify ( left ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( left ) ; verify ( right ) . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) ; verifyNoMoreInteractions ( right ) ; } is ( java . lang . annotation . Annotation ) { return is ( AnnotationDescription . ForLoadedAnnotation . of ( annotation ) ) ; }", "answer": "org . junit . Assert . assertThat ( rawMatcher . matches ( typeDescription , classLoader , module , net . bytebuddy . agent . builder . AgentBuilderRawMatcherConjunctionTest . Foo . class , protectionDomain ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getFirmwareVersion ( ) { return firmwareVersion ; }", "testMethod": "setFirmwareVersion_stringLength50_noException ( ) { java . lang . String stringLength50 = \"12345678901234567890123456789012345678901234567890\" ; request . setFirmwareVersion ( stringLength50 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( request . getFirmwareVersion ( ) , org . hamcrest . CoreMatchers . equalTo ( stringLength50 ) )", "total": "setFirmwareVersion_stringLength50_noException ( ) { java . lang . String stringLength50 = \"12345678901234567890123456789012345678901234567890\" ; request . setFirmwareVersion ( stringLength50 ) ; \"<AssertPlaceHolder>\" ; } getFirmwareVersion ( ) { return firmwareVersion ; }", "answer": "org . junit . Assert . assertThat ( request . getFirmwareVersion ( ) , org . hamcrest . CoreMatchers . equalTo ( stringLength50 ) )"}
{"focal": "hasNext ( ) { if ( ( m_nextKey ) != null ) return true ; while ( ( ( m_currentResultSet ) != null ) && ( ( ! ( m_currentResultSet . isExhausted ( ) ) ) || ( m_resultSets . hasNext ( ) ) ) ) { m_nextKey = nextKeyFromIterator ( m_currentResultSet ) ; if ( ( m_nextKey ) != null ) break ; if ( m_resultSets . hasNext ( ) ) m_currentResultSet = m_resultSets . next ( ) ; } if ( ( m_nextKey ) == null ) { org . kairosdb . core . reporting . ThreadReporter . addDataPoint ( CassandraDatastore . RAW_ROW_KEY_COUNT , m_rawRowKeyCount ) ; } return ( m_nextKey ) != null ; }", "testMethod": "test_noValues ( ) { org . kairosdb . testing . ListDataPointGroup group = new org . kairosdb . testing . ListDataPointGroup ( \"group\" ) ; org . kairosdb . core . datastore . DataPointGroup results = aggregator . aggregate ( group ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results . hasNext ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "test_noValues ( ) { org . kairosdb . testing . ListDataPointGroup group = new org . kairosdb . testing . ListDataPointGroup ( \"group\" ) ; org . kairosdb . core . datastore . DataPointGroup results = aggregator . aggregate ( group ) ; \"<AssertPlaceHolder>\" ; } hasNext ( ) { if ( ( m_nextKey ) != null ) return true ; while ( ( ( m_currentResultSet ) != null ) && ( ( ! ( m_currentResultSet . isExhausted ( ) ) ) || ( m_resultSets . hasNext ( ) ) ) ) { m_nextKey = nextKeyFromIterator ( m_currentResultSet ) ; if ( ( m_nextKey ) != null ) break ; if ( m_resultSets . hasNext ( ) ) m_currentResultSet = m_resultSets . next ( ) ; } if ( ( m_nextKey ) == null ) { org . kairosdb . core . reporting . ThreadReporter . addDataPoint ( CassandraDatastore . RAW_ROW_KEY_COUNT , m_rawRowKeyCount ) ; } return ( m_nextKey ) != null ; }", "answer": "org . junit . Assert . assertThat ( results . hasNext ( ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "getCommentary ( ru . szhernovoy . tracker . models . Task ) { java . lang . String result = null ; if ( task != null ) { result = task . getComm ( ) ; } return result ; }", "testMethod": "addItemCommy ( ) { ru . java_edu . start . Tracker track = new ru . java_edu . start . Tracker ( ) ; ru . java_edu . start . Task task1 = new ru . java_edu . start . Task ( \"pervaja<sp>zajavka\" , \"eto<sp>pervaja<sp>zajavka\" ) ; track . addItem ( task1 ) ; track . addCommentary ( task1 , \"eto<sp>message\" ) ; java . lang . String message = \"eto<sp>message\" ; java . lang . String result = track . getCommentary ( task1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( message ) )", "total": "addItemCommy ( ) { ru . java_edu . start . Tracker track = new ru . java_edu . start . Tracker ( ) ; ru . java_edu . start . Task task1 = new ru . java_edu . start . Task ( \"pervaja<sp>zajavka\" , \"eto<sp>pervaja<sp>zajavka\" ) ; track . addItem ( task1 ) ; track . addCommentary ( task1 , \"eto<sp>message\" ) ; java . lang . String message = \"eto<sp>message\" ; java . lang . String result = track . getCommentary ( task1 ) ; \"<AssertPlaceHolder>\" ; } getCommentary ( ru . szhernovoy . tracker . models . Task ) { java . lang . String result = null ; if ( task != null ) { result = task . getComm ( ) ; } return result ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . core . Is . is ( message ) )"}
{"focal": "company ( ) { org . junit . Assert . assertThat ( faker . space ( ) . company ( ) , matchesRegularExpression ( \"((\\\\w|\\')+<sp>?){2,4}\" ) ) ; }", "testMethod": "testUrl ( ) { java . lang . String regexp = \"(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( faker . company ( ) . url ( ) , matchesRegularExpression ( regexp ) )", "total": "testUrl ( ) { java . lang . String regexp = \"(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\\\-]*[a-zA-Z0-9])\\\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\\\-]*[A-Za-z0-9])\" ; \"<AssertPlaceHolder>\" ; } company ( ) { org . junit . Assert . assertThat ( faker . space ( ) . company ( ) , matchesRegularExpression ( \"((\\\\w|\\')+<sp>?){2,4}\" ) ) ; }", "answer": "org . junit . Assert . assertThat ( faker . company ( ) . url ( ) , matchesRegularExpression ( regexp ) )"}
{"focal": "find ( java . lang . Number ) { T entity = entityManager . find ( entityType , id ) ; return entity ; }", "testMethod": "shouldCreateTheRightAmountOfRestrictionsIfARoleIsGiven ( ) { java . lang . String roleName1 = \"Role1\" ; java . lang . String permissionName1 = \"RESOURCE\" ; java . lang . String permissionName2 = \"RESOURCETYPE\" ; java . lang . String contextNameA = \"A\" ; when ( permissionRepository . getPermissionByName ( \"RESOURCE\" ) ) . thenReturn ( resourcePermission ) ; when ( permissionRepository . getPermissionByName ( \"RESOURCETYPE\" ) ) . thenReturn ( resourceTypePermission ) ; when ( resourceGroupRepository . find ( 1 ) ) . thenReturn ( new ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceGroupEntity ( ) ) ; int total = permissionBoundary . createMultipleRestrictions ( roleName1 , null , java . util . Arrays . asList ( permissionName1 , permissionName2 ) , java . util . Arrays . asList ( 1 ) , null , ResourceTypePermission . ANY , java . util . Arrays . asList ( contextNameA ) , java . util . Arrays . asList ( Action . CREATE ) , false , true ) ; \"<AssertPlaceHolder>\" ; verify ( restrictionRepository , times ( total ) ) . create ( any ( ch . puzzle . itc . mobiliar . business . security . boundary . RestrictionEntity . class ) ) ; verify ( permissionRepository , times ( 1 ) ) . forceReloadingOfLists ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( total , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "shouldCreateTheRightAmountOfRestrictionsIfARoleIsGiven ( ) { java . lang . String roleName1 = \"Role1\" ; java . lang . String permissionName1 = \"RESOURCE\" ; java . lang . String permissionName2 = \"RESOURCETYPE\" ; java . lang . String contextNameA = \"A\" ; when ( permissionRepository . getPermissionByName ( \"RESOURCE\" ) ) . thenReturn ( resourcePermission ) ; when ( permissionRepository . getPermissionByName ( \"RESOURCETYPE\" ) ) . thenReturn ( resourceTypePermission ) ; when ( resourceGroupRepository . find ( 1 ) ) . thenReturn ( new ch . puzzle . itc . mobiliar . business . resourcegroup . entity . ResourceGroupEntity ( ) ) ; int total = permissionBoundary . createMultipleRestrictions ( roleName1 , null , java . util . Arrays . asList ( permissionName1 , permissionName2 ) , java . util . Arrays . asList ( 1 ) , null , ResourceTypePermission . ANY , java . util . Arrays . asList ( contextNameA ) , java . util . Arrays . asList ( Action . CREATE ) , false , true ) ; \"<AssertPlaceHolder>\" ; verify ( restrictionRepository , times ( total ) ) . create ( any ( ch . puzzle . itc . mobiliar . business . security . boundary . RestrictionEntity . class ) ) ; verify ( permissionRepository , times ( 1 ) ) . forceReloadingOfLists ( ) ; } find ( java . lang . Number ) { T entity = entityManager . find ( entityType , id ) ; return entity ; }", "answer": "org . junit . Assert . assertThat ( total , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "setSocketFactory ( javax . net . ssl . SSLSocketFactory ) { org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . factories . set ( factory ) ; }", "testMethod": "testSSLConnectionWithoutPool ( ) { java . lang . System . setProperty ( \"simple\" 7 , \"2\" ) ; java . lang . System . setProperty ( \"simple\" 0 , \"simple\" 1 ) ; java . lang . System . setProperty ( \"com.sun.jndi.ldap.connect.pool.debug\" , \"all\" ) ; java . util . Hashtable < java . lang . String , java . lang . String > env = new java . util . Hashtable ( ) ; env . put ( \"com.sun.jndi.ldap.connect.pool\" , \"false\" ) ; env . put ( \"simple\" 4 , \"com.sun.jndi.ldap.connect.pool.debug\" 0 ) ; env . put ( \"java.naming.provider.url\" , ( ( \"simple\" 5 + ( getLdapServer ( ) . getPortSSL ( ) ) ) + \"/ou=system\" ) ) ; env . put ( \"simple\" 6 , org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . class . getName ( ) ) ; env . put ( \"simple\" 8 , \"simple\" 1 ) ; env . put ( \"java.naming.security.principal\" , \"simple\" 2 ) ; env . put ( \"simple\" 3 , \"simple\" 9 ) ; env . put ( \"java.naming.security.authentication\" , \"simple\" ) ; final int [ ] socketsCreated = new int [ ] { 0 } ; org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . setSocketFactory ( new org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory ( sslContext . getSocketFactory ( ) ) { @ org . apache . karaf . jaas . modules . ldap . Override public java . net . Socket createSocket ( java . lang . String host , int port ) throws java . io . IOException { ( socketsCreated [ 0 ] ) ++ ; return super . createSocket ( host , port ) ; } } ) ; javax . naming . directory . InitialDirContext context = new javax . naming . directory . InitialDirContext ( env ) ; context . close ( ) ; new javax . naming . directory . InitialDirContext ( env ) ; context . close ( ) ; org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . setSocketFactory ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( socketsCreated [ 0 ] , org . hamcrest . CoreMatchers . equalTo ( 2 ) )", "total": "testSSLConnectionWithoutPool ( ) { java . lang . System . setProperty ( \"simple\" 7 , \"2\" ) ; java . lang . System . setProperty ( \"simple\" 0 , \"simple\" 1 ) ; java . lang . System . setProperty ( \"com.sun.jndi.ldap.connect.pool.debug\" , \"all\" ) ; java . util . Hashtable < java . lang . String , java . lang . String > env = new java . util . Hashtable ( ) ; env . put ( \"com.sun.jndi.ldap.connect.pool\" , \"false\" ) ; env . put ( \"simple\" 4 , \"com.sun.jndi.ldap.connect.pool.debug\" 0 ) ; env . put ( \"java.naming.provider.url\" , ( ( \"simple\" 5 + ( getLdapServer ( ) . getPortSSL ( ) ) ) + \"/ou=system\" ) ) ; env . put ( \"simple\" 6 , org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . class . getName ( ) ) ; env . put ( \"simple\" 8 , \"simple\" 1 ) ; env . put ( \"java.naming.security.principal\" , \"simple\" 2 ) ; env . put ( \"simple\" 3 , \"simple\" 9 ) ; env . put ( \"java.naming.security.authentication\" , \"simple\" ) ; final int [ ] socketsCreated = new int [ ] { 0 } ; org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . setSocketFactory ( new org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory ( sslContext . getSocketFactory ( ) ) { @ org . apache . karaf . jaas . modules . ldap . Override public java . net . Socket createSocket ( java . lang . String host , int port ) throws java . io . IOException { ( socketsCreated [ 0 ] ) ++ ; return super . createSocket ( host , port ) ; } } ) ; javax . naming . directory . InitialDirContext context = new javax . naming . directory . InitialDirContext ( env ) ; context . close ( ) ; new javax . naming . directory . InitialDirContext ( env ) ; context . close ( ) ; org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . setSocketFactory ( null ) ; \"<AssertPlaceHolder>\" ; } setSocketFactory ( javax . net . ssl . SSLSocketFactory ) { org . apache . karaf . jaas . modules . ldap . ManagedSSLSocketFactory . factories . set ( factory ) ; }", "answer": "org . junit . Assert . assertThat ( socketsCreated [ 0 ] , org . hamcrest . CoreMatchers . equalTo ( 2 ) )"}
{"focal": "fetchCount ( ) { return ( statistics . getEntityFetchCount ( ) ) - ( fetches ) ; }", "testMethod": "releaseReferenceDoesNotHitDatabase ( ) { fm . last . musicbrainz . data . model . Medium medium = ( ( fm . last . musicbrainz . data . model . Medium ) ( session . load ( fm . last . musicbrainz . data . model . Medium . class , 2 ) ) ) ; fm . last . musicbrainz . data . model . Release release = medium . getRelease ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( fetchCount ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "releaseReferenceDoesNotHitDatabase ( ) { fm . last . musicbrainz . data . model . Medium medium = ( ( fm . last . musicbrainz . data . model . Medium ) ( session . load ( fm . last . musicbrainz . data . model . Medium . class , 2 ) ) ) ; fm . last . musicbrainz . data . model . Release release = medium . getRelease ( ) ; \"<AssertPlaceHolder>\" ; } fetchCount ( ) { return ( statistics . getEntityFetchCount ( ) ) - ( fetches ) ; }", "answer": "org . junit . Assert . assertThat ( fetchCount ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "getActiveClientCount ( ) { java . util . List < org . mifos . customers . business . CustomerBO > clients = getChildren ( ) ; if ( clients != null ) { return java . lang . Integer . valueOf ( clients . size ( ) ) ; } return java . lang . Integer . valueOf ( 0 ) ; }", "testMethod": "shouldCountClientsThatAreActiveOrOnHold ( ) { existingGroup = customerDao . findGroupBySystemId ( existingGroup . getGlobalCustNum ( ) ) ; java . lang . Integer activeClientsInGroup = existingGroup . getGroupPerformanceHistory ( ) . getActiveClientCount ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( activeClientsInGroup , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "shouldCountClientsThatAreActiveOrOnHold ( ) { existingGroup = customerDao . findGroupBySystemId ( existingGroup . getGlobalCustNum ( ) ) ; java . lang . Integer activeClientsInGroup = existingGroup . getGroupPerformanceHistory ( ) . getActiveClientCount ( ) ; \"<AssertPlaceHolder>\" ; } getActiveClientCount ( ) { java . util . List < org . mifos . customers . business . CustomerBO > clients = getChildren ( ) ; if ( clients != null ) { return java . lang . Integer . valueOf ( clients . size ( ) ) ; } return java . lang . Integer . valueOf ( 0 ) ; }", "answer": "org . junit . Assert . assertThat ( activeClientsInGroup , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "size ( ) { return size ; }", "testMethod": "testAndOperationMultiQueryBuilderTablescan ( ) { com . oberasoftware . jasdb . api . session . DBSession pojoDb = sessionFactory . createSession ( ) ; com . oberasoftware . jasdb . api . session . EntityBag bag = pojoDb . createOrGetBag ( \"thosha\" ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID1 ) . addProperty ( \"type\" , \"thing\" ) ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID2 ) . addProperty ( \"type\" , \"thing\" ) ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID3 ) . addProperty ( \"type\" , \"contribution\" ) ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID4 ) . addProperty ( \"type\" , \"contribution\" ) ) ; try { com . oberasoftware . jasdb . api . session . query . QueryBuilder builder = com . oberasoftware . jasdb . api . session . query . QueryBuilder . createBuilder ( BlockType . AND ) ; builder . addQueryBlock ( com . oberasoftware . jasdb . api . session . query . QueryBuilder . createBuilder ( ) . field ( \"__ID\" ) . value ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID3 ) ) ; builder . addQueryBlock ( com . oberasoftware . jasdb . api . session . query . QueryBuilder . createBuilder ( ) . field ( \"type\" ) . value ( \"contribution\" ) ) ; com . oberasoftware . jasdb . api . session . query . QueryExecutor executor = bag . find ( builder ) ; java . util . List < com . oberasoftware . jasdb . api . session . Entity > entities = toList ( executor . execute ( ) ) ; \"<AssertPlaceHolder>\" ; } finally { pojoDb . closeSession ( ) ; com . oberasoftware . jasdb . service . JasDBMain . shutdown ( ) ; } }", "assertLine": "org . junit . Assert . assertThat ( entities . size ( ) , org . hamcrest . core . Is . is ( 1 ) )", "total": "testAndOperationMultiQueryBuilderTablescan ( ) { com . oberasoftware . jasdb . api . session . DBSession pojoDb = sessionFactory . createSession ( ) ; com . oberasoftware . jasdb . api . session . EntityBag bag = pojoDb . createOrGetBag ( \"thosha\" ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID1 ) . addProperty ( \"type\" , \"thing\" ) ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID2 ) . addProperty ( \"type\" , \"thing\" ) ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID3 ) . addProperty ( \"type\" , \"contribution\" ) ) ; bag . addEntity ( new com . oberasoftware . jasdb . core . SimpleEntity ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID4 ) . addProperty ( \"type\" , \"contribution\" ) ) ; try { com . oberasoftware . jasdb . api . session . query . QueryBuilder builder = com . oberasoftware . jasdb . api . session . query . QueryBuilder . createBuilder ( BlockType . AND ) ; builder . addQueryBlock ( com . oberasoftware . jasdb . api . session . query . QueryBuilder . createBuilder ( ) . field ( \"__ID\" ) . value ( com . oberasoftware . jasdb . test . TableScanQueryTest . ID3 ) ) ; builder . addQueryBlock ( com . oberasoftware . jasdb . api . session . query . QueryBuilder . createBuilder ( ) . field ( \"type\" ) . value ( \"contribution\" ) ) ; com . oberasoftware . jasdb . api . session . query . QueryExecutor executor = bag . find ( builder ) ; java . util . List < com . oberasoftware . jasdb . api . session . Entity > entities = toList ( executor . execute ( ) ) ; \"<AssertPlaceHolder>\" ; } finally { pojoDb . closeSession ( ) ; com . oberasoftware . jasdb . service . JasDBMain . shutdown ( ) ; } } size ( ) { return size ; }", "answer": "org . junit . Assert . assertThat ( entities . size ( ) , org . hamcrest . core . Is . is ( 1 ) )"}
{"focal": "proceedTo ( T ) { if ( ( edge ) == null ) { com . maxgarfinkel . suffixTree . Edge < T , S > tmpEdge = node . getEdgeStarting ( item ) ; if ( tmpEdge != null ) { edge = tmpEdge ; length = 1 ; return true ; } else { return false ; } } else if ( ( edge . getLength ( ) ) > ( length ) ) { T nextItem = edge . getItemAt ( length ) ; if ( ( nextItem != null ) && ( item . equals ( nextItem ) ) ) { ( length ) ++ ; return true ; } else { return false ; } } else { com . maxgarfinkel . suffixTree . Node < T , S > terminal = edge . getTerminal ( ) ; if ( terminal == null ) return false ; else { com . maxgarfinkel . suffixTree . Edge < T , S > tmpEdge = terminal . getEdgeStarting ( item ) ; if ( tmpEdge != null ) { edge = tmpEdge ; length = 1 ; node = terminal ; return true ; } else { return false ; } } } }", "testMethod": "proceedToWalksEdgeOfLengthOneAndHandlesBranchWhereItemNotFound ( ) { com . maxgarfinkel . suffixTree . Word word = new com . maxgarfinkel . suffixTree . Word ( \"ababc\" ) ; com . maxgarfinkel . suffixTree . SuffixTree < java . lang . Character , com . maxgarfinkel . suffixTree . Word > tree = new com . maxgarfinkel . suffixTree . SuffixTree < java . lang . Character , com . maxgarfinkel . suffixTree . Word > ( word ) ; com . maxgarfinkel . suffixTree . Cursor < java . lang . Character , com . maxgarfinkel . suffixTree . Word > cursor = new com . maxgarfinkel . suffixTree . Cursor < java . lang . Character , com . maxgarfinkel . suffixTree . Word > ( tree ) ; cursor . proceedTo ( 'b' ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cursor . proceedTo ( 'b' ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "proceedToWalksEdgeOfLengthOneAndHandlesBranchWhereItemNotFound ( ) { com . maxgarfinkel . suffixTree . Word word = new com . maxgarfinkel . suffixTree . Word ( \"ababc\" ) ; com . maxgarfinkel . suffixTree . SuffixTree < java . lang . Character , com . maxgarfinkel . suffixTree . Word > tree = new com . maxgarfinkel . suffixTree . SuffixTree < java . lang . Character , com . maxgarfinkel . suffixTree . Word > ( word ) ; com . maxgarfinkel . suffixTree . Cursor < java . lang . Character , com . maxgarfinkel . suffixTree . Word > cursor = new com . maxgarfinkel . suffixTree . Cursor < java . lang . Character , com . maxgarfinkel . suffixTree . Word > ( tree ) ; cursor . proceedTo ( 'b' ) ; \"<AssertPlaceHolder>\" ; } proceedTo ( T ) { if ( ( edge ) == null ) { com . maxgarfinkel . suffixTree . Edge < T , S > tmpEdge = node . getEdgeStarting ( item ) ; if ( tmpEdge != null ) { edge = tmpEdge ; length = 1 ; return true ; } else { return false ; } } else if ( ( edge . getLength ( ) ) > ( length ) ) { T nextItem = edge . getItemAt ( length ) ; if ( ( nextItem != null ) && ( item . equals ( nextItem ) ) ) { ( length ) ++ ; return true ; } else { return false ; } } else { com . maxgarfinkel . suffixTree . Node < T , S > terminal = edge . getTerminal ( ) ; if ( terminal == null ) return false ; else { com . maxgarfinkel . suffixTree . Edge < T , S > tmpEdge = terminal . getEdgeStarting ( item ) ; if ( tmpEdge != null ) { edge = tmpEdge ; length = 1 ; node = terminal ; return true ; } else { return false ; } } } }", "answer": "org . junit . Assert . assertThat ( cursor . proceedTo ( 'b' ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "findOtherByOwnerAndType ( org . incode . module . communications . dom . impl . commchannel . CommunicationChannelOwner , org . incode . module . communications . dom . impl . commchannel . CommunicationChannelType , org . incode . module . communications . dom . impl . commchannel . CommunicationChannel ) { final java . util . SortedSet < org . incode . module . communications . dom . impl . commchannel . CommunicationChannel > communicationChannels = findByOwnerAndType ( owner , type ) ; communicationChannels . remove ( exclude ) ; return communicationChannels ; }", "testMethod": "happyCase ( ) { org . incode . module . communications . dom . impl . commchannel . CommunicationChannel exclude = communicationChannelRepository . findByOwnerAndType ( party , CommunicationChannelType . POSTAL_ADDRESS ) . first ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( communicationChannelRepository . findOtherByOwnerAndType ( party , CommunicationChannelType . POSTAL_ADDRESS , exclude ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "happyCase ( ) { org . incode . module . communications . dom . impl . commchannel . CommunicationChannel exclude = communicationChannelRepository . findByOwnerAndType ( party , CommunicationChannelType . POSTAL_ADDRESS ) . first ( ) ; \"<AssertPlaceHolder>\" ; } findOtherByOwnerAndType ( org . incode . module . communications . dom . impl . commchannel . CommunicationChannelOwner , org . incode . module . communications . dom . impl . commchannel . CommunicationChannelType , org . incode . module . communications . dom . impl . commchannel . CommunicationChannel ) { final java . util . SortedSet < org . incode . module . communications . dom . impl . commchannel . CommunicationChannel > communicationChannels = findByOwnerAndType ( owner , type ) ; communicationChannels . remove ( exclude ) ; return communicationChannels ; }", "answer": "org . junit . Assert . assertThat ( communicationChannelRepository . findOtherByOwnerAndType ( party , CommunicationChannelType . POSTAL_ADDRESS , exclude ) . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getSoname ( java . nio . file . Path ) { return com . facebook . buck . cxx . ElfFile . getSoname ( com . facebook . buck . cxx . ElfFile . mapReadOnly ( elfFilePath ) ) ; }", "testMethod": "staticExecutableHasNoSoname ( ) { java . nio . file . Path elfFilePath = workspace . resolve ( \"static_executable\" ) ; com . facebook . buck . cxx . toolchain . elf . Elf elf = com . facebook . buck . cxx . ElfFile . mapReadOnly ( elfFilePath ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . facebook . buck . cxx . ElfFile . getSoname ( elf ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . empty ( ) ) )", "total": "staticExecutableHasNoSoname ( ) { java . nio . file . Path elfFilePath = workspace . resolve ( \"static_executable\" ) ; com . facebook . buck . cxx . toolchain . elf . Elf elf = com . facebook . buck . cxx . ElfFile . mapReadOnly ( elfFilePath ) ; \"<AssertPlaceHolder>\" ; } getSoname ( java . nio . file . Path ) { return com . facebook . buck . cxx . ElfFile . getSoname ( com . facebook . buck . cxx . ElfFile . mapReadOnly ( elfFilePath ) ) ; }", "answer": "org . junit . Assert . assertThat ( com . facebook . buck . cxx . ElfFile . getSoname ( elf ) , org . hamcrest . Matchers . equalTo ( java . util . Optional . empty ( ) ) )"}
{"focal": "contains ( java . lang . String ) { for ( org . meridor . perspective . shell . common . validator . Field c : org . meridor . perspective . shell . common . validator . Field . values ( ) ) { if ( c . name ( ) . equals ( name ) ) { return true ; } } return false ; }", "testMethod": "testListen ( ) { final java . lang . String ID = \"new-id\" ; org . meridor . perspective . beans . Image image = org . meridor . perspective . backend . EntityGenerator . getImage ( ) ; image . setId ( ID ) ; image . setCloudId ( org . meridor . perspective . worker . fetcher . impl . ImageModificationListenerTest . CLOUD_ID ) ; image . setTimestamp ( java . time . ZonedDateTime . now ( ) . minus ( 1 , ChronoUnit . DAYS ) ) ; imagesAware . saveImage ( image ) ; java . util . Set < java . lang . String > ids = imageModificationListener . getIds ( org . meridor . perspective . worker . fetcher . impl . ImageModificationListenerTest . CLOUD_ID , LastModified . LONG_AGO ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ids , org . hamcrest . Matchers . contains ( ID ) )", "total": "testListen ( ) { final java . lang . String ID = \"new-id\" ; org . meridor . perspective . beans . Image image = org . meridor . perspective . backend . EntityGenerator . getImage ( ) ; image . setId ( ID ) ; image . setCloudId ( org . meridor . perspective . worker . fetcher . impl . ImageModificationListenerTest . CLOUD_ID ) ; image . setTimestamp ( java . time . ZonedDateTime . now ( ) . minus ( 1 , ChronoUnit . DAYS ) ) ; imagesAware . saveImage ( image ) ; java . util . Set < java . lang . String > ids = imageModificationListener . getIds ( org . meridor . perspective . worker . fetcher . impl . ImageModificationListenerTest . CLOUD_ID , LastModified . LONG_AGO ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . String ) { for ( org . meridor . perspective . shell . common . validator . Field c : org . meridor . perspective . shell . common . validator . Field . values ( ) ) { if ( c . name ( ) . equals ( name ) ) { return true ; } } return false ; }", "answer": "org . junit . Assert . assertThat ( ids , org . hamcrest . Matchers . contains ( ID ) )"}
{"focal": "getPerformanceCost ( ) { return _cost . getPerformanceCost ( ) ; }", "testMethod": "whenTapeQueuesHaveQueuedItemsTheyAreConsideredFull ( ) { diskCacheV111 . pools . PoolCostInfo cost = diskCacheV111 . pools . CostCalculationV5Test . buildPoolCost ( 0 , 100 , 0 , 0 , 0 , 1 , 0 , 0 , 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( cost . getPerformanceCost ( ) , org . hamcrest . Matchers . is ( ( 1.0 / 2 ) ) )", "total": "whenTapeQueuesHaveQueuedItemsTheyAreConsideredFull ( ) { diskCacheV111 . pools . PoolCostInfo cost = diskCacheV111 . pools . CostCalculationV5Test . buildPoolCost ( 0 , 100 , 0 , 0 , 0 , 1 , 0 , 0 , 1 ) ; \"<AssertPlaceHolder>\" ; } getPerformanceCost ( ) { return _cost . getPerformanceCost ( ) ; }", "answer": "org . junit . Assert . assertThat ( cost . getPerformanceCost ( ) , org . hamcrest . Matchers . is ( ( 1.0 / 2 ) ) )"}
{"focal": "size ( ) { return org . talend . dataprep . folder . store . file . FileSystemUtils . countSubDirectories ( pathsConverter . getRootFolder ( ) ) ; }", "testMethod": "shouldTestgetSettings ( ) { java . util . List < org . talend . dataprep . api . service . settings . uris . api . UriSettings > listUriSettings = urisProvider . getSettings ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( listUriSettings . size ( ) , org . hamcrest . Matchers . is ( 16 ) )", "total": "shouldTestgetSettings ( ) { java . util . List < org . talend . dataprep . api . service . settings . uris . api . UriSettings > listUriSettings = urisProvider . getSettings ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return org . talend . dataprep . folder . store . file . FileSystemUtils . countSubDirectories ( pathsConverter . getRootFolder ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( listUriSettings . size ( ) , org . hamcrest . Matchers . is ( 16 ) )"}
{"focal": "get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "testMethod": "writable_0 ( ) { com . asakusafw . runtime . value . DateTimeOption option = new com . asakusafw . runtime . value . DateTimeOption ( ) ; option . modify ( time ( 0 ) ) ; com . asakusafw . runtime . value . DateTimeOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( option . get ( ) , is ( restored . get ( ) ) )", "total": "writable_0 ( ) { com . asakusafw . runtime . value . DateTimeOption option = new com . asakusafw . runtime . value . DateTimeOption ( ) ; option . modify ( time ( 0 ) ) ; com . asakusafw . runtime . value . DateTimeOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "answer": "org . junit . Assert . assertThat ( option . get ( ) , is ( restored . get ( ) ) )"}
{"focal": "getMethod ( ) { java . lang . String method = getConfig ( ) . getMethod ( ) ; return method == null ? null : RestRequestInterface . HttpMethod . valueOf ( method ) ; }", "testMethod": "shouldSetMethod ( ) { mockAction . setMethod ( RestRequestInterface . HttpMethod . TRACE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mockAction . getMethod ( ) , org . hamcrest . core . Is . is ( RestRequestInterface . HttpMethod . TRACE ) )", "total": "shouldSetMethod ( ) { mockAction . setMethod ( RestRequestInterface . HttpMethod . TRACE ) ; \"<AssertPlaceHolder>\" ; } getMethod ( ) { java . lang . String method = getConfig ( ) . getMethod ( ) ; return method == null ? null : RestRequestInterface . HttpMethod . valueOf ( method ) ; }", "answer": "org . junit . Assert . assertThat ( mockAction . getMethod ( ) , org . hamcrest . core . Is . is ( RestRequestInterface . HttpMethod . TRACE ) )"}
{"focal": "handle ( java . lang . Exception , org . springframework . springfaces . mvc . context . SpringFacesContext ) { javax . faces . context . ExternalContext externalContext = context . getFacesContext ( ) . getExternalContext ( ) ; javax . servlet . http . HttpServletRequest request = ( ( javax . servlet . http . HttpServletRequest ) ( externalContext . getRequest ( ) ) ) ; javax . servlet . http . HttpServletResponse response = ( ( javax . servlet . http . HttpServletResponse ) ( externalContext . getResponse ( ) ) ) ; java . lang . Object handler = context . getHandler ( ) ; org . springframework . web . servlet . ModelAndView modelAndView = processHandlerException ( request , response , handler , exception ) ; if ( modelAndView != null ) { org . springframework . web . util . WebUtils . clearErrorRequestAttributes ( request ) ; if ( modelAndView . isReference ( ) ) { java . lang . String viewName = modelAndView . getViewName ( ) ; java . util . Map < java . lang . String , java . lang . Object > model = modelAndView . getModel ( ) ; java . util . Locale locale = org . springframework . springfaces . util . FacesUtils . getLocale ( context . getFacesContext ( ) ) ; org . springframework . web . servlet . View view = this . dispatcher . resolveViewName ( viewName , model , locale , request ) ; modelAndView . setView ( view ) ; } context . render ( modelAndView . getView ( ) , modelAndView . getModel ( ) ) ; return true ; } return false ; }", "testMethod": "shouldNotHandleIfNoSpringFacesContext ( ) { org . springframework . springfaces . mvc . SpringFacesContextSetter . setCurrentInstance ( null ) ; java . lang . Exception exception = mock ( org . springframework . springfaces . mvc . servlet . Exception . class ) ; boolean handled = this . exceptionHandler . handle ( exception , this . event ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( handled , org . hamcrest . Matchers . is ( false ) )", "total": "shouldNotHandleIfNoSpringFacesContext ( ) { org . springframework . springfaces . mvc . SpringFacesContextSetter . setCurrentInstance ( null ) ; java . lang . Exception exception = mock ( org . springframework . springfaces . mvc . servlet . Exception . class ) ; boolean handled = this . exceptionHandler . handle ( exception , this . event ) ; \"<AssertPlaceHolder>\" ; } handle ( java . lang . Exception , org . springframework . springfaces . mvc . context . SpringFacesContext ) { javax . faces . context . ExternalContext externalContext = context . getFacesContext ( ) . getExternalContext ( ) ; javax . servlet . http . HttpServletRequest request = ( ( javax . servlet . http . HttpServletRequest ) ( externalContext . getRequest ( ) ) ) ; javax . servlet . http . HttpServletResponse response = ( ( javax . servlet . http . HttpServletResponse ) ( externalContext . getResponse ( ) ) ) ; java . lang . Object handler = context . getHandler ( ) ; org . springframework . web . servlet . ModelAndView modelAndView = processHandlerException ( request , response , handler , exception ) ; if ( modelAndView != null ) { org . springframework . web . util . WebUtils . clearErrorRequestAttributes ( request ) ; if ( modelAndView . isReference ( ) ) { java . lang . String viewName = modelAndView . getViewName ( ) ; java . util . Map < java . lang . String , java . lang . Object > model = modelAndView . getModel ( ) ; java . util . Locale locale = org . springframework . springfaces . util . FacesUtils . getLocale ( context . getFacesContext ( ) ) ; org . springframework . web . servlet . View view = this . dispatcher . resolveViewName ( viewName , model , locale , request ) ; modelAndView . setView ( view ) ; } context . render ( modelAndView . getView ( ) , modelAndView . getModel ( ) ) ; return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( handled , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "equals ( java . lang . Object ) { if ( ( this ) == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof org . jboss . aerogear . simplepush . protocol . Ack ) ) { return false ; } final org . jboss . aerogear . simplepush . protocol . impl . AckImpl other = ( ( org . jboss . aerogear . simplepush . protocol . impl . AckImpl ) ( obj ) ) ; return ( channelId ) == null ? ( other . channelId ) == null : channelId . equals ( other . channelId ) ; }", "testMethod": "equalsContractReflexive ( ) { final org . jboss . aerogear . simplepush . server . datastore . model . AckDTO x = new org . jboss . aerogear . simplepush . server . datastore . model . AckDTO ( new org . jboss . aerogear . simplepush . server . datastore . model . UserAgentDTO ( uaid ) , channelId , version ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( x . equals ( x ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "equalsContractReflexive ( ) { final org . jboss . aerogear . simplepush . server . datastore . model . AckDTO x = new org . jboss . aerogear . simplepush . server . datastore . model . AckDTO ( new org . jboss . aerogear . simplepush . server . datastore . model . UserAgentDTO ( uaid ) , channelId , version ) ; \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( ( this ) == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof org . jboss . aerogear . simplepush . protocol . Ack ) ) { return false ; } final org . jboss . aerogear . simplepush . protocol . impl . AckImpl other = ( ( org . jboss . aerogear . simplepush . protocol . impl . AckImpl ) ( obj ) ) ; return ( channelId ) == null ? ( other . channelId ) == null : channelId . equals ( other . channelId ) ; }", "answer": "org . junit . Assert . assertThat ( x . equals ( x ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "verbose ( ) { java . io . File current = openWorkingDir ( ) ; add ( \"root\" , \"/\" , \"a.txt\" ) ; invoke ( \"get\" , \"a.txt\" , \".\" , \"-v\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( new java . io . File ( current , \"a.txt\" ) , is ( file ( ) ) )", "total": "verbose ( ) { java . io . File current = openWorkingDir ( ) ; add ( \"root\" , \"/\" , \"a.txt\" ) ; invoke ( \"get\" , \"a.txt\" , \".\" , \"-v\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( new java . io . File ( current , \"a.txt\" ) , is ( file ( ) ) )"}
{"focal": "is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "testMethod": "shouldNotDeletePodAfterNonDeletePeriodIfRunStateStillRunning ( java . lang . String ) { final com . spotify . styx . state . RunState . State state = com . spotify . styx . state . RunState . State . valueOf ( stateName ) ; final java . lang . String name = createdPod . getMetadata ( ) . getName ( ) ; when ( k8sClient . pods ( ) . withName ( name ) ) . thenReturn ( namedPod ) ; when ( namedPod . get ( ) ) . thenReturn ( createdPod ) ; createdPod . setStatus ( podStatus ) ; when ( podStatus . getContainerStatuses ( ) ) . thenReturn ( java . util . List . of ( containerStatus , keepaliveContainerStatus ) ) ; when ( containerStatus . getName ( ) ) . thenReturn ( com . spotify . styx . docker . KubernetesDockerRunner . MAIN_CONTAINER_NAME ) ; when ( containerStatus . getState ( ) ) . thenReturn ( containerState ) ; when ( containerState . getTerminated ( ) ) . thenReturn ( containerStateTerminated ) ; when ( containerStateTerminated . getFinishedAt ( ) ) . thenReturn ( com . spotify . styx . docker . KubernetesDockerRunnerTest . FIXED_INSTANT . minus ( java . time . Duration . ofMinutes ( 5 ) ) . toString ( ) ) ; com . spotify . styx . docker . var runState = com . spotify . styx . state . RunState . create ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , state ) ; com . spotify . styx . docker . var shouldDelete = kdr . shouldDeletePodWithRunState ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , createdPod , runState ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( shouldDelete , org . hamcrest . Matchers . is ( false ) )", "total": "shouldNotDeletePodAfterNonDeletePeriodIfRunStateStillRunning ( java . lang . String ) { final com . spotify . styx . state . RunState . State state = com . spotify . styx . state . RunState . State . valueOf ( stateName ) ; final java . lang . String name = createdPod . getMetadata ( ) . getName ( ) ; when ( k8sClient . pods ( ) . withName ( name ) ) . thenReturn ( namedPod ) ; when ( namedPod . get ( ) ) . thenReturn ( createdPod ) ; createdPod . setStatus ( podStatus ) ; when ( podStatus . getContainerStatuses ( ) ) . thenReturn ( java . util . List . of ( containerStatus , keepaliveContainerStatus ) ) ; when ( containerStatus . getName ( ) ) . thenReturn ( com . spotify . styx . docker . KubernetesDockerRunner . MAIN_CONTAINER_NAME ) ; when ( containerStatus . getState ( ) ) . thenReturn ( containerState ) ; when ( containerState . getTerminated ( ) ) . thenReturn ( containerStateTerminated ) ; when ( containerStateTerminated . getFinishedAt ( ) ) . thenReturn ( com . spotify . styx . docker . KubernetesDockerRunnerTest . FIXED_INSTANT . minus ( java . time . Duration . ofMinutes ( 5 ) ) . toString ( ) ) ; com . spotify . styx . docker . var runState = com . spotify . styx . state . RunState . create ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , state ) ; com . spotify . styx . docker . var shouldDelete = kdr . shouldDeletePodWithRunState ( com . spotify . styx . docker . KubernetesDockerRunnerTest . WORKFLOW_INSTANCE , createdPod , runState ) ; \"<AssertPlaceHolder>\" ; } is ( com . spotify . styx . api . Api$Version ) { return new org . hamcrest . TypeSafeMatcher < com . spotify . styx . api . Api . Version > ( ) { @ com . spotify . styx . api . Override protected boolean matchesSafely ( com . spotify . styx . api . Api . Version item ) { return ( item . ordinal ( ) ) == ( version . ordinal ( ) ) ; } @ com . spotify . styx . api . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( \"Version<sp>can<sp>only<sp>be\" ) ; description . appendValue ( version ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( shouldDelete , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObjectThis ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( target ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testEqualsObjectThis ( ) { \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( target ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "size ( ) { return elementen . size ( ) ; }", "testMethod": "alleFiltersTrueDanResultaatOrigineleMap ( ) { final java . util . Map < java . lang . Integer , nl . bzk . brp . levering . model . Populatie > populatieMap = new java . util . HashMap ( ) ; populatieMap . put ( 1 , Populatie . BETREEDT ) ; populatieMap . put ( 2 , Populatie . BINNEN ) ; final nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig persoon1 = mock ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) ; when ( persoon1 . getID ( ) ) . thenReturn ( 1 ) ; final nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig persoon2 = mock ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) ; when ( persoon2 . getID ( ) ) . thenReturn ( 2 ) ; final java . util . List < nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig > personen = java . util . Arrays . asList ( persoon1 , persoon2 ) ; when ( populatieBepalingFilter . magLeverenDoorgaan ( any ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) , any ( nl . bzk . brp . levering . model . Populatie . class ) , eq ( leveringAutorisatie ) , eq ( administratieveHandelingModel ) ) ) . thenReturn ( true ) ; when ( afnemerIndicatieFilter . magLeverenDoorgaan ( any ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) , any ( nl . bzk . brp . levering . model . Populatie . class ) , eq ( leveringAutorisatie ) , eq ( administratieveHandelingModel ) ) ) . thenReturn ( true ) ; nietTeLeverenPersonenService . filterNietTeLeverenPersonen ( personen , populatieMap , leveringAutorisatie , administratieveHandelingModel ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( populatieMap . size ( ) , org . hamcrest . Matchers . is ( 2 ) )", "total": "alleFiltersTrueDanResultaatOrigineleMap ( ) { final java . util . Map < java . lang . Integer , nl . bzk . brp . levering . model . Populatie > populatieMap = new java . util . HashMap ( ) ; populatieMap . put ( 1 , Populatie . BETREEDT ) ; populatieMap . put ( 2 , Populatie . BINNEN ) ; final nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig persoon1 = mock ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) ; when ( persoon1 . getID ( ) ) . thenReturn ( 1 ) ; final nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig persoon2 = mock ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) ; when ( persoon2 . getID ( ) ) . thenReturn ( 2 ) ; final java . util . List < nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig > personen = java . util . Arrays . asList ( persoon1 , persoon2 ) ; when ( populatieBepalingFilter . magLeverenDoorgaan ( any ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) , any ( nl . bzk . brp . levering . model . Populatie . class ) , eq ( leveringAutorisatie ) , eq ( administratieveHandelingModel ) ) ) . thenReturn ( true ) ; when ( afnemerIndicatieFilter . magLeverenDoorgaan ( any ( nl . bzk . brp . model . hisvolledig . kern . PersoonHisVolledig . class ) , any ( nl . bzk . brp . levering . model . Populatie . class ) , eq ( leveringAutorisatie ) , eq ( administratieveHandelingModel ) ) ) . thenReturn ( true ) ; nietTeLeverenPersonenService . filterNietTeLeverenPersonen ( personen , populatieMap , leveringAutorisatie , administratieveHandelingModel ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return elementen . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( populatieMap . size ( ) , org . hamcrest . Matchers . is ( 2 ) )"}
{"focal": "close ( ) { if ( ! ( open ) ) { throw new java . io . IOException ( ( \"Connection<sp>already<sp>closed:<sp>\" + ( this ) ) ) ; } errorHandler . wrapVoidIoCall ( delegate . close ( ) , ( \"Could<sp>not<sp>close<sp>db:<sp>\" + ( descriptor ) ) ) ; open = false ; }", "testMethod": "open ( ) { java . io . File file = temporaryFolder . newFile ( \"KyotoDbImplTest-open.kch\" ) ; db = new kyotocabinet . DB ( ) ; kyotoDb = new fm . last . commons . kyoto . factory . KyotoDbImpl ( fm . last . commons . kyoto . DbType . FILE_HASH , db , file . getAbsolutePath ( ) , java . util . EnumSet . of ( Mode . CREATE , Mode . READ_WRITE ) , file ) ; kyotoDb . open ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( db . close ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "open ( ) { java . io . File file = temporaryFolder . newFile ( \"KyotoDbImplTest-open.kch\" ) ; db = new kyotocabinet . DB ( ) ; kyotoDb = new fm . last . commons . kyoto . factory . KyotoDbImpl ( fm . last . commons . kyoto . DbType . FILE_HASH , db , file . getAbsolutePath ( ) , java . util . EnumSet . of ( Mode . CREATE , Mode . READ_WRITE ) , file ) ; kyotoDb . open ( ) ; \"<AssertPlaceHolder>\" ; } close ( ) { if ( ! ( open ) ) { throw new java . io . IOException ( ( \"Connection<sp>already<sp>closed:<sp>\" + ( this ) ) ) ; } errorHandler . wrapVoidIoCall ( delegate . close ( ) , ( \"Could<sp>not<sp>close<sp>db:<sp>\" + ( descriptor ) ) ) ; open = false ; }", "answer": "org . junit . Assert . assertThat ( db . close ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "apply ( java . lang . Integer ) { return ( input % 2 ) == 0 ; }", "testMethod": "whenTransformingWithIterables_thenTransformed ( ) { final com . google . common . base . Function < java . lang . String , java . lang . Integer > function = new com . google . common . base . Function < java . lang . String , java . lang . Integer > ( ) { public final com . github . mysite . common . guava . Integer apply ( final java . lang . String input ) { return input . length ( ) ; } } ; final java . util . List < java . lang . String > names = com . google . common . collect . Lists . newArrayList ( \"John\" , \"Jane\" , \"Adam\" , \"Tom\" ) ; final java . lang . Iterable < java . lang . Integer > result = com . google . common . collect . Iterables . transform ( names , function ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . contains ( 4 , 4 , 4 , 3 ) )", "total": "whenTransformingWithIterables_thenTransformed ( ) { final com . google . common . base . Function < java . lang . String , java . lang . Integer > function = new com . google . common . base . Function < java . lang . String , java . lang . Integer > ( ) { public final com . github . mysite . common . guava . Integer apply ( final java . lang . String input ) { return input . length ( ) ; } } ; final java . util . List < java . lang . String > names = com . google . common . collect . Lists . newArrayList ( \"John\" , \"Jane\" , \"Adam\" , \"Tom\" ) ; final java . lang . Iterable < java . lang . Integer > result = com . google . common . collect . Iterables . transform ( names , function ) ; \"<AssertPlaceHolder>\" ; } apply ( java . lang . Integer ) { return ( input % 2 ) == 0 ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . contains ( 4 , 4 , 4 , 3 ) )"}
{"focal": "getStatus ( ) { return status ; }", "testMethod": "get_A$Request_followRedirects301 ( ) { com . m3 . curly . com . m3 . curly . Request request = new com . m3 . curly . Request ( \"http://localhost:8813/\" ) . setFollowRedirects ( true ) ; com . m3 . curly . Response response = com . m3 . curly . com . m3 . curly . HTTP . get ( request ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . getStatus ( ) , is ( 200 ) )", "total": "get_A$Request_followRedirects301 ( ) { com . m3 . curly . com . m3 . curly . Request request = new com . m3 . curly . Request ( \"http://localhost:8813/\" ) . setFollowRedirects ( true ) ; com . m3 . curly . Response response = com . m3 . curly . com . m3 . curly . HTTP . get ( request ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return status ; }", "answer": "org . junit . Assert . assertThat ( response . getStatus ( ) , is ( 200 ) )"}
{"focal": "expr ( org . openscience . cdk . isomorphism . matchers . Expr$Type ) { return new org . openscience . cdk . isomorphism . matchers . Expr ( type ) ; }", "testMethod": "specifiedIsotope ( ) { org . openscience . cdk . isomorphism . matchers . Expr actual = org . openscience . cdk . smarts . SmartsExprReadTest . getAtomExpr ( \"[!0]\" ) ; org . openscience . cdk . isomorphism . matchers . Expr expected = org . openscience . cdk . smarts . SmartsExprReadTest . expr ( org . openscience . cdk . smarts . HAS_ISOTOPE ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "specifiedIsotope ( ) { org . openscience . cdk . isomorphism . matchers . Expr actual = org . openscience . cdk . smarts . SmartsExprReadTest . getAtomExpr ( \"[!0]\" ) ; org . openscience . cdk . isomorphism . matchers . Expr expected = org . openscience . cdk . smarts . SmartsExprReadTest . expr ( org . openscience . cdk . smarts . HAS_ISOTOPE ) ; \"<AssertPlaceHolder>\" ; } expr ( org . openscience . cdk . isomorphism . matchers . Expr$Type ) { return new org . openscience . cdk . isomorphism . matchers . Expr ( type ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "getOffset ( kafka . javaapi . consumer . SimpleConsumer , java . lang . String , int , storm . kafka . KafkaConfig ) { long startOffsetTime = kafka . api . OffsetRequest . LatestTime ( ) ; if ( config . forceFromStart ) { startOffsetTime = config . startOffsetTime ; } return storm . kafka . KafkaUtils . getOffset ( consumer , topic , partition , startOffsetTime ) ; }", "testMethod": "getOffsetFromConfigAndFroceFromStart ( ) { config . forceFromStart = true ; config . startOffsetTime = kafka . api . OffsetRequest . EarliestTime ( ) ; createTopicAndSendMessage ( ) ; long earliestOffset = storm . kafka . KafkaUtils . getOffset ( simpleConsumer , config . topic , 0 , kafka . api . OffsetRequest . EarliestTime ( ) ) ; long offsetFromConfig = storm . kafka . KafkaUtils . getOffset ( simpleConsumer , config . topic , 0 , config ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( earliestOffset , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( offsetFromConfig ) ) )", "total": "getOffsetFromConfigAndFroceFromStart ( ) { config . forceFromStart = true ; config . startOffsetTime = kafka . api . OffsetRequest . EarliestTime ( ) ; createTopicAndSendMessage ( ) ; long earliestOffset = storm . kafka . KafkaUtils . getOffset ( simpleConsumer , config . topic , 0 , kafka . api . OffsetRequest . EarliestTime ( ) ) ; long offsetFromConfig = storm . kafka . KafkaUtils . getOffset ( simpleConsumer , config . topic , 0 , config ) ; \"<AssertPlaceHolder>\" ; } getOffset ( kafka . javaapi . consumer . SimpleConsumer , java . lang . String , int , storm . kafka . KafkaConfig ) { long startOffsetTime = kafka . api . OffsetRequest . LatestTime ( ) ; if ( config . forceFromStart ) { startOffsetTime = config . startOffsetTime ; } return storm . kafka . KafkaUtils . getOffset ( consumer , topic , partition , startOffsetTime ) ; }", "answer": "org . junit . Assert . assertThat ( earliestOffset , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( offsetFromConfig ) ) )"}
{"focal": "noOfAllSolutions ( org . jacop . core . Store , org . jacop . core . IntVar [ ] [ ] ) { org . jacop . SelectChoicePoint < org . jacop . core . IntVar > select = new org . jacop . SimpleSelect < org . jacop . core . IntVar > ( java . util . Arrays . stream ( variables ) . map ( Arrays :: stream ) . flatMap ( ( i ) -> i ) . toArray ( org . jacop . core . IntVar [ ] :: new ) , new org . jacop . MostConstrainedStatic < org . jacop . core . IntVar > ( ) , new org . jacop . IndomainMin < org . jacop . core . IntVar > ( ) ) ; org . jacop . DepthFirstSearch search = new org . jacop . DepthFirstSearch < org . jacop . core . IntVar > ( ) ; search . getSolutionListener ( ) . searchAll ( true ) ; search . getSolutionListener ( ) . recordSolutions ( true ) ; search . setAssignSolution ( true ) ; boolean result = search . labeling ( store , select ) ; return search . getSolutionListener ( ) . solutionsNo ( ) ; }", "testMethod": "testXgtCwithHelperSimpleConstraintsToAvoidNoConstraintBeingActiveSmall ( ) { org . jacop . Store store = new org . jacop . Store ( ) ; int xLength = 2 ; int xSize = ( xLength * 2 ) + 2 ; org . jacop . IntVar [ ] x = getIntVars ( store , \"x\" , xLength , xSize ) ; java . util . Arrays . stream ( x ) . forEach ( ( i ) -> store . impose ( new org . jacop . XgtC ( i , ( ( i . min ( ) ) + ( xSize / 2 ) ) ) ) ) ; store . impose ( new org . jacop . Alldiff ( x ) ) ; store . print ( ) ; int noOfSolutions = noOfAllSolutions ( store , x ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( noOfSolutions , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "testXgtCwithHelperSimpleConstraintsToAvoidNoConstraintBeingActiveSmall ( ) { org . jacop . Store store = new org . jacop . Store ( ) ; int xLength = 2 ; int xSize = ( xLength * 2 ) + 2 ; org . jacop . IntVar [ ] x = getIntVars ( store , \"x\" , xLength , xSize ) ; java . util . Arrays . stream ( x ) . forEach ( ( i ) -> store . impose ( new org . jacop . XgtC ( i , ( ( i . min ( ) ) + ( xSize / 2 ) ) ) ) ) ; store . impose ( new org . jacop . Alldiff ( x ) ) ; store . print ( ) ; int noOfSolutions = noOfAllSolutions ( store , x ) ; \"<AssertPlaceHolder>\" ; } noOfAllSolutions ( org . jacop . core . Store , org . jacop . core . IntVar [ ] [ ] ) { org . jacop . SelectChoicePoint < org . jacop . core . IntVar > select = new org . jacop . SimpleSelect < org . jacop . core . IntVar > ( java . util . Arrays . stream ( variables ) . map ( Arrays :: stream ) . flatMap ( ( i ) -> i ) . toArray ( org . jacop . core . IntVar [ ] :: new ) , new org . jacop . MostConstrainedStatic < org . jacop . core . IntVar > ( ) , new org . jacop . IndomainMin < org . jacop . core . IntVar > ( ) ) ; org . jacop . DepthFirstSearch search = new org . jacop . DepthFirstSearch < org . jacop . core . IntVar > ( ) ; search . getSolutionListener ( ) . searchAll ( true ) ; search . getSolutionListener ( ) . recordSolutions ( true ) ; search . setAssignSolution ( true ) ; boolean result = search . labeling ( store , select ) ; return search . getSolutionListener ( ) . solutionsNo ( ) ; }", "answer": "org . junit . Assert . assertThat ( noOfSolutions , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "UserIsNotAuthorized ( ) { java . util . Collection < com . stratelia . webactiv . node . model . NodePK > fathers = org . silverpeas . util . CollectionUtil . asList ( nodePk1 , nodePk2 ) ; org . silverpeas . core . contribution . publication . model . PublicationPK pk = new org . silverpeas . core . contribution . publication . model . PublicationPK ( \"50\" ) ; org . powermock . api . mockito . PowerMockito . mockStatic ( org . silverpeas . core . security . authorization . EJBUtilitaire . class ) ; org . silverpeas . core . contribution . publication . control . PublicationService publicationService = mock ( org . silverpeas . core . contribution . publication . control . PublicationService . class ) ; when ( publicationService . getAllFatherPK ( pk ) ) . thenReturn ( fathers ) ; org . silverpeas . importExport . versioning . Document document = new org . silverpeas . importExport . versioning . Document ( ) ; document . setForeignKey ( new org . silverpeas . util . ForeignPK ( pk ) ) ; org . silverpeas . core . security . authorization . NodeAccessController accessController = mock ( org . silverpeas . core . security . authorization . NodeAccessController . class ) ; org . silverpeas . core . security . authorization . DocumentAccessController instance = new org . silverpeas . core . security . authorization . DocumentAccessController ( accessController ) ; boolean result = instance . isUserAuthorized ( userId , document ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )", "total": "UserIsNotAuthorized ( ) { java . util . Collection < com . stratelia . webactiv . node . model . NodePK > fathers = org . silverpeas . util . CollectionUtil . asList ( nodePk1 , nodePk2 ) ; org . silverpeas . core . contribution . publication . model . PublicationPK pk = new org . silverpeas . core . contribution . publication . model . PublicationPK ( \"50\" ) ; org . powermock . api . mockito . PowerMockito . mockStatic ( org . silverpeas . core . security . authorization . EJBUtilitaire . class ) ; org . silverpeas . core . contribution . publication . control . PublicationService publicationService = mock ( org . silverpeas . core . contribution . publication . control . PublicationService . class ) ; when ( publicationService . getAllFatherPK ( pk ) ) . thenReturn ( fathers ) ; org . silverpeas . importExport . versioning . Document document = new org . silverpeas . importExport . versioning . Document ( ) ; document . setForeignKey ( new org . silverpeas . util . ForeignPK ( pk ) ) ; org . silverpeas . core . security . authorization . NodeAccessController accessController = mock ( org . silverpeas . core . security . authorization . NodeAccessController . class ) ; org . silverpeas . core . security . authorization . DocumentAccessController instance = new org . silverpeas . core . security . authorization . DocumentAccessController ( accessController ) ; boolean result = instance . isUserAuthorized ( userId , document ) ; \"<AssertPlaceHolder>\" ; } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testEquality ( ) { org . onosproject . net . intent . IntentId id1 = new org . onosproject . net . intent . IntentId ( 1L ) ; org . onosproject . net . intent . IntentId id2 = new org . onosproject . net . intent . IntentId ( 1L ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( id1 , org . hamcrest . Matchers . is ( id2 ) )", "total": "testEquality ( ) { org . onosproject . net . intent . IntentId id1 = new org . onosproject . net . intent . IntentId ( 1L ) ; org . onosproject . net . intent . IntentId id2 = new org . onosproject . net . intent . IntentId ( 1L ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( id1 , org . hamcrest . Matchers . is ( id2 ) )"}
{"focal": "is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "testMethod": "updateOfResourceByANonAuthorizedUser ( ) { denieAuthorizationToUsers ( ) ; try { putAt ( aResourceURI ( ) , aResource ( ) ) ; org . junit . Assert . fail ( \"An<sp>unauthorized<sp>user<sp>shouldn't<sp>update<sp>a<sp>resource\" ) ; } catch ( javax . ws . rs . WebApplicationException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int forbidden = Status . FORBIDDEN . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( forbidden ) )", "total": "updateOfResourceByANonAuthorizedUser ( ) { denieAuthorizationToUsers ( ) ; try { putAt ( aResourceURI ( ) , aResource ( ) ) ; org . junit . Assert . fail ( \"An<sp>unauthorized<sp>user<sp>shouldn't<sp>update<sp>a<sp>resource\" ) ; } catch ( javax . ws . rs . WebApplicationException ex ) { int receivedStatus = ex . getResponse ( ) . getStatus ( ) ; int forbidden = Status . FORBIDDEN . getStatusCode ( ) ; \"<AssertPlaceHolder>\" ; } } is ( T ) { return java . util . Objects . equals ( this . value , value ) ; }", "answer": "org . junit . Assert . assertThat ( receivedStatus , org . hamcrest . Matchers . is ( forbidden ) )"}
{"focal": "size ( ) { return fieldErrors . size ( ) ; }", "testMethod": "testShouldFindExistingMandatorySavingsAccountsForClientsWhenCenterIsTopOfCustomerHierarchy ( ) { savingsProduct = new org . mifos . domain . builders . SavingsProductBuilder ( ) . mandatory ( ) . appliesToClientsOnly ( ) . buildForIntegrationTests ( ) ; savingsAccount = new org . mifos . domain . builders . SavingsAccountBuilder ( ) . withSavingsProduct ( savingsProduct ) . withCustomer ( client ) . withCreatedBy ( org . mifos . framework . util . helpers . IntegrationTestObjectMother . testUser ( ) ) . build ( ) ; org . mifos . framework . util . helpers . IntegrationTestObjectMother . saveSavingsProductAndAssociatedSavingsAccounts ( savingsProduct , savingsAccount ) ; java . util . List < org . mifos . application . servicefacade . CollectionSheetCustomerSavingDto > mandatorySavingAccounts = savingsDao . findAllMandatorySavingAccountsForClientsOrGroupsWithCompleteGroupStatusForCustomerHierarchy ( customerHierarchyParams ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( mandatorySavingAccounts . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testShouldFindExistingMandatorySavingsAccountsForClientsWhenCenterIsTopOfCustomerHierarchy ( ) { savingsProduct = new org . mifos . domain . builders . SavingsProductBuilder ( ) . mandatory ( ) . appliesToClientsOnly ( ) . buildForIntegrationTests ( ) ; savingsAccount = new org . mifos . domain . builders . SavingsAccountBuilder ( ) . withSavingsProduct ( savingsProduct ) . withCustomer ( client ) . withCreatedBy ( org . mifos . framework . util . helpers . IntegrationTestObjectMother . testUser ( ) ) . build ( ) ; org . mifos . framework . util . helpers . IntegrationTestObjectMother . saveSavingsProductAndAssociatedSavingsAccounts ( savingsProduct , savingsAccount ) ; java . util . List < org . mifos . application . servicefacade . CollectionSheetCustomerSavingDto > mandatorySavingAccounts = savingsDao . findAllMandatorySavingAccountsForClientsOrGroupsWithCompleteGroupStatusForCustomerHierarchy ( customerHierarchyParams ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return fieldErrors . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( mandatorySavingAccounts . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter4 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"reset<sp>properties<sp>?\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter4 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"reset<sp>properties<sp>?\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "toString ( java . io . InputStream , int ) { final java . io . StringWriter sw = new java . io . StringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( input , sw , bufferSize ) ; return sw . toString ( ) ; }", "testMethod": "toStringByteArrayPosBufSz ( ) { java . lang . String probe = \"A<sp>string<sp>\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( org . apache . maven . shared . utils . io . IOUtil . toString ( probe . getBytes ( ) , 1 ) . getBytes ( ) , org . hamcrest . CoreMatchers . is ( probe . getBytes ( ) ) )", "total": "toStringByteArrayPosBufSz ( ) { java . lang . String probe = \"A<sp>string<sp>\" ; \"<AssertPlaceHolder>\" ; } toString ( java . io . InputStream , int ) { final java . io . StringWriter sw = new java . io . StringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( input , sw , bufferSize ) ; return sw . toString ( ) ; }", "answer": "org . junit . Assert . assertThat ( org . apache . maven . shared . utils . io . IOUtil . toString ( probe . getBytes ( ) , 1 ) . getBytes ( ) , org . hamcrest . CoreMatchers . is ( probe . getBytes ( ) ) )"}
{"focal": "with ( net . time4j . tz . TransitionStrategy ) { if ( ( ( this . id ) == null ) || ( ( this . getStrategy ( ) ) == strategy ) ) { return this ; } else if ( strategy == ( DEFAULT_CONFLICT_STRATEGY ) ) { return new net . time4j . tz . PlatformTimezone ( this . id , this . tz , false ) ; } else if ( strategy == ( STRICT_MODE ) ) { return new net . time4j . tz . PlatformTimezone ( this . id , this . tz , true ) ; } throw new java . lang . UnsupportedOperationException ( strategy . toString ( ) ) ; }", "testMethod": "flexibleStylePattern ( ) { net . time4j . PlainDate date = net . time4j . PlainDate . of ( 2016 , 12 , 18 ) ; net . time4j . format . expert . ChronoFormatter < net . time4j . PlainDate > chinese = net . time4j . format . expert . ChronoFormatter . ofDateStyle ( DisplayMode . LONG , Locale . CHINESE ) ; net . time4j . format . expert . ChronoFormatter < net . time4j . PlainDate > english = net . time4j . format . expert . ChronoFormatter . ofDateStyle ( DisplayMode . LONG , Locale . ENGLISH ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( chinese . with ( Locale . ENGLISH ) . format ( date ) , org . hamcrest . CoreMatchers . is ( english . format ( date ) ) )", "total": "flexibleStylePattern ( ) { net . time4j . PlainDate date = net . time4j . PlainDate . of ( 2016 , 12 , 18 ) ; net . time4j . format . expert . ChronoFormatter < net . time4j . PlainDate > chinese = net . time4j . format . expert . ChronoFormatter . ofDateStyle ( DisplayMode . LONG , Locale . CHINESE ) ; net . time4j . format . expert . ChronoFormatter < net . time4j . PlainDate > english = net . time4j . format . expert . ChronoFormatter . ofDateStyle ( DisplayMode . LONG , Locale . ENGLISH ) ; \"<AssertPlaceHolder>\" ; } with ( net . time4j . tz . TransitionStrategy ) { if ( ( ( this . id ) == null ) || ( ( this . getStrategy ( ) ) == strategy ) ) { return this ; } else if ( strategy == ( DEFAULT_CONFLICT_STRATEGY ) ) { return new net . time4j . tz . PlatformTimezone ( this . id , this . tz , false ) ; } else if ( strategy == ( STRICT_MODE ) ) { return new net . time4j . tz . PlatformTimezone ( this . id , this . tz , true ) ; } throw new java . lang . UnsupportedOperationException ( strategy . toString ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( chinese . with ( Locale . ENGLISH ) . format ( date ) , org . hamcrest . CoreMatchers . is ( english . format ( date ) ) )"}
{"focal": "forClass ( java . lang . Class ) { if ( testClass == null ) throw new java . lang . IllegalArgumentException ( \"TestClass<sp>must<sp>not<sp>be<sp>null!\" ) ; if ( ! ( de . bechte . junit . runners . model . TestClassPool . testClasses . containsKey ( testClass ) ) ) de . bechte . junit . runners . model . TestClassPool . testClasses . put ( testClass , new org . junit . runners . model . TestClass ( testClass ) ) ; return de . bechte . junit . runners . model . TestClassPool . testClasses . get ( testClass ) ; }", "testMethod": "whenForClassIsCalledWithAClassTwice_theSameTestClassObjectIsReturned ( ) { org . junit . runners . model . TestClass testClass1 = de . bechte . junit . runners . model . TestClassPool . forClass ( de . bechte . junit . runners . model . TestClassPoolTest . TEST_CLASS ) ; org . junit . runners . model . TestClass testClass2 = de . bechte . junit . runners . model . TestClassPool . forClass ( de . bechte . junit . runners . model . TestClassPoolTest . TEST_CLASS ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testClass1 , is ( equalTo ( testClass2 ) ) )", "total": "whenForClassIsCalledWithAClassTwice_theSameTestClassObjectIsReturned ( ) { org . junit . runners . model . TestClass testClass1 = de . bechte . junit . runners . model . TestClassPool . forClass ( de . bechte . junit . runners . model . TestClassPoolTest . TEST_CLASS ) ; org . junit . runners . model . TestClass testClass2 = de . bechte . junit . runners . model . TestClassPool . forClass ( de . bechte . junit . runners . model . TestClassPoolTest . TEST_CLASS ) ; \"<AssertPlaceHolder>\" ; } forClass ( java . lang . Class ) { if ( testClass == null ) throw new java . lang . IllegalArgumentException ( \"TestClass<sp>must<sp>not<sp>be<sp>null!\" ) ; if ( ! ( de . bechte . junit . runners . model . TestClassPool . testClasses . containsKey ( testClass ) ) ) de . bechte . junit . runners . model . TestClassPool . testClasses . put ( testClass , new org . junit . runners . model . TestClass ( testClass ) ) ; return de . bechte . junit . runners . model . TestClassPool . testClasses . get ( testClass ) ; }", "answer": "org . junit . Assert . assertThat ( testClass1 , is ( equalTo ( testClass2 ) ) )"}
{"focal": "hashCode ( ) { return value . hashCode ( ) ; }", "testMethod": "testHashCodeIsTheSameForDifferentLabels ( ) { org . eclipse . lyo . oslc4j . core . model . Link linkA = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_A ) ) ; org . eclipse . lyo . oslc4j . core . model . Link linkB = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_B ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( linkA . hashCode ( ) , org . hamcrest . CoreMatchers . equalTo ( linkB . hashCode ( ) ) )", "total": "testHashCodeIsTheSameForDifferentLabels ( ) { org . eclipse . lyo . oslc4j . core . model . Link linkA = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_A ) ) ; org . eclipse . lyo . oslc4j . core . model . Link linkB = new org . eclipse . lyo . oslc4j . core . model . Link ( java . net . URI . create ( org . eclipse . lyo . oslc4j . core . model . LinkTest . URI_A ) , new java . lang . String ( org . eclipse . lyo . oslc4j . core . model . LinkTest . LABEL_B ) ) ; \"<AssertPlaceHolder>\" ; } hashCode ( ) { return value . hashCode ( ) ; }", "answer": "org . junit . Assert . assertThat ( linkA . hashCode ( ) , org . hamcrest . CoreMatchers . equalTo ( linkB . hashCode ( ) ) )"}
{"focal": "delLink ( java . lang . String ) { java . lang . String path = java . lang . String . format ( org . o3project . odenos . core . component . NetworkInterface . LINK_PATH , linkId ) ; org . o3project . odenos . core . component . NetworkInterface . log . debug ( \">><sp>[networkId<sp>:<sp>'{}']\" , this . networkId ) ; return delObjectToNetwork ( this . networkId , path ) ; }", "testMethod": "testDelLinkIdErr ( ) { target = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . util . PathCalculator ( ) ) ; org . o3project . odenos . core . component . network . topology . Link link = new org . o3project . odenos . core . component . network . topology . Link ( ) { @ org . o3project . odenos . core . util . Override public java . lang . String getId ( ) { return null ; } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . delLink ( link ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testDelLinkIdErr ( ) { target = org . powermock . api . mockito . PowerMockito . spy ( new org . o3project . odenos . core . util . PathCalculator ( ) ) ; org . o3project . odenos . core . component . network . topology . Link link = new org . o3project . odenos . core . component . network . topology . Link ( ) { @ org . o3project . odenos . core . util . Override public java . lang . String getId ( ) { return null ; } } ; \"<AssertPlaceHolder>\" ; } delLink ( java . lang . String ) { java . lang . String path = java . lang . String . format ( org . o3project . odenos . core . component . NetworkInterface . LINK_PATH , linkId ) ; org . o3project . odenos . core . component . NetworkInterface . log . debug ( \">><sp>[networkId<sp>:<sp>'{}']\" , this . networkId ) ; return delObjectToNetwork ( this . networkId , path ) ; }", "answer": "org . junit . Assert . assertThat ( target . delLink ( link ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getClientName ( ) { return delegate . getClientName ( ) ; }", "testMethod": "getClientNameShouldEqualWithFactorySetting ( ) { org . springframework . data . redis . connection . lettuce . LettuceConnectionFactory factory = new org . springframework . data . redis . connection . lettuce . LettuceConnectionFactory ( new org . springframework . data . redis . connection . RedisStandaloneConfiguration ( ) ) ; factory . setClientResources ( org . springframework . data . redis . connection . lettuce . LettuceTestClientResources . getSharedClientResources ( ) ) ; factory . setClientName ( \"clientName\" ) ; factory . afterPropertiesSet ( ) ; org . springframework . data . redis . ConnectionFactoryTracker . add ( factory ) ; org . springframework . data . redis . connection . RedisConnection connection = factory . getConnection ( ) ; \"<AssertPlaceHolder>\" ; connection . close ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( connection . getClientName ( ) , equalTo ( \"clientName\" ) )", "total": "getClientNameShouldEqualWithFactorySetting ( ) { org . springframework . data . redis . connection . lettuce . LettuceConnectionFactory factory = new org . springframework . data . redis . connection . lettuce . LettuceConnectionFactory ( new org . springframework . data . redis . connection . RedisStandaloneConfiguration ( ) ) ; factory . setClientResources ( org . springframework . data . redis . connection . lettuce . LettuceTestClientResources . getSharedClientResources ( ) ) ; factory . setClientName ( \"clientName\" ) ; factory . afterPropertiesSet ( ) ; org . springframework . data . redis . ConnectionFactoryTracker . add ( factory ) ; org . springframework . data . redis . connection . RedisConnection connection = factory . getConnection ( ) ; \"<AssertPlaceHolder>\" ; connection . close ( ) ; } getClientName ( ) { return delegate . getClientName ( ) ; }", "answer": "org . junit . Assert . assertThat ( connection . getClientName ( ) , equalTo ( \"clientName\" ) )"}
{"focal": "size ( ) { return allNodes . size ( ) ; }", "testMethod": "testLargePool ( ) { int numConcurrentConsumers = 128 ; java . util . Set < com . facebook . buck . worker . WorkerProcess > createdWorkers = new java . util . HashSet ( ) ; com . facebook . buck . worker . WorkerProcessPool pool = com . facebook . buck . worker . WorkerProcessPoolTest . createPool ( ( numConcurrentConsumers * 2 ) , createdWorkers :: add ) ; com . facebook . buck . worker . WorkerProcessPoolTest . acquireWorkersThenRelease ( pool , numConcurrentConsumers ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( createdWorkers . size ( ) , org . hamcrest . Matchers . is ( numConcurrentConsumers ) )", "total": "testLargePool ( ) { int numConcurrentConsumers = 128 ; java . util . Set < com . facebook . buck . worker . WorkerProcess > createdWorkers = new java . util . HashSet ( ) ; com . facebook . buck . worker . WorkerProcessPool pool = com . facebook . buck . worker . WorkerProcessPoolTest . createPool ( ( numConcurrentConsumers * 2 ) , createdWorkers :: add ) ; com . facebook . buck . worker . WorkerProcessPoolTest . acquireWorkersThenRelease ( pool , numConcurrentConsumers ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return allNodes . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( createdWorkers . size ( ) , org . hamcrest . Matchers . is ( numConcurrentConsumers ) )"}
{"focal": "getTestUser ( ) { if ( ( testUser ) == null ) { testUser = userContext . getCurrentUser ( ) ; } return testUser ; }", "testMethod": "testReadyAgentCountOwnedAgentInactivy ( ) { java . lang . String currRegion = config . getRegion ( ) ; int oriCount = getAvailableAgentCountBy ( currRegion ) ; saveAgent ( \"nhn_owned_otherUser\" , AgentControllerState . INACTIVE ) ; saveAgent ( \"google_owned_admin\" , AgentControllerState . READY ) ; localAgentService . expireCache ( ) ; int newCount = agentManagerService . getReadyAgentCount ( getTestUser ( ) , \"nhn\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( newCount , org . hamcrest . Matchers . is ( ( oriCount + 0 ) ) )", "total": "testReadyAgentCountOwnedAgentInactivy ( ) { java . lang . String currRegion = config . getRegion ( ) ; int oriCount = getAvailableAgentCountBy ( currRegion ) ; saveAgent ( \"nhn_owned_otherUser\" , AgentControllerState . INACTIVE ) ; saveAgent ( \"google_owned_admin\" , AgentControllerState . READY ) ; localAgentService . expireCache ( ) ; int newCount = agentManagerService . getReadyAgentCount ( getTestUser ( ) , \"nhn\" ) ; \"<AssertPlaceHolder>\" ; } getTestUser ( ) { if ( ( testUser ) == null ) { testUser = userContext . getCurrentUser ( ) ; } return testUser ; }", "answer": "org . junit . Assert . assertThat ( newCount , org . hamcrest . Matchers . is ( ( oriCount + 0 ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testSetLocalCircuitId ( ) { isisNeighbor . setLocalCircuitId ( ( ( byte ) ( 1 ) ) ) ; result4 = isisNeighbor . localCircuitId ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result4 , org . hamcrest . CoreMatchers . is ( ( ( byte ) ( 1 ) ) ) )", "total": "testSetLocalCircuitId ( ) { isisNeighbor . setLocalCircuitId ( ( ( byte ) ( 1 ) ) ) ; result4 = isisNeighbor . localCircuitId ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result4 , org . hamcrest . CoreMatchers . is ( ( ( byte ) ( 1 ) ) ) )"}
{"focal": "toBuilder ( ) { return new org . batfish . question . SearchFiltersParameters . Builder ( ) . setDestinationIpSpaceSpecifier ( _destinationIpSpaceSpecifier ) . setHeaderSpace ( _headerSpace ) . setStartLocationSpecifier ( _startLocationSpecifier ) . setSourceIpSpaceSpecifier ( _sourceIpSpaceSpecifier ) ; }", "testMethod": "testToBuilder ( ) { org . batfish . dataplane . rib . RouteAdvertisement < org . batfish . datamodel . StaticRoute > ra = org . batfish . dataplane . rib . RouteAdvertisement . < org . batfish . datamodel . StaticRoute > builder ( ) . setRoute ( org . batfish . datamodel . StaticRoute . builder ( ) . setAdministrativeCost ( 1 ) . setNetwork ( org . batfish . datamodel . Prefix . parse ( \"1.1.1.0/24\" ) ) . setNextHopIp ( org . batfish . datamodel . Ip . parse ( \"2.2.2.2\" ) ) . build ( ) ) . setReason ( Reason . WITHDRAW ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ra . toBuilder ( ) . build ( ) , org . hamcrest . Matchers . equalTo ( ra ) )", "total": "testToBuilder ( ) { org . batfish . dataplane . rib . RouteAdvertisement < org . batfish . datamodel . StaticRoute > ra = org . batfish . dataplane . rib . RouteAdvertisement . < org . batfish . datamodel . StaticRoute > builder ( ) . setRoute ( org . batfish . datamodel . StaticRoute . builder ( ) . setAdministrativeCost ( 1 ) . setNetwork ( org . batfish . datamodel . Prefix . parse ( \"1.1.1.0/24\" ) ) . setNextHopIp ( org . batfish . datamodel . Ip . parse ( \"2.2.2.2\" ) ) . build ( ) ) . setReason ( Reason . WITHDRAW ) . build ( ) ; \"<AssertPlaceHolder>\" ; } toBuilder ( ) { return new org . batfish . question . SearchFiltersParameters . Builder ( ) . setDestinationIpSpaceSpecifier ( _destinationIpSpaceSpecifier ) . setHeaderSpace ( _headerSpace ) . setStartLocationSpecifier ( _startLocationSpecifier ) . setSourceIpSpaceSpecifier ( _sourceIpSpaceSpecifier ) ; }", "answer": "org . junit . Assert . assertThat ( ra . toBuilder ( ) . build ( ) , org . hamcrest . Matchers . equalTo ( ra ) )"}
{"focal": "format ( com . github . mygreen . supercsv . localization . MessageResolver , com . github . mygreen . supercsv . localization . MessageInterpolator ) { for ( java . lang . String code : getCodes ( ) ) { java . util . Optional < java . lang . String > message = messageResolver . getMessage ( code ) ; if ( message . isPresent ( ) ) { return messageInterpolator . interpolate ( message . get ( ) , getVariables ( ) , true , messageResolver ) ; } } return messageInterpolator . interpolate ( getDefaultMessage ( ) , getVariables ( ) , true , messageResolver ) ; }", "testMethod": "testValidate_relation ( ) { java . lang . Class < ? > [ ] groups = new java . lang . Class [ ] { com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . Group2 . class } ; com . github . mygreen . supercsv . validation . CsvBindingErrors bindingErrors = new com . github . mygreen . supercsv . validation . CsvBindingErrors ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class ) ; com . github . mygreen . supercsv . builder . BeanMapping < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > beanMapping = beanMappingFactory . create ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class , groupEmpty ) ; com . github . mygreen . supercsv . validation . ValidationContext < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > validationContext = new com . github . mygreen . supercsv . validation . ValidationContext ( ANONYMOUS_CSVCONTEXT , beanMapping ) ; com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv record = new com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv ( ) ; record . id = \"a01\" ; record . name = \"test\" ; csvValidator . validate ( record , bindingErrors , ( ( com . github . mygreen . supercsv . validation . ValidationContext ) ( validationContext ) ) , groups ) ; java . util . List < java . lang . String > messages = bindingErrors . getAllErrors ( ) . stream ( ) . map ( ( error ) -> error . format ( testMessageResolver , messageInterpolator ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" . hasSize ( 1 ) . contains ( \"\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( messages )", "total": "testValidate_relation ( ) { java . lang . Class < ? > [ ] groups = new java . lang . Class [ ] { com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . Group2 . class } ; com . github . mygreen . supercsv . validation . CsvBindingErrors bindingErrors = new com . github . mygreen . supercsv . validation . CsvBindingErrors ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class ) ; com . github . mygreen . supercsv . builder . BeanMapping < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > beanMapping = beanMappingFactory . create ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class , groupEmpty ) ; com . github . mygreen . supercsv . validation . ValidationContext < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > validationContext = new com . github . mygreen . supercsv . validation . ValidationContext ( ANONYMOUS_CSVCONTEXT , beanMapping ) ; com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv record = new com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv ( ) ; record . id = \"a01\" ; record . name = \"test\" ; csvValidator . validate ( record , bindingErrors , ( ( com . github . mygreen . supercsv . validation . ValidationContext ) ( validationContext ) ) , groups ) ; java . util . List < java . lang . String > messages = bindingErrors . getAllErrors ( ) . stream ( ) . map ( ( error ) -> error . format ( testMessageResolver , messageInterpolator ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" . hasSize ( 1 ) . contains ( \"\" ) ; } format ( com . github . mygreen . supercsv . localization . MessageResolver , com . github . mygreen . supercsv . localization . MessageInterpolator ) { for ( java . lang . String code : getCodes ( ) ) { java . util . Optional < java . lang . String > message = messageResolver . getMessage ( code ) ; if ( message . isPresent ( ) ) { return messageInterpolator . interpolate ( message . get ( ) , getVariables ( ) , true , messageResolver ) ; } } return messageInterpolator . interpolate ( getDefaultMessage ( ) , getVariables ( ) , true , messageResolver ) ; }", "answer": "org . junit . Assert . assertThat ( messages )"}
{"focal": "getMeasurand ( ) { return measurand ; }", "testMethod": "setMeasurand_energyReactiveImportInterval_measurandIsSet ( ) { java . lang . String measurand = \"Energy.Reactive.Import.Interval\" ; sampledValue . setMeasurand ( measurand ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sampledValue . getMeasurand ( ) , org . hamcrest . CoreMatchers . equalTo ( measurand ) )", "total": "setMeasurand_energyReactiveImportInterval_measurandIsSet ( ) { java . lang . String measurand = \"Energy.Reactive.Import.Interval\" ; sampledValue . setMeasurand ( measurand ) ; \"<AssertPlaceHolder>\" ; } getMeasurand ( ) { return measurand ; }", "answer": "org . junit . Assert . assertThat ( sampledValue . getMeasurand ( ) , org . hamcrest . CoreMatchers . equalTo ( measurand ) )"}
{"focal": "getCommonAncestor ( org . modeshape . jcr . value . Path ) { org . modeshape . common . util . CheckArg . isNotNull ( that , \"that\" ) ; if ( that . isRoot ( ) ) return that ; org . modeshape . jcr . value . Path normalizedPath = this . getNormalizedPath ( ) ; int lastIndex = 0 ; java . util . Iterator < org . modeshape . jcr . value . basic . Segment > thisIter = normalizedPath . iterator ( ) ; java . util . Iterator < org . modeshape . jcr . value . basic . Segment > thatIter = that . getNormalizedPath ( ) . iterator ( ) ; while ( ( thisIter . hasNext ( ) ) && ( thatIter . hasNext ( ) ) ) { org . modeshape . jcr . value . basic . Segment thisSeg = thisIter . next ( ) ; org . modeshape . jcr . value . basic . Segment thatSeg = thatIter . next ( ) ; if ( thisSeg . equals ( thatSeg ) ) { ++ lastIndex ; } else { break ; } } if ( lastIndex == 0 ) return RootPath . INSTANCE ; return normalizedPath . subpath ( 0 , lastIndex ) ; }", "testMethod": "shouldConsiderRootTheLowestCommonAncestorOfAnyNodesOnSeparateBrances ( ) { org . modeshape . jcr . value . Path path1 = pathFactory . create ( \"/x/y/z\" ) ; org . modeshape . jcr . value . Path path2 = pathFactory . create ( \"/a/b/c\" ) ; org . modeshape . jcr . value . Path common = org . modeshape . jcr . value . basic . BasicPathOldTest . ROOT ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( path1 . getCommonAncestor ( path2 ) , org . hamcrest . core . Is . is ( common ) )", "total": "shouldConsiderRootTheLowestCommonAncestorOfAnyNodesOnSeparateBrances ( ) { org . modeshape . jcr . value . Path path1 = pathFactory . create ( \"/x/y/z\" ) ; org . modeshape . jcr . value . Path path2 = pathFactory . create ( \"/a/b/c\" ) ; org . modeshape . jcr . value . Path common = org . modeshape . jcr . value . basic . BasicPathOldTest . ROOT ; \"<AssertPlaceHolder>\" ; } getCommonAncestor ( org . modeshape . jcr . value . Path ) { org . modeshape . common . util . CheckArg . isNotNull ( that , \"that\" ) ; if ( that . isRoot ( ) ) return that ; org . modeshape . jcr . value . Path normalizedPath = this . getNormalizedPath ( ) ; int lastIndex = 0 ; java . util . Iterator < org . modeshape . jcr . value . basic . Segment > thisIter = normalizedPath . iterator ( ) ; java . util . Iterator < org . modeshape . jcr . value . basic . Segment > thatIter = that . getNormalizedPath ( ) . iterator ( ) ; while ( ( thisIter . hasNext ( ) ) && ( thatIter . hasNext ( ) ) ) { org . modeshape . jcr . value . basic . Segment thisSeg = thisIter . next ( ) ; org . modeshape . jcr . value . basic . Segment thatSeg = thatIter . next ( ) ; if ( thisSeg . equals ( thatSeg ) ) { ++ lastIndex ; } else { break ; } } if ( lastIndex == 0 ) return RootPath . INSTANCE ; return normalizedPath . subpath ( 0 , lastIndex ) ; }", "answer": "org . junit . Assert . assertThat ( path1 . getCommonAncestor ( path2 ) , org . hamcrest . core . Is . is ( common ) )"}
{"focal": "isAuditViewEntryRelevant ( ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry , ch . puzzle . itc . mobiliar . business . auditview . control . Map ) { if ( entry == null ) { return false ; } if ( ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . ADD ) ) || ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . DEL ) ) ) { return true ; } if ( ( allAuditViewEntries . get ( entry . hashCode ( ) ) ) != null ) { return false ; } if ( entry . getType ( ) . equals ( Auditable . TYPE_TEMPLATE_DESCRIPTOR ) ) { return true ; } if ( entry . isObfuscatedValue ( ) ) { return true ; } return ! ( org . apache . commons . lang . StringUtils . equals ( entry . getOldValue ( ) , entry . getValue ( ) ) ) ; }", "testMethod": "shouldReturnTrueIfTypeIsTemplateDescriptor_valuesEqual ( ) { java . lang . String value = EMPTY ; ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity revisionEntity = new ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity ( ) ; ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry entryInList = ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry . builder ( revisionEntity , RevisionType . MOD ) . oldValue ( value ) . value ( value ) . type ( Auditable . TYPE_TEMPLATE_DESCRIPTOR ) . build ( ) ; java . util . Map < java . lang . Integer , ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry > allAuditViewEntries = new java . util . HashMap ( 1 ) ; boolean relevant = auditService . isAuditViewEntryRelevant ( entryInList , allAuditViewEntries ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( relevant , org . hamcrest . Matchers . is ( true ) )", "total": "shouldReturnTrueIfTypeIsTemplateDescriptor_valuesEqual ( ) { java . lang . String value = EMPTY ; ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity revisionEntity = new ch . puzzle . itc . mobiliar . business . database . entity . MyRevisionEntity ( ) ; ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry entryInList = ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry . builder ( revisionEntity , RevisionType . MOD ) . oldValue ( value ) . value ( value ) . type ( Auditable . TYPE_TEMPLATE_DESCRIPTOR ) . build ( ) ; java . util . Map < java . lang . Integer , ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry > allAuditViewEntries = new java . util . HashMap ( 1 ) ; boolean relevant = auditService . isAuditViewEntryRelevant ( entryInList , allAuditViewEntries ) ; \"<AssertPlaceHolder>\" ; } isAuditViewEntryRelevant ( ch . puzzle . itc . mobiliar . business . auditview . entity . AuditViewEntry , ch . puzzle . itc . mobiliar . business . auditview . control . Map ) { if ( entry == null ) { return false ; } if ( ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . ADD ) ) || ( ( entry . getMode ( ) ) == ( org . hibernate . envers . RevisionType . DEL ) ) ) { return true ; } if ( ( allAuditViewEntries . get ( entry . hashCode ( ) ) ) != null ) { return false ; } if ( entry . getType ( ) . equals ( Auditable . TYPE_TEMPLATE_DESCRIPTOR ) ) { return true ; } if ( entry . isObfuscatedValue ( ) ) { return true ; } return ! ( org . apache . commons . lang . StringUtils . equals ( entry . getOldValue ( ) , entry . getValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( relevant , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "_1 ( ) { return _1 ; }", "testMethod": "_1_A$ ( ) { java . lang . String _1 = \"foo\" ; java . lang . Integer _2 = 123 ; com . m3 . scalaflavor4j . Tuple2 < java . lang . String , java . lang . Integer > target = com . m3 . scalaflavor4j . Tuple2 . apply ( _1 , _2 ) ; java . lang . String actual = target . _1 ( ) ; java . lang . String expected = \"foo\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "_1_A$ ( ) { java . lang . String _1 = \"foo\" ; java . lang . Integer _2 = 123 ; com . m3 . scalaflavor4j . Tuple2 < java . lang . String , java . lang . Integer > target = com . m3 . scalaflavor4j . Tuple2 . apply ( _1 , _2 ) ; java . lang . String actual = target . _1 ( ) ; java . lang . String expected = \"foo\" ; \"<AssertPlaceHolder>\" ; } _1 ( ) { return _1 ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "contains ( java . lang . Integer ) { return hashToString . containsKey ( stringId ) ; }", "testMethod": "testCanGetPartitions ( ) { org . apache . kafka . clients . consumer . KafkaConsumer < java . lang . String , java . lang . String > mockConsumer = mock ( org . apache . kafka . clients . consumer . KafkaConsumer . class ) ; org . apache . kafka . common . TopicPartition expectedPartition = new org . apache . kafka . common . TopicPartition ( \"test\" , 0 ) ; org . apache . storm . kafka . spout . subscription . TopicFilter mockFilter = mock ( org . apache . storm . kafka . spout . subscription . TopicFilter . class ) ; when ( mockFilter . getAllSubscribedPartitions ( any ( ) ) ) . thenReturn ( java . util . Collections . singleton ( expectedPartition ) ) ; org . apache . storm . kafka . spout . trident . KafkaTridentSpoutConfig < java . lang . String , java . lang . String > spoutConfig = org . apache . storm . kafka . spout . trident . config . builder . SingleTopicKafkaTridentSpoutConfiguration . createKafkaSpoutConfigBuilder ( mockFilter , mock ( org . apache . storm . kafka . spout . subscription . ManualPartitioner . class ) , ( - 1 ) ) . build ( ) ; org . apache . storm . kafka . spout . trident . KafkaTridentSpoutCoordinator < java . lang . String , java . lang . String > coordinator = new org . apache . storm . kafka . spout . trident . KafkaTridentSpoutCoordinator ( spoutConfig , ( ignored ) -> mockConsumer ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > partitionsForBatch = coordinator . getPartitionsForBatch ( ) ; java . util . List < org . apache . kafka . common . TopicPartition > tps = deserializePartitions ( partitionsForBatch ) ; verify ( mockFilter ) . getAllSubscribedPartitions ( mockConsumer ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tps , org . hamcrest . Matchers . contains ( expectedPartition ) )", "total": "testCanGetPartitions ( ) { org . apache . kafka . clients . consumer . KafkaConsumer < java . lang . String , java . lang . String > mockConsumer = mock ( org . apache . kafka . clients . consumer . KafkaConsumer . class ) ; org . apache . kafka . common . TopicPartition expectedPartition = new org . apache . kafka . common . TopicPartition ( \"test\" , 0 ) ; org . apache . storm . kafka . spout . subscription . TopicFilter mockFilter = mock ( org . apache . storm . kafka . spout . subscription . TopicFilter . class ) ; when ( mockFilter . getAllSubscribedPartitions ( any ( ) ) ) . thenReturn ( java . util . Collections . singleton ( expectedPartition ) ) ; org . apache . storm . kafka . spout . trident . KafkaTridentSpoutConfig < java . lang . String , java . lang . String > spoutConfig = org . apache . storm . kafka . spout . trident . config . builder . SingleTopicKafkaTridentSpoutConfiguration . createKafkaSpoutConfigBuilder ( mockFilter , mock ( org . apache . storm . kafka . spout . subscription . ManualPartitioner . class ) , ( - 1 ) ) . build ( ) ; org . apache . storm . kafka . spout . trident . KafkaTridentSpoutCoordinator < java . lang . String , java . lang . String > coordinator = new org . apache . storm . kafka . spout . trident . KafkaTridentSpoutCoordinator ( spoutConfig , ( ignored ) -> mockConsumer ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > partitionsForBatch = coordinator . getPartitionsForBatch ( ) ; java . util . List < org . apache . kafka . common . TopicPartition > tps = deserializePartitions ( partitionsForBatch ) ; verify ( mockFilter ) . getAllSubscribedPartitions ( mockConsumer ) ; \"<AssertPlaceHolder>\" ; } contains ( java . lang . Integer ) { return hashToString . containsKey ( stringId ) ; }", "answer": "org . junit . Assert . assertThat ( tps , org . hamcrest . Matchers . contains ( expectedPartition ) )"}
{"focal": "getTargetSize ( ) { return allocator . getTargetSize ( ) ; }", "testMethod": "settingTargetSizeOnPoolThatHasBeenShutDownDoesNothing ( ) { config . setSize ( 3 ) ; createPool ( ) ; pool . shutdown ( ) ; pool . setTargetSize ( 10 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pool . getTargetSize ( ) , is ( 3 ) )", "total": "settingTargetSizeOnPoolThatHasBeenShutDownDoesNothing ( ) { config . setSize ( 3 ) ; createPool ( ) ; pool . shutdown ( ) ; pool . setTargetSize ( 10 ) ; \"<AssertPlaceHolder>\" ; } getTargetSize ( ) { return allocator . getTargetSize ( ) ; }", "answer": "org . junit . Assert . assertThat ( pool . getTargetSize ( ) , is ( 3 ) )"}
{"focal": "getUpdateCount ( ) { return 0 ; }", "testMethod": "assertGetUpdateCountNoData ( ) { java . lang . String sql = \"DELETE<sp>FROM<sp>t_order<sp>WHERE<sp>status<sp>=<sp>'none'\" ; for ( java . util . Map . Entry < org . apache . shardingsphere . core . constant . DatabaseType , java . sql . Statement > each : statements . entrySet ( ) ) { each . getValue ( ) . execute ( sql ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( each . getValue ( ) . getUpdateCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "assertGetUpdateCountNoData ( ) { java . lang . String sql = \"DELETE<sp>FROM<sp>t_order<sp>WHERE<sp>status<sp>=<sp>'none'\" ; for ( java . util . Map . Entry < org . apache . shardingsphere . core . constant . DatabaseType , java . sql . Statement > each : statements . entrySet ( ) ) { each . getValue ( ) . execute ( sql ) ; \"<AssertPlaceHolder>\" ; } } getUpdateCount ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( each . getValue ( ) . getUpdateCount ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "endRun ( hudson . matrix . MatrixRun ) { if ( ! ( org . jenkinsci . plugins . postbuildscript . MatrixPostBuildScript . class . isAssignableFrom ( initiator ) ) ) { logger . warn ( org . jenkinsci . plugins . postbuildscript . Messages . PostBuildScript_DeprecatedUsageOfMatrixOptions ( ) ) ; } logger . debug ( \"endRun:<sp>{}\" , run ) ; listener . getLogger ( ) . println ( ) ; return super . endRun ( run ) ; }", "testMethod": "addsNewLineToLoggerAfterRun ( ) { givenAggregator ( ) ; boolean canContinue = aggregator . endRun ( run ) ; \"<AssertPlaceHolder>\" ; verify ( logger ) . println ( ) ; verifyNoMoreInteractions ( run ) ; }", "assertLine": "org . junit . Assert . assertThat ( canContinue , org . hamcrest . CoreMatchers . is ( true ) )", "total": "addsNewLineToLoggerAfterRun ( ) { givenAggregator ( ) ; boolean canContinue = aggregator . endRun ( run ) ; \"<AssertPlaceHolder>\" ; verify ( logger ) . println ( ) ; verifyNoMoreInteractions ( run ) ; } endRun ( hudson . matrix . MatrixRun ) { if ( ! ( org . jenkinsci . plugins . postbuildscript . MatrixPostBuildScript . class . isAssignableFrom ( initiator ) ) ) { logger . warn ( org . jenkinsci . plugins . postbuildscript . Messages . PostBuildScript_DeprecatedUsageOfMatrixOptions ( ) ) ; } logger . debug ( \"endRun:<sp>{}\" , run ) ; listener . getLogger ( ) . println ( ) ; return super . endRun ( run ) ; }", "answer": "org . junit . Assert . assertThat ( canContinue , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "encode ( long [ ] , long [ ] ) { boolean modified = left . encode ( current , next ) ; return ( right . encode ( current , next ) ) || modified ; }", "testMethod": "testNConnectedAtoms ( ) { org . openscience . cdk . interfaces . IAtom atom = mock ( org . openscience . cdk . interfaces . IAtom . class ) ; org . openscience . cdk . interfaces . IAtomContainer container = mock ( org . openscience . cdk . interfaces . IAtomContainer . class ) ; org . openscience . cdk . hash . AtomEncoder encoder = org . openscience . cdk . hash . BasicAtomEncoder . N_CONNECTED_ATOMS ; when ( container . getConnectedBondsCount ( atom ) ) . thenReturn ( 2 ) ; \"<AssertPlaceHolder>\" ; verify ( container , times ( 1 ) ) . getConnectedBondsCount ( atom ) ; verifyNoMoreInteractions ( atom , container ) ; }", "assertLine": "org . junit . Assert . assertThat ( encoder . encode ( atom , container ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "testNConnectedAtoms ( ) { org . openscience . cdk . interfaces . IAtom atom = mock ( org . openscience . cdk . interfaces . IAtom . class ) ; org . openscience . cdk . interfaces . IAtomContainer container = mock ( org . openscience . cdk . interfaces . IAtomContainer . class ) ; org . openscience . cdk . hash . AtomEncoder encoder = org . openscience . cdk . hash . BasicAtomEncoder . N_CONNECTED_ATOMS ; when ( container . getConnectedBondsCount ( atom ) ) . thenReturn ( 2 ) ; \"<AssertPlaceHolder>\" ; verify ( container , times ( 1 ) ) . getConnectedBondsCount ( atom ) ; verifyNoMoreInteractions ( atom , container ) ; } encode ( long [ ] , long [ ] ) { boolean modified = left . encode ( current , next ) ; return ( right . encode ( current , next ) ) || modified ; }", "answer": "org . junit . Assert . assertThat ( encoder . encode ( atom , container ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "restore ( boolean , java . nio . file . PathMatcher ) { org . apache . commons . lang . Validate . notNull ( filter , \"invalid<sp>null<sp>path<sp>filter\" ) ; if ( ( restored ) == null ) { this . restored = false ; if ( filter . matches ( path ) ) { this . restored = handleRestore ( required , filter ) ; } else { this . restored = handleRestoreWhenFilterNotMatching ( required ) ; } } return restored ; }", "testMethod": "restoreWithFilterSuccessfullyWithMatchingChecksumWhenNotMatching ( ) { \"<AssertPlaceHolder>\" ; verify ( mockPathUtils , never ( ) ) . getChecksumFor ( any ( java . nio . file . Path . class ) ) ; verifyReportHasMatchingError ( report , \"does<sp>not<sp>match<sp>filter\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( entry . restore ( true , ( p ) -> false ) , org . hamcrest . CoreMatchers . equalTo ( false ) )", "total": "restoreWithFilterSuccessfullyWithMatchingChecksumWhenNotMatching ( ) { \"<AssertPlaceHolder>\" ; verify ( mockPathUtils , never ( ) ) . getChecksumFor ( any ( java . nio . file . Path . class ) ) ; verifyReportHasMatchingError ( report , \"does<sp>not<sp>match<sp>filter\" ) ; } restore ( boolean , java . nio . file . PathMatcher ) { org . apache . commons . lang . Validate . notNull ( filter , \"invalid<sp>null<sp>path<sp>filter\" ) ; if ( ( restored ) == null ) { this . restored = false ; if ( filter . matches ( path ) ) { this . restored = handleRestore ( required , filter ) ; } else { this . restored = handleRestoreWhenFilterNotMatching ( required ) ; } } return restored ; }", "answer": "org . junit . Assert . assertThat ( entry . restore ( true , ( p ) -> false ) , org . hamcrest . CoreMatchers . equalTo ( false ) )"}
{"focal": "getName ( ) { return name ; }", "testMethod": "testBeanConversion ( ) { org . piraso . api . converter . ObjectConverterRegistry . register ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean . class , new org . piraso . api . converter . TypeConverter < org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean > ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean . class ) ) ; org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean expected = new org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean ( \"sample\" ) ; java . lang . String convertedValue = org . piraso . api . converter . ObjectConverterRegistry . convertToString ( expected ) ; org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean actual = ( ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean ) ( org . piraso . api . converter . ObjectConverterRegistry . convertToObject ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean . class . getName ( ) , convertedValue ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testBeanConversion ( ) { org . piraso . api . converter . ObjectConverterRegistry . register ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean . class , new org . piraso . api . converter . TypeConverter < org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean > ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean . class ) ) ; org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean expected = new org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean ( \"sample\" ) ; java . lang . String convertedValue = org . piraso . api . converter . ObjectConverterRegistry . convertToString ( expected ) ; org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean actual = ( ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean ) ( org . piraso . api . converter . ObjectConverterRegistry . convertToObject ( org . piraso . api . converter . ObjectConverterRegistryTest . SampleBean . class . getName ( ) , convertedValue ) ) ) ; \"<AssertPlaceHolder>\" ; } getName ( ) { return name ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "first ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final com . arangodb . velocypack . VPackSlice first = cursor . first ( ) ; org . junit . Assert . assertThat ( first , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . not ( org . hamcrest . Matchers . nullValue ( ) ) ) ) ; org . junit . Assert . assertThat ( first . isInteger ( ) , org . hamcrest . Matchers . is ( true ) ) ; org . junit . Assert . assertThat ( first . getAsLong ( ) , org . hamcrest . Matchers . is ( 0L ) ) ; }", "testMethod": "mapFilterFirst ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final long count = cursor . map ( new com . arangodb . Function < com . arangodb . velocypack . VPackSlice , java . lang . Long > ( ) { @ com . arangodb . Override public com . arangodb . Long apply ( final com . arangodb . velocypack . VPackSlice t ) { return t . getAsLong ( ) ; } } ) . filter ( new com . arangodb . Predicate < java . lang . Long > ( ) { @ com . arangodb . Override public boolean test ( final java . lang . Long t ) { return t < 50 ; } } ) . first ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , org . hamcrest . Matchers . is ( 0L ) )", "total": "mapFilterFirst ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final long count = cursor . map ( new com . arangodb . Function < com . arangodb . velocypack . VPackSlice , java . lang . Long > ( ) { @ com . arangodb . Override public com . arangodb . Long apply ( final com . arangodb . velocypack . VPackSlice t ) { return t . getAsLong ( ) ; } } ) . filter ( new com . arangodb . Predicate < java . lang . Long > ( ) { @ com . arangodb . Override public boolean test ( final java . lang . Long t ) { return t < 50 ; } } ) . first ( ) ; \"<AssertPlaceHolder>\" ; } first ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final com . arangodb . velocypack . VPackSlice first = cursor . first ( ) ; org . junit . Assert . assertThat ( first , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . not ( org . hamcrest . Matchers . nullValue ( ) ) ) ) ; org . junit . Assert . assertThat ( first . isInteger ( ) , org . hamcrest . Matchers . is ( true ) ) ; org . junit . Assert . assertThat ( first . getAsLong ( ) , org . hamcrest . Matchers . is ( 0L ) ) ; }", "answer": "org . junit . Assert . assertThat ( count , org . hamcrest . Matchers . is ( 0L ) )"}
{"focal": "apply ( java . io . OutputStream ) { if ( ( writers ) == null ) { throw new java . lang . IllegalStateException ( \"Closed\" ) ; } long total = 0 ; for ( com . github . horrorho . liquiddonkey . cloud . store . DataWriter writer : writers ) { total += writer . apply ( outputStream ) ; } return total ; }", "testMethod": "testFromArgs ( java . lang . String , java . util . function . Function , T ) { java . lang . String [ ] args = in . split ( \"\\\\s\" ) ; com . github . horrorho . liquiddonkey . settings . config . Config config = com . github . horrorho . liquiddonkey . settings . commandline . CommandLineConfigFactory . getInstance ( ) . fromArgs ( args ) ; T value = function . apply ( config ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "testFromArgs ( java . lang . String , java . util . function . Function , T ) { java . lang . String [ ] args = in . split ( \"\\\\s\" ) ; com . github . horrorho . liquiddonkey . settings . config . Config config = com . github . horrorho . liquiddonkey . settings . commandline . CommandLineConfigFactory . getInstance ( ) . fromArgs ( args ) ; T value = function . apply ( config ) ; \"<AssertPlaceHolder>\" ; } apply ( java . io . OutputStream ) { if ( ( writers ) == null ) { throw new java . lang . IllegalStateException ( \"Closed\" ) ; } long total = 0 ; for ( com . github . horrorho . liquiddonkey . cloud . store . DataWriter writer : writers ) { total += writer . apply ( outputStream ) ; } return total ; }", "answer": "org . junit . Assert . assertThat ( value , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "promoteUrl ( ) { final java . lang . String url = new org . commonjava . indy . client . core . Indy ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE , new org . commonjava . indy . promote . client . IndyPromoteClientModule ( ) ) . module ( org . commonjava . indy . promote . client . IndyPromoteClientModule . class ) . promoteUrl ( ) ; org . junit . Assert . assertThat ( url , org . hamcrest . CoreMatchers . equalTo ( ( ( ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE ) + \"/\" ) + ( IndyPromoteClientModule . PATHS_PROMOTE_PATH ) ) ) ) ; }", "testMethod": "promoteUrl ( ) { final java . lang . String url = new org . commonjava . indy . client . core . Indy ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE , new org . commonjava . indy . promote . client . IndyPromoteClientModule ( ) ) . module ( org . commonjava . indy . promote . client . IndyPromoteClientModule . class ) . promoteUrl ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( url , org . hamcrest . CoreMatchers . equalTo ( ( ( ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE ) + \"/\" ) + ( IndyPromoteClientModule . PATHS_PROMOTE_PATH ) ) ) )", "total": "promoteUrl ( ) { final java . lang . String url = new org . commonjava . indy . client . core . Indy ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE , new org . commonjava . indy . promote . client . IndyPromoteClientModule ( ) ) . module ( org . commonjava . indy . promote . client . IndyPromoteClientModule . class ) . promoteUrl ( ) ; \"<AssertPlaceHolder>\" ; } promoteUrl ( ) { final java . lang . String url = new org . commonjava . indy . client . core . Indy ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE , new org . commonjava . indy . promote . client . IndyPromoteClientModule ( ) ) . module ( org . commonjava . indy . promote . client . IndyPromoteClientModule . class ) . promoteUrl ( ) ; org . junit . Assert . assertThat ( url , org . hamcrest . CoreMatchers . equalTo ( ( ( ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE ) + \"/\" ) + ( IndyPromoteClientModule . PATHS_PROMOTE_PATH ) ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( url , org . hamcrest . CoreMatchers . equalTo ( ( ( ( org . commonjava . indy . promote . client . IndyPromoteClientModuleUrlsTest . BASE ) + \"/\" ) + ( IndyPromoteClientModule . PATHS_PROMOTE_PATH ) ) ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testIsErrorIsInternal ( ) { reachability . setErrorIsInternal ( true ) ; result1 = reachability . isErrorIsInternal ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testIsErrorIsInternal ( ) { reachability . setErrorIsInternal ( true ) ; result1 = reachability . isErrorIsInternal ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( result1 , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getpid ( ) { return handler . getPID ( ) ; }", "testMethod": "testGetPid ( ) { int pid_from_jmx = java . lang . Integer . parseInt ( java . lang . management . ManagementFactory . getRuntimeMXBean ( ) . getName ( ) . split ( \"@\" ) [ 0 ] ) ; jnr . posix . POSIX posix = jnr . posix . POSIXFactory . getPOSIX ( new jnr . posix . util . DefaultPOSIXHandler ( ) , true ) ; int pid = posix . getpid ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pid , org . hamcrest . CoreMatchers . equalTo ( pid_from_jmx ) )", "total": "testGetPid ( ) { int pid_from_jmx = java . lang . Integer . parseInt ( java . lang . management . ManagementFactory . getRuntimeMXBean ( ) . getName ( ) . split ( \"@\" ) [ 0 ] ) ; jnr . posix . POSIX posix = jnr . posix . POSIXFactory . getPOSIX ( new jnr . posix . util . DefaultPOSIXHandler ( ) , true ) ; int pid = posix . getpid ( ) ; \"<AssertPlaceHolder>\" ; } getpid ( ) { return handler . getPID ( ) ; }", "answer": "org . junit . Assert . assertThat ( pid , org . hamcrest . CoreMatchers . equalTo ( pid_from_jmx ) )"}
{"focal": "deleteTaskDefinition ( org . springframework . cloud . dataflow . core . TaskDefinition ) { org . springframework . cloud . dataflow . core . dsl . TaskParser taskParser = new org . springframework . cloud . dataflow . core . dsl . TaskParser ( taskDefinition . getName ( ) , taskDefinition . getDslText ( ) , true , true ) ; org . springframework . cloud . dataflow . core . dsl . TaskNode taskNode = taskParser . parse ( ) ; if ( taskNode . isComposed ( ) ) { java . lang . String childTaskPrefix = org . springframework . cloud . dataflow . core . dsl . TaskNode . getTaskPrefix ( taskDefinition . getTaskName ( ) ) ; taskNode . getTaskApps ( ) . forEach ( ( task ) -> { java . lang . String childName = task . getName ( ) ; if ( ( task . getLabel ( ) ) != null ) { childName = task . getLabel ( ) ; } destroyChildTask ( ( childTaskPrefix + childName ) ) ; } ) ; } destroyPrimaryTask ( taskDefinition . getTaskName ( ) ) ; }", "testMethod": "deleteComposedTask ( ) { org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . initializeSuccessfulRegistry ( appRegistry ) ; java . lang . String dsl = \"AAA<sp>&&<sp>BBB<sp>&&<sp>CCC\" ; taskSaveService . saveTaskDefinition ( \"deleteTask\" , dsl ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask-AAA\" , \"AAA\" , taskDefinitionRepository ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask-BBB\" , \"BBB\" , taskDefinitionRepository ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask-CCC\" , \"CCC\" , taskDefinitionRepository ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask\" , dsl , taskDefinitionRepository ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskDeleteService . deleteTaskDefinition ( \"deleteTask\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ( preDeleteSize - 4 ) , org . hamcrest . core . Is . is ( org . hamcrest . CoreMatchers . equalTo ( taskDefinitionRepository . count ( ) ) ) )", "total": "deleteComposedTask ( ) { org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . initializeSuccessfulRegistry ( appRegistry ) ; java . lang . String dsl = \"AAA<sp>&&<sp>BBB<sp>&&<sp>CCC\" ; taskSaveService . saveTaskDefinition ( \"deleteTask\" , dsl ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask-AAA\" , \"AAA\" , taskDefinitionRepository ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask-BBB\" , \"BBB\" , taskDefinitionRepository ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask-CCC\" , \"CCC\" , taskDefinitionRepository ) ; org . springframework . cloud . dataflow . server . service . impl . DefaultTaskExecutionServiceTests . verifyTaskExistsInRepo ( \"deleteTask\" , dsl , taskDefinitionRepository ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskDeleteService . deleteTaskDefinition ( \"deleteTask\" ) ; \"<AssertPlaceHolder>\" ; } deleteTaskDefinition ( org . springframework . cloud . dataflow . core . TaskDefinition ) { org . springframework . cloud . dataflow . core . dsl . TaskParser taskParser = new org . springframework . cloud . dataflow . core . dsl . TaskParser ( taskDefinition . getName ( ) , taskDefinition . getDslText ( ) , true , true ) ; org . springframework . cloud . dataflow . core . dsl . TaskNode taskNode = taskParser . parse ( ) ; if ( taskNode . isComposed ( ) ) { java . lang . String childTaskPrefix = org . springframework . cloud . dataflow . core . dsl . TaskNode . getTaskPrefix ( taskDefinition . getTaskName ( ) ) ; taskNode . getTaskApps ( ) . forEach ( ( task ) -> { java . lang . String childName = task . getName ( ) ; if ( ( task . getLabel ( ) ) != null ) { childName = task . getLabel ( ) ; } destroyChildTask ( ( childTaskPrefix + childName ) ) ; } ) ; } destroyPrimaryTask ( taskDefinition . getTaskName ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( ( preDeleteSize - 4 ) , org . hamcrest . core . Is . is ( org . hamcrest . CoreMatchers . equalTo ( taskDefinitionRepository . count ( ) ) ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldSerializeCollectionWithPrefixTag ( ) { java . lang . String expectedResult = \"<sp><order>\\n<sp><price>15.0</price>\\n<sp><comments>pack<sp>it<sp>nicely,<sp>please</comments>\\n<sp></order>\\n\" ; expectedResult += expectedResult ; expectedResult = ( \"<orders>\\n\" + expectedResult ) + \"</orders>\" ; br . com . caelum . vraptor . serialization . xstream . XStreamXMLSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamXMLSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamXMLSerializationTest . Client ( \"guilherme<sp>silveira\" ) , 15.0 , \"pack<sp>it<sp>nicely,<sp>please\" ) ; serialization . from ( java . util . Arrays . asList ( order , order ) , \"orders\" ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldSerializeCollectionWithPrefixTag ( ) { java . lang . String expectedResult = \"<sp><order>\\n<sp><price>15.0</price>\\n<sp><comments>pack<sp>it<sp>nicely,<sp>please</comments>\\n<sp></order>\\n\" ; expectedResult += expectedResult ; expectedResult = ( \"<orders>\\n\" + expectedResult ) + \"</orders>\" ; br . com . caelum . vraptor . serialization . xstream . XStreamXMLSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamXMLSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamXMLSerializationTest . Client ( \"guilherme<sp>silveira\" ) , 15.0 , \"pack<sp>it<sp>nicely,<sp>please\" ) ; serialization . from ( java . util . Arrays . asList ( order , order ) , \"orders\" ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "limit ( org . diirt . util . array . ListDouble , int , int ) { return new org . diirt . util . array . ListDouble ( ) { @ org . diirt . util . array . Override public double getDouble ( int index ) { return data . getDouble ( ( index + start ) ) ; } @ org . diirt . util . array . Override public int size ( ) { return end - start ; } } ; }", "testMethod": "limit2 ( ) { org . diirt . util . array . ListLong array1 = new org . diirt . util . array . ArrayLong ( 0 , 1 , 2 , 3 , 4 , 5 ) ; org . diirt . util . array . ListLong limit = org . diirt . util . array . ListMath . limit ( array1 , 1 , 5 ) ; org . diirt . util . array . ListLong reference = new org . diirt . util . array . ArrayLong ( 1 , 2 , 3 , 4 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( limit , equalTo ( reference ) )", "total": "limit2 ( ) { org . diirt . util . array . ListLong array1 = new org . diirt . util . array . ArrayLong ( 0 , 1 , 2 , 3 , 4 , 5 ) ; org . diirt . util . array . ListLong limit = org . diirt . util . array . ListMath . limit ( array1 , 1 , 5 ) ; org . diirt . util . array . ListLong reference = new org . diirt . util . array . ArrayLong ( 1 , 2 , 3 , 4 ) ; \"<AssertPlaceHolder>\" ; } limit ( org . diirt . util . array . ListDouble , int , int ) { return new org . diirt . util . array . ListDouble ( ) { @ org . diirt . util . array . Override public double getDouble ( int index ) { return data . getDouble ( ( index + start ) ) ; } @ org . diirt . util . array . Override public int size ( ) { return end - start ; } } ; }", "answer": "org . junit . Assert . assertThat ( limit , equalTo ( reference ) )"}
{"focal": "doesSwitchReduceCrossings ( int , int ) { if ( constraintsPreventSwitch ( upperNodeIndex , lowerNodeIndex ) ) { return false ; } org . eclipse . elk . alg . layered . graph . LNode upperNode = freeLayer [ upperNodeIndex ] ; org . eclipse . elk . alg . layered . graph . LNode lowerNode = freeLayer [ lowerNodeIndex ] ; org . eclipse . elk . core . util . Pair < java . lang . Integer , java . lang . Integer > leftInlayer = leftInLayerCounter . countInLayerCrossingsBetweenNodesInBothOrders ( upperNode , lowerNode , PortSide . WEST ) ; org . eclipse . elk . core . util . Pair < java . lang . Integer , java . lang . Integer > rightInlayer = rightInLayerCounter . countInLayerCrossingsBetweenNodesInBothOrders ( upperNode , lowerNode , PortSide . EAST ) ; northSouthCounter . countCrossings ( upperNode , lowerNode ) ; int upperLowerCrossings = ( ( ( crossingMatrixFiller . getCrossingMatrixEntry ( upperNode , lowerNode ) ) + ( leftInlayer . getFirst ( ) ) ) + ( rightInlayer . getFirst ( ) ) ) + ( northSouthCounter . getUpperLowerCrossings ( ) ) ; int lowerUpperCrossings = ( ( ( crossingMatrixFiller . getCrossingMatrixEntry ( lowerNode , upperNode ) ) + ( leftInlayer . getSecond ( ) ) ) + ( rightInlayer . getSecond ( ) ) ) + ( northSouthCounter . getLowerUpperCrossings ( ) ) ; if ( countCrossingsCausedByPortSwitch ) { org . eclipse . elk . alg . layered . graph . LPort upperPort = ( ( org . eclipse . elk . alg . layered . graph . LPort ) ( upperNode . getProperty ( InternalProperties . ORIGIN ) ) ) ; org . eclipse . elk . alg . layered . graph . LPort lowerPort = ( ( org . eclipse . elk . alg . layered . graph . LPort ) ( lowerNode . getProperty ( InternalProperties . ORIGIN ) ) ) ; org . eclipse . elk . core . util . Pair < java . lang . Integer , java . lang . Integer > crossingNumbers = parentCrossCounter . countCrossingsBetweenPortsInBothOrders ( upperPort , lowerPort ) ; upperLowerCrossings += crossingNumbers . getFirst ( ) ; lowerUpperCrossings += crossingNumbers . getSecond ( ) ; } return upperLowerCrossings > lowerUpperCrossings ; }", "testMethod": "layoutUnitConstraintPreventsSwitchWithNodeWithSouthernPorts ( ) { graph = new org . eclipse . alg . layered . intermediate . greedyswitch . NorthSouthEdgeTestGraphCreator ( ) . getGraphLayoutUnitPreventsSwitchWithNodeWithNodeWithSouthernEdges ( ) ; decider = givenDeciderForFreeLayer ( 0 , CrossingCountSide . EAST ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( decider . doesSwitchReduceCrossings ( 0 , 1 ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "layoutUnitConstraintPreventsSwitchWithNodeWithSouthernPorts ( ) { graph = new org . eclipse . alg . layered . intermediate . greedyswitch . NorthSouthEdgeTestGraphCreator ( ) . getGraphLayoutUnitPreventsSwitchWithNodeWithNodeWithSouthernEdges ( ) ; decider = givenDeciderForFreeLayer ( 0 , CrossingCountSide . EAST ) ; \"<AssertPlaceHolder>\" ; } doesSwitchReduceCrossings ( int , int ) { if ( constraintsPreventSwitch ( upperNodeIndex , lowerNodeIndex ) ) { return false ; } org . eclipse . elk . alg . layered . graph . LNode upperNode = freeLayer [ upperNodeIndex ] ; org . eclipse . elk . alg . layered . graph . LNode lowerNode = freeLayer [ lowerNodeIndex ] ; org . eclipse . elk . core . util . Pair < java . lang . Integer , java . lang . Integer > leftInlayer = leftInLayerCounter . countInLayerCrossingsBetweenNodesInBothOrders ( upperNode , lowerNode , PortSide . WEST ) ; org . eclipse . elk . core . util . Pair < java . lang . Integer , java . lang . Integer > rightInlayer = rightInLayerCounter . countInLayerCrossingsBetweenNodesInBothOrders ( upperNode , lowerNode , PortSide . EAST ) ; northSouthCounter . countCrossings ( upperNode , lowerNode ) ; int upperLowerCrossings = ( ( ( crossingMatrixFiller . getCrossingMatrixEntry ( upperNode , lowerNode ) ) + ( leftInlayer . getFirst ( ) ) ) + ( rightInlayer . getFirst ( ) ) ) + ( northSouthCounter . getUpperLowerCrossings ( ) ) ; int lowerUpperCrossings = ( ( ( crossingMatrixFiller . getCrossingMatrixEntry ( lowerNode , upperNode ) ) + ( leftInlayer . getSecond ( ) ) ) + ( rightInlayer . getSecond ( ) ) ) + ( northSouthCounter . getLowerUpperCrossings ( ) ) ; if ( countCrossingsCausedByPortSwitch ) { org . eclipse . elk . alg . layered . graph . LPort upperPort = ( ( org . eclipse . elk . alg . layered . graph . LPort ) ( upperNode . getProperty ( InternalProperties . ORIGIN ) ) ) ; org . eclipse . elk . alg . layered . graph . LPort lowerPort = ( ( org . eclipse . elk . alg . layered . graph . LPort ) ( lowerNode . getProperty ( InternalProperties . ORIGIN ) ) ) ; org . eclipse . elk . core . util . Pair < java . lang . Integer , java . lang . Integer > crossingNumbers = parentCrossCounter . countCrossingsBetweenPortsInBothOrders ( upperPort , lowerPort ) ; upperLowerCrossings += crossingNumbers . getFirst ( ) ; lowerUpperCrossings += crossingNumbers . getSecond ( ) ; } return upperLowerCrossings > lowerUpperCrossings ; }", "answer": "org . junit . Assert . assertThat ( decider . doesSwitchReduceCrossings ( 0 , 1 ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getSelectItems ( ) { if ( ( this . selectItems ) == null ) { javax . faces . context . FacesContext context = getFacesContext ( ) ; java . util . List < javax . faces . model . SelectItem > selectItems = new java . util . ArrayList < javax . faces . model . SelectItem > ( ) ; addNoSelectionOptionAsRequired ( context , selectItems ) ; java . lang . Iterable < java . lang . Object > valueItems = getOrDeduceValues ( ) ; for ( java . lang . Object valueItem : valueItems ) { javax . faces . model . SelectItem selectItem = convertToSelectItem ( context , valueItem ) ; selectItems . add ( selectItem ) ; } this . selectItems = selectItems ; } return this . selectItems ; }", "testMethod": "shouldGetSelectItemsFromDataModel ( ) { this . selectItems . setParent ( mockParent ( javax . faces . component . UISelectMany . class ) ) ; javax . faces . model . SelectItem selectItem = new javax . faces . model . SelectItem ( ) ; javax . faces . model . DataModel < javax . faces . model . SelectItem > value = new javax . faces . model . ArrayDataModel < javax . faces . model . SelectItem > ( new javax . faces . model . SelectItem [ ] { selectItem } ) ; this . selectItems . setValue ( value ) ; java . util . List < javax . faces . model . SelectItem > actual = this . selectItems . getSelectItems ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( ( ( java . util . Collection < javax . faces . model . SelectItem > ) ( java . util . Collections . singletonList ( selectItem ) ) ) ) ) )", "total": "shouldGetSelectItemsFromDataModel ( ) { this . selectItems . setParent ( mockParent ( javax . faces . component . UISelectMany . class ) ) ; javax . faces . model . SelectItem selectItem = new javax . faces . model . SelectItem ( ) ; javax . faces . model . DataModel < javax . faces . model . SelectItem > value = new javax . faces . model . ArrayDataModel < javax . faces . model . SelectItem > ( new javax . faces . model . SelectItem [ ] { selectItem } ) ; this . selectItems . setValue ( value ) ; java . util . List < javax . faces . model . SelectItem > actual = this . selectItems . getSelectItems ( ) ; \"<AssertPlaceHolder>\" ; } getSelectItems ( ) { if ( ( this . selectItems ) == null ) { javax . faces . context . FacesContext context = getFacesContext ( ) ; java . util . List < javax . faces . model . SelectItem > selectItems = new java . util . ArrayList < javax . faces . model . SelectItem > ( ) ; addNoSelectionOptionAsRequired ( context , selectItems ) ; java . lang . Iterable < java . lang . Object > valueItems = getOrDeduceValues ( ) ; for ( java . lang . Object valueItem : valueItems ) { javax . faces . model . SelectItem selectItem = convertToSelectItem ( context , valueItem ) ; selectItems . add ( selectItem ) ; } this . selectItems = selectItems ; } return this . selectItems ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( ( ( java . util . Collection < javax . faces . model . SelectItem > ) ( java . util . Collections . singletonList ( selectItem ) ) ) ) ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptInValidParameter4 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"savex<sp>property<sp>\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )", "total": "testAcceptInValidParameter4 ( ) { final org . openspotlight . graph . query . console . ConsoleState state = new org . openspotlight . graph . query . console . ConsoleState ( null ) ; state . setInput ( \"savex<sp>property<sp>\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( false ) )"}
{"focal": "isRequired ( ) { return _required ; }", "testMethod": "testIsRequired1 ( ) { java . lang . String name = \"Test\" ; com . liferay . talend . runtime . apio . form . Property property = new com . liferay . talend . runtime . apio . form . Property ( name , true , true , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( property . isRequired ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "testIsRequired1 ( ) { java . lang . String name = \"Test\" ; com . liferay . talend . runtime . apio . form . Property property = new com . liferay . talend . runtime . apio . form . Property ( name , true , true , true ) ; \"<AssertPlaceHolder>\" ; } isRequired ( ) { return _required ; }", "answer": "org . junit . Assert . assertThat ( property . isRequired ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "size ( ) { return cells . size ( ) ; }", "testMethod": "kanbanBacklogDoesnAllowChangeInTheData ( ) { com . metservice . kanban . model . WorkItemType type = new com . metservice . kanban . model . WorkItemType ( \"backlog\" ) ; java . util . List < com . metservice . kanban . model . KanbanCell > list = new java . util . ArrayList < com . metservice . kanban . model . KanbanCell > ( ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; com . metservice . kanban . model . KanbanBacklog backlog = new com . metservice . kanban . model . KanbanBacklog ( list ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( backlog . size ( ) , org . hamcrest . core . Is . is ( 3 ) )", "total": "kanbanBacklogDoesnAllowChangeInTheData ( ) { com . metservice . kanban . model . WorkItemType type = new com . metservice . kanban . model . WorkItemType ( \"backlog\" ) ; java . util . List < com . metservice . kanban . model . KanbanCell > list = new java . util . ArrayList < com . metservice . kanban . model . KanbanCell > ( ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; com . metservice . kanban . model . KanbanBacklog backlog = new com . metservice . kanban . model . KanbanBacklog ( list ) ; list . add ( new com . metservice . kanban . model . KanbanCell ( type ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return cells . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( backlog . size ( ) , org . hamcrest . core . Is . is ( 3 ) )"}
{"focal": "isMyPrimitiveBoolean ( ) { return myPrimitiveBoolean ; }", "testMethod": "primitiveBoolean ( ) { model . setMyPrimitiveBoolean ( true ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model2 . isMyPrimitiveBoolean ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "primitiveBoolean ( ) { model . setMyPrimitiveBoolean ( true ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; } isMyPrimitiveBoolean ( ) { return myPrimitiveBoolean ; }", "answer": "org . junit . Assert . assertThat ( model2 . isMyPrimitiveBoolean ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "isAvailableType ( java . lang . String , org . junithelper . core . config . Configuration ) { if ( typeName == null ) { return false ; } boolean isTypeAvailable = false ; java . lang . String [ ] packageArr = typeName . split ( \"\\\\.\" ) ; java . lang . String packageName = null ; if ( ( packageArr . length ) > 1 ) { packageName = typeName . replaceFirst ( \"\\\\.[^\\\\.]+$\" , StringValue . Empty ) ; } for ( java . lang . String imported : classMeta . importedList ) { if ( ( packageName != null ) && ( imported . equals ( typeName ) ) ) { return true ; } else if ( imported . matches ( ( ( \".+\\\\.\" + typeName ) + \"$\" ) ) ) { return true ; } } try { java . lang . Class . forName ( ( \"java.lang.\" + typeName ) ) ; isTypeAvailable = true ; } catch ( java . lang . Exception ignore ) { if ( ( config != null ) && ( packageName != null ) ) { java . lang . String searchPath = ( ( config . directoryPathOfProductSourceCode ) + \"/\" ) + ( packageName . replaceAll ( \"\\\\.\" , \"/\" ) ) ; try { java . util . List < java . io . File > files = org . junithelper . core . file . FileSearcherFactory . create ( ) . searchFilesRecursivelyByName ( searchPath , ( typeName + ( RegExp . FileExtension . JavaFile ) ) ) ; if ( ( files != null ) && ( ( files . size ( ) ) > 0 ) ) { isTypeAvailable = true ; } } catch ( java . lang . Exception e ) { org . junithelper . core . util . Stderr . p ( ( ( ( e . getLocalizedMessage ( ) ) + \"<sp>-<sp>\" ) + searchPath ) ) ; } } } return isTypeAvailable ; }", "testMethod": "isAvailableType_A$String$Configuration_StringIsEmpty ( ) { org . junithelper . core . meta . ClassMeta classMeta = new org . junithelper . core . meta . ClassMeta ( ) ; org . junithelper . core . extractor . AvailableTypeDetector target = new org . junithelper . core . extractor . AvailableTypeDetector ( classMeta ) ; java . lang . String typeName = \"\" ; org . junithelper . core . config . Configuration config = null ; boolean actual = target . isAvailableType ( typeName , config ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "isAvailableType_A$String$Configuration_StringIsEmpty ( ) { org . junithelper . core . meta . ClassMeta classMeta = new org . junithelper . core . meta . ClassMeta ( ) ; org . junithelper . core . extractor . AvailableTypeDetector target = new org . junithelper . core . extractor . AvailableTypeDetector ( classMeta ) ; java . lang . String typeName = \"\" ; org . junithelper . core . config . Configuration config = null ; boolean actual = target . isAvailableType ( typeName , config ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; } isAvailableType ( java . lang . String , org . junithelper . core . config . Configuration ) { if ( typeName == null ) { return false ; } boolean isTypeAvailable = false ; java . lang . String [ ] packageArr = typeName . split ( \"\\\\.\" ) ; java . lang . String packageName = null ; if ( ( packageArr . length ) > 1 ) { packageName = typeName . replaceFirst ( \"\\\\.[^\\\\.]+$\" , StringValue . Empty ) ; } for ( java . lang . String imported : classMeta . importedList ) { if ( ( packageName != null ) && ( imported . equals ( typeName ) ) ) { return true ; } else if ( imported . matches ( ( ( \".+\\\\.\" + typeName ) + \"$\" ) ) ) { return true ; } } try { java . lang . Class . forName ( ( \"java.lang.\" + typeName ) ) ; isTypeAvailable = true ; } catch ( java . lang . Exception ignore ) { if ( ( config != null ) && ( packageName != null ) ) { java . lang . String searchPath = ( ( config . directoryPathOfProductSourceCode ) + \"/\" ) + ( packageName . replaceAll ( \"\\\\.\" , \"/\" ) ) ; try { java . util . List < java . io . File > files = org . junithelper . core . file . FileSearcherFactory . create ( ) . searchFilesRecursivelyByName ( searchPath , ( typeName + ( RegExp . FileExtension . JavaFile ) ) ) ; if ( ( files != null ) && ( ( files . size ( ) ) > 0 ) ) { isTypeAvailable = true ; } } catch ( java . lang . Exception e ) { org . junithelper . core . util . Stderr . p ( ( ( ( e . getLocalizedMessage ( ) ) + \"<sp>-<sp>\" ) + searchPath ) ) ; } } } return isTypeAvailable ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "match ( org . mule . runtime . api . message . ErrorType ) { return errorTypeMatchers . stream ( ) . anyMatch ( ( errorTypeMatcher ) -> errorTypeMatcher . match ( errorType ) ) ; }", "testMethod": "matchEqual ( ) { org . mule . runtime . core . api . exception . ErrorTypeMatcher transformationMatcher = new org . mule . runtime . core . api . exception . SingleErrorTypeMatcher ( transformationErrorType ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( transformationMatcher . match ( transformationErrorType ) , org . hamcrest . Matchers . is ( true ) )", "total": "matchEqual ( ) { org . mule . runtime . core . api . exception . ErrorTypeMatcher transformationMatcher = new org . mule . runtime . core . api . exception . SingleErrorTypeMatcher ( transformationErrorType ) ; \"<AssertPlaceHolder>\" ; } match ( org . mule . runtime . api . message . ErrorType ) { return errorTypeMatchers . stream ( ) . anyMatch ( ( errorTypeMatcher ) -> errorTypeMatcher . match ( errorType ) ) ; }", "answer": "org . junit . Assert . assertThat ( transformationMatcher . match ( transformationErrorType ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "size ( ) { return sizeInList ; }", "testMethod": "object ( ) { java . util . List < java . lang . reflect . Type > invoked = com . asakusafw . runtime . util . TypeUtil . invoke ( java . lang . Object . class , java . lang . String . class ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( invoked . size ( ) , is ( 0 ) )", "total": "object ( ) { java . util . List < java . lang . reflect . Type > invoked = com . asakusafw . runtime . util . TypeUtil . invoke ( java . lang . Object . class , java . lang . String . class ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return sizeInList ; }", "answer": "org . junit . Assert . assertThat ( invoked . size ( ) , is ( 0 ) )"}
{"focal": "allows ( org . jenkinsci . plugins . postbuildscript . model . PostBuildItem , boolean ) { java . util . Optional < hudson . model . Result > result = java . util . Optional . ofNullable ( build . getResult ( ) ) ; return ( result . isPresent ( ) ) && ( item . shouldBeExecuted ( result . get ( ) . toString ( ) ) ) ; }", "testMethod": "deniesAxesExecutionIfEndOfMatrixBuild ( ) { given ( item . getExecuteOn ( ) ) . willReturn ( ExecuteOn . AXES ) ; boolean actual = matrixRule . allows ( item , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( false ) )", "total": "deniesAxesExecutionIfEndOfMatrixBuild ( ) { given ( item . getExecuteOn ( ) ) . willReturn ( ExecuteOn . AXES ) ; boolean actual = matrixRule . allows ( item , true ) ; \"<AssertPlaceHolder>\" ; } allows ( org . jenkinsci . plugins . postbuildscript . model . PostBuildItem , boolean ) { java . util . Optional < hudson . model . Result > result = java . util . Optional . ofNullable ( build . getResult ( ) ) ; return ( result . isPresent ( ) ) && ( item . shouldBeExecuted ( result . get ( ) . toString ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "isAllowed ( java . lang . String , java . net . URI ) { checkNotNull ( crawlerAgentString , \"crawlerAgentString<sp>is<sp>null\" ) ; checkNotNull ( resourceUri , \"resourceUri<sp>is<sp>null\" ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolving<sp>robots<sp>URL<sp>for:<sp>{}\" , resourceUri ) ; final java . net . URI robotsUri = utilities . getRobotsURIForResource ( resourceUri ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolved<sp>robots<sp>URI<sp>to:<sp>{}\" , robotsUri ) ; final com . brandwatch . robots . domain . Robots robots ; try { robots = loader . load ( robotsUri ) ; } catch ( java . lang . Exception e ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Download<sp>failure<sp>{}\" , e . getMessage ( ) ) ; return allow ( resourceUri ) ; } if ( robots . getGroups ( ) . isEmpty ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>agent<sp>groups<sp>found\" , resourceUri ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . Group > group = matcherUtils . getMostSpecificMatchingGroup ( robots . getGroups ( ) , crawlerAgentString ) ; if ( group . isPresent ( ) ) { if ( com . brandwatch . robots . RobotsServiceImpl . log . isDebugEnabled ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>user-agent<sp>group:<sp>{}\" , matcherUtils . getMostSpecificMatch ( group . get ( ) , crawlerAgentString ) . get ( ) . getValue ( ) ) ; } } else { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>user-agent<sp>group<sp>matched\" ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . PathDirective > bestMatch = matcherUtils . getMostSpecificMatch ( group . get ( ) . getDirectives ( com . brandwatch . robots . domain . PathDirective . class ) , utilities . getResourceLocalComponents ( resourceUri ) ) ; if ( ! ( bestMatch . isPresent ( ) ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>matching<sp>path<sp>directive\" ) ; return allow ( resourceUri ) ; } else { final com . brandwatch . robots . domain . PathDirective directive = bestMatch . get ( ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>path<sp>directive<sp>{}:{}\" , directive . getField ( ) , directive . getValue ( ) ) ; return directive . isAllowed ( ) ? allow ( resourceUri ) : disallow ( resourceUri ) ; } }", "testMethod": "givenDisallowBlankPathDirective_whenIsAllowed_thenReturnsTrue ( ) { parse ( \"blank_disallow_robots.txt\" ) ; boolean allowed = service . isAllowed ( agent , java . net . URI . create ( \"http://example.com/index.html\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( allowed , org . hamcrest . core . Is . is ( true ) )", "total": "givenDisallowBlankPathDirective_whenIsAllowed_thenReturnsTrue ( ) { parse ( \"blank_disallow_robots.txt\" ) ; boolean allowed = service . isAllowed ( agent , java . net . URI . create ( \"http://example.com/index.html\" ) ) ; \"<AssertPlaceHolder>\" ; } isAllowed ( java . lang . String , java . net . URI ) { checkNotNull ( crawlerAgentString , \"crawlerAgentString<sp>is<sp>null\" ) ; checkNotNull ( resourceUri , \"resourceUri<sp>is<sp>null\" ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolving<sp>robots<sp>URL<sp>for:<sp>{}\" , resourceUri ) ; final java . net . URI robotsUri = utilities . getRobotsURIForResource ( resourceUri ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Resolved<sp>robots<sp>URI<sp>to:<sp>{}\" , robotsUri ) ; final com . brandwatch . robots . domain . Robots robots ; try { robots = loader . load ( robotsUri ) ; } catch ( java . lang . Exception e ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Download<sp>failure<sp>{}\" , e . getMessage ( ) ) ; return allow ( resourceUri ) ; } if ( robots . getGroups ( ) . isEmpty ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>agent<sp>groups<sp>found\" , resourceUri ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . Group > group = matcherUtils . getMostSpecificMatchingGroup ( robots . getGroups ( ) , crawlerAgentString ) ; if ( group . isPresent ( ) ) { if ( com . brandwatch . robots . RobotsServiceImpl . log . isDebugEnabled ( ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>user-agent<sp>group:<sp>{}\" , matcherUtils . getMostSpecificMatch ( group . get ( ) , crawlerAgentString ) . get ( ) . getValue ( ) ) ; } } else { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>user-agent<sp>group<sp>matched\" ) ; return allow ( resourceUri ) ; } final com . google . common . base . Optional < com . brandwatch . robots . domain . PathDirective > bestMatch = matcherUtils . getMostSpecificMatch ( group . get ( ) . getDirectives ( com . brandwatch . robots . domain . PathDirective . class ) , utilities . getResourceLocalComponents ( resourceUri ) ) ; if ( ! ( bestMatch . isPresent ( ) ) ) { com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"No<sp>matching<sp>path<sp>directive\" ) ; return allow ( resourceUri ) ; } else { final com . brandwatch . robots . domain . PathDirective directive = bestMatch . get ( ) ; com . brandwatch . robots . RobotsServiceImpl . log . debug ( \"Matched<sp>path<sp>directive<sp>{}:{}\" , directive . getField ( ) , directive . getValue ( ) ) ; return directive . isAllowed ( ) ? allow ( resourceUri ) : disallow ( resourceUri ) ; } }", "answer": "org . junit . Assert . assertThat ( allowed , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getAnnotations ( ) { java . lang . reflect . Method method = getClass ( ) . getMethod ( \"foo\" , int . class ) ; java . util . List < java . lang . annotation . Annotation > annotations = org . junit . experimental . theories . ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; org . junit . Assert . assertThat ( annotations , org . hamcrest . CoreMatchers . < org . junit . experimental . theories . suppliers . TestedOn > hasItem ( org . hamcrest . CoreMatchers . isA ( org . junit . experimental . theories . suppliers . TestedOn . class ) ) ) ; }", "testMethod": "getAnnotations ( ) { java . lang . reflect . Method method = getClass ( ) . getMethod ( \"foo\" , int . class ) ; java . util . List < java . lang . annotation . Annotation > annotations = org . junit . experimental . theories . ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( annotations , org . hamcrest . CoreMatchers . < org . junit . experimental . theories . suppliers . TestedOn > hasItem ( org . hamcrest . CoreMatchers . isA ( org . junit . experimental . theories . suppliers . TestedOn . class ) ) )", "total": "getAnnotations ( ) { java . lang . reflect . Method method = getClass ( ) . getMethod ( \"foo\" , int . class ) ; java . util . List < java . lang . annotation . Annotation > annotations = org . junit . experimental . theories . ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; \"<AssertPlaceHolder>\" ; } getAnnotations ( ) { java . lang . reflect . Method method = getClass ( ) . getMethod ( \"foo\" , int . class ) ; java . util . List < java . lang . annotation . Annotation > annotations = org . junit . experimental . theories . ParameterSignature . signatures ( method ) . get ( 0 ) . getAnnotations ( ) ; org . junit . Assert . assertThat ( annotations , org . hamcrest . CoreMatchers . < org . junit . experimental . theories . suppliers . TestedOn > hasItem ( org . hamcrest . CoreMatchers . isA ( org . junit . experimental . theories . suppliers . TestedOn . class ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( annotations , org . hamcrest . CoreMatchers . < org . junit . experimental . theories . suppliers . TestedOn > hasItem ( org . hamcrest . CoreMatchers . isA ( org . junit . experimental . theories . suppliers . TestedOn . class ) ) )"}
{"focal": "of ( int ) { return weightedCucumberScenarios . sliceInto ( sliceCount ) . get ( ( ( sliceNumber ) - 1 ) ) ; }", "testMethod": "slicingASliceIntoOneSliceOfOneShouldBeTheSameAsAllScenarios ( ) { java . util . List < net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenario > scenarios = java . util . Collections . singletonList ( new net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenario ( \"test.feature\" , \"featurename\" , \"scenarioname\" , java . math . BigDecimal . ONE , emptySet ( ) , 0 ) ) ; net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenarios oneScenario = new net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenarios ( scenarios ) ; net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenarios fork1 = oneScenario . slice ( 1 ) . of ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( oneScenario , org . hamcrest . core . Is . is ( fork1 ) )", "total": "slicingASliceIntoOneSliceOfOneShouldBeTheSameAsAllScenarios ( ) { java . util . List < net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenario > scenarios = java . util . Collections . singletonList ( new net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenario ( \"test.feature\" , \"featurename\" , \"scenarioname\" , java . math . BigDecimal . ONE , emptySet ( ) , 0 ) ) ; net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenarios oneScenario = new net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenarios ( scenarios ) ; net . serenitybdd . cucumber . suiteslicing . WeightedCucumberScenarios fork1 = oneScenario . slice ( 1 ) . of ( 1 ) ; \"<AssertPlaceHolder>\" ; } of ( int ) { return weightedCucumberScenarios . sliceInto ( sliceCount ) . get ( ( ( sliceNumber ) - 1 ) ) ; }", "answer": "org . junit . Assert . assertThat ( oneScenario , org . hamcrest . core . Is . is ( fork1 ) )"}
{"focal": "asDocument ( ) { final long cursorId = myCursorId ; if ( cursorId != 0 ) { final com . allanbank . mongodb . bson . builder . DocumentBuilder b = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; b . add ( com . allanbank . mongodb . client . callback . NAME_SPACE_FIELD , ( ( ( myDatabaseName ) + \".\" ) + ( myCollectionName ) ) ) ; b . add ( com . allanbank . mongodb . client . callback . CURSOR_ID_FIELD , cursorId ) ; b . add ( com . allanbank . mongodb . client . callback . SERVER_FIELD , myAddress ) ; b . add ( com . allanbank . mongodb . client . callback . LIMIT_FIELD , myLimit ) ; b . add ( com . allanbank . mongodb . client . callback . BATCH_SIZE_FIELD , myBatchSize ) ; return b . build ( ) ; } return null ; }", "testMethod": "testAsDocument ( ) { final com . allanbank . mongodb . bson . builder . DocumentBuilder b = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; b . add ( MongoCursorControl . NAME_SPACE_FIELD , ( ( ( myQuery . getDatabaseName ( ) ) + \".\" ) + ( myQuery . getCollectionName ( ) ) ) ) ; b . add ( MongoCursorControl . CURSOR_ID_FIELD , 123456L ) ; b . add ( MongoCursorControl . SERVER_FIELD , myAddress ) ; b . add ( MongoCursorControl . LIMIT_FIELD , 0 ) ; b . add ( MongoCursorControl . BATCH_SIZE_FIELD , myQuery . getBatchSize ( ) ) ; final com . allanbank . mongodb . client . Client mockClient = createMock ( com . allanbank . mongodb . client . Client . class ) ; final com . allanbank . mongodb . StreamCallback < com . allanbank . mongodb . bson . Document > mockCallback = createMock ( com . allanbank . mongodb . StreamCallback . class ) ; final com . allanbank . mongodb . client . message . Reply reply = new com . allanbank . mongodb . client . message . Reply ( 0 , 123456 , 0 , myDocs , false , false , false , false ) ; final com . allanbank . mongodb . client . callback . CursorStreamingCallback qsCallback = new com . allanbank . mongodb . client . callback . CursorStreamingCallback ( mockClient , myQuery , false , mockCallback ) ; for ( final com . allanbank . mongodb . bson . Document doc : myDocs ) { mockCallback . callback ( doc ) ; expectLastCall ( ) ; } mockClient . send ( anyObject ( com . allanbank . mongodb . client . Message . class ) , eq ( qsCallback ) ) ; expectLastCall ( ) ; mockClient . send ( anyObject ( com . allanbank . mongodb . client . message . KillCursors . class ) , isNull ( com . allanbank . mongodb . client . callback . ReplyCallback . class ) ) ; expectLastCall ( ) ; replay ( mockClient , mockCallback ) ; qsCallback . setAddress ( myAddress ) ; qsCallback . callback ( reply ) ; \"<AssertPlaceHolder>\" ; qsCallback . close ( ) ; verify ( mockClient , mockCallback ) ; }", "assertLine": "org . junit . Assert . assertThat ( qsCallback . asDocument ( ) , org . hamcrest . CoreMatchers . is ( b . build ( ) ) )", "total": "testAsDocument ( ) { final com . allanbank . mongodb . bson . builder . DocumentBuilder b = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; b . add ( MongoCursorControl . NAME_SPACE_FIELD , ( ( ( myQuery . getDatabaseName ( ) ) + \".\" ) + ( myQuery . getCollectionName ( ) ) ) ) ; b . add ( MongoCursorControl . CURSOR_ID_FIELD , 123456L ) ; b . add ( MongoCursorControl . SERVER_FIELD , myAddress ) ; b . add ( MongoCursorControl . LIMIT_FIELD , 0 ) ; b . add ( MongoCursorControl . BATCH_SIZE_FIELD , myQuery . getBatchSize ( ) ) ; final com . allanbank . mongodb . client . Client mockClient = createMock ( com . allanbank . mongodb . client . Client . class ) ; final com . allanbank . mongodb . StreamCallback < com . allanbank . mongodb . bson . Document > mockCallback = createMock ( com . allanbank . mongodb . StreamCallback . class ) ; final com . allanbank . mongodb . client . message . Reply reply = new com . allanbank . mongodb . client . message . Reply ( 0 , 123456 , 0 , myDocs , false , false , false , false ) ; final com . allanbank . mongodb . client . callback . CursorStreamingCallback qsCallback = new com . allanbank . mongodb . client . callback . CursorStreamingCallback ( mockClient , myQuery , false , mockCallback ) ; for ( final com . allanbank . mongodb . bson . Document doc : myDocs ) { mockCallback . callback ( doc ) ; expectLastCall ( ) ; } mockClient . send ( anyObject ( com . allanbank . mongodb . client . Message . class ) , eq ( qsCallback ) ) ; expectLastCall ( ) ; mockClient . send ( anyObject ( com . allanbank . mongodb . client . message . KillCursors . class ) , isNull ( com . allanbank . mongodb . client . callback . ReplyCallback . class ) ) ; expectLastCall ( ) ; replay ( mockClient , mockCallback ) ; qsCallback . setAddress ( myAddress ) ; qsCallback . callback ( reply ) ; \"<AssertPlaceHolder>\" ; qsCallback . close ( ) ; verify ( mockClient , mockCallback ) ; } asDocument ( ) { final long cursorId = myCursorId ; if ( cursorId != 0 ) { final com . allanbank . mongodb . bson . builder . DocumentBuilder b = com . allanbank . mongodb . bson . builder . BuilderFactory . start ( ) ; b . add ( com . allanbank . mongodb . client . callback . NAME_SPACE_FIELD , ( ( ( myDatabaseName ) + \".\" ) + ( myCollectionName ) ) ) ; b . add ( com . allanbank . mongodb . client . callback . CURSOR_ID_FIELD , cursorId ) ; b . add ( com . allanbank . mongodb . client . callback . SERVER_FIELD , myAddress ) ; b . add ( com . allanbank . mongodb . client . callback . LIMIT_FIELD , myLimit ) ; b . add ( com . allanbank . mongodb . client . callback . BATCH_SIZE_FIELD , myBatchSize ) ; return b . build ( ) ; } return null ; }", "answer": "org . junit . Assert . assertThat ( qsCallback . asDocument ( ) , org . hamcrest . CoreMatchers . is ( b . build ( ) ) )"}
{"focal": "brokerAdded ( java . lang . String , org . eclipse . smarthome . io . transport . mqtt . MqttBrokerConnection ) { if ( ( ! ( connectionName . equals ( brokerID ) ) ) || ( ( connection ) == addedConnection ) ) { return ; } this . connection = addedConnection ; super . initialize ( ) ; }", "testMethod": "brokerAdded ( ) { org . eclipse . smarthome . binding . mqtt . handler . MqttBrokerConnectionEx connection = spy ( new org . eclipse . smarthome . binding . mqtt . handler . MqttBrokerConnectionEx ( \"10.10.0.10\" , 80 , false , \"BrokerHandlerTest\" ) ) ; doReturn ( connection ) . when ( service ) . getBrokerConnection ( eq ( handler . brokerID ) ) ; verify ( callback , times ( 0 ) ) . statusUpdated ( any ( ) , any ( ) ) ; handler . brokerAdded ( handler . brokerID , connection ) ; \"<AssertPlaceHolder>\" ; verify ( connection ) . start ( ) ; verify ( callback , times ( 3 ) ) . statusUpdated ( any ( ) , any ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( handler . connection , org . hamcrest . CoreMatchers . is ( connection ) )", "total": "brokerAdded ( ) { org . eclipse . smarthome . binding . mqtt . handler . MqttBrokerConnectionEx connection = spy ( new org . eclipse . smarthome . binding . mqtt . handler . MqttBrokerConnectionEx ( \"10.10.0.10\" , 80 , false , \"BrokerHandlerTest\" ) ) ; doReturn ( connection ) . when ( service ) . getBrokerConnection ( eq ( handler . brokerID ) ) ; verify ( callback , times ( 0 ) ) . statusUpdated ( any ( ) , any ( ) ) ; handler . brokerAdded ( handler . brokerID , connection ) ; \"<AssertPlaceHolder>\" ; verify ( connection ) . start ( ) ; verify ( callback , times ( 3 ) ) . statusUpdated ( any ( ) , any ( ) ) ; } brokerAdded ( java . lang . String , org . eclipse . smarthome . io . transport . mqtt . MqttBrokerConnection ) { if ( ( ! ( connectionName . equals ( brokerID ) ) ) || ( ( connection ) == addedConnection ) ) { return ; } this . connection = addedConnection ; super . initialize ( ) ; }", "answer": "org . junit . Assert . assertThat ( handler . connection , org . hamcrest . CoreMatchers . is ( connection ) )"}
{"focal": "toString ( ) { return ( ( ( ( \"beanType:\" + ( beanType ) ) + \"<sp>queryKey:\" ) + ( queryKey ) ) + \"<sp>sql:\" ) + ( sql ) ; }", "testMethod": "test_add ( ) { io . ebean . text . PathProperties root = io . ebean . text . PathProperties . parse ( \"status,date\" ) ; root . addNested ( \"customer\" , io . ebean . text . PathProperties . parse ( \"id,name\" ) ) ; io . ebean . FetchPath expect = io . ebean . text . PathProperties . parse ( \"status,date,customer(id,name)\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( expect . toString ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( root . toString ( ) )", "total": "test_add ( ) { io . ebean . text . PathProperties root = io . ebean . text . PathProperties . parse ( \"status,date\" ) ; root . addNested ( \"customer\" , io . ebean . text . PathProperties . parse ( \"id,name\" ) ) ; io . ebean . FetchPath expect = io . ebean . text . PathProperties . parse ( \"status,date,customer(id,name)\" ) ; \"<AssertPlaceHolder>\" . isEqualTo ( expect . toString ( ) ) ; } toString ( ) { return ( ( ( ( \"beanType:\" + ( beanType ) ) + \"<sp>queryKey:\" ) + ( queryKey ) ) + \"<sp>sql:\" ) + ( sql ) ; }", "answer": "org . junit . Assert . assertThat ( root . toString ( ) )"}
{"focal": "isKeepAlive ( ) { return Boolean . TRUE . equals ( getKeepAlive ( ) ) ; }", "testMethod": "closeClientCacheWithoutKeepAlive ( ) { org . apache . geode . cache . client . ClientCache mockClientCache = org . mockito . Mockito . mock ( org . apache . geode . cache . client . ClientCache . class ) ; org . springframework . data . gemfire . client . ClientCacheFactoryBean clientCacheFactoryBean = new org . springframework . data . gemfire . client . ClientCacheFactoryBean ( ) ; clientCacheFactoryBean . setKeepAlive ( false ) ; \"<AssertPlaceHolder>\" ; clientCacheFactoryBean . close ( mockClientCache ) ; org . mockito . Mockito . verify ( mockClientCache , org . mockito . Mockito . times ( 1 ) ) . close ( org . mockito . Matchers . eq ( false ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( clientCacheFactoryBean . isKeepAlive ( ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "closeClientCacheWithoutKeepAlive ( ) { org . apache . geode . cache . client . ClientCache mockClientCache = org . mockito . Mockito . mock ( org . apache . geode . cache . client . ClientCache . class ) ; org . springframework . data . gemfire . client . ClientCacheFactoryBean clientCacheFactoryBean = new org . springframework . data . gemfire . client . ClientCacheFactoryBean ( ) ; clientCacheFactoryBean . setKeepAlive ( false ) ; \"<AssertPlaceHolder>\" ; clientCacheFactoryBean . close ( mockClientCache ) ; org . mockito . Mockito . verify ( mockClientCache , org . mockito . Mockito . times ( 1 ) ) . close ( org . mockito . Matchers . eq ( false ) ) ; } isKeepAlive ( ) { return Boolean . TRUE . equals ( getKeepAlive ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( clientCacheFactoryBean . isKeepAlive ( ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "getByte ( java . lang . String ) { return getByte ( 1 ) ; }", "testMethod": "assertGetByteForColumnIndex ( ) { for ( java . sql . ResultSet each : resultSets . values ( ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( each . getByte ( 1 ) , org . hamcrest . CoreMatchers . is ( ( ( byte ) ( 10 ) ) ) )", "total": "assertGetByteForColumnIndex ( ) { for ( java . sql . ResultSet each : resultSets . values ( ) ) { \"<AssertPlaceHolder>\" ; } } getByte ( java . lang . String ) { return getByte ( 1 ) ; }", "answer": "org . junit . Assert . assertThat ( each . getByte ( 1 ) , org . hamcrest . CoreMatchers . is ( ( ( byte ) ( 10 ) ) ) )"}
{"focal": "get ( java . lang . String ) { return new com . navercorp . volleyextensions . volleyer . GetBuilder ( requestQueue , configuration , url ) ; }", "testMethod": "getShouldBeCalled ( ) { given ( delegate . get ( key ) ) . willReturn ( value ) ; android . graphics . Bitmap hit = imageCache . get ( key ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( hit , org . hamcrest . CoreMatchers . is ( value ) )", "total": "getShouldBeCalled ( ) { given ( delegate . get ( key ) ) . willReturn ( value ) ; android . graphics . Bitmap hit = imageCache . get ( key ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . String ) { return new com . navercorp . volleyextensions . volleyer . GetBuilder ( requestQueue , configuration , url ) ; }", "answer": "org . junit . Assert . assertThat ( hit , org . hamcrest . CoreMatchers . is ( value ) )"}
{"focal": "formatAttributes ( ) { return component . formatAttributes ( ) ; }", "testMethod": "testCopyFormatAttributesWithHomepage ( ) { org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor underTest = new org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor ( new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"homepage\" , \"https://www.example.com/homepage\" ) . build ( ) ) ; underTest . copyFormatAttributes ( asset ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( asset . formatAttributes ( ) . get ( \"homepage\" ) , org . hamcrest . Matchers . is ( \"https://www.example.com/homepage\" ) )", "total": "testCopyFormatAttributesWithHomepage ( ) { org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor underTest = new org . sonatype . nexus . repository . npm . internal . NpmFormatAttributesExtractor ( new ImmutableMap . Builder < java . lang . String , java . lang . Object > ( ) . put ( \"homepage\" , \"https://www.example.com/homepage\" ) . build ( ) ) ; underTest . copyFormatAttributes ( asset ) ; \"<AssertPlaceHolder>\" ; } formatAttributes ( ) { return component . formatAttributes ( ) ; }", "answer": "org . junit . Assert . assertThat ( asset . formatAttributes ( ) . get ( \"homepage\" ) , org . hamcrest . Matchers . is ( \"https://www.example.com/homepage\" ) )"}
{"focal": "build ( ) { return object ; }", "testMethod": "findByNameShouldFindStateWhenValidNameIsGiven ( ) { com . epam . rft . atsy . persistence . entities . StatesEntity expectedStatesEntity = com . epam . rft . atsy . persistence . entities . StatesEntity . builder ( ) . id ( com . epam . rft . atsy . persistence . repositories . StatesRepositoryIT . VALID_STATE_ID ) . name ( com . epam . rft . atsy . persistence . repositories . StatesRepositoryIT . VALID_STATE_NAME ) . build ( ) ; com . epam . rft . atsy . persistence . entities . StatesEntity result = statesRepository . findByName ( com . epam . rft . atsy . persistence . repositories . StatesRepositoryIT . VALID_STATE_NAME ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( expectedStatesEntity ) )", "total": "findByNameShouldFindStateWhenValidNameIsGiven ( ) { com . epam . rft . atsy . persistence . entities . StatesEntity expectedStatesEntity = com . epam . rft . atsy . persistence . entities . StatesEntity . builder ( ) . id ( com . epam . rft . atsy . persistence . repositories . StatesRepositoryIT . VALID_STATE_ID ) . name ( com . epam . rft . atsy . persistence . repositories . StatesRepositoryIT . VALID_STATE_NAME ) . build ( ) ; com . epam . rft . atsy . persistence . entities . StatesEntity result = statesRepository . findByName ( com . epam . rft . atsy . persistence . repositories . StatesRepositoryIT . VALID_STATE_NAME ) ; \"<AssertPlaceHolder>\" ; } build ( ) { return object ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( expectedStatesEntity ) )"}
{"focal": "getMessageId ( ) { com . miracle . framework . remote . server . exception . ServerException serverException = new com . miracle . framework . remote . server . exception . ServerException ( 1L , new java . lang . RuntimeException ( ) ) ; org . junit . Assert . assertThat ( serverException . getMessageId ( ) , org . hamcrest . CoreMatchers . is ( 1L ) ) ; }", "testMethod": "getMessageId ( ) { com . miracle . framework . remote . server . exception . ServerException serverException = new com . miracle . framework . remote . server . exception . ServerException ( 1L , new java . lang . RuntimeException ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serverException . getMessageId ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )", "total": "getMessageId ( ) { com . miracle . framework . remote . server . exception . ServerException serverException = new com . miracle . framework . remote . server . exception . ServerException ( 1L , new java . lang . RuntimeException ( ) ) ; \"<AssertPlaceHolder>\" ; } getMessageId ( ) { com . miracle . framework . remote . server . exception . ServerException serverException = new com . miracle . framework . remote . server . exception . ServerException ( 1L , new java . lang . RuntimeException ( ) ) ; org . junit . Assert . assertThat ( serverException . getMessageId ( ) , org . hamcrest . CoreMatchers . is ( 1L ) ) ; }", "answer": "org . junit . Assert . assertThat ( serverException . getMessageId ( ) , org . hamcrest . CoreMatchers . is ( 1L ) )"}
{"focal": "getItem ( int ) { return masterSequence . get ( index ) ; }", "testMethod": "getItemRetrievesCorrectItem ( ) { com . maxgarfinkel . suffixTree . Word word = new com . maxgarfinkel . suffixTree . Word ( \"Test<sp>word\" ) ; char [ ] characters = new char [ ] { 'T' , 'e' , 's' , 't' , '<sp>' , 'w' , 'o' , 'r' , 'd' } ; com . maxgarfinkel . suffixTree . Sequence < java . lang . Character , com . maxgarfinkel . suffixTree . Word > sequence = new com . maxgarfinkel . suffixTree . Sequence < java . lang . Character , com . maxgarfinkel . suffixTree . Word > ( word ) ; for ( int i = 0 ; i < ( ( sequence . getLength ( ) ) - 1 ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( ( ( java . lang . Character ) ( sequence . getItem ( i ) ) ) , org . hamcrest . CoreMatchers . is ( characters [ i ] ) )", "total": "getItemRetrievesCorrectItem ( ) { com . maxgarfinkel . suffixTree . Word word = new com . maxgarfinkel . suffixTree . Word ( \"Test<sp>word\" ) ; char [ ] characters = new char [ ] { 'T' , 'e' , 's' , 't' , '<sp>' , 'w' , 'o' , 'r' , 'd' } ; com . maxgarfinkel . suffixTree . Sequence < java . lang . Character , com . maxgarfinkel . suffixTree . Word > sequence = new com . maxgarfinkel . suffixTree . Sequence < java . lang . Character , com . maxgarfinkel . suffixTree . Word > ( word ) ; for ( int i = 0 ; i < ( ( sequence . getLength ( ) ) - 1 ) ; i ++ ) { \"<AssertPlaceHolder>\" ; } } getItem ( int ) { return masterSequence . get ( index ) ; }", "answer": "org . junit . Assert . assertThat ( ( ( java . lang . Character ) ( sequence . getItem ( i ) ) ) , org . hamcrest . CoreMatchers . is ( characters [ i ] ) )"}
{"focal": "getMeasurementStreams ( ) { return streams . values ( ) ; }", "testMethod": "shouldSkipMeasurementsFromDisabledStreams ( ) { currentSessionManager . state . recording ( ) . startRecording ( ) ; when ( sensor . isEnabled ( ) ) . thenReturn ( false ) ; triggerMeasurement ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( currentSessionManager . getMeasurementStreams ( ) . isEmpty ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "shouldSkipMeasurementsFromDisabledStreams ( ) { currentSessionManager . state . recording ( ) . startRecording ( ) ; when ( sensor . isEnabled ( ) ) . thenReturn ( false ) ; triggerMeasurement ( ) ; \"<AssertPlaceHolder>\" ; } getMeasurementStreams ( ) { return streams . values ( ) ; }", "answer": "org . junit . Assert . assertThat ( currentSessionManager . getMeasurementStreams ( ) . isEmpty ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "get ( ) { slim3 . demo . model . Blog blog = new slim3 . demo . model . Blog ( ) ; org . slim3 . datastore . Datastore . put ( blog ) ; org . junit . Assert . assertThat ( service . get ( blog . getKey ( ) , blog . getVersion ( ) ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "testMethod": "getAsyncUsingModelMeta ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . DatastoreUtil . put ( ds , null , new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . model . Hoge model = delegate . getAsync ( ( ( com . google . appengine . api . datastore . Transaction ) ( null ) ) , meta , key ) . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) )", "total": "getAsyncUsingModelMeta ( ) { com . google . appengine . api . datastore . Key key = org . slim3 . datastore . DatastoreUtil . put ( ds , null , new com . google . appengine . api . datastore . Entity ( \"Hoge\" ) ) ; org . slim3 . datastore . model . Hoge model = delegate . getAsync ( ( ( com . google . appengine . api . datastore . Transaction ) ( null ) ) , meta , key ) . get ( ) ; \"<AssertPlaceHolder>\" ; } get ( ) { slim3 . demo . model . Blog blog = new slim3 . demo . model . Blog ( ) ; org . slim3 . datastore . Datastore . put ( blog ) ; org . junit . Assert . assertThat ( service . get ( blog . getKey ( ) , blog . getVersion ( ) ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( model , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) )"}
{"focal": "getFilters ( ) { return filters ; }", "testMethod": "testStartsEmptyWhenConfigured ( ) { org . ehcache . sizeof . SizeOfFilterSource source = new org . ehcache . sizeof . SizeOfFilterSource ( false ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( source . getFilters ( ) . length , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "testStartsEmptyWhenConfigured ( ) { org . ehcache . sizeof . SizeOfFilterSource source = new org . ehcache . sizeof . SizeOfFilterSource ( false ) ; \"<AssertPlaceHolder>\" ; } getFilters ( ) { return filters ; }", "answer": "org . junit . Assert . assertThat ( source . getFilters ( ) . length , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getOrNull ( ) { return null ; }", "testMethod": "map_A$Function1 ( ) { java . lang . String value = \"vvv\" ; com . m3 . scalaflavor4j . Some < java . lang . String > target = new com . m3 . scalaflavor4j . Some < java . lang . String > ( value ) ; com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . String > f = new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . String > ( ) { @ com . m3 . scalaflavor4j . Override public java . lang . String apply ( java . lang . String v1 ) { return v1 ; } } ; com . m3 . scalaflavor4j . Option < java . lang . String > actual = target . map ( f ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . getOrNull ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"vvv\" ) ) )", "total": "map_A$Function1 ( ) { java . lang . String value = \"vvv\" ; com . m3 . scalaflavor4j . Some < java . lang . String > target = new com . m3 . scalaflavor4j . Some < java . lang . String > ( value ) ; com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . String > f = new com . m3 . scalaflavor4j . F1 < java . lang . String , java . lang . String > ( ) { @ com . m3 . scalaflavor4j . Override public java . lang . String apply ( java . lang . String v1 ) { return v1 ; } } ; com . m3 . scalaflavor4j . Option < java . lang . String > actual = target . map ( f ) ; \"<AssertPlaceHolder>\" ; } getOrNull ( ) { return null ; }", "answer": "org . junit . Assert . assertThat ( actual . getOrNull ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"vvv\" ) ) )"}
{"focal": "toAmazonS3URI ( java . net . URI ) { if ( com . hotels . bdp . circustrain . s3s3copier . aws . FS_PROTOCOL_S3 . equalsIgnoreCase ( uri . getScheme ( ) ) ) { return new com . amazonaws . services . s3 . AmazonS3URI ( uri ) ; } else if ( com . hotels . bdp . circustrain . aws . S3Schemes . isS3Scheme ( uri . getScheme ( ) ) ) { try { return new com . amazonaws . services . s3 . AmazonS3URI ( new java . net . URI ( FS_PROTOCOL_S3 , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , uri . getQuery ( ) , uri . getFragment ( ) ) ) ; } catch ( java . net . URISyntaxException e ) { } } return new com . amazonaws . services . s3 . AmazonS3URI ( uri ) ; }", "testMethod": "toAmazonS3URISchemeIsS3n ( ) { com . amazonaws . services . s3 . AmazonS3URI result = com . hotels . bdp . circustrain . s3s3copier . aws . AmazonS3URIs . toAmazonS3URI ( new java . net . URI ( \"s3n://a/b\" ) ) ; com . amazonaws . services . s3 . AmazonS3URI expected = new com . amazonaws . services . s3 . AmazonS3URI ( \"s3://a/b\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "toAmazonS3URISchemeIsS3n ( ) { com . amazonaws . services . s3 . AmazonS3URI result = com . hotels . bdp . circustrain . s3s3copier . aws . AmazonS3URIs . toAmazonS3URI ( new java . net . URI ( \"s3n://a/b\" ) ) ; com . amazonaws . services . s3 . AmazonS3URI expected = new com . amazonaws . services . s3 . AmazonS3URI ( \"s3://a/b\" ) ; \"<AssertPlaceHolder>\" ; } toAmazonS3URI ( java . net . URI ) { if ( com . hotels . bdp . circustrain . s3s3copier . aws . FS_PROTOCOL_S3 . equalsIgnoreCase ( uri . getScheme ( ) ) ) { return new com . amazonaws . services . s3 . AmazonS3URI ( uri ) ; } else if ( com . hotels . bdp . circustrain . aws . S3Schemes . isS3Scheme ( uri . getScheme ( ) ) ) { try { return new com . amazonaws . services . s3 . AmazonS3URI ( new java . net . URI ( FS_PROTOCOL_S3 , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , uri . getQuery ( ) , uri . getFragment ( ) ) ) ; } catch ( java . net . URISyntaxException e ) { } } return new com . amazonaws . services . s3 . AmazonS3URI ( uri ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "testMethod": "parseFileList ( ) { java . io . File a = folder . newFile ( \"a.properties\" ) . getCanonicalFile ( ) ; java . io . File b = folder . newFile ( \"c.properties\" ) . getCanonicalFile ( ) ; java . io . File c = folder . newFile ( \"b.properties\" ) . getCanonicalFile ( ) ; java . lang . StringBuilder buf = new java . lang . StringBuilder ( ) ; buf . append ( a ) ; buf . append ( File . pathSeparatorChar ) ; buf . append ( b ) ; buf . append ( File . pathSeparatorChar ) ; buf . append ( c ) ; java . util . List < java . io . File > result = canonicalize ( com . asakusafw . yaess . bootstrap . CommandLineUtil . parseFileList ( buf . toString ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , is ( java . util . Arrays . asList ( a , b , c ) ) )", "total": "parseFileList ( ) { java . io . File a = folder . newFile ( \"a.properties\" ) . getCanonicalFile ( ) ; java . io . File b = folder . newFile ( \"c.properties\" ) . getCanonicalFile ( ) ; java . io . File c = folder . newFile ( \"b.properties\" ) . getCanonicalFile ( ) ; java . lang . StringBuilder buf = new java . lang . StringBuilder ( ) ; buf . append ( a ) ; buf . append ( File . pathSeparatorChar ) ; buf . append ( b ) ; buf . append ( File . pathSeparatorChar ) ; buf . append ( c ) ; java . util . List < java . io . File > result = canonicalize ( com . asakusafw . yaess . bootstrap . CommandLineUtil . parseFileList ( buf . toString ( ) ) ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . CharSequence , int , char ) { return ( string . charAt ( column ) ) == value ; }", "answer": "org . junit . Assert . assertThat ( result , is ( java . util . Arrays . asList ( a , b , c ) ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "loadProperties_classpath ( ) { java . lang . String className = getClass ( ) . getName ( ) ; java . lang . String packageName = className . substring ( 0 , className . lastIndexOf ( '.' ) ) ; java . net . URI uri = new java . net . URI ( ( ( \"classpath:\" + ( packageName . replace ( '.' , '/' ) ) ) + \"/loadProperties.properties\" ) ) ; java . util . Properties loaded = com . asakusafw . windgate . cli . CommandLineUtil . loadProperties ( uri , getClass ( ) . getClassLoader ( ) ) ; java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( \"hello\" , \"world!\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( loaded , is ( p ) )", "total": "loadProperties_classpath ( ) { java . lang . String className = getClass ( ) . getName ( ) ; java . lang . String packageName = className . substring ( 0 , className . lastIndexOf ( '.' ) ) ; java . net . URI uri = new java . net . URI ( ( ( \"classpath:\" + ( packageName . replace ( '.' , '/' ) ) ) + \"/loadProperties.properties\" ) ) ; java . util . Properties loaded = com . asakusafw . windgate . cli . CommandLineUtil . loadProperties ( uri , getClass ( ) . getClassLoader ( ) ) ; java . util . Properties p = new java . util . Properties ( ) ; p . setProperty ( \"hello\" , \"world!\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( loaded , is ( p ) )"}
{"focal": "getMeasurand ( ) { return measurand ; }", "testMethod": "setMeasurand_energyReactiveExportInterval_measurandIsSet ( ) { java . lang . String measurand = \"Energy.Reactive.Export.Interval\" ; sampledValue . setMeasurand ( measurand ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sampledValue . getMeasurand ( ) , org . hamcrest . CoreMatchers . equalTo ( measurand ) )", "total": "setMeasurand_energyReactiveExportInterval_measurandIsSet ( ) { java . lang . String measurand = \"Energy.Reactive.Export.Interval\" ; sampledValue . setMeasurand ( measurand ) ; \"<AssertPlaceHolder>\" ; } getMeasurand ( ) { return measurand ; }", "answer": "org . junit . Assert . assertThat ( sampledValue . getMeasurand ( ) , org . hamcrest . CoreMatchers . equalTo ( measurand ) )"}
{"focal": "getAllQuestionGroups ( org . springframework . ui . ModelMap , javax . servlet . http . HttpServletRequest ) { java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > questionGroups = questionnaireServiceFacade . getAllQuestionGroups ( ) ; model . addAttribute ( \"questionGroups\" , groupByEventSource ( questionGroups ) ) ; return \"viewQuestionGroups\" ; }", "testMethod": "shouldGetAllQuestionGroups ( ) { org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail1 = getQuestionGroupDetail ( 1 , ( ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) + \"sectionName2\" 0 ) , \"View\" , \"Loan\" , true , true , \"title1\" , \"sectionName1\" ) ; org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail2 = getQuestionGroupDetail ( 2 , ( ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) + \"sectionName2\" 1 ) , \"View\" , \"Loan\" , true , true , \"sectionName2\" 5 , \"sectionName2\" ) ; org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail3 = getQuestionGroupDetail ( 3 , ( ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) + \"3\" ) , \"sectionName2\" 2 , \"Loan\" , true , true , \"title3\" , \"sectionName3\" ) ; java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > questionGroupDetails = asList ( questionGroupDetail1 , questionGroupDetail2 , questionGroupDetail3 ) ; java . util . Map < java . lang . String , java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > > questionGroupsCategoriesSplit = new java . util . HashMap < java . lang . String , java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > > ( ) ; questionGroupsCategoriesSplit . put ( \"sectionName2\" 3 , asList ( questionGroupDetail1 , questionGroupDetail2 ) ) ; questionGroupsCategoriesSplit . put ( \"sectionName2\" 4 , asList ( questionGroupDetail3 ) ) ; when ( questionnaireServiceFacade . getAllQuestionGroups ( ) ) . thenReturn ( questionGroupDetails ) ; when ( questionnaireServiceFacade . getAllEventSources ( ) ) . thenReturn ( asList ( questionGroupDetail2 . getEventSources ( ) . get ( 0 ) , questionGroupDetail3 . getEventSources ( ) . get ( 0 ) ) ) ; java . lang . String view = questionGroupController . getAllQuestionGroups ( model , httpServletRequest ) ; \"<AssertPlaceHolder>\" ; verify ( questionnaireServiceFacade ) . getAllQuestionGroups ( ) ; verify ( questionnaireServiceFacade ) . getAllEventSources ( ) ; verify ( model ) . addAttribute ( org . mockito . Matchers . eq ( \"questionGroups\" ) , argThat ( new org . mifos . platform . questionnaire . matchers . QuestionGroupsGroupByEventSourceMatcher ( questionGroupsCategoriesSplit ) ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( view , org . hamcrest . core . Is . is ( \"viewQuestionGroups\" ) )", "total": "shouldGetAllQuestionGroups ( ) { org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail1 = getQuestionGroupDetail ( 1 , ( ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) + \"sectionName2\" 0 ) , \"View\" , \"Loan\" , true , true , \"title1\" , \"sectionName1\" ) ; org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail2 = getQuestionGroupDetail ( 2 , ( ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) + \"sectionName2\" 1 ) , \"View\" , \"Loan\" , true , true , \"sectionName2\" 5 , \"sectionName2\" ) ; org . mifos . platform . questionnaire . service . QuestionGroupDetail questionGroupDetail3 = getQuestionGroupDetail ( 3 , ( ( org . mifos . platform . questionnaire . ui . controller . QuestionGroupControllerTest . TITLE ) + \"3\" ) , \"sectionName2\" 2 , \"Loan\" , true , true , \"title3\" , \"sectionName3\" ) ; java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > questionGroupDetails = asList ( questionGroupDetail1 , questionGroupDetail2 , questionGroupDetail3 ) ; java . util . Map < java . lang . String , java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > > questionGroupsCategoriesSplit = new java . util . HashMap < java . lang . String , java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > > ( ) ; questionGroupsCategoriesSplit . put ( \"sectionName2\" 3 , asList ( questionGroupDetail1 , questionGroupDetail2 ) ) ; questionGroupsCategoriesSplit . put ( \"sectionName2\" 4 , asList ( questionGroupDetail3 ) ) ; when ( questionnaireServiceFacade . getAllQuestionGroups ( ) ) . thenReturn ( questionGroupDetails ) ; when ( questionnaireServiceFacade . getAllEventSources ( ) ) . thenReturn ( asList ( questionGroupDetail2 . getEventSources ( ) . get ( 0 ) , questionGroupDetail3 . getEventSources ( ) . get ( 0 ) ) ) ; java . lang . String view = questionGroupController . getAllQuestionGroups ( model , httpServletRequest ) ; \"<AssertPlaceHolder>\" ; verify ( questionnaireServiceFacade ) . getAllQuestionGroups ( ) ; verify ( questionnaireServiceFacade ) . getAllEventSources ( ) ; verify ( model ) . addAttribute ( org . mockito . Matchers . eq ( \"questionGroups\" ) , argThat ( new org . mifos . platform . questionnaire . matchers . QuestionGroupsGroupByEventSourceMatcher ( questionGroupsCategoriesSplit ) ) ) ; } getAllQuestionGroups ( org . springframework . ui . ModelMap , javax . servlet . http . HttpServletRequest ) { java . util . List < org . mifos . platform . questionnaire . service . QuestionGroupDetail > questionGroups = questionnaireServiceFacade . getAllQuestionGroups ( ) ; model . addAttribute ( \"questionGroups\" , groupByEventSource ( questionGroups ) ) ; return \"viewQuestionGroups\" ; }", "answer": "org . junit . Assert . assertThat ( view , org . hamcrest . core . Is . is ( \"viewQuestionGroups\" ) )"}
{"focal": "next ( ) { return ( index ) < ( org . modeshape . schematic . internal . document . IndexSequence . MAXIMUM_KEY_COUNT ) ? org . modeshape . schematic . internal . document . IndexSequence . INDEX_VALUES [ ( ( index ) ++ ) ] : java . lang . String . valueOf ( ( ( index ) ++ ) ) ; }", "testMethod": "shouldCreateIteratorOverValuesWhenSuppliedIteratorOfUnknownObjects ( ) { java . util . List < java . lang . String > values = new java . util . ArrayList < java . lang . String > ( ) ; for ( int i = 0 ; i != 10 ; ++ i ) values . add ( ( \"\" + i ) ) ; java . util . Iterator < java . lang . Double > iter = factory . create ( values . iterator ( ) ) ; java . util . Iterator < java . lang . String > valueIter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( iter . next ( ) , org . hamcrest . core . Is . is ( factory . create ( valueIter . next ( ) ) ) )", "total": "shouldCreateIteratorOverValuesWhenSuppliedIteratorOfUnknownObjects ( ) { java . util . List < java . lang . String > values = new java . util . ArrayList < java . lang . String > ( ) ; for ( int i = 0 ; i != 10 ; ++ i ) values . add ( ( \"\" + i ) ) ; java . util . Iterator < java . lang . Double > iter = factory . create ( values . iterator ( ) ) ; java . util . Iterator < java . lang . String > valueIter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { \"<AssertPlaceHolder>\" ; } } next ( ) { return ( index ) < ( org . modeshape . schematic . internal . document . IndexSequence . MAXIMUM_KEY_COUNT ) ? org . modeshape . schematic . internal . document . IndexSequence . INDEX_VALUES [ ( ( index ) ++ ) ] : java . lang . String . valueOf ( ( ( index ) ++ ) ) ; }", "answer": "org . junit . Assert . assertThat ( iter . next ( ) , org . hamcrest . core . Is . is ( factory . create ( valueIter . next ( ) ) ) )"}
{"focal": "databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "testMethod": "empty_expected_table_and_empty_database_table_should_be_equal ( ) { createTable ( getDynamoDB ( ) , \"col1\" , \"id\" ) ; boolean isEquals = com . lordofthejars . nosqlunit . dynamodb . integration . WhenExpectedDataShouldBeCompared . dynamoOperation . databaseIs ( new java . io . ByteArrayInputStream ( \"{\\\"col1\\\":[]}\" . getBytes ( \"UTF-8\" ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isEquals , org . hamcrest . CoreMatchers . is ( true ) )", "total": "empty_expected_table_and_empty_database_table_should_be_equal ( ) { createTable ( getDynamoDB ( ) , \"col1\" , \"id\" ) ; boolean isEquals = com . lordofthejars . nosqlunit . dynamodb . integration . WhenExpectedDataShouldBeCompared . dynamoOperation . databaseIs ( new java . io . ByteArrayInputStream ( \"{\\\"col1\\\":[]}\" . getBytes ( \"UTF-8\" ) ) ) ; \"<AssertPlaceHolder>\" ; } databaseIs ( java . io . InputStream ) { return compareData ( contentStream ) ; }", "answer": "org . junit . Assert . assertThat ( isEquals , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getLastActivity ( ) { if ( ( ( getStages ( ) ) == null ) || ( getStages ( ) . isEmpty ( ) ) ) { return 0 ; } long result = 0 ; for ( se . diabol . jenkins . workflow . model . Stage stage : getStages ( ) ) { for ( se . diabol . jenkins . workflow . model . Task task : stage . getTasks ( ) ) { if ( ( task . getStatus ( ) . getLastActivity ( ) ) > result ) { result = task . getStatus ( ) . getLastActivity ( ) ; } } } return result ; }", "testMethod": "shouldGetLastActivity ( ) { final long latestActivity = java . lang . System . currentTimeMillis ( ) ; se . diabol . jenkins . core . GenericPipeline first = new se . diabol . jenkins . core . GenericPipeline ( \"\" ) { @ se . diabol . jenkins . core . Override public long getLastActivity ( ) { return 1000 ; } } ; se . diabol . jenkins . core . GenericPipeline second = new se . diabol . jenkins . core . GenericPipeline ( \"\" ) { @ se . diabol . jenkins . core . Override public long getLastActivity ( ) { return 2000 ; } } ; se . diabol . jenkins . core . GenericPipeline third = new se . diabol . jenkins . core . GenericPipeline ( \"\" ) { @ se . diabol . jenkins . core . Override public long getLastActivity ( ) { return latestActivity ; } } ; se . diabol . jenkins . core . GenericComponent component = new se . diabol . jenkins . core . GenericComponent ( \"component\" ) { @ se . diabol . jenkins . core . Override public java . util . List < ? extends se . diabol . jenkins . core . GenericPipeline > getPipelines ( ) { return java . util . Arrays . asList ( first , second , third ) ; } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( component . getLastActivity ( ) , org . hamcrest . core . Is . is ( latestActivity ) )", "total": "shouldGetLastActivity ( ) { final long latestActivity = java . lang . System . currentTimeMillis ( ) ; se . diabol . jenkins . core . GenericPipeline first = new se . diabol . jenkins . core . GenericPipeline ( \"\" ) { @ se . diabol . jenkins . core . Override public long getLastActivity ( ) { return 1000 ; } } ; se . diabol . jenkins . core . GenericPipeline second = new se . diabol . jenkins . core . GenericPipeline ( \"\" ) { @ se . diabol . jenkins . core . Override public long getLastActivity ( ) { return 2000 ; } } ; se . diabol . jenkins . core . GenericPipeline third = new se . diabol . jenkins . core . GenericPipeline ( \"\" ) { @ se . diabol . jenkins . core . Override public long getLastActivity ( ) { return latestActivity ; } } ; se . diabol . jenkins . core . GenericComponent component = new se . diabol . jenkins . core . GenericComponent ( \"component\" ) { @ se . diabol . jenkins . core . Override public java . util . List < ? extends se . diabol . jenkins . core . GenericPipeline > getPipelines ( ) { return java . util . Arrays . asList ( first , second , third ) ; } } ; \"<AssertPlaceHolder>\" ; } getLastActivity ( ) { if ( ( ( getStages ( ) ) == null ) || ( getStages ( ) . isEmpty ( ) ) ) { return 0 ; } long result = 0 ; for ( se . diabol . jenkins . workflow . model . Stage stage : getStages ( ) ) { for ( se . diabol . jenkins . workflow . model . Task task : stage . getTasks ( ) ) { if ( ( task . getStatus ( ) . getLastActivity ( ) ) > result ) { result = task . getStatus ( ) . getLastActivity ( ) ; } } } return result ; }", "answer": "org . junit . Assert . assertThat ( component . getLastActivity ( ) , org . hamcrest . core . Is . is ( latestActivity ) )"}
{"focal": "size ( ) { return columns . size ( ) ; }", "testMethod": "testAddPropertyWithSameName_shouldLeaveListUnchanged ( ) { tester . startPage ( new org . openengsb . ui . admin . connectorEditorPage . ConnectorEditorPage ( \"testdomain\" , \"testconnector\" ) ) ; org . apache . wicket . util . tester . FormTester formTester = tester . newFormTester ( \"bar\" 2 ) ; formTester . setValue ( \"bar\" 4 , \"bar\" 5 ) ; org . apache . wicket . ajax . markup . html . form . AjaxButton newPropertyButton = ( ( org . apache . wicket . ajax . markup . html . form . AjaxButton ) ( tester . getComponentFromLastRenderedPage ( \"editor:form:addProperty\" ) ) ) ; formTester . setValue ( \"newPropertyKey\" , \"bar\" 6 ) ; tester . executeAjaxEvent ( newPropertyButton , \"bar\" 0 ) ; tester . executeAjaxEvent ( \"bar\" 3 , \"bar\" 0 ) ; formTester . setValue ( \"attributesPanel:properties:0:values:1:value:editor\" , \"foo\" ) ; tester . executeAjaxEvent ( \"editor:form:attributesPanel:properties:0:newArrayEntry\" , \"bar\" 0 ) ; tester . executeAjaxEvent ( \"editor:form:attributesPanel:properties:0:values:2:value:label\" , \"bar\" 0 ) ; formTester . setValue ( \"attributesPanel:properties:0:values:2:value:editor\" , \"bar\" ) ; formTester . setValue ( \"newPropertyKey\" , \"bar\" 6 ) ; tester . executeAjaxEvent ( newPropertyButton , \"bar\" 0 ) ; org . apache . wicket . markup . repeater . AbstractRepeater list = ( ( org . apache . wicket . markup . repeater . AbstractRepeater ) ( tester . getComponentFromLastRenderedPage ( \"bar\" 1 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "testAddPropertyWithSameName_shouldLeaveListUnchanged ( ) { tester . startPage ( new org . openengsb . ui . admin . connectorEditorPage . ConnectorEditorPage ( \"testdomain\" , \"testconnector\" ) ) ; org . apache . wicket . util . tester . FormTester formTester = tester . newFormTester ( \"bar\" 2 ) ; formTester . setValue ( \"bar\" 4 , \"bar\" 5 ) ; org . apache . wicket . ajax . markup . html . form . AjaxButton newPropertyButton = ( ( org . apache . wicket . ajax . markup . html . form . AjaxButton ) ( tester . getComponentFromLastRenderedPage ( \"editor:form:addProperty\" ) ) ) ; formTester . setValue ( \"newPropertyKey\" , \"bar\" 6 ) ; tester . executeAjaxEvent ( newPropertyButton , \"bar\" 0 ) ; tester . executeAjaxEvent ( \"bar\" 3 , \"bar\" 0 ) ; formTester . setValue ( \"attributesPanel:properties:0:values:1:value:editor\" , \"foo\" ) ; tester . executeAjaxEvent ( \"editor:form:attributesPanel:properties:0:newArrayEntry\" , \"bar\" 0 ) ; tester . executeAjaxEvent ( \"editor:form:attributesPanel:properties:0:values:2:value:label\" , \"bar\" 0 ) ; formTester . setValue ( \"attributesPanel:properties:0:values:2:value:editor\" , \"bar\" ) ; formTester . setValue ( \"newPropertyKey\" , \"bar\" 6 ) ; tester . executeAjaxEvent ( newPropertyButton , \"bar\" 0 ) ; org . apache . wicket . markup . repeater . AbstractRepeater list = ( ( org . apache . wicket . markup . repeater . AbstractRepeater ) ( tester . getComponentFromLastRenderedPage ( \"bar\" 1 ) ) ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return columns . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( list . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "getDeviceId ( ) { return this . deviceId ; }", "testMethod": "getDeviceIdReturnsDeviceId ( ) { final java . lang . String iotHubHostname = \"test.iothubhostname\" ; final java . lang . String deviceId = \"test-deviceid\" ; final java . lang . String deviceKey = \"test-devicekey\" ; final java . lang . String sharedAccessToken = null ; new tests . unit . com . microsoft . azure . sdk . iot . device . NonStrictExpectations ( ) { { new tests . unit . com . microsoft . azure . sdk . iot . device . IotHubSasTokenSoftwareAuthenticationProvider ( anyString , anyString , anyString , anyString , anyString , anyString ) ; result = mockSasTokenSoftwareAuthentication ; mockSasTokenSoftwareAuthentication . getDeviceId ( ) ; result = deviceId ; } } ; tests . unit . com . microsoft . azure . sdk . iot . device . DeviceClientConfig config = tests . unit . com . microsoft . azure . sdk . iot . device . Deencapsulation . newInstance ( tests . unit . com . microsoft . azure . sdk . iot . device . DeviceClientConfig . class , mockIotHubConnectionString ) ; java . lang . String testDeviceId = config . getDeviceId ( ) ; final java . lang . String expectedDeviceId = deviceId ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( testDeviceId , org . hamcrest . CoreMatchers . is ( expectedDeviceId ) )", "total": "getDeviceIdReturnsDeviceId ( ) { final java . lang . String iotHubHostname = \"test.iothubhostname\" ; final java . lang . String deviceId = \"test-deviceid\" ; final java . lang . String deviceKey = \"test-devicekey\" ; final java . lang . String sharedAccessToken = null ; new tests . unit . com . microsoft . azure . sdk . iot . device . NonStrictExpectations ( ) { { new tests . unit . com . microsoft . azure . sdk . iot . device . IotHubSasTokenSoftwareAuthenticationProvider ( anyString , anyString , anyString , anyString , anyString , anyString ) ; result = mockSasTokenSoftwareAuthentication ; mockSasTokenSoftwareAuthentication . getDeviceId ( ) ; result = deviceId ; } } ; tests . unit . com . microsoft . azure . sdk . iot . device . DeviceClientConfig config = tests . unit . com . microsoft . azure . sdk . iot . device . Deencapsulation . newInstance ( tests . unit . com . microsoft . azure . sdk . iot . device . DeviceClientConfig . class , mockIotHubConnectionString ) ; java . lang . String testDeviceId = config . getDeviceId ( ) ; final java . lang . String expectedDeviceId = deviceId ; \"<AssertPlaceHolder>\" ; } getDeviceId ( ) { return this . deviceId ; }", "answer": "org . junit . Assert . assertThat ( testDeviceId , org . hamcrest . CoreMatchers . is ( expectedDeviceId ) )"}
{"focal": "isPresent ( java . lang . String ) { if ( com . navercorp . volleyextensions . volleyer . util . StringUtils . isEmpty ( clazzName ) ) { return false ; } boolean isPresent ; try { @ com . navercorp . volleyextensions . volleyer . util . SuppressWarnings ( \"unused\" ) java . lang . Class < ? > clazz = java . lang . Class . forName ( clazzName ) ; isPresent = true ; } catch ( java . lang . ClassNotFoundException e ) { isPresent = false ; } return isPresent ; }", "testMethod": "shouldReturnFalseWhenClassNameNull ( ) { boolean isPresent = com . navercorp . volleyextensions . volleyer . util . ClassUtils . isPresent ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isPresent , org . hamcrest . CoreMatchers . is ( false ) )", "total": "shouldReturnFalseWhenClassNameNull ( ) { boolean isPresent = com . navercorp . volleyextensions . volleyer . util . ClassUtils . isPresent ( null ) ; \"<AssertPlaceHolder>\" ; } isPresent ( java . lang . String ) { if ( com . navercorp . volleyextensions . volleyer . util . StringUtils . isEmpty ( clazzName ) ) { return false ; } boolean isPresent ; try { @ com . navercorp . volleyextensions . volleyer . util . SuppressWarnings ( \"unused\" ) java . lang . Class < ? > clazz = java . lang . Class . forName ( clazzName ) ; isPresent = true ; } catch ( java . lang . ClassNotFoundException e ) { isPresent = false ; } return isPresent ; }", "answer": "org . junit . Assert . assertThat ( isPresent , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testEquality ( ) { org . onosproject . routing . bgp . BgpRouteEntry . PathSegment pathSegment1 = generatePathSegment ( ) ; org . onosproject . routing . bgp . BgpRouteEntry . PathSegment pathSegment2 = generatePathSegment ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( pathSegment1 , org . hamcrest . Matchers . is ( pathSegment2 ) )", "total": "testEquality ( ) { org . onosproject . routing . bgp . BgpRouteEntry . PathSegment pathSegment1 = generatePathSegment ( ) ; org . onosproject . routing . bgp . BgpRouteEntry . PathSegment pathSegment2 = generatePathSegment ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( pathSegment1 , org . hamcrest . Matchers . is ( pathSegment2 ) )"}
{"focal": "build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "testMethod": "input_header ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withHeaderType ( HeaderType . FORCE ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" } } ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"C\" , \"D\" } } ) )", "total": "input_header ( ) { com . asakusafw . runtime . io . text . driver . RecordDefinition < java . lang . String [ ] > def = com . asakusafw . runtime . io . text . driver . RecordDefinition . builder ( java . lang . String [ ] . class ) . withHeaderType ( HeaderType . FORCE ) . withField ( self ( ) , field ( 0 ) . build ( ) ) . withField ( self ( ) , field ( 1 ) . build ( ) ) . build ( ) ; java . lang . String [ ] [ ] results = collect ( def , new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"A\" , \"B\" } , new java . lang . String [ ] { \"C\" , \"D\" } } ) ; \"<AssertPlaceHolder>\" ; } build ( ) { if ( ( row ) != null ) { entity . add ( row ) ; row = null ; } return new com . asakusafw . iterative . common . basic . BasicParameterTable ( entity ) ; }", "answer": "org . junit . Assert . assertThat ( results , is ( new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"C\" , \"D\" } } ) )"}
{"focal": "getNameWithClass ( ) { return ( ( getDeclaredClass ( ) . getName ( ) ) + \"#\" ) + ( getName ( ) ) ; }", "testMethod": "testGetNameWithClass ( ) { java . lang . reflect . Field field = com . github . mygreen . supercsv . builder . FieldAccessorTest . SampleBean . class . getDeclaredField ( \"col1\" ) ; com . github . mygreen . supercsv . builder . FieldAccessor property = new com . github . mygreen . supercsv . builder . FieldAccessor ( field , comparator ) ; \"<AssertPlaceHolder>\" . isEqualTo ( ( ( com . github . mygreen . supercsv . builder . FieldAccessorTest . SampleBean . class . getName ( ) ) + \"#col1\" ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( property . getNameWithClass ( ) )", "total": "testGetNameWithClass ( ) { java . lang . reflect . Field field = com . github . mygreen . supercsv . builder . FieldAccessorTest . SampleBean . class . getDeclaredField ( \"col1\" ) ; com . github . mygreen . supercsv . builder . FieldAccessor property = new com . github . mygreen . supercsv . builder . FieldAccessor ( field , comparator ) ; \"<AssertPlaceHolder>\" . isEqualTo ( ( ( com . github . mygreen . supercsv . builder . FieldAccessorTest . SampleBean . class . getName ( ) ) + \"#col1\" ) ) ; } getNameWithClass ( ) { return ( ( getDeclaredClass ( ) . getName ( ) ) + \"#\" ) + ( getName ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( property . getNameWithClass ( ) )"}
{"focal": "get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "testMethod": "write ( ) { com . asakusafw . runtime . value . DecimalOption option = new com . asakusafw . runtime . value . DecimalOption ( ) ; option . modify ( decimal ( \"3.14\" ) ) ; com . asakusafw . runtime . value . DecimalOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )", "total": "write ( ) { com . asakusafw . runtime . value . DecimalOption option = new com . asakusafw . runtime . value . DecimalOption ( ) ; option . modify ( decimal ( \"3.14\" ) ) ; com . asakusafw . runtime . value . DecimalOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } get ( ) { if ( canGet ) { return next ; } throw new java . io . IOException ( ) ; }", "answer": "org . junit . Assert . assertThat ( restored . get ( ) , is ( option . get ( ) ) )"}
{"focal": "contains ( E [ ] ) { return org . hamcrest . Matchers . Matchers . contains ( items ) ; }", "testMethod": "escape_crlf ( ) { java . util . List < java . lang . String > results = com . asakusafw . runtime . io . text . tabular . LineCursorTest . parse ( '\\\\' , false , \"Hello\\\\\\r\\nworld\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , contains ( \"Hello\\\\\\r\\nworld\" ) )", "total": "escape_crlf ( ) { java . util . List < java . lang . String > results = com . asakusafw . runtime . io . text . tabular . LineCursorTest . parse ( '\\\\' , false , \"Hello\\\\\\r\\nworld\" ) ; \"<AssertPlaceHolder>\" ; } contains ( E [ ] ) { return org . hamcrest . Matchers . Matchers . contains ( items ) ; }", "answer": "org . junit . Assert . assertThat ( results , contains ( \"Hello\\\\\\r\\nworld\" ) )"}
{"focal": "isPresent ( ) { return _present ; }", "testMethod": "testOptionalPortWithDefaultWithUnknown ( ) { java . net . URI uri = java . net . URI . create ( \"unknown://server.example.org/foo\" ) ; java . util . Optional < java . lang . Integer > port = org . dcache . util . URIs . optionalPortWithDefault ( uri ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( port . isPresent ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( false ) ) )", "total": "testOptionalPortWithDefaultWithUnknown ( ) { java . net . URI uri = java . net . URI . create ( \"unknown://server.example.org/foo\" ) ; java . util . Optional < java . lang . Integer > port = org . dcache . util . URIs . optionalPortWithDefault ( uri ) ; \"<AssertPlaceHolder>\" ; } isPresent ( ) { return _present ; }", "answer": "org . junit . Assert . assertThat ( port . isPresent ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( false ) ) )"}
{"focal": "getBaseImage ( java . lang . Class ) { return baseImages . getBaseImage ( applicationClass ) ; }", "testMethod": "shouldGetBaseImageIfDirectMatch ( ) { java . lang . String image = \"oraclelinux:7.1\" ; com . oracle . bedrock . runtime . docker . options . DockerDefaultBaseImages tree = new com . oracle . bedrock . runtime . docker . options . DockerDefaultBaseImages ( com . oracle . bedrock . runtime . Application . class , image ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tree . getBaseImage ( com . oracle . bedrock . runtime . Application . class ) , org . hamcrest . CoreMatchers . is ( image ) )", "total": "shouldGetBaseImageIfDirectMatch ( ) { java . lang . String image = \"oraclelinux:7.1\" ; com . oracle . bedrock . runtime . docker . options . DockerDefaultBaseImages tree = new com . oracle . bedrock . runtime . docker . options . DockerDefaultBaseImages ( com . oracle . bedrock . runtime . Application . class , image ) ; \"<AssertPlaceHolder>\" ; } getBaseImage ( java . lang . Class ) { return baseImages . getBaseImage ( applicationClass ) ; }", "answer": "org . junit . Assert . assertThat ( tree . getBaseImage ( com . oracle . bedrock . runtime . Application . class ) , org . hamcrest . CoreMatchers . is ( image ) )"}
{"focal": "getDependencies ( ) { java . util . List < ch . jalu . injector . context . ObjectIdentifier > depList = ( ( dependencies ) == null ) ? null : dependencies . get ( ) ; if ( depList == null ) { java . util . List < ch . jalu . injector . context . ObjectIdentifier > constructorDeps = buildConstructorDependencies ( ) ; java . util . List < ch . jalu . injector . context . ObjectIdentifier > fieldDeps = buildFieldDependencies ( ) ; depList = new java . util . ArrayList ( ( ( constructorDeps . size ( ) ) + ( fieldDeps . size ( ) ) ) ) ; depList . addAll ( constructorDeps ) ; depList . addAll ( fieldDeps ) ; this . dependencies = new java . lang . ref . SoftReference ( depList ) ; } return depList ; }", "testMethod": "shouldHaveEmptyDependenciesAndAnnotations ( ) { ch . jalu . injector . handlers . instantiation . Resolution < ch . jalu . injector . samples . InstantiationFallbackClasses . FallbackClass > instantiation = provider . safeGet ( ch . jalu . injector . samples . InstantiationFallbackClasses . FallbackClass . class ) ; java . util . List < ch . jalu . injector . context . ObjectIdentifier > dependencies = instantiation . getDependencies ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dependencies , org . hamcrest . Matchers . empty ( ) )", "total": "shouldHaveEmptyDependenciesAndAnnotations ( ) { ch . jalu . injector . handlers . instantiation . Resolution < ch . jalu . injector . samples . InstantiationFallbackClasses . FallbackClass > instantiation = provider . safeGet ( ch . jalu . injector . samples . InstantiationFallbackClasses . FallbackClass . class ) ; java . util . List < ch . jalu . injector . context . ObjectIdentifier > dependencies = instantiation . getDependencies ( ) ; \"<AssertPlaceHolder>\" ; } getDependencies ( ) { java . util . List < ch . jalu . injector . context . ObjectIdentifier > depList = ( ( dependencies ) == null ) ? null : dependencies . get ( ) ; if ( depList == null ) { java . util . List < ch . jalu . injector . context . ObjectIdentifier > constructorDeps = buildConstructorDependencies ( ) ; java . util . List < ch . jalu . injector . context . ObjectIdentifier > fieldDeps = buildFieldDependencies ( ) ; depList = new java . util . ArrayList ( ( ( constructorDeps . size ( ) ) + ( fieldDeps . size ( ) ) ) ) ; depList . addAll ( constructorDeps ) ; depList . addAll ( fieldDeps ) ; this . dependencies = new java . lang . ref . SoftReference ( depList ) ; } return depList ; }", "answer": "org . junit . Assert . assertThat ( dependencies , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "merge ( java . util . List ) { if ( ( intervals . size ( ) ) <= 1 ) { return intervals ; } java . util . Collections . sort ( intervals , ( i1 , i2 ) -> java . lang . Integer . compare ( i1 . start , i2 . start ) ) ; java . util . List < net . neoremind . mycode . argorithm . leetcode . support . Interval > result = new java . util . LinkedList ( ) ; int start = intervals . get ( 0 ) . start ; int end = intervals . get ( 0 ) . end ; for ( net . neoremind . mycode . argorithm . leetcode . support . Interval interval : intervals ) { if ( ( interval . start ) <= end ) { end = java . lang . Math . max ( end , interval . end ) ; } else { result . add ( new net . neoremind . mycode . argorithm . leetcode . support . Interval ( start , end ) ) ; start = interval . start ; end = interval . end ; } } result . add ( new net . neoremind . mycode . argorithm . leetcode . support . Interval ( start , end ) ) ; return result ; }", "testMethod": "test ( ) { java . util . List < net . neoremind . mycode . argorithm . leetcode . support . Interval > intervals = com . google . common . collect . Lists . newArrayList ( net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 1 , 3 ) , net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 2 , 6 ) , net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 8 , 10 ) , net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 15 , 18 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( merge ( intervals ) . size ( ) , org . hamcrest . Matchers . is ( 3 ) )", "total": "test ( ) { java . util . List < net . neoremind . mycode . argorithm . leetcode . support . Interval > intervals = com . google . common . collect . Lists . newArrayList ( net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 1 , 3 ) , net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 2 , 6 ) , net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 8 , 10 ) , net . neoremind . mycode . argorithm . leetcode . support . Interval . of ( 15 , 18 ) ) ; \"<AssertPlaceHolder>\" ; } merge ( java . util . List ) { if ( ( intervals . size ( ) ) <= 1 ) { return intervals ; } java . util . Collections . sort ( intervals , ( i1 , i2 ) -> java . lang . Integer . compare ( i1 . start , i2 . start ) ) ; java . util . List < net . neoremind . mycode . argorithm . leetcode . support . Interval > result = new java . util . LinkedList ( ) ; int start = intervals . get ( 0 ) . start ; int end = intervals . get ( 0 ) . end ; for ( net . neoremind . mycode . argorithm . leetcode . support . Interval interval : intervals ) { if ( ( interval . start ) <= end ) { end = java . lang . Math . max ( end , interval . end ) ; } else { result . add ( new net . neoremind . mycode . argorithm . leetcode . support . Interval ( start , end ) ) ; start = interval . start ; end = interval . end ; } } result . add ( new net . neoremind . mycode . argorithm . leetcode . support . Interval ( start , end ) ) ; return result ; }", "answer": "org . junit . Assert . assertThat ( merge ( intervals ) . size ( ) , org . hamcrest . Matchers . is ( 3 ) )"}
{"focal": "get ( java . lang . String ) { final java . lang . String val = this . data . get ( key ) ; return org . apache . commons . lang . StringUtils . stripToEmpty ( val ) ; }", "testMethod": "shouldMapSingleParam ( ) { request . setParameterMap ( com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . Object > of ( \":form\" , \"x\" , \"hello\" , \"world\" ) ) ; final com . adobe . acs . commons . forms . Form form = formHelper . getForm ( \"x\" , request , response ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( form . get ( \"hello\" ) , is ( equalTo ( \"world\" ) ) )", "total": "shouldMapSingleParam ( ) { request . setParameterMap ( com . google . common . collect . ImmutableMap . < java . lang . String , java . lang . Object > of ( \":form\" , \"x\" , \"hello\" , \"world\" ) ) ; final com . adobe . acs . commons . forms . Form form = formHelper . getForm ( \"x\" , request , response ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . String ) { final java . lang . String val = this . data . get ( key ) ; return org . apache . commons . lang . StringUtils . stripToEmpty ( val ) ; }", "answer": "org . junit . Assert . assertThat ( form . get ( \"hello\" ) , is ( equalTo ( \"world\" ) ) )"}
{"focal": "is ( java . lang . String ) { return ( com . threewks . thundr . configuration . Environment . environment ) == null ? environment == null : com . threewks . thundr . configuration . Environment . environment . equals ( environment ) ; }", "testMethod": "shouldReadStringFromBytes ( ) { java . lang . String string = \"Expected<sp>string\" ; java . io . ByteArrayInputStream is = new java . io . ByteArrayInputStream ( string . getBytes ( ) ) ; java . lang . String result = com . threewks . thundr . util . Streams . readString ( is ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( string ) )", "total": "shouldReadStringFromBytes ( ) { java . lang . String string = \"Expected<sp>string\" ; java . io . ByteArrayInputStream is = new java . io . ByteArrayInputStream ( string . getBytes ( ) ) ; java . lang . String result = com . threewks . thundr . util . Streams . readString ( is ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { return ( com . threewks . thundr . configuration . Environment . environment ) == null ? environment == null : com . threewks . thundr . configuration . Environment . environment . equals ( environment ) ; }", "answer": "org . junit . Assert . assertThat ( result , org . hamcrest . Matchers . is ( string ) )"}
{"focal": "expandSingleLevel ( java . lang . String ) { org . apache . http . client . methods . HttpHead request = null ; try { request = new org . apache . http . client . methods . HttpHead ( url ) ; final org . apache . http . HttpResponse httpResponse = client . execute ( request ) ; final int statusCode = httpResponse . getStatusLine ( ) . getStatusCode ( ) ; if ( ( statusCode != 301 ) && ( statusCode != 302 ) ) { return url ; } final org . apache . http . Header [ ] headers = httpResponse . getHeaders ( HttpHeaders . LOCATION ) ; com . google . common . base . Preconditions . checkState ( ( ( headers . length ) == 1 ) ) ; return headers [ 0 ] . getValue ( ) ; } catch ( final java . lang . IllegalArgumentException uriEx ) { return url ; } finally { if ( request != null ) { request . releaseConnection ( ) ; } } }", "testMethod": "givenShortenedOnce_whenUrlIsUnshortened_thenCorrectResult ( ) { final java . lang . String expectedResult = \"http://www.baeldung.com/rest-versioning\" ; final java . lang . String actualResult = expandSingleLevel ( \"http://bit.ly/13jEoS1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualResult , org . hamcrest . Matchers . equalTo ( expectedResult ) )", "total": "givenShortenedOnce_whenUrlIsUnshortened_thenCorrectResult ( ) { final java . lang . String expectedResult = \"http://www.baeldung.com/rest-versioning\" ; final java . lang . String actualResult = expandSingleLevel ( \"http://bit.ly/13jEoS1\" ) ; \"<AssertPlaceHolder>\" ; } expandSingleLevel ( java . lang . String ) { org . apache . http . client . methods . HttpHead request = null ; try { request = new org . apache . http . client . methods . HttpHead ( url ) ; final org . apache . http . HttpResponse httpResponse = client . execute ( request ) ; final int statusCode = httpResponse . getStatusLine ( ) . getStatusCode ( ) ; if ( ( statusCode != 301 ) && ( statusCode != 302 ) ) { return url ; } final org . apache . http . Header [ ] headers = httpResponse . getHeaders ( HttpHeaders . LOCATION ) ; com . google . common . base . Preconditions . checkState ( ( ( headers . length ) == 1 ) ) ; return headers [ 0 ] . getValue ( ) ; } catch ( final java . lang . IllegalArgumentException uriEx ) { return url ; } finally { if ( request != null ) { request . releaseConnection ( ) ; } } }", "answer": "org . junit . Assert . assertThat ( actualResult , org . hamcrest . Matchers . equalTo ( expectedResult ) )"}
{"focal": "getPassword ( ) { return password ; }", "testMethod": "shouldPromptFromStdinForPasswordIfPasswordParamSuppliedWithNoArg ( ) { when ( userInputReader . read ( \"Password\" ) ) . thenReturn ( \"user<sp>entered<sp>password\" ) ; parser . parse ( new java . lang . String [ ] { \"-P\" } , dbDeploy ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dbDeploy . getPassword ( ) , org . hamcrest . Matchers . is ( \"user<sp>entered<sp>password\" ) )", "total": "shouldPromptFromStdinForPasswordIfPasswordParamSuppliedWithNoArg ( ) { when ( userInputReader . read ( \"Password\" ) ) . thenReturn ( \"user<sp>entered<sp>password\" ) ; parser . parse ( new java . lang . String [ ] { \"-P\" } , dbDeploy ) ; \"<AssertPlaceHolder>\" ; } getPassword ( ) { return password ; }", "answer": "org . junit . Assert . assertThat ( dbDeploy . getPassword ( ) , org . hamcrest . Matchers . is ( \"user<sp>entered<sp>password\" ) )"}
{"focal": "get ( java . lang . String ) { throw new java . lang . RuntimeException ( \"not<sp>implemented\" ) ; }", "testMethod": "testRetrieveQueryMetacardSpecifiedId ( ) { doReturn ( new ddf . catalog . data . impl . MetacardImpl ( ) ) . when ( org . codice . ddf . catalog . ui . metacard . QueryMetacardApplicationTest . ENDPOINT_UTIL ) . getMetacardById ( any ( java . lang . String . class ) ) ; int statusCode = com . jayway . restassured . RestAssured . given ( ) . get ( ( ( org . codice . ddf . catalog . ui . metacard . QueryMetacardApplicationTest . localhostUrl ) + \"/123\" ) ) . statusCode ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( statusCode , org . hamcrest . CoreMatchers . is ( 200 ) )", "total": "testRetrieveQueryMetacardSpecifiedId ( ) { doReturn ( new ddf . catalog . data . impl . MetacardImpl ( ) ) . when ( org . codice . ddf . catalog . ui . metacard . QueryMetacardApplicationTest . ENDPOINT_UTIL ) . getMetacardById ( any ( java . lang . String . class ) ) ; int statusCode = com . jayway . restassured . RestAssured . given ( ) . get ( ( ( org . codice . ddf . catalog . ui . metacard . QueryMetacardApplicationTest . localhostUrl ) + \"/123\" ) ) . statusCode ( ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . String ) { throw new java . lang . RuntimeException ( \"not<sp>implemented\" ) ; }", "answer": "org . junit . Assert . assertThat ( statusCode , org . hamcrest . CoreMatchers . is ( 200 ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testSetInterfaceState ( ) { defaultIsisInterface . setInterfaceState ( IsisInterfaceState . UP ) ; resultIfState = defaultIsisInterface . interfaceState ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( resultIfState , org . hamcrest . CoreMatchers . is ( IsisInterfaceState . UP ) )", "total": "testSetInterfaceState ( ) { defaultIsisInterface . setInterfaceState ( IsisInterfaceState . UP ) ; resultIfState = defaultIsisInterface . interfaceState ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( resultIfState , org . hamcrest . CoreMatchers . is ( IsisInterfaceState . UP ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "brokerageIdSet ( ) { com . github . mthizo247 . cloud . netflix . zuul . web . socket . ZuulWebSocketProperties . WsBrokerage brokerage = new com . github . mthizo247 . cloud . netflix . zuul . web . socket . ZuulWebSocketProperties . WsBrokerage ( ) ; brokerage . setId ( \"bar\" ) ; java . util . Map < java . lang . String , com . github . mthizo247 . cloud . netflix . zuul . web . socket . ZuulWebSocketProperties . WsBrokerage > brokerages = new java . util . HashMap ( ) ; brokerages . put ( \"foo\" , brokerage ) ; properties . setBrokerages ( brokerages ) ; properties . init ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( brokerage . getId ( ) , org . hamcrest . core . Is . is ( \"bar\" ) )", "total": "brokerageIdSet ( ) { com . github . mthizo247 . cloud . netflix . zuul . web . socket . ZuulWebSocketProperties . WsBrokerage brokerage = new com . github . mthizo247 . cloud . netflix . zuul . web . socket . ZuulWebSocketProperties . WsBrokerage ( ) ; brokerage . setId ( \"bar\" ) ; java . util . Map < java . lang . String , com . github . mthizo247 . cloud . netflix . zuul . web . socket . ZuulWebSocketProperties . WsBrokerage > brokerages = new java . util . HashMap ( ) ; brokerages . put ( \"foo\" , brokerage ) ; properties . setBrokerages ( brokerages ) ; properties . init ( ) ; \"<AssertPlaceHolder>\" ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( brokerage . getId ( ) , org . hamcrest . core . Is . is ( \"bar\" ) )"}
{"focal": "deleteDtoLogicallyById ( java . lang . Long ) { org . springframework . util . Assert . notNull ( id ) ; E entity = ( ( E ) ( this . logicallyDeletableRepository . findOne ( id ) ) ) ; if ( entity == null ) { throw new com . epam . rft . atsy . service . exception . ObjectNotFoundException ( ) ; } entity . setDeleted ( true ) ; this . logicallyDeletableRepository . saveAndFlush ( entity ) ; }", "testMethod": "deleteDtoLogicallyByIdShouldDeletedLogicallyWhenChannelEntityExists ( ) { org . mockito . ArgumentCaptor < com . epam . rft . atsy . persistence . entities . ChannelEntity > channelEntityArgumentCaptor = org . mockito . ArgumentCaptor . forClass ( com . epam . rft . atsy . persistence . entities . ChannelEntity . class ) ; given ( this . channelRepository . findOne ( com . epam . rft . atsy . service . impl . ChannelServiceImplTest . CHANNEL_ID_FACEBOOK ) ) . willReturn ( facebookEntity ) ; this . channelService . deleteDtoLogicallyById ( com . epam . rft . atsy . service . impl . ChannelServiceImplTest . CHANNEL_ID_FACEBOOK ) ; verify ( channelRepository ) . saveAndFlush ( channelEntityArgumentCaptor . capture ( ) ) ; \"<AssertPlaceHolder>\" ; then ( channelRepository ) . should ( ) . findOne ( com . epam . rft . atsy . service . impl . ChannelServiceImplTest . CHANNEL_ID_FACEBOOK ) ; then ( channelRepository ) . should ( ) . saveAndFlush ( deletedFacebookEntity ) ; }", "assertLine": "org . junit . Assert . assertThat ( deletedFacebookEntity , org . hamcrest . CoreMatchers . equalTo ( channelEntityArgumentCaptor . getValue ( ) ) )", "total": "deleteDtoLogicallyByIdShouldDeletedLogicallyWhenChannelEntityExists ( ) { org . mockito . ArgumentCaptor < com . epam . rft . atsy . persistence . entities . ChannelEntity > channelEntityArgumentCaptor = org . mockito . ArgumentCaptor . forClass ( com . epam . rft . atsy . persistence . entities . ChannelEntity . class ) ; given ( this . channelRepository . findOne ( com . epam . rft . atsy . service . impl . ChannelServiceImplTest . CHANNEL_ID_FACEBOOK ) ) . willReturn ( facebookEntity ) ; this . channelService . deleteDtoLogicallyById ( com . epam . rft . atsy . service . impl . ChannelServiceImplTest . CHANNEL_ID_FACEBOOK ) ; verify ( channelRepository ) . saveAndFlush ( channelEntityArgumentCaptor . capture ( ) ) ; \"<AssertPlaceHolder>\" ; then ( channelRepository ) . should ( ) . findOne ( com . epam . rft . atsy . service . impl . ChannelServiceImplTest . CHANNEL_ID_FACEBOOK ) ; then ( channelRepository ) . should ( ) . saveAndFlush ( deletedFacebookEntity ) ; } deleteDtoLogicallyById ( java . lang . Long ) { org . springframework . util . Assert . notNull ( id ) ; E entity = ( ( E ) ( this . logicallyDeletableRepository . findOne ( id ) ) ) ; if ( entity == null ) { throw new com . epam . rft . atsy . service . exception . ObjectNotFoundException ( ) ; } entity . setDeleted ( true ) ; this . logicallyDeletableRepository . saveAndFlush ( entity ) ; }", "answer": "org . junit . Assert . assertThat ( deletedFacebookEntity , org . hamcrest . CoreMatchers . equalTo ( channelEntityArgumentCaptor . getValue ( ) ) )"}
{"focal": "matchesField ( java . lang . String , java . lang . String ) { return new org . hamcrest . TypeSafeMatcher < java . util . List < java . util . Map < java . lang . String , java . lang . Object > > > ( ) { @ uk . gov . pay . api . it . Override protected boolean matchesSafely ( java . util . List < java . util . Map < java . lang . String , java . lang . Object > > maps ) { return maps . stream ( ) . allMatch ( ( result ) -> value . equals ( result . get ( field ) ) ) ; } @ uk . gov . pay . api . it . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( java . lang . String . format ( \"not<sp>all<sp>result<sp>%s<sp>match<sp>%s\" , field , value ) ) ; } } ; }", "testMethod": "searchPayments_filterByFullReference ( ) { java . lang . String payments = aPaginatedPaymentSearchResult ( ) . withCount ( 10 ) . withPage ( 2 ) . withTotal ( 20 ) . withPayments ( aSuccessfulSearchPayment ( ) . withReference ( uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE ) . getResults ( ) ) . build ( ) ; connectorMock . respondOk_whenSearchCharges ( uk . gov . pay . api . it . GATEWAY_ACCOUNT_ID , uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE , null , null , null , null , null , null , null , null , payments ) ; io . restassured . response . ValidatableResponse response = searchPayments ( uk . gov . pay . api . it . API_KEY , com . google . common . collect . ImmutableMap . of ( \"reference\" , uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE ) ) . statusCode ( 200 ) . contentType ( io . restassured . http . ContentType . JSON ) . body ( \"results.size()\" , org . hamcrest . CoreMatchers . equalTo ( 3 ) ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > results = response . extract ( ) . body ( ) . jsonPath ( ) . getList ( \"results\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( results , matchesField ( \"reference\" , uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE ) )", "total": "searchPayments_filterByFullReference ( ) { java . lang . String payments = aPaginatedPaymentSearchResult ( ) . withCount ( 10 ) . withPage ( 2 ) . withTotal ( 20 ) . withPayments ( aSuccessfulSearchPayment ( ) . withReference ( uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE ) . getResults ( ) ) . build ( ) ; connectorMock . respondOk_whenSearchCharges ( uk . gov . pay . api . it . GATEWAY_ACCOUNT_ID , uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE , null , null , null , null , null , null , null , null , payments ) ; io . restassured . response . ValidatableResponse response = searchPayments ( uk . gov . pay . api . it . API_KEY , com . google . common . collect . ImmutableMap . of ( \"reference\" , uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE ) ) . statusCode ( 200 ) . contentType ( io . restassured . http . ContentType . JSON ) . body ( \"results.size()\" , org . hamcrest . CoreMatchers . equalTo ( 3 ) ) ; java . util . List < java . util . Map < java . lang . String , java . lang . Object > > results = response . extract ( ) . body ( ) . jsonPath ( ) . getList ( \"results\" ) ; \"<AssertPlaceHolder>\" ; } matchesField ( java . lang . String , java . lang . String ) { return new org . hamcrest . TypeSafeMatcher < java . util . List < java . util . Map < java . lang . String , java . lang . Object > > > ( ) { @ uk . gov . pay . api . it . Override protected boolean matchesSafely ( java . util . List < java . util . Map < java . lang . String , java . lang . Object > > maps ) { return maps . stream ( ) . allMatch ( ( result ) -> value . equals ( result . get ( field ) ) ) ; } @ uk . gov . pay . api . it . Override public void describeTo ( org . hamcrest . Description description ) { description . appendText ( java . lang . String . format ( \"not<sp>all<sp>result<sp>%s<sp>match<sp>%s\" , field , value ) ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( results , matchesField ( \"reference\" , uk . gov . pay . api . it . PaymentResourceSearchITest . TEST_REFERENCE ) )"}
{"focal": "getValueForAttribute ( net . ripe . db . whois . common . rpsl . AttributeType ) { return findAttribute ( attributeType ) . getCleanValue ( ) ; }", "testMethod": "transform_nserver_glue_ipv6 ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( \"domain:<sp>17.45.212.in-addr.arpa\\n\" + \"nserver:<sp>hostname.nu<sp>FFAA::0\\n\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject result = attributeSanitizer . sanitize ( rpslObject , objectMessages ) ; \"<AssertPlaceHolder>\" ; verify ( objectMessages ) . addMessage ( result . findAttribute ( AttributeType . NSERVER ) , net . ripe . db . whois . common . rpsl . ValidationMessages . attributeValueConverted ( \"hostname.nu<sp>FFAA::0\" , \"hostname.nu<sp>ffaa::\" ) ) ; verifyNoMoreInteractions ( objectMessages ) ; }", "assertLine": "org . junit . Assert . assertThat ( result . getValueForAttribute ( AttributeType . NSERVER ) . toString ( ) , org . hamcrest . Matchers . is ( \"hostname.nu<sp>ffaa::\" ) )", "total": "transform_nserver_glue_ipv6 ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( \"domain:<sp>17.45.212.in-addr.arpa\\n\" + \"nserver:<sp>hostname.nu<sp>FFAA::0\\n\" ) ) ) ; final net . ripe . db . whois . common . rpsl . RpslObject result = attributeSanitizer . sanitize ( rpslObject , objectMessages ) ; \"<AssertPlaceHolder>\" ; verify ( objectMessages ) . addMessage ( result . findAttribute ( AttributeType . NSERVER ) , net . ripe . db . whois . common . rpsl . ValidationMessages . attributeValueConverted ( \"hostname.nu<sp>FFAA::0\" , \"hostname.nu<sp>ffaa::\" ) ) ; verifyNoMoreInteractions ( objectMessages ) ; } getValueForAttribute ( net . ripe . db . whois . common . rpsl . AttributeType ) { return findAttribute ( attributeType ) . getCleanValue ( ) ; }", "answer": "org . junit . Assert . assertThat ( result . getValueForAttribute ( AttributeType . NSERVER ) . toString ( ) , org . hamcrest . Matchers . is ( \"hostname.nu<sp>ffaa::\" ) )"}
{"focal": "size ( ) { return fragment . size ( ) ; }", "testMethod": "testGetDatasetMetadata ( ) { org . deegree . services . metadata . provider . DefaultOWSMetadataProvider metadataProvider = createProvider ( ) ; java . util . List < org . deegree . commons . ows . metadata . DatasetMetadata > datasetMetadata = metadataProvider . getDatasetMetadata ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( datasetMetadata . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )", "total": "testGetDatasetMetadata ( ) { org . deegree . services . metadata . provider . DefaultOWSMetadataProvider metadataProvider = createProvider ( ) ; java . util . List < org . deegree . commons . ows . metadata . DatasetMetadata > datasetMetadata = metadataProvider . getDatasetMetadata ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return fragment . size ( ) ; }", "answer": "org . junit . Assert . assertThat ( datasetMetadata . size ( ) , org . hamcrest . CoreMatchers . is ( 3 ) )"}
{"focal": "getId ( ) { return id ; }", "testMethod": "isTaskPendingForUser_should_be_true_when_mapped_using_pending_mapping ( ) { final org . bonitasoft . engine . identity . model . SUser expectedUser = repository . add ( aUser ( ) . withId ( 1L ) . build ( ) ) ; repository . add ( aUser ( ) . withId ( 2L ) . build ( ) ) ; final org . bonitasoft . engine . core . process . instance . model . SPendingActivityMapping pendingActivity = repository . add ( aPendingActivityMapping ( ) . withUserId ( expectedUser . getId ( ) ) . build ( ) ) ; boolean taskPendingForUser = repository . isTaskPendingForUser ( pendingActivity . getActivityId ( ) , expectedUser . getId ( ) ) ; \"<AssertPlaceHolder>\" . isTrue ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( taskPendingForUser )", "total": "isTaskPendingForUser_should_be_true_when_mapped_using_pending_mapping ( ) { final org . bonitasoft . engine . identity . model . SUser expectedUser = repository . add ( aUser ( ) . withId ( 1L ) . build ( ) ) ; repository . add ( aUser ( ) . withId ( 2L ) . build ( ) ) ; final org . bonitasoft . engine . core . process . instance . model . SPendingActivityMapping pendingActivity = repository . add ( aPendingActivityMapping ( ) . withUserId ( expectedUser . getId ( ) ) . build ( ) ) ; boolean taskPendingForUser = repository . isTaskPendingForUser ( pendingActivity . getActivityId ( ) , expectedUser . getId ( ) ) ; \"<AssertPlaceHolder>\" . isTrue ( ) ; } getId ( ) { return id ; }", "answer": "org . junit . Assert . assertThat ( taskPendingForUser )"}
{"focal": "sortListByPropertyNamesValue ( java . util . List , java . lang . String [ ] ) { if ( null == list ) { return java . util . Collections . emptyList ( ) ; } org . apache . commons . lang3 . Validate . notEmpty ( propertyNameAndOrders , \"propertyNameAndOrders<sp>can't<sp>be<sp>null/empty!\" ) ; org . apache . commons . lang3 . Validate . noNullElements ( propertyNameAndOrders , \"propertyNameAndOrders:[%s]<sp>has<sp>empty<sp>value\" , propertyNameAndOrders ) ; java . util . Comparator < O > comparator = com . feilong . core . util . comparator . BeanComparatorUtil . chainedComparator ( propertyNameAndOrders ) ; return com . feilong . core . util . SortUtil . sortList ( list , comparator ) ; }", "testMethod": "testSortByPropertyNamesValueWithNullPropertyValue ( ) { com . feilong . store . member . User u_null_id = new com . feilong . store . member . User ( ( ( java . lang . Long ) ( null ) ) ) ; com . feilong . store . member . User id12 = new com . feilong . store . member . User ( 12L ) ; com . feilong . store . member . User id2 = new com . feilong . store . member . User ( 2L ) ; com . feilong . store . member . User u_null = null ; com . feilong . store . member . User id1 = new com . feilong . store . member . User ( 1L ) ; java . util . List < com . feilong . store . member . User > list = toList ( u_null_id , id12 , id2 , u_null , id1 , u_null_id ) ; com . feilong . core . util . SortUtil . sortListByPropertyNamesValue ( list , \"id\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( list , org . hamcrest . Matchers . contains ( u_null_id , u_null_id , id1 , id2 , id12 , u_null ) )", "total": "testSortByPropertyNamesValueWithNullPropertyValue ( ) { com . feilong . store . member . User u_null_id = new com . feilong . store . member . User ( ( ( java . lang . Long ) ( null ) ) ) ; com . feilong . store . member . User id12 = new com . feilong . store . member . User ( 12L ) ; com . feilong . store . member . User id2 = new com . feilong . store . member . User ( 2L ) ; com . feilong . store . member . User u_null = null ; com . feilong . store . member . User id1 = new com . feilong . store . member . User ( 1L ) ; java . util . List < com . feilong . store . member . User > list = toList ( u_null_id , id12 , id2 , u_null , id1 , u_null_id ) ; com . feilong . core . util . SortUtil . sortListByPropertyNamesValue ( list , \"id\" ) ; \"<AssertPlaceHolder>\" ; } sortListByPropertyNamesValue ( java . util . List , java . lang . String [ ] ) { if ( null == list ) { return java . util . Collections . emptyList ( ) ; } org . apache . commons . lang3 . Validate . notEmpty ( propertyNameAndOrders , \"propertyNameAndOrders<sp>can't<sp>be<sp>null/empty!\" ) ; org . apache . commons . lang3 . Validate . noNullElements ( propertyNameAndOrders , \"propertyNameAndOrders:[%s]<sp>has<sp>empty<sp>value\" , propertyNameAndOrders ) ; java . util . Comparator < O > comparator = com . feilong . core . util . comparator . BeanComparatorUtil . chainedComparator ( propertyNameAndOrders ) ; return com . feilong . core . util . SortUtil . sortList ( list , comparator ) ; }", "answer": "org . junit . Assert . assertThat ( list , org . hamcrest . Matchers . contains ( u_null_id , u_null_id , id1 , id2 , id12 , u_null ) )"}
{"focal": "isEmpty ( ) { if ( ( ( entries ) == null ) || ( entries . isEmpty ( ) ) ) { return true ; } for ( org . silverpeas . web . pdc . vo . FacetEntryVO entry : entries ) { if ( ( entry . getNbElt ( ) ) > 0 ) { return false ; } } return true ; }", "testMethod": "aStartDateEqualToTheEndDateIsValid ( ) { java . time . LocalDate today = java . time . LocalDate . now ( ) ; org . silverpeas . core . annotation . constraint . DateInterval interval = new org . silverpeas . core . annotation . constraint . DateInterval ( today , today ) ; java . util . Set < javax . validation . ConstraintViolation < org . silverpeas . core . annotation . constraint . DateInterval > > violations = validator . validate ( interval ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "aStartDateEqualToTheEndDateIsValid ( ) { java . time . LocalDate today = java . time . LocalDate . now ( ) ; org . silverpeas . core . annotation . constraint . DateInterval interval = new org . silverpeas . core . annotation . constraint . DateInterval ( today , today ) ; java . util . Set < javax . validation . ConstraintViolation < org . silverpeas . core . annotation . constraint . DateInterval > > violations = validator . validate ( interval ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { if ( ( ( entries ) == null ) || ( entries . isEmpty ( ) ) ) { return true ; } for ( org . silverpeas . web . pdc . vo . FacetEntryVO entry : entries ) { if ( ( entry . getNbElt ( ) ) > 0 ) { return false ; } } return true ; }", "answer": "org . junit . Assert . assertThat ( violations . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getAsDoubleArray ( ) { return timeDiscretization . clone ( ) ; }", "testMethod": "testIntersectionWithNoDuplicates ( ) { double [ ] leftTimes = new double [ ] { 1.0 , 2.0 , 3.0 } ; double [ ] rightTimes = new double [ ] { 0.5 , 1.5 } ; net . finmath . time . TimeDiscretization intersection = new net . finmath . time . TimeDiscretizationFromArray ( leftTimes ) . intersect ( new net . finmath . time . TimeDiscretizationFromArray ( rightTimes ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( intersection . getAsDoubleArray ( ) . length , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "testIntersectionWithNoDuplicates ( ) { double [ ] leftTimes = new double [ ] { 1.0 , 2.0 , 3.0 } ; double [ ] rightTimes = new double [ ] { 0.5 , 1.5 } ; net . finmath . time . TimeDiscretization intersection = new net . finmath . time . TimeDiscretizationFromArray ( leftTimes ) . intersect ( new net . finmath . time . TimeDiscretizationFromArray ( rightTimes ) ) ; \"<AssertPlaceHolder>\" ; } getAsDoubleArray ( ) { return timeDiscretization . clone ( ) ; }", "answer": "org . junit . Assert . assertThat ( intersection . getAsDoubleArray ( ) . length , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "testMethod": "testQueryNoAuthenticatedTenants ( ) { org . camunda . bpm . engine . repository . DecisionRequirementsDefinition decisionRequirementsDefinition = repositoryService . createDecisionRequirementsDefinitionQuery ( ) . singleResult ( ) ; identityService . setAuthentication ( org . camunda . bpm . engine . test . api . multitenancy . query . history . MultiTenancySharedDecisionInstanceStatisticsQueryTest . USER_ID , null , null ) ; org . camunda . bpm . engine . history . HistoricDecisionInstanceStatisticsQuery query = historyService . createHistoricDecisionInstanceStatisticsQuery ( decisionRequirementsDefinition . getId ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "testQueryNoAuthenticatedTenants ( ) { org . camunda . bpm . engine . repository . DecisionRequirementsDefinition decisionRequirementsDefinition = repositoryService . createDecisionRequirementsDefinitionQuery ( ) . singleResult ( ) ; identityService . setAuthentication ( org . camunda . bpm . engine . test . api . multitenancy . query . history . MultiTenancySharedDecisionInstanceStatisticsQueryTest . USER_ID , null , null ) ; org . camunda . bpm . engine . history . HistoricDecisionInstanceStatisticsQuery query = historyService . createHistoricDecisionInstanceStatisticsQuery ( decisionRequirementsDefinition . getId ( ) ) ; \"<AssertPlaceHolder>\" ; } count ( ) { this . resultType = org . camunda . bpm . engine . impl . AbstractNativeQuery . ResultType . COUNT ; if ( ( commandExecutor ) != null ) { return ( ( java . lang . Long ) ( commandExecutor . execute ( this ) ) ) ; } return executeCount ( org . camunda . bpm . engine . impl . context . Context . getCommandContext ( ) , getParameterMap ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( query . count ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "property ( com . asakusafw . directio . hive . serde . PropertyDescriptor ) { this . properties . add ( descriptor ) ; return this ; }", "testMethod": "with_provider_conf ( ) { provider . withProvider ( ( it ) -> it . withProject ( ( p ) -> p . withProperty ( \"action.provider\" , \"true\" ) ) ) ; com . asakusafw . integration . AsakusaProject project = provider . newInstance ( \"testing\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( project . property ( \"action.provider\" ) , is ( \"true\" ) )", "total": "with_provider_conf ( ) { provider . withProvider ( ( it ) -> it . withProject ( ( p ) -> p . withProperty ( \"action.provider\" , \"true\" ) ) ) ; com . asakusafw . integration . AsakusaProject project = provider . newInstance ( \"testing\" ) ; \"<AssertPlaceHolder>\" ; } property ( com . asakusafw . directio . hive . serde . PropertyDescriptor ) { this . properties . add ( descriptor ) ; return this ; }", "answer": "org . junit . Assert . assertThat ( project . property ( \"action.provider\" ) , is ( \"true\" ) )"}
{"focal": "isPermanentBlockRequired ( ) { return ( getTemporaryBlockCount ( ) ) >= ( net . ripe . db . whois . common . domain . BlockEvents . NR_TEMP_BLOCKS_BEFORE_PERMANENT ) ; }", "testMethod": "test_permanent_block_limit_reached_9 ( ) { final net . ripe . db . whois . common . domain . BlockEvents blockEvents = net . ripe . db . whois . common . domain . BlockEventsTest . createBlockEvents ( prefix , 9 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( blockEvents . isPermanentBlockRequired ( ) , org . hamcrest . Matchers . is ( false ) )", "total": "test_permanent_block_limit_reached_9 ( ) { final net . ripe . db . whois . common . domain . BlockEvents blockEvents = net . ripe . db . whois . common . domain . BlockEventsTest . createBlockEvents ( prefix , 9 ) ; \"<AssertPlaceHolder>\" ; } isPermanentBlockRequired ( ) { return ( getTemporaryBlockCount ( ) ) >= ( net . ripe . db . whois . common . domain . BlockEvents . NR_TEMP_BLOCKS_BEFORE_PERMANENT ) ; }", "answer": "org . junit . Assert . assertThat ( blockEvents . isPermanentBlockRequired ( ) , org . hamcrest . Matchers . is ( false ) )"}
{"focal": "jsonNull ( com . fasterxml . jackson . databind . node . NullNode ) { return com . spotify . hamcrest . jackson . IsJsonNull . jsonNull ( ) ; }", "testMethod": "testLiteral ( ) { final org . hamcrest . Matcher < com . fasterxml . jackson . databind . JsonNode > sut = com . spotify . hamcrest . jackson . IsJsonNull . jsonNull ( com . spotify . hamcrest . jackson . IsJsonNullTest . NF . nullNode ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . spotify . hamcrest . jackson . IsJsonNullTest . NF . nullNode ( ) , org . hamcrest . core . Is . is ( sut ) )", "total": "testLiteral ( ) { final org . hamcrest . Matcher < com . fasterxml . jackson . databind . JsonNode > sut = com . spotify . hamcrest . jackson . IsJsonNull . jsonNull ( com . spotify . hamcrest . jackson . IsJsonNullTest . NF . nullNode ( ) ) ; \"<AssertPlaceHolder>\" ; } jsonNull ( com . fasterxml . jackson . databind . node . NullNode ) { return com . spotify . hamcrest . jackson . IsJsonNull . jsonNull ( ) ; }", "answer": "org . junit . Assert . assertThat ( com . spotify . hamcrest . jackson . IsJsonNullTest . NF . nullNode ( ) , org . hamcrest . core . Is . is ( sut ) )"}
{"focal": "build ( ) { if ( ( startedEvent . getOperation ( ) ) == ( Operation . FETCH ) ) { com . facebook . buck . core . rulekey . RuleKey requestsRuleKey = java . util . Objects . requireNonNull ( com . google . common . collect . Iterables . getFirst ( startedEvent . getRuleKeys ( ) , null ) ) ; fetchDataBuilder . setRequestedRuleKey ( requestsRuleKey ) ; return new com . facebook . buck . artifact_cache . HttpArtifactCacheEvent . Finished ( startedEvent , target , fetchDataBuilder . build ( ) ) ; } else { storeDataBuilder . setRuleKeys ( startedEvent . getRuleKeys ( ) ) ; storeDataBuilder . setStoreType ( startedEvent . getStoreType ( ) ) ; return new com . facebook . buck . artifact_cache . HttpArtifactCacheEvent . Finished ( startedEvent , storeDataBuilder . build ( ) ) ; } }", "testMethod": "appendToRuleKey ( ) { com . facebook . buck . rules . args . SanitizedArg arg1 = com . facebook . buck . rules . args . SanitizedArg . create ( com . google . common . base . Functions . constant ( \"sanitized\" ) , \"unsanitized<sp>1\" ) ; com . facebook . buck . rules . args . SanitizedArg arg2 = com . facebook . buck . rules . args . SanitizedArg . create ( com . google . common . base . Functions . constant ( \"sanitized\" ) , \"unsanitized<sp>2\" ) ; com . facebook . buck . rules . keys . RuleKeyBuilder < com . google . common . hash . HashCode > builder1 = createRuleKeyBuilder ( ) ; com . facebook . buck . rules . keys . RuleKeyBuilder < com . google . common . hash . HashCode > builder2 = createRuleKeyBuilder ( ) ; com . facebook . buck . rules . keys . AlterRuleKeys . amendKey ( builder1 , arg1 ) ; com . facebook . buck . rules . keys . AlterRuleKeys . amendKey ( builder2 , arg2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( builder1 . build ( ) , org . hamcrest . Matchers . equalTo ( builder2 . build ( ) ) )", "total": "appendToRuleKey ( ) { com . facebook . buck . rules . args . SanitizedArg arg1 = com . facebook . buck . rules . args . SanitizedArg . create ( com . google . common . base . Functions . constant ( \"sanitized\" ) , \"unsanitized<sp>1\" ) ; com . facebook . buck . rules . args . SanitizedArg arg2 = com . facebook . buck . rules . args . SanitizedArg . create ( com . google . common . base . Functions . constant ( \"sanitized\" ) , \"unsanitized<sp>2\" ) ; com . facebook . buck . rules . keys . RuleKeyBuilder < com . google . common . hash . HashCode > builder1 = createRuleKeyBuilder ( ) ; com . facebook . buck . rules . keys . RuleKeyBuilder < com . google . common . hash . HashCode > builder2 = createRuleKeyBuilder ( ) ; com . facebook . buck . rules . keys . AlterRuleKeys . amendKey ( builder1 , arg1 ) ; com . facebook . buck . rules . keys . AlterRuleKeys . amendKey ( builder2 , arg2 ) ; \"<AssertPlaceHolder>\" ; } build ( ) { if ( ( startedEvent . getOperation ( ) ) == ( Operation . FETCH ) ) { com . facebook . buck . core . rulekey . RuleKey requestsRuleKey = java . util . Objects . requireNonNull ( com . google . common . collect . Iterables . getFirst ( startedEvent . getRuleKeys ( ) , null ) ) ; fetchDataBuilder . setRequestedRuleKey ( requestsRuleKey ) ; return new com . facebook . buck . artifact_cache . HttpArtifactCacheEvent . Finished ( startedEvent , target , fetchDataBuilder . build ( ) ) ; } else { storeDataBuilder . setRuleKeys ( startedEvent . getRuleKeys ( ) ) ; storeDataBuilder . setStoreType ( startedEvent . getStoreType ( ) ) ; return new com . facebook . buck . artifact_cache . HttpArtifactCacheEvent . Finished ( startedEvent , storeDataBuilder . build ( ) ) ; } }", "answer": "org . junit . Assert . assertThat ( builder1 . build ( ) , org . hamcrest . Matchers . equalTo ( builder2 . build ( ) ) )"}
{"focal": "normalize ( org . batfish . datamodel . acl . AclLineMatchExpr ) { return org . batfish . datamodel . acl . AclLineMatchExprNormalizer . normalize ( _toBDD , expr ) ; }", "testMethod": "visitAndMatchExpr_distributeOverOr ( ) { org . batfish . datamodel . acl . AclLineMatchExpr expr = org . batfish . datamodel . acl . AclLineMatchExprs . and ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . D ) ) ; org . batfish . datamodel . acl . AclLineMatchExpr nf = org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprs . and ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C ) , org . batfish . datamodel . acl . AclLineMatchExprs . and ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . D ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( normalize ( expr ) , org . hamcrest . Matchers . equalTo ( nf ) )", "total": "visitAndMatchExpr_distributeOverOr ( ) { org . batfish . datamodel . acl . AclLineMatchExpr expr = org . batfish . datamodel . acl . AclLineMatchExprs . and ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . D ) ) ; org . batfish . datamodel . acl . AclLineMatchExpr nf = org . batfish . datamodel . acl . AclLineMatchExprs . or ( org . batfish . datamodel . acl . AclLineMatchExprs . and ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . C ) , org . batfish . datamodel . acl . AclLineMatchExprs . and ( org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . A , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . B , org . batfish . datamodel . acl . AclLineMatchExprNormalizerTest . D ) ) ; \"<AssertPlaceHolder>\" ; } normalize ( org . batfish . datamodel . acl . AclLineMatchExpr ) { return org . batfish . datamodel . acl . AclLineMatchExprNormalizer . normalize ( _toBDD , expr ) ; }", "answer": "org . junit . Assert . assertThat ( normalize ( expr ) , org . hamcrest . Matchers . equalTo ( nf ) )"}
{"focal": "count ( java . lang . Class ) { if ( modelClass == null ) { throw new java . lang . NullPointerException ( \"The<sp>modelClass<sp>parameter<sp>is<sp>null.\" ) ; } return count ( org . slim3 . datastore . DatastoreUtil . getModelMeta ( modelClass ) . getKind ( ) ) ; }", "testMethod": "slim3test1 ( ) { int beforeCount = tester . count ( $ . Slim3Model . class ) ; $ . Slim3Service . newAndPut ( \"abc\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( tester . count ( $ . Slim3Model . class ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( ( beforeCount + 1 ) ) ) )", "total": "slim3test1 ( ) { int beforeCount = tester . count ( $ . Slim3Model . class ) ; $ . Slim3Service . newAndPut ( \"abc\" ) ; \"<AssertPlaceHolder>\" ; } count ( java . lang . Class ) { if ( modelClass == null ) { throw new java . lang . NullPointerException ( \"The<sp>modelClass<sp>parameter<sp>is<sp>null.\" ) ; } return count ( org . slim3 . datastore . DatastoreUtil . getModelMeta ( modelClass ) . getKind ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( tester . count ( $ . Slim3Model . class ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( ( beforeCount + 1 ) ) ) )"}
{"focal": "getById ( int ) { return net . ripe . db . whois . common . dao . jdbc . JdbcRpslObjectOperations . getSerialEntry ( jdbcTemplate , serialId ) ; }", "testMethod": "getById ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( \"person:<sp>Test\\n\" + \"nic-hdl:<sp>TEST-PN\\n\" ) + \"source:<sp>RIPE\\n\" ) ) ) ; databaseHelper . addObject ( rpslObject ) ; final net . ripe . db . whois . common . rpsl . RpslObject object = subject . getById ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( object , org . hamcrest . Matchers . is ( rpslObject ) )", "total": "getById ( ) { final net . ripe . db . whois . common . rpsl . RpslObject rpslObject = net . ripe . db . whois . common . rpsl . RpslObject . parse ( ( \"\" + ( ( \"person:<sp>Test\\n\" + \"nic-hdl:<sp>TEST-PN\\n\" ) + \"source:<sp>RIPE\\n\" ) ) ) ; databaseHelper . addObject ( rpslObject ) ; final net . ripe . db . whois . common . rpsl . RpslObject object = subject . getById ( 1 ) ; \"<AssertPlaceHolder>\" ; } getById ( int ) { return net . ripe . db . whois . common . dao . jdbc . JdbcRpslObjectOperations . getSerialEntry ( jdbcTemplate , serialId ) ; }", "answer": "org . junit . Assert . assertThat ( object , org . hamcrest . Matchers . is ( rpslObject ) )"}
{"focal": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "testMethod": "testEqualsObject_NullObject ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( target . equals ( null ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "testEqualsObject_NullObject ( ) { \"<AssertPlaceHolder>\" ; } equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . o3project . odenos . remoteobject . event . EventSubscription ) ) { return false ; } org . o3project . odenos . remoteobject . event . EventSubscription eventSubscription = ( ( org . o3project . odenos . remoteobject . event . EventSubscription ) ( obj ) ) ; return this . subscriberId . equals ( eventSubscription . getSubscriberId ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( target . equals ( null ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "add ( java . lang . String , int ) { int oldSize = size ( item ) ; int newSize = oldSize + num ; list . put ( item , newSize ) ; }", "testMethod": "add516 ( ) { tdd . Calculator sut = new tdd . Calculator ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( sut . add ( 5 , 1 ) , org . hamcrest . CoreMatchers . is ( 6 ) )", "total": "add516 ( ) { tdd . Calculator sut = new tdd . Calculator ( ) ; \"<AssertPlaceHolder>\" ; } add ( java . lang . String , int ) { int oldSize = size ( item ) ; int newSize = oldSize + num ; list . put ( item , newSize ) ; }", "answer": "org . junit . Assert . assertThat ( sut . add ( 5 , 1 ) , org . hamcrest . CoreMatchers . is ( 6 ) )"}
{"focal": "build ( ) { return observer ; }", "testMethod": "testOutputMapCreation ( ) { java . util . List < java . lang . String > outputs = java . util . Arrays . asList ( \"output1\" , \"output2\" , \"output3\" ) ; org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . BiMap < java . lang . String , java . lang . Integer > outputMap = org . apache . beam . runners . fnexecution . translation . PipelineTranslatorUtils . createOutputMap ( outputs ) ; java . util . Map < java . lang . Object , java . lang . Object > expected = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableMap . builder ( ) . put ( \"output1\" , 0 ) . put ( \"output2\" , 1 ) . put ( \"output3\" , 2 ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( outputMap , org . hamcrest . core . Is . is ( expected ) )", "total": "testOutputMapCreation ( ) { java . util . List < java . lang . String > outputs = java . util . Arrays . asList ( \"output1\" , \"output2\" , \"output3\" ) ; org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . BiMap < java . lang . String , java . lang . Integer > outputMap = org . apache . beam . runners . fnexecution . translation . PipelineTranslatorUtils . createOutputMap ( outputs ) ; java . util . Map < java . lang . Object , java . lang . Object > expected = org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . ImmutableMap . builder ( ) . put ( \"output1\" , 0 ) . put ( \"output2\" , 1 ) . put ( \"output3\" , 2 ) . build ( ) ; \"<AssertPlaceHolder>\" ; } build ( ) { return observer ; }", "answer": "org . junit . Assert . assertThat ( outputMap , org . hamcrest . core . Is . is ( expected ) )"}
{"focal": "getIssues ( ) { return issues ; }", "testMethod": "testPredefOption ( ) { lint . addOption ( Option . PREDEF , \"foo,bar\" ) ; com . googlecode . jslint4java . JSLintResult result = lint ( \"foo(bar(42));\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result . getIssues ( ) , org . hamcrest . Matchers . empty ( ) )", "total": "testPredefOption ( ) { lint . addOption ( Option . PREDEF , \"foo,bar\" ) ; com . googlecode . jslint4java . JSLintResult result = lint ( \"foo(bar(42));\" ) ; \"<AssertPlaceHolder>\" ; } getIssues ( ) { return issues ; }", "answer": "org . junit . Assert . assertThat ( result . getIssues ( ) , org . hamcrest . Matchers . empty ( ) )"}
{"focal": "getChannelState ( ) { return channelState ; }", "testMethod": "receiveStringTest ( ) { org . eclipse . smarthome . binding . mqtt . generic . internal . generic . ChannelState c = spy ( new org . eclipse . smarthome . binding . mqtt . generic . internal . generic . ChannelState ( config , channelUID , textValue , channelStateUpdateListener ) ) ; java . util . concurrent . CompletableFuture < java . lang . @ org . eclipse . jdt . annotation . Nullable Void > future = c . start ( connection , scheduler , 100 ) ; c . processMessage ( \"state\" , \"A<sp>TEST\" . getBytes ( ) ) ; future . get ( 300 , TimeUnit . MILLISECONDS ) ; \"<AssertPlaceHolder>\" ; verify ( channelStateUpdateListener ) . updateChannelState ( eq ( channelUID ) , org . hamcrest . CoreMatchers . any ( ) ) ; }", "assertLine": "org . junit . Assert . assertThat ( textValue . getChannelState ( ) . toString ( ) , org . hamcrest . CoreMatchers . is ( \"A<sp>TEST\" ) )", "total": "receiveStringTest ( ) { org . eclipse . smarthome . binding . mqtt . generic . internal . generic . ChannelState c = spy ( new org . eclipse . smarthome . binding . mqtt . generic . internal . generic . ChannelState ( config , channelUID , textValue , channelStateUpdateListener ) ) ; java . util . concurrent . CompletableFuture < java . lang . @ org . eclipse . jdt . annotation . Nullable Void > future = c . start ( connection , scheduler , 100 ) ; c . processMessage ( \"state\" , \"A<sp>TEST\" . getBytes ( ) ) ; future . get ( 300 , TimeUnit . MILLISECONDS ) ; \"<AssertPlaceHolder>\" ; verify ( channelStateUpdateListener ) . updateChannelState ( eq ( channelUID ) , org . hamcrest . CoreMatchers . any ( ) ) ; } getChannelState ( ) { return channelState ; }", "answer": "org . junit . Assert . assertThat ( textValue . getChannelState ( ) . toString ( ) , org . hamcrest . CoreMatchers . is ( \"A<sp>TEST\" ) )"}
{"focal": "get ( java . lang . Object , java . lang . String ) { org . springframework . util . Assert . notNull ( id , \"Cannot<sp>get<sp>item<sp>with<sp>null<sp>id.\" ) ; return getKeySpaceMap ( keyspace ) . get ( id ) ; }", "testMethod": "getShouldReturnElementWhenMatchingIdPresent ( ) { adapter . put ( \"1\" , object1 , org . springframework . data . map . MapKeyValueAdapterUnitTests . COLLECTION_1 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( adapter . get ( \"1\" , org . springframework . data . map . MapKeyValueAdapterUnitTests . COLLECTION_1 ) , org . hamcrest . core . Is . is ( object1 ) )", "total": "getShouldReturnElementWhenMatchingIdPresent ( ) { adapter . put ( \"1\" , object1 , org . springframework . data . map . MapKeyValueAdapterUnitTests . COLLECTION_1 ) ; \"<AssertPlaceHolder>\" ; } get ( java . lang . Object , java . lang . String ) { org . springframework . util . Assert . notNull ( id , \"Cannot<sp>get<sp>item<sp>with<sp>null<sp>id.\" ) ; return getKeySpaceMap ( keyspace ) . get ( id ) ; }", "answer": "org . junit . Assert . assertThat ( adapter . get ( \"1\" , org . springframework . data . map . MapKeyValueAdapterUnitTests . COLLECTION_1 ) , org . hamcrest . core . Is . is ( object1 ) )"}
{"focal": "next ( ) { return mapper . apply ( iterator . next ( ) ) ; }", "testMethod": "mapFilterNext ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final long count = cursor . map ( new com . arangodb . Function < com . arangodb . velocypack . VPackSlice , java . lang . Long > ( ) { @ com . arangodb . Override public com . arangodb . Long apply ( final com . arangodb . velocypack . VPackSlice t ) { return t . getAsLong ( ) ; } } ) . filter ( new com . arangodb . Predicate < java . lang . Long > ( ) { @ com . arangodb . Override public boolean test ( final java . lang . Long t ) { return t < 50 ; } } ) . iterator ( ) . next ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( count , org . hamcrest . Matchers . is ( 0L ) )", "total": "mapFilterNext ( ) { final com . arangodb . ArangoCursor < com . arangodb . velocypack . VPackSlice > cursor = db . query ( \"FOR<sp>i<sp>IN<sp>0..99<sp>RETURN<sp>i\" , com . arangodb . velocypack . VPackSlice . class ) ; final long count = cursor . map ( new com . arangodb . Function < com . arangodb . velocypack . VPackSlice , java . lang . Long > ( ) { @ com . arangodb . Override public com . arangodb . Long apply ( final com . arangodb . velocypack . VPackSlice t ) { return t . getAsLong ( ) ; } } ) . filter ( new com . arangodb . Predicate < java . lang . Long > ( ) { @ com . arangodb . Override public boolean test ( final java . lang . Long t ) { return t < 50 ; } } ) . iterator ( ) . next ( ) ; \"<AssertPlaceHolder>\" ; } next ( ) { return mapper . apply ( iterator . next ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( count , org . hamcrest . Matchers . is ( 0L ) )"}
{"focal": "getResult ( ) { return this . result ; }", "testMethod": "testAction ( ) { final ru . lessons . lesson_28 . Output out = new ru . lessons . lesson_28 . OutputStub ( ) ; final ru . lessons . lesson_28 . Input input = new ru . lessons . lesson_28 . InputStub ( java . util . Arrays . asList ( \"1\" , \"+\" , \"1\" , \"no\" , \"yes\" ) . iterator ( ) , out ) ; final ru . lessons . lesson_4 . Calculator calc = new ru . lessons . lesson_4 . Calculator ( ) ; final ru . lessons . lesson_28 . InteractCalculator interact = new ru . lessons . lesson_28 . InteractCalculator ( input , out , calc ) ; interact . action ( ) ; input . close ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( calc . getResult ( ) , org . hamcrest . core . Is . is ( 2 ) )", "total": "testAction ( ) { final ru . lessons . lesson_28 . Output out = new ru . lessons . lesson_28 . OutputStub ( ) ; final ru . lessons . lesson_28 . Input input = new ru . lessons . lesson_28 . InputStub ( java . util . Arrays . asList ( \"1\" , \"+\" , \"1\" , \"no\" , \"yes\" ) . iterator ( ) , out ) ; final ru . lessons . lesson_4 . Calculator calc = new ru . lessons . lesson_4 . Calculator ( ) ; final ru . lessons . lesson_28 . InteractCalculator interact = new ru . lessons . lesson_28 . InteractCalculator ( input , out , calc ) ; interact . action ( ) ; input . close ( ) ; \"<AssertPlaceHolder>\" ; } getResult ( ) { return this . result ; }", "answer": "org . junit . Assert . assertThat ( calc . getResult ( ) , org . hamcrest . core . Is . is ( 2 ) )"}
{"focal": "getStatusMessage ( ) { if ( ( statusMsg ) == null ) { return getMessage ( org . infinitest . intellij . plugin . swingui . INDEXING ) ; } java . lang . String msg = statusMsg . replace ( \"$TEST_COUNT\" , java . lang . Integer . toString ( getMaximum ( ) ) ) ; msg = msg . replace ( \"$TESTS_RAN\" , java . lang . Integer . toString ( getValue ( ) ) ) ; msg = msg . replace ( \"$CURRENT_TEST\" , getCurrentTest ( ) ) ; return msg ; }", "testMethod": "shouldReplaceAllVariablesInCurrentStatusMessages ( ) { org . infinitest . CoreStatus . CoreStatus [ ] statuses = new org . infinitest . CoreStatus . CoreStatus [ ] { SCANNING , INDEXING , RUNNING , PASSING , FAILING } ; for ( org . infinitest . CoreStatus . CoreStatus status : statuses ) { progressBar . setStatusMessage ( getMessage ( status ) ) ; \"<AssertPlaceHolder>\" . doesNotContain ( \"$\" ) ; } }", "assertLine": "org . junit . Assert . assertThat ( progressBar . getStatusMessage ( ) )", "total": "shouldReplaceAllVariablesInCurrentStatusMessages ( ) { org . infinitest . CoreStatus . CoreStatus [ ] statuses = new org . infinitest . CoreStatus . CoreStatus [ ] { SCANNING , INDEXING , RUNNING , PASSING , FAILING } ; for ( org . infinitest . CoreStatus . CoreStatus status : statuses ) { progressBar . setStatusMessage ( getMessage ( status ) ) ; \"<AssertPlaceHolder>\" . doesNotContain ( \"$\" ) ; } } getStatusMessage ( ) { if ( ( statusMsg ) == null ) { return getMessage ( org . infinitest . intellij . plugin . swingui . INDEXING ) ; } java . lang . String msg = statusMsg . replace ( \"$TEST_COUNT\" , java . lang . Integer . toString ( getMaximum ( ) ) ) ; msg = msg . replace ( \"$TESTS_RAN\" , java . lang . Integer . toString ( getValue ( ) ) ) ; msg = msg . replace ( \"$CURRENT_TEST\" , getCurrentTest ( ) ) ; return msg ; }", "answer": "org . junit . Assert . assertThat ( progressBar . getStatusMessage ( ) )"}
{"focal": "format ( com . github . mygreen . supercsv . localization . MessageResolver , com . github . mygreen . supercsv . localization . MessageInterpolator ) { for ( java . lang . String code : getCodes ( ) ) { java . util . Optional < java . lang . String > message = messageResolver . getMessage ( code ) ; if ( message . isPresent ( ) ) { return messageInterpolator . interpolate ( message . get ( ) , getVariables ( ) , true , messageResolver ) ; } } return messageInterpolator . interpolate ( getDefaultMessage ( ) , getVariables ( ) , true , messageResolver ) ; }", "testMethod": "testValidate_getter_boolean ( ) { java . lang . Class < ? > [ ] groups = new java . lang . Class [ ] { com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . Group4 . class } ; com . github . mygreen . supercsv . validation . CsvBindingErrors bindingErrors = new com . github . mygreen . supercsv . validation . CsvBindingErrors ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class ) ; com . github . mygreen . supercsv . builder . BeanMapping < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > beanMapping = beanMappingFactory . create ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class , groupEmpty ) ; com . github . mygreen . supercsv . validation . ValidationContext < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > validationContext = new com . github . mygreen . supercsv . validation . ValidationContext ( ANONYMOUS_CSVCONTEXT , beanMapping ) ; com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv record = new com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv ( ) ; record . id = \"a01\" ; record . used = false ; csvValidator . validate ( record , bindingErrors , ( ( com . github . mygreen . supercsv . validation . ValidationContext ) ( validationContext ) ) , groups ) ; java . util . List < java . lang . String > messages = bindingErrors . getAllErrors ( ) . stream ( ) . map ( ( error ) -> error . format ( testMessageResolver , messageInterpolator ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" . hasSize ( 1 ) . contains ( \"true\" ) ; }", "assertLine": "org . junit . Assert . assertThat ( messages )", "total": "testValidate_getter_boolean ( ) { java . lang . Class < ? > [ ] groups = new java . lang . Class [ ] { com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . Group4 . class } ; com . github . mygreen . supercsv . validation . CsvBindingErrors bindingErrors = new com . github . mygreen . supercsv . validation . CsvBindingErrors ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class ) ; com . github . mygreen . supercsv . builder . BeanMapping < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > beanMapping = beanMappingFactory . create ( com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv . class , groupEmpty ) ; com . github . mygreen . supercsv . validation . ValidationContext < com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv > validationContext = new com . github . mygreen . supercsv . validation . ValidationContext ( ANONYMOUS_CSVCONTEXT , beanMapping ) ; com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv record = new com . github . mygreen . supercsv . validation . beanvalidation . CsvBeanValidatorTest . TestCsv ( ) ; record . id = \"a01\" ; record . used = false ; csvValidator . validate ( record , bindingErrors , ( ( com . github . mygreen . supercsv . validation . ValidationContext ) ( validationContext ) ) , groups ) ; java . util . List < java . lang . String > messages = bindingErrors . getAllErrors ( ) . stream ( ) . map ( ( error ) -> error . format ( testMessageResolver , messageInterpolator ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; \"<AssertPlaceHolder>\" . hasSize ( 1 ) . contains ( \"true\" ) ; } format ( com . github . mygreen . supercsv . localization . MessageResolver , com . github . mygreen . supercsv . localization . MessageInterpolator ) { for ( java . lang . String code : getCodes ( ) ) { java . util . Optional < java . lang . String > message = messageResolver . getMessage ( code ) ; if ( message . isPresent ( ) ) { return messageInterpolator . interpolate ( message . get ( ) , getVariables ( ) , true , messageResolver ) ; } } return messageInterpolator . interpolate ( getDefaultMessage ( ) , getVariables ( ) , true , messageResolver ) ; }", "answer": "org . junit . Assert . assertThat ( messages )"}
{"focal": "process ( javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse , javax . servlet . FilterChain ) { java . lang . String pathInfo = req . getPathInfo ( ) ; if ( ( pathInfo != null ) && ( pathInfo . equals ( getExclusionPath ( ) ) ) ) { chain . doFilter ( req , resp ) ; return true ; } return false ; }", "testMethod": "testProcessPathInfo ( ) { java . lang . String pathInfo = ( '/' + ( GitBucketWebHook . WEBHOOK_URL ) ) + '/' ; javax . servlet . http . HttpServletRequest req = mock ( javax . servlet . http . HttpServletRequest . class ) ; javax . servlet . http . HttpServletResponse res = mock ( javax . servlet . http . HttpServletResponse . class ) ; javax . servlet . FilterChain chain = mock ( javax . servlet . FilterChain . class ) ; when ( req . getPathInfo ( ) ) . thenReturn ( pathInfo ) ; boolean actual = target . process ( req , res , chain ) ; \"<AssertPlaceHolder>\" ; verify ( chain , times ( 1 ) ) . doFilter ( req , res ) ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( true ) )", "total": "testProcessPathInfo ( ) { java . lang . String pathInfo = ( '/' + ( GitBucketWebHook . WEBHOOK_URL ) ) + '/' ; javax . servlet . http . HttpServletRequest req = mock ( javax . servlet . http . HttpServletRequest . class ) ; javax . servlet . http . HttpServletResponse res = mock ( javax . servlet . http . HttpServletResponse . class ) ; javax . servlet . FilterChain chain = mock ( javax . servlet . FilterChain . class ) ; when ( req . getPathInfo ( ) ) . thenReturn ( pathInfo ) ; boolean actual = target . process ( req , res , chain ) ; \"<AssertPlaceHolder>\" ; verify ( chain , times ( 1 ) ) . doFilter ( req , res ) ; } process ( javax . servlet . http . HttpServletRequest , javax . servlet . http . HttpServletResponse , javax . servlet . FilterChain ) { java . lang . String pathInfo = req . getPathInfo ( ) ; if ( ( pathInfo != null ) && ( pathInfo . equals ( getExclusionPath ( ) ) ) ) { chain . doFilter ( req , resp ) ; return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "size ( ) { return 0 ; }", "testMethod": "distinct_A$_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > actual = seq . distinct ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "total": "distinct_A$_Nil ( ) { com . m3 . scalaflavor4j . Seq < java . lang . Integer > seq = com . m3 . scalaflavor4j . Seq . apply ( ) ; com . m3 . scalaflavor4j . Seq < java . lang . Integer > actual = seq . distinct ( ) ; \"<AssertPlaceHolder>\" ; } size ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( actual . size ( ) , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )"}
{"focal": "getInput ( ) { return org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . Iterables . getOnlyElement ( org . apache . beam . runners . core . construction . TransformInputs . nonAdditionalInputs ( getCurrentTransform ( ) ) ) ; }", "testMethod": "getInputSucceeds ( ) { org . apache . beam . sdk . testing . TestPipeline p = org . apache . beam . sdk . testing . TestPipeline . create ( ) ; org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Integer > > input = p . apply ( org . apache . beam . sdk . transforms . Create . of ( org . apache . beam . sdk . values . KV . of ( \"foo\" , 1 ) ) . withCoder ( org . apache . beam . sdk . coders . KvCoder . of ( org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) , org . apache . beam . sdk . coders . VarIntCoder . of ( ) ) ) ) ; org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Iterable < java . lang . Integer > > > grouped = input . apply ( org . apache . beam . sdk . transforms . GroupByKey . create ( ) ) ; org . apache . beam . sdk . runners . AppliedPTransform < ? , ? , ? > producer = org . apache . beam . runners . direct . DirectGraphs . getProducer ( grouped ) ; org . apache . beam . sdk . runners . PTransformOverrideFactory . PTransformReplacement < org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Integer > > , org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Iterable < java . lang . Integer > > > > replacement = factory . getReplacementTransform ( ( ( org . apache . beam . sdk . runners . AppliedPTransform ) ( producer ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( replacement . getInput ( ) , org . hamcrest . Matchers . < org . apache . beam . sdk . values . PCollection < ? > > equalTo ( input ) )", "total": "getInputSucceeds ( ) { org . apache . beam . sdk . testing . TestPipeline p = org . apache . beam . sdk . testing . TestPipeline . create ( ) ; org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Integer > > input = p . apply ( org . apache . beam . sdk . transforms . Create . of ( org . apache . beam . sdk . values . KV . of ( \"foo\" , 1 ) ) . withCoder ( org . apache . beam . sdk . coders . KvCoder . of ( org . apache . beam . sdk . coders . StringUtf8Coder . of ( ) , org . apache . beam . sdk . coders . VarIntCoder . of ( ) ) ) ) ; org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Iterable < java . lang . Integer > > > grouped = input . apply ( org . apache . beam . sdk . transforms . GroupByKey . create ( ) ) ; org . apache . beam . sdk . runners . AppliedPTransform < ? , ? , ? > producer = org . apache . beam . runners . direct . DirectGraphs . getProducer ( grouped ) ; org . apache . beam . sdk . runners . PTransformOverrideFactory . PTransformReplacement < org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Integer > > , org . apache . beam . sdk . values . PCollection < org . apache . beam . sdk . values . KV < java . lang . String , java . lang . Iterable < java . lang . Integer > > > > replacement = factory . getReplacementTransform ( ( ( org . apache . beam . sdk . runners . AppliedPTransform ) ( producer ) ) ) ; \"<AssertPlaceHolder>\" ; } getInput ( ) { return org . apache . beam . vendor . guava . v20_0 . com . google . common . collect . Iterables . getOnlyElement ( org . apache . beam . runners . core . construction . TransformInputs . nonAdditionalInputs ( getCurrentTransform ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( replacement . getInput ( ) , org . hamcrest . Matchers . < org . apache . beam . sdk . values . PCollection < ? > > equalTo ( input ) )"}
{"focal": "getLocalizedMessage ( ) { return this . message ; }", "testMethod": "getLocalizedMessage_A$ ( ) { java . lang . String message = \"xxx\" ; com . m3 . curly . Response response = null ; com . m3 . curly . HTTPIOException target = new com . m3 . curly . HTTPIOException ( message , response ) ; java . lang . String actual = target . getLocalizedMessage ( ) ; java . lang . String expected = \"xxx\" ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "getLocalizedMessage_A$ ( ) { java . lang . String message = \"xxx\" ; com . m3 . curly . Response response = null ; com . m3 . curly . HTTPIOException target = new com . m3 . curly . HTTPIOException ( message , response ) ; java . lang . String actual = target . getLocalizedMessage ( ) ; java . lang . String expected = \"xxx\" ; \"<AssertPlaceHolder>\" ; } getLocalizedMessage ( ) { return this . message ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "parseArguments_empty_value ( ) { java . util . Map < java . lang . String , java . lang . String > parsed = com . asakusafw . windgate . cli . CommandLineUtil . parseArguments ( \"hello=\" ) . getPairs ( ) ; java . util . Map < java . lang . String , java . lang . String > answer = new java . util . HashMap ( ) ; answer . put ( \"hello\" , \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( parsed , is ( answer ) )", "total": "parseArguments_empty_value ( ) { java . util . Map < java . lang . String , java . lang . String > parsed = com . asakusafw . windgate . cli . CommandLineUtil . parseArguments ( \"hello=\" ) . getPairs ( ) ; java . util . Map < java . lang . String , java . lang . String > answer = new java . util . HashMap ( ) ; answer . put ( \"hello\" , \"\" ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( parsed , is ( answer ) )"}
{"focal": "compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "testMethod": "selectionWithConditionExpression ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , Selection ( Comparison ( \"==\" , Property ( \"bar\" ) , Property ( \"baz\" ) ) ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo[?bar<sp>==<sp>baz]\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )", "total": "selectionWithConditionExpression ( ) { io . burt . jmespath . Expression < java . lang . Object > expected = Sequence ( Property ( \"foo\" ) , Selection ( Comparison ( \"==\" , Property ( \"bar\" ) , Property ( \"baz\" ) ) ) ) ; io . burt . jmespath . Expression < java . lang . Object > actual = compile ( \"foo[?bar<sp>==<sp>baz]\" ) ; \"<AssertPlaceHolder>\" ; } compile ( java . lang . String ) { return runtime . compile ( str ) ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . Matchers . is ( expected ) )"}
{"focal": "isNull ( ) { return nullValue ; }", "testMethod": "writableOption ( ) { com . asakusafw . runtime . value . DateTimeOption option = new com . asakusafw . runtime . value . DateTimeOption ( ) ; com . asakusafw . runtime . value . DateTimeOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( restored . isNull ( ) , is ( true ) )", "total": "writableOption ( ) { com . asakusafw . runtime . value . DateTimeOption option = new com . asakusafw . runtime . value . DateTimeOption ( ) ; com . asakusafw . runtime . value . DateTimeOption restored = restore ( option ) ; \"<AssertPlaceHolder>\" ; } isNull ( ) { return nullValue ; }", "answer": "org . junit . Assert . assertThat ( restored . isNull ( ) , is ( true ) )"}
{"focal": "is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "testMethod": "invalid_format ( ) { java . io . File output = folder . newFolder ( \"output\" ) ; java . io . File source = folder . newFolder ( \"source\" ) ; deploy ( \"simple.dmdl\" , source ) ; java . util . List < java . lang . String > args = new java . util . ArrayList ( ) ; java . util . Collections . addAll ( args , \"-output\" , output . getAbsolutePath ( ) ) ; java . util . Collections . addAll ( args , \"-source\" , source . getAbsolutePath ( ) ) ; java . util . Collections . addAll ( args , \"-format\" , \"INVALID_FORMAT\" ) ; int exit = com . asakusafw . testdata . generator . excel . Main . start ( args . toArray ( new java . lang . String [ args . size ( ) ] ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( exit , is ( 1 ) )", "total": "invalid_format ( ) { java . io . File output = folder . newFolder ( \"output\" ) ; java . io . File source = folder . newFolder ( \"source\" ) ; deploy ( \"simple.dmdl\" , source ) ; java . util . List < java . lang . String > args = new java . util . ArrayList ( ) ; java . util . Collections . addAll ( args , \"-output\" , output . getAbsolutePath ( ) ) ; java . util . Collections . addAll ( args , \"-source\" , source . getAbsolutePath ( ) ) ; java . util . Collections . addAll ( args , \"-format\" , \"INVALID_FORMAT\" ) ; int exit = com . asakusafw . testdata . generator . excel . Main . start ( args . toArray ( new java . lang . String [ args . size ( ) ] ) ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . String ) { com . asakusafw . dmdl . java . util . JavaName jn = com . asakusafw . dmdl . java . util . JavaName . of ( new com . asakusafw . dmdl . model . AstSimpleName ( null , name ) ) ; jn . addFirst ( \"is\" ) ; java . lang . Object result = invoke ( jn . toMemberName ( ) ) ; return ( ( java . lang . Boolean ) ( result ) ) ; }", "answer": "org . junit . Assert . assertThat ( exit , is ( 1 ) )"}
{"focal": "keySet ( ) { return pCollectionIdsToConsumers . keySet ( ) ; }", "testMethod": "multipleConsumersSamePCollection ( ) { final java . lang . String pCollectionA = \"pCollectionA\" ; final java . lang . String pTransformId = \"pTransformId\" ; org . apache . beam . runners . core . metrics . MetricsContainerStepMap metricsContainerRegistry = new org . apache . beam . runners . core . metrics . MetricsContainerStepMap ( ) ; org . apache . beam . fn . harness . data . PCollectionConsumerRegistry consumers = new org . apache . beam . fn . harness . data . PCollectionConsumerRegistry ( metricsContainerRegistry , mock ( org . apache . beam . runners . core . metrics . ExecutionStateTracker . class ) ) ; org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > consumerA1 = mock ( org . apache . beam . sdk . fn . data . FnDataReceiver . class ) ; org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > consumerA2 = mock ( org . apache . beam . sdk . fn . data . FnDataReceiver . class ) ; consumers . register ( pCollectionA , pTransformId , consumerA1 ) ; consumers . register ( pCollectionA , pTransformId , consumerA2 ) ; org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > wrapperConsumer = ( ( org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > ) ( ( org . apache . beam . sdk . fn . data . FnDataReceiver ) ( consumers . getMultiplexingConsumer ( pCollectionA ) ) ) ) ; org . apache . beam . sdk . util . WindowedValue < java . lang . String > element = org . apache . beam . sdk . util . WindowedValue . valueInGlobalWindow ( \"elem\" ) ; int numElements = 20 ; for ( int i = 0 ; i < numElements ; i ++ ) { wrapperConsumer . accept ( element ) ; } verify ( consumerA1 , times ( numElements ) ) . accept ( element ) ; verify ( consumerA2 , times ( numElements ) ) . accept ( element ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( consumers . keySet ( ) , org . hamcrest . Matchers . contains ( pCollectionA ) )", "total": "multipleConsumersSamePCollection ( ) { final java . lang . String pCollectionA = \"pCollectionA\" ; final java . lang . String pTransformId = \"pTransformId\" ; org . apache . beam . runners . core . metrics . MetricsContainerStepMap metricsContainerRegistry = new org . apache . beam . runners . core . metrics . MetricsContainerStepMap ( ) ; org . apache . beam . fn . harness . data . PCollectionConsumerRegistry consumers = new org . apache . beam . fn . harness . data . PCollectionConsumerRegistry ( metricsContainerRegistry , mock ( org . apache . beam . runners . core . metrics . ExecutionStateTracker . class ) ) ; org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > consumerA1 = mock ( org . apache . beam . sdk . fn . data . FnDataReceiver . class ) ; org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > consumerA2 = mock ( org . apache . beam . sdk . fn . data . FnDataReceiver . class ) ; consumers . register ( pCollectionA , pTransformId , consumerA1 ) ; consumers . register ( pCollectionA , pTransformId , consumerA2 ) ; org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > wrapperConsumer = ( ( org . apache . beam . sdk . fn . data . FnDataReceiver < org . apache . beam . sdk . util . WindowedValue < java . lang . String > > ) ( ( org . apache . beam . sdk . fn . data . FnDataReceiver ) ( consumers . getMultiplexingConsumer ( pCollectionA ) ) ) ) ; org . apache . beam . sdk . util . WindowedValue < java . lang . String > element = org . apache . beam . sdk . util . WindowedValue . valueInGlobalWindow ( \"elem\" ) ; int numElements = 20 ; for ( int i = 0 ; i < numElements ; i ++ ) { wrapperConsumer . accept ( element ) ; } verify ( consumerA1 , times ( numElements ) ) . accept ( element ) ; verify ( consumerA2 , times ( numElements ) ) . accept ( element ) ; \"<AssertPlaceHolder>\" ; } keySet ( ) { return pCollectionIdsToConsumers . keySet ( ) ; }", "answer": "org . junit . Assert . assertThat ( consumers . keySet ( ) , org . hamcrest . Matchers . contains ( pCollectionA ) )"}
{"focal": "is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "testMethod": "no_quotes ( ) { java . lang . String escape = org . apache . isis . core . runtime . services . i18n . po . PoWriter . escape ( \"abc\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( escape , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"abc\" ) ) )", "total": "no_quotes ( ) { java . lang . String escape = org . apache . isis . core . runtime . services . i18n . po . PoWriter . escape ( \"abc\" ) ; \"<AssertPlaceHolder>\" ; } is ( org . apache . isis . core . metamodel . spec . feature . Contributed ) { return new com . google . common . base . Predicate < T > ( ) { @ org . apache . isis . core . metamodel . specloader . specimpl . Override public boolean apply ( org . apache . isis . core . metamodel . spec . feature . ObjectMember input ) { return contributed . isIncluded ( ) ; } } ; }", "answer": "org . junit . Assert . assertThat ( escape , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( \"abc\" ) ) )"}
{"focal": "isPermitted ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType ) { boolean permitted ; oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . ResponseType xacmlResponse ; try { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Calling<sp>PDP<sp>to<sp>evaluate<sp>XACML<sp>request.\" ) ; xacmlResponse = pdp . evaluate ( xacmlRequest ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Received<sp>response<sp>from<sp>PDP.\" ) ; permitted = ( xacmlResponse != null ) && ( ( xacmlResponse . getResult ( ) . get ( 0 ) . getDecision ( ) ) == ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . DecisionType . PERMIT ) ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Permitted:<sp>{}\" , permitted ) ; } catch ( ddf . security . pdp . realm . xacml . processor . PdpException e ) { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( e . getMessage ( ) , e ) ; permitted = false ; } return permitted ; }", "testMethod": "testActionBadAction ( ) { oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType request = ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . createXACMLRequest ( ddf . security . pdp . realm . xacml . XacmlPdpTest . USER_NAME , generateSubjectInfo ( ddf . security . pdp . realm . xacml . XacmlPdpTest . TEST_COUNTRY ) , new ddf . security . permission . KeyValueCollectionPermission ( \"bad\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . isPermitted ( request ) , org . hamcrest . Matchers . equalTo ( false ) )", "total": "testActionBadAction ( ) { oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType request = ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . createXACMLRequest ( ddf . security . pdp . realm . xacml . XacmlPdpTest . USER_NAME , generateSubjectInfo ( ddf . security . pdp . realm . xacml . XacmlPdpTest . TEST_COUNTRY ) , new ddf . security . permission . KeyValueCollectionPermission ( \"bad\" ) ) ; \"<AssertPlaceHolder>\" ; } isPermitted ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . RequestType ) { boolean permitted ; oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . ResponseType xacmlResponse ; try { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Calling<sp>PDP<sp>to<sp>evaluate<sp>XACML<sp>request.\" ) ; xacmlResponse = pdp . evaluate ( xacmlRequest ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Received<sp>response<sp>from<sp>PDP.\" ) ; permitted = ( xacmlResponse != null ) && ( ( xacmlResponse . getResult ( ) . get ( 0 ) . getDecision ( ) ) == ( oasis . names . tc . xacml . _3_0 . core . schema . wd_17 . DecisionType . PERMIT ) ) ; ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( \"Permitted:<sp>{}\" , permitted ) ; } catch ( ddf . security . pdp . realm . xacml . processor . PdpException e ) { ddf . security . pdp . realm . xacml . XacmlPdp . LOGGER . debug ( e . getMessage ( ) , e ) ; permitted = false ; } return permitted ; }", "answer": "org . junit . Assert . assertThat ( ddf . security . pdp . realm . xacml . XacmlPdpTest . testRealm . isPermitted ( request ) , org . hamcrest . Matchers . equalTo ( false ) )"}
{"focal": "getExtConfiguration ( ) { return this . config ; }", "testMethod": "getExtConfiguration_A$ ( ) { org . junithelper . core . config . extension . ExtConfigurationParserHandler target = new org . junithelper . core . config . extension . ExtConfigurationParserHandler ( ) ; org . junithelper . core . config . extension . ExtConfiguration actual = target . getExtConfiguration ( ) ; org . junithelper . core . config . extension . ExtConfiguration expected = null ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "total": "getExtConfiguration_A$ ( ) { org . junithelper . core . config . extension . ExtConfigurationParserHandler target = new org . junithelper . core . config . extension . ExtConfigurationParserHandler ( ) ; org . junithelper . core . config . extension . ExtConfiguration actual = target . getExtConfiguration ( ) ; org . junithelper . core . config . extension . ExtConfiguration expected = null ; \"<AssertPlaceHolder>\" ; } getExtConfiguration ( ) { return this . config ; }", "answer": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )"}
{"focal": "canAcquireIdToken ( com . google . auth . oauth2 . GoogleCredentials ) { final com . spotify . styx . client . GoogleIdTokenAuth idTokenAuth = com . spotify . styx . client . GoogleIdTokenAuth . of ( credentials ) ; final java . lang . String targetAudience = \"http://styx.foo.bar\" ; final java . util . Optional < java . lang . String > token = idTokenAuth . getToken ( targetAudience ) ; final com . google . api . client . googleapis . auth . oauth2 . GoogleIdToken verifiedToken = com . spotify . styx . client . GoogleIdTokenAuthTest . VERIFIER . verify ( token . orElseThrow ( ) ) ; org . junit . Assert . assertThat ( verifiedToken , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . notNullValue ( ) ) ) ; if ( ! ( credentials instanceof com . google . auth . oauth2 . UserCredentials ) ) { org . junit . Assert . assertThat ( verifiedToken . verifyAudience ( com . google . common . collect . ImmutableList . of ( targetAudience ) ) , org . hamcrest . Matchers . is ( true ) ) ; } return true ; }", "testMethod": "testServiceAccountCredentials ( ) { org . junit . Assume . assumeNotNull ( credentials ) ; final com . google . auth . oauth2 . GoogleCredentials serviceAccountCredentials ; final java . net . URI keyUri = java . net . URI . create ( \"gs://styx-oss-test/styx-test-user.json\" ) ; try ( java . io . InputStream is = java . nio . file . Files . newInputStream ( java . nio . file . Paths . get ( keyUri ) ) ) { serviceAccountCredentials = com . google . auth . oauth2 . GoogleCredentials . fromStream ( is ) ; } \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( com . spotify . styx . client . GoogleIdTokenAuthTest . canAcquireIdToken ( serviceAccountCredentials ) , org . hamcrest . Matchers . is ( true ) )", "total": "testServiceAccountCredentials ( ) { org . junit . Assume . assumeNotNull ( credentials ) ; final com . google . auth . oauth2 . GoogleCredentials serviceAccountCredentials ; final java . net . URI keyUri = java . net . URI . create ( \"gs://styx-oss-test/styx-test-user.json\" ) ; try ( java . io . InputStream is = java . nio . file . Files . newInputStream ( java . nio . file . Paths . get ( keyUri ) ) ) { serviceAccountCredentials = com . google . auth . oauth2 . GoogleCredentials . fromStream ( is ) ; } \"<AssertPlaceHolder>\" ; } canAcquireIdToken ( com . google . auth . oauth2 . GoogleCredentials ) { final com . spotify . styx . client . GoogleIdTokenAuth idTokenAuth = com . spotify . styx . client . GoogleIdTokenAuth . of ( credentials ) ; final java . lang . String targetAudience = \"http://styx.foo.bar\" ; final java . util . Optional < java . lang . String > token = idTokenAuth . getToken ( targetAudience ) ; final com . google . api . client . googleapis . auth . oauth2 . GoogleIdToken verifiedToken = com . spotify . styx . client . GoogleIdTokenAuthTest . VERIFIER . verify ( token . orElseThrow ( ) ) ; org . junit . Assert . assertThat ( verifiedToken , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . notNullValue ( ) ) ) ; if ( ! ( credentials instanceof com . google . auth . oauth2 . UserCredentials ) ) { org . junit . Assert . assertThat ( verifiedToken . verifyAudience ( com . google . common . collect . ImmutableList . of ( targetAudience ) ) , org . hamcrest . Matchers . is ( true ) ) ; } return true ; }", "answer": "org . junit . Assert . assertThat ( com . spotify . styx . client . GoogleIdTokenAuthTest . canAcquireIdToken ( serviceAccountCredentials ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "isTestMethod ( org . eclipse . jdt . core . IJavaElement ) { if ( ! ( element instanceof org . eclipse . jdt . core . IMethod ) ) return false ; org . eclipse . jdt . core . IMethod method = ( ( org . eclipse . jdt . core . IMethod ) ( element ) ) ; if ( ! ( method . getReturnType ( ) . equals ( \"V\" ) ) ) return false ; int flags = method . getFlags ( ) ; if ( ( ! ( org . eclipse . jdt . core . Flags . isPublic ( flags ) ) ) || ( org . eclipse . jdt . core . Flags . isStatic ( flags ) ) ) return false ; if ( method . getElementName ( ) . startsWith ( \"test\" ) ) return true ; return junit . extensions . eclipse . quick . JavaElements . hasTestAnnotationOnMethod ( method ) ; }", "testMethod": "test_method_should_has_no_args ( ) { org . eclipse . jdt . core . IMethod element = methodBuilder . returnVoid ( ) . setNumberOfParameters ( 1 ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( junit . extensions . eclipse . quick . JavaElements . isTestMethod ( element ) , org . hamcrest . CoreMatchers . is ( false ) )", "total": "test_method_should_has_no_args ( ) { org . eclipse . jdt . core . IMethod element = methodBuilder . returnVoid ( ) . setNumberOfParameters ( 1 ) . build ( ) ; \"<AssertPlaceHolder>\" ; } isTestMethod ( org . eclipse . jdt . core . IJavaElement ) { if ( ! ( element instanceof org . eclipse . jdt . core . IMethod ) ) return false ; org . eclipse . jdt . core . IMethod method = ( ( org . eclipse . jdt . core . IMethod ) ( element ) ) ; if ( ! ( method . getReturnType ( ) . equals ( \"V\" ) ) ) return false ; int flags = method . getFlags ( ) ; if ( ( ! ( org . eclipse . jdt . core . Flags . isPublic ( flags ) ) ) || ( org . eclipse . jdt . core . Flags . isStatic ( flags ) ) ) return false ; if ( method . getElementName ( ) . startsWith ( \"test\" ) ) return true ; return junit . extensions . eclipse . quick . JavaElements . hasTestAnnotationOnMethod ( method ) ; }", "answer": "org . junit . Assert . assertThat ( junit . extensions . eclipse . quick . JavaElements . isTestMethod ( element ) , org . hamcrest . CoreMatchers . is ( false ) )"}
{"focal": "is ( java . lang . Class ) { return true ; }", "testMethod": "testInterfaceState ( ) { isisNeighbor . setNeighborState ( IsisInterfaceState . DOWN ) ; isisInterfaceState = isisNeighbor . neighborState ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( isisInterfaceState , org . hamcrest . CoreMatchers . is ( IsisInterfaceState . DOWN ) )", "total": "testInterfaceState ( ) { isisNeighbor . setNeighborState ( IsisInterfaceState . DOWN ) ; isisInterfaceState = isisNeighbor . neighborState ( ) ; \"<AssertPlaceHolder>\" ; } is ( java . lang . Class ) { return true ; }", "answer": "org . junit . Assert . assertThat ( isisInterfaceState , org . hamcrest . CoreMatchers . is ( IsisInterfaceState . DOWN ) )"}
{"focal": "parseTpicHeader ( javax . xml . transform . Source ) { return parseTpicHeader ( io . tracee . transport . SoapHeaderTransport . SOURCE_UNMARSHALLER , source ) ; }", "testMethod": "parseTpicHeaderToEmptyMapIfNoTraceeHeaderIsPresent ( ) { final java . util . Map < java . lang . String , java . lang . String > context = java . util . Collections . emptyMap ( ) ; final javax . xml . soap . SOAPHeader soapHeader = soapMessage . getSOAPHeader ( ) ; unit . renderSoapHeader ( context , soapHeader ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( unit . parseTpicHeader ( soapHeader ) , org . hamcrest . Matchers . equalTo ( java . util . Collections . < java . lang . String , java . lang . String > emptyMap ( ) ) )", "total": "parseTpicHeaderToEmptyMapIfNoTraceeHeaderIsPresent ( ) { final java . util . Map < java . lang . String , java . lang . String > context = java . util . Collections . emptyMap ( ) ; final javax . xml . soap . SOAPHeader soapHeader = soapMessage . getSOAPHeader ( ) ; unit . renderSoapHeader ( context , soapHeader ) ; \"<AssertPlaceHolder>\" ; } parseTpicHeader ( javax . xml . transform . Source ) { return parseTpicHeader ( io . tracee . transport . SoapHeaderTransport . SOURCE_UNMARSHALLER , source ) ; }", "answer": "org . junit . Assert . assertThat ( unit . parseTpicHeader ( soapHeader ) , org . hamcrest . Matchers . equalTo ( java . util . Collections . < java . lang . String , java . lang . String > emptyMap ( ) ) )"}
{"focal": "decode ( com . fasterxml . jackson . databind . node . ObjectNode ) { com . fasterxml . jackson . databind . JsonNode ingressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . INGRESS_POINT ) ; if ( ! ( ingressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint ingress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( ingressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode egressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . EGRESS_POINT ) ; if ( ! ( egressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint egress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( egressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode bidirectionalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . BIDIRECTIONAL ) ; boolean bidirectional = ( bidirectionalJson != null ) ? bidirectionalJson . asBoolean ( ) : false ; com . fasterxml . jackson . databind . JsonNode signalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SIGNAL ) ; org . onosproject . net . OchSignal signal = null ; if ( signalJson != null ) { if ( ! ( signalJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } else { signal = org . onosproject . net . optical . json . OchSignalCodec . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( signalJson ) ) ) ; } } java . lang . String appIdString = nullIsIllegal ( json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) , ( ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) + ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . MISSING_MEMBER_MESSAGE ) ) ) . asText ( ) ; org . onosproject . core . CoreService service = getService ( org . onosproject . core . CoreService . class ) ; org . onosproject . core . ApplicationId appId = nullIsNotFound ( service . getAppId ( appIdString ) , org . onosproject . net . optical . rest . OpticalIntentsWebResource . E_APP_ID_NOT_FOUND ) ; org . onosproject . net . intent . Key key = null ; org . onosproject . net . device . DeviceService deviceService = get ( org . onosproject . net . device . DeviceService . class ) ; com . fasterxml . jackson . databind . JsonNode suggestedPathJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SUGGESTEDPATH ) ; org . onosproject . net . DefaultPath suggestedPath = null ; org . onosproject . net . link . LinkService linkService = get ( org . onosproject . net . link . LinkService . class ) ; if ( suggestedPathJson != null ) { if ( ! ( suggestedPathJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } else { com . fasterxml . jackson . databind . node . ArrayNode linksJson = nullIsIllegal ( ( ( com . fasterxml . jackson . databind . node . ArrayNode ) ( suggestedPathJson . get ( \"links\" ) ) ) , \"Suggested<sp>path<sp>specified<sp>without<sp>links\" ) ; java . util . List < org . onosproject . net . Link > listLinks = new java . util . ArrayList ( ) ; for ( com . fasterxml . jackson . databind . JsonNode node : linksJson ) { java . lang . String srcString = node . get ( \"src\" ) . asText ( ) ; java . lang . String dstString = node . get ( \"dst\" ) . asText ( ) ; org", "testMethod": "testDifferenceSerializable ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . net . resource . DiscreteResource res2 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"b\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources set1 = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 , res2 ) ) ; org . onosproject . store . resource . impl . DiscreteResources set2 = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; org . onosproject . store . resource . impl . DiscreteResources difference = set1 . difference ( set2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( serializer . decode ( serializer . encode ( difference ) ) , org . hamcrest . Matchers . is ( difference ) )", "total": "testDifferenceSerializable ( ) { org . onosproject . net . resource . DiscreteResource res1 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"a\" ) ) . resource ( ) ; org . onosproject . net . resource . DiscreteResource res2 = org . onosproject . net . resource . Resources . discrete ( org . onosproject . net . DeviceId . deviceId ( \"b\" ) ) . resource ( ) ; org . onosproject . store . resource . impl . DiscreteResources set1 = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 , res2 ) ) ; org . onosproject . store . resource . impl . DiscreteResources set2 = org . onosproject . store . resource . impl . GenericDiscreteResources . of ( com . google . common . collect . ImmutableSet . of ( res1 ) ) ; org . onosproject . store . resource . impl . DiscreteResources difference = set1 . difference ( set2 ) ; \"<AssertPlaceHolder>\" ; } decode ( com . fasterxml . jackson . databind . node . ObjectNode ) { com . fasterxml . jackson . databind . JsonNode ingressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . INGRESS_POINT ) ; if ( ! ( ingressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint ingress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( ingressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode egressJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . EGRESS_POINT ) ; if ( ! ( egressJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } org . onosproject . net . ConnectPoint egress = codec ( org . onosproject . net . ConnectPoint . class ) . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( egressJson ) ) , this ) ; com . fasterxml . jackson . databind . JsonNode bidirectionalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . BIDIRECTIONAL ) ; boolean bidirectional = ( bidirectionalJson != null ) ? bidirectionalJson . asBoolean ( ) : false ; com . fasterxml . jackson . databind . JsonNode signalJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SIGNAL ) ; org . onosproject . net . OchSignal signal = null ; if ( signalJson != null ) { if ( ! ( signalJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } else { signal = org . onosproject . net . optical . json . OchSignalCodec . decode ( ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( signalJson ) ) ) ; } } java . lang . String appIdString = nullIsIllegal ( json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) , ( ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . APP_ID ) + ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . MISSING_MEMBER_MESSAGE ) ) ) . asText ( ) ; org . onosproject . core . CoreService service = getService ( org . onosproject . core . CoreService . class ) ; org . onosproject . core . ApplicationId appId = nullIsNotFound ( service . getAppId ( appIdString ) , org . onosproject . net . optical . rest . OpticalIntentsWebResource . E_APP_ID_NOT_FOUND ) ; org . onosproject . net . intent . Key key = null ; org . onosproject . net . device . DeviceService deviceService = get ( org . onosproject . net . device . DeviceService . class ) ; com . fasterxml . jackson . databind . JsonNode suggestedPathJson = json . get ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . SUGGESTEDPATH ) ; org . onosproject . net . DefaultPath suggestedPath = null ; org . onosproject . net . link . LinkService linkService = get ( org . onosproject . net . link . LinkService . class ) ; if ( suggestedPathJson != null ) { if ( ! ( suggestedPathJson . isObject ( ) ) ) { throw new java . lang . IllegalArgumentException ( org . onosproject . net . optical . rest . OpticalIntentsWebResource . JSON_INVALID ) ; } else { com . fasterxml . jackson . databind . node . ArrayNode linksJson = nullIsIllegal ( ( ( com . fasterxml . jackson . databind . node . ArrayNode ) ( suggestedPathJson . get ( \"links\" ) ) ) , \"Suggested<sp>path<sp>specified<sp>without<sp>links\" ) ; java . util . List < org . onosproject . net . Link > listLinks = new java . util . ArrayList ( ) ; for ( com . fasterxml . jackson . databind . JsonNode node : linksJson ) { java . lang . String srcString = node . get ( \"src\" ) . asText ( ) ; java . lang . String dstString = node . get ( \"dst\" ) . asText ( ) ; org", "answer": "org . junit . Assert . assertThat ( serializer . decode ( serializer . encode ( difference ) ) , org . hamcrest . Matchers . is ( difference ) )"}
{"focal": "resolveExceptionLevel ( java . lang . Exception ) { java . lang . String exceptionCode = resolveExceptionCode ( ex ) ; if ( ( exceptionCode == null ) || ( exceptionCode . isEmpty ( ) ) ) { return ExceptionLevel . ERROR ; } java . lang . String exceptionCodePrefix = exceptionCode . substring ( 0 , 1 ) ; if ( \"e\" . equalsIgnoreCase ( exceptionCodePrefix ) ) { return ExceptionLevel . ERROR ; } if ( \"w\" . equalsIgnoreCase ( exceptionCodePrefix ) ) { return ExceptionLevel . WARN ; } if ( \"i\" . equalsIgnoreCase ( exceptionCodePrefix ) ) { return ExceptionLevel . INFO ; } return ExceptionLevel . ERROR ; }", "testMethod": "testResolveExceptionLevel_info ( ) { java . lang . Exception exception = new org . terasoluna . gfw . common . exception . SystemException ( \"i\" , \"info.\" ) ; org . terasoluna . gfw . common . exception . ExceptionLevel actualExceptionLevel = testTarget . resolveExceptionLevel ( exception ) ; org . terasoluna . gfw . common . exception . ExceptionLevel expectedExceptionLevel = org . terasoluna . gfw . common . exception . ExceptionLevel . INFO ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualExceptionLevel , org . hamcrest . CoreMatchers . is ( expectedExceptionLevel ) )", "total": "testResolveExceptionLevel_info ( ) { java . lang . Exception exception = new org . terasoluna . gfw . common . exception . SystemException ( \"i\" , \"info.\" ) ; org . terasoluna . gfw . common . exception . ExceptionLevel actualExceptionLevel = testTarget . resolveExceptionLevel ( exception ) ; org . terasoluna . gfw . common . exception . ExceptionLevel expectedExceptionLevel = org . terasoluna . gfw . common . exception . ExceptionLevel . INFO ; \"<AssertPlaceHolder>\" ; } resolveExceptionLevel ( java . lang . Exception ) { java . lang . String exceptionCode = resolveExceptionCode ( ex ) ; if ( ( exceptionCode == null ) || ( exceptionCode . isEmpty ( ) ) ) { return ExceptionLevel . ERROR ; } java . lang . String exceptionCodePrefix = exceptionCode . substring ( 0 , 1 ) ; if ( \"e\" . equalsIgnoreCase ( exceptionCodePrefix ) ) { return ExceptionLevel . ERROR ; } if ( \"w\" . equalsIgnoreCase ( exceptionCodePrefix ) ) { return ExceptionLevel . WARN ; } if ( \"i\" . equalsIgnoreCase ( exceptionCodePrefix ) ) { return ExceptionLevel . INFO ; } return ExceptionLevel . ERROR ; }", "answer": "org . junit . Assert . assertThat ( actualExceptionLevel , org . hamcrest . CoreMatchers . is ( expectedExceptionLevel ) )"}
{"focal": "getStatus ( ) { return ctx . getStatus ( ) ; }", "testMethod": "ResourceAvailableTest ( ) { final javax . ws . rs . core . Response response = target ( \"testresource\" ) . request ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( response . getStatus ( ) , org . hamcrest . core . Is . is ( 200 ) )", "total": "ResourceAvailableTest ( ) { final javax . ws . rs . core . Response response = target ( \"testresource\" ) . request ( ) . get ( ) ; \"<AssertPlaceHolder>\" ; } getStatus ( ) { return ctx . getStatus ( ) ; }", "answer": "org . junit . Assert . assertThat ( response . getStatus ( ) , org . hamcrest . core . Is . is ( 200 ) )"}
{"focal": "getVersion ( ) { final com . arangodb . entity . ArangoDBVersion version = db . getVersion ( ) ; org . junit . Assert . assertThat ( version , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; org . junit . Assert . assertThat ( version . getServer ( ) , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; org . junit . Assert . assertThat ( version . getVersion ( ) , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "testMethod": "acquireHostList ( ) { final com . arangodb . ArangoDB arango = new com . arangodb . ArangoDB . Builder ( ) . acquireHostList ( true ) . build ( ) ; final com . arangodb . entity . ArangoDBVersion version = arango . getVersion ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( version , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . notNullValue ( ) ) )", "total": "acquireHostList ( ) { final com . arangodb . ArangoDB arango = new com . arangodb . ArangoDB . Builder ( ) . acquireHostList ( true ) . build ( ) ; final com . arangodb . entity . ArangoDBVersion version = arango . getVersion ( ) ; \"<AssertPlaceHolder>\" ; } getVersion ( ) { final com . arangodb . entity . ArangoDBVersion version = db . getVersion ( ) ; org . junit . Assert . assertThat ( version , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; org . junit . Assert . assertThat ( version . getServer ( ) , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; org . junit . Assert . assertThat ( version . getVersion ( ) , org . hamcrest . Matchers . is ( org . hamcrest . CoreMatchers . notNullValue ( ) ) ) ; }", "answer": "org . junit . Assert . assertThat ( version , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . notNullValue ( ) ) )"}
{"focal": "get ( ) { return producePongMessage ( pingContext ) ; }", "testMethod": "testIgnoreOwnBeacon ( ) { final int port = org . zeromq . Utils . findOpenPort ( ) ; final byte [ ] beacon = new byte [ ] { 'Z' , 'R' , 'E' , 1 , 2 } ; final byte [ ] prefix = new byte [ ] { 'Z' , 'R' , 'E' , 1 } ; final org . zeromq . ZBeacon zbeacon = new org . zeromq . ZBeacon ( ZBeacon . DEFAULT_BROADCAST_HOST , port , beacon , true ) ; zbeacon . setPrefix ( prefix ) ; final java . util . concurrent . atomic . AtomicLong counter = new java . util . concurrent . atomic . AtomicLong ( ) ; zbeacon . setListener ( new org . zeromq . ZBeacon . Listener ( ) { @ org . zeromq . Override public void onBeacon ( java . net . InetAddress sender , byte [ ] beacon ) { counter . incrementAndGet ( ) ; System . out . println ( sender . toString ( ) ) ; try { System . out . println ( java . net . InetAddress . getLocalHost ( ) . getHostAddress ( ) ) ; } catch ( java . lang . Exception e ) { } System . out . println ( new java . lang . String ( beacon ) ) ; } } ) ; zbeacon . start ( ) ; zmq . ZMQ . sleep ( 1 ) ; zbeacon . stop ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( counter . get ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )", "total": "testIgnoreOwnBeacon ( ) { final int port = org . zeromq . Utils . findOpenPort ( ) ; final byte [ ] beacon = new byte [ ] { 'Z' , 'R' , 'E' , 1 , 2 } ; final byte [ ] prefix = new byte [ ] { 'Z' , 'R' , 'E' , 1 } ; final org . zeromq . ZBeacon zbeacon = new org . zeromq . ZBeacon ( ZBeacon . DEFAULT_BROADCAST_HOST , port , beacon , true ) ; zbeacon . setPrefix ( prefix ) ; final java . util . concurrent . atomic . AtomicLong counter = new java . util . concurrent . atomic . AtomicLong ( ) ; zbeacon . setListener ( new org . zeromq . ZBeacon . Listener ( ) { @ org . zeromq . Override public void onBeacon ( java . net . InetAddress sender , byte [ ] beacon ) { counter . incrementAndGet ( ) ; System . out . println ( sender . toString ( ) ) ; try { System . out . println ( java . net . InetAddress . getLocalHost ( ) . getHostAddress ( ) ) ; } catch ( java . lang . Exception e ) { } System . out . println ( new java . lang . String ( beacon ) ) ; } } ) ; zbeacon . start ( ) ; zmq . ZMQ . sleep ( 1 ) ; zbeacon . stop ( ) ; \"<AssertPlaceHolder>\" ; } get ( ) { return producePongMessage ( pingContext ) ; }", "answer": "org . junit . Assert . assertThat ( counter . get ( ) , org . hamcrest . CoreMatchers . is ( 0L ) )"}
{"focal": "save ( java . lang . Object , org . bson . Document ) { try { org . mongolink . domain . mapper . Collection collection = value ( instance ) ; java . lang . Object children = collection . stream ( ) . map ( ( v ) -> context ( ) . converterFor ( v . getClass ( ) ) . toDbValue ( v ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; into . put ( name ( ) , children ) ; } catch ( java . lang . Exception e ) { org . mongolink . domain . mapper . CollectionMapper . LOGGER . error ( \"Can't<sp>saveInto<sp>collection<sp>{}\" , name ( ) , e ) ; } }", "testMethod": "canCreateFromField ( ) { org . mongolink . domain . mapper . FakeAggregate entity = new org . mongolink . domain . mapper . FakeAggregate ( \"value\" ) ; org . bson . Document dbObject = new org . bson . Document ( ) ; propertyMapperFromField ( ) . save ( entity , dbObject ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( dbObject . getString ( \"value\" ) , org . hamcrest . Matchers . is ( \"value\" ) )", "total": "canCreateFromField ( ) { org . mongolink . domain . mapper . FakeAggregate entity = new org . mongolink . domain . mapper . FakeAggregate ( \"value\" ) ; org . bson . Document dbObject = new org . bson . Document ( ) ; propertyMapperFromField ( ) . save ( entity , dbObject ) ; \"<AssertPlaceHolder>\" ; } save ( java . lang . Object , org . bson . Document ) { try { org . mongolink . domain . mapper . Collection collection = value ( instance ) ; java . lang . Object children = collection . stream ( ) . map ( ( v ) -> context ( ) . converterFor ( v . getClass ( ) ) . toDbValue ( v ) ) . collect ( java . util . stream . Collectors . toList ( ) ) ; into . put ( name ( ) , children ) ; } catch ( java . lang . Exception e ) { org . mongolink . domain . mapper . CollectionMapper . LOGGER . error ( \"Can't<sp>saveInto<sp>collection<sp>{}\" , name ( ) , e ) ; } }", "answer": "org . junit . Assert . assertThat ( dbObject . getString ( \"value\" ) , org . hamcrest . Matchers . is ( \"value\" ) )"}
{"focal": "isIncomplete ( ) { java . lang . Boolean noStreams = streams . isEmpty ( ) ; java . lang . Boolean noMeasurements = any ( streams . values ( ) , new com . google . common . base . Predicate < pl . llp . aircasting . model . MeasurementStream > ( ) { @ pl . llp . aircasting . model . Override public boolean apply ( @ org . jetbrains . annotations . Nullable pl . llp . aircasting . model . MeasurementStream input ) { return input . isEmpty ( ) ; } } ) ; return noStreams || noMeasurements ; }", "testMethod": "returnsTrueWhenAllOfStreamsHasNoMeasurements ( ) { pl . llp . aircasting . model . MeasurementStream stream1 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream1 . isEmpty ( ) ) . thenReturn ( true ) ; pl . llp . aircasting . model . MeasurementStream stream2 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream2 . isEmpty ( ) ) . thenReturn ( true ) ; session . add ( stream1 ) ; session . add ( stream2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( session . isIncomplete ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )", "total": "returnsTrueWhenAllOfStreamsHasNoMeasurements ( ) { pl . llp . aircasting . model . MeasurementStream stream1 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream1 . isEmpty ( ) ) . thenReturn ( true ) ; pl . llp . aircasting . model . MeasurementStream stream2 = mock ( pl . llp . aircasting . model . MeasurementStream . class ) ; when ( stream2 . isEmpty ( ) ) . thenReturn ( true ) ; session . add ( stream1 ) ; session . add ( stream2 ) ; \"<AssertPlaceHolder>\" ; } isIncomplete ( ) { java . lang . Boolean noStreams = streams . isEmpty ( ) ; java . lang . Boolean noMeasurements = any ( streams . values ( ) , new com . google . common . base . Predicate < pl . llp . aircasting . model . MeasurementStream > ( ) { @ pl . llp . aircasting . model . Override public boolean apply ( @ org . jetbrains . annotations . Nullable pl . llp . aircasting . model . MeasurementStream input ) { return input . isEmpty ( ) ; } } ) ; return noStreams || noMeasurements ; }", "answer": "org . junit . Assert . assertThat ( session . isIncomplete ( ) , org . hamcrest . CoreMatchers . equalTo ( true ) )"}
{"focal": "extractPatterns ( java . lang . String ) { if ( propertyValue == null ) return java . util . Collections . emptyList ( ) ; final java . util . List < java . util . regex . Pattern > trimmedPatterns = new java . util . ArrayList ( ) ; final java . util . StringTokenizer tokenizer = new java . util . StringTokenizer ( propertyValue , \",\" ) ; while ( tokenizer . hasMoreTokens ( ) ) { final java . lang . String trimmedString = tokenizer . nextToken ( ) . trim ( ) ; if ( ! ( trimmedString . isEmpty ( ) ) ) { try { trimmedPatterns . add ( java . util . regex . Pattern . compile ( trimmedString ) ) ; } catch ( java . util . regex . PatternSyntaxException e ) { io . tracee . configuration . PropertiesBasedTraceeFilterConfiguration . logger . error ( ( ( ( ( \"Can<sp>not<sp>compile<sp>pattern<sp>'\" + trimmedString ) + \"'.<sp>Message:<sp>\" ) + ( e . getMessage ( ) ) ) + \"<sp>--<sp>Ignore<sp>pattern\" ) ) ; io . tracee . configuration . PropertiesBasedTraceeFilterConfiguration . logger . debug ( ( \"Detailed<sp>Exception<sp>cause:<sp>\" + ( e . getMessage ( ) ) ) , e ) ; } } } return trimmedPatterns ; }", "testMethod": "extractPatternsShouldReturnEmptyListOnNullValue ( ) { \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( unit . extractPatterns ( null ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . empty ( ) ) )", "total": "extractPatternsShouldReturnEmptyListOnNullValue ( ) { \"<AssertPlaceHolder>\" ; } extractPatterns ( java . lang . String ) { if ( propertyValue == null ) return java . util . Collections . emptyList ( ) ; final java . util . List < java . util . regex . Pattern > trimmedPatterns = new java . util . ArrayList ( ) ; final java . util . StringTokenizer tokenizer = new java . util . StringTokenizer ( propertyValue , \",\" ) ; while ( tokenizer . hasMoreTokens ( ) ) { final java . lang . String trimmedString = tokenizer . nextToken ( ) . trim ( ) ; if ( ! ( trimmedString . isEmpty ( ) ) ) { try { trimmedPatterns . add ( java . util . regex . Pattern . compile ( trimmedString ) ) ; } catch ( java . util . regex . PatternSyntaxException e ) { io . tracee . configuration . PropertiesBasedTraceeFilterConfiguration . logger . error ( ( ( ( ( \"Can<sp>not<sp>compile<sp>pattern<sp>'\" + trimmedString ) + \"'.<sp>Message:<sp>\" ) + ( e . getMessage ( ) ) ) + \"<sp>--<sp>Ignore<sp>pattern\" ) ) ; io . tracee . configuration . PropertiesBasedTraceeFilterConfiguration . logger . debug ( ( \"Detailed<sp>Exception<sp>cause:<sp>\" + ( e . getMessage ( ) ) ) , e ) ; } } } return trimmedPatterns ; }", "answer": "org . junit . Assert . assertThat ( unit . extractPatterns ( null ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . empty ( ) ) )"}
{"focal": "getExitCode ( ) { if ( ( replicationFailures ) == ( tableReplications . size ( ) ) ) { return - 1 ; } if ( ( replicationFailures ) > 0 ) { return - 2 ; } return 0 ; }", "testMethod": "exitCodeIsZeroWhenAllReplicationsAreSuccessful ( ) { locomotive . run ( applicationArguments ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( locomotive . getExitCode ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "exitCodeIsZeroWhenAllReplicationsAreSuccessful ( ) { locomotive . run ( applicationArguments ) ; \"<AssertPlaceHolder>\" ; } getExitCode ( ) { if ( ( replicationFailures ) == ( tableReplications . size ( ) ) ) { return - 1 ; } if ( ( replicationFailures ) > 0 ) { return - 2 ; } return 0 ; }", "answer": "org . junit . Assert . assertThat ( locomotive . getExitCode ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "toString ( ) { return ( ( ( \"ReportSet{id='\" + ( getId ( ) ) ) + \"',<sp>reports=\" ) + ( reports ) ) + \"}\" ; }", "testMethod": "copyByteArrayValidWriterJunkEncodingNegBufSz ( ) { java . lang . String probe = \"A<sp>string<sp>\" ; java . io . StringWriter writer = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseStringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( probe . getBytes ( ) , writer , \"junk\" , ( - 1 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( writer . toString ( ) . getBytes ( ) , org . hamcrest . CoreMatchers . is ( probe . getBytes ( ) ) )", "total": "copyByteArrayValidWriterJunkEncodingNegBufSz ( ) { java . lang . String probe = \"A<sp>string<sp>\" ; java . io . StringWriter writer = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseStringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( probe . getBytes ( ) , writer , \"junk\" , ( - 1 ) ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return ( ( ( \"ReportSet{id='\" + ( getId ( ) ) ) + \"',<sp>reports=\" ) + ( reports ) ) + \"}\" ; }", "answer": "org . junit . Assert . assertThat ( writer . toString ( ) . getBytes ( ) , org . hamcrest . CoreMatchers . is ( probe . getBytes ( ) ) )"}
{"focal": "paths ( ) { int [ ] [ ] paths = new int [ this . paths . size ( ) ] [ 0 ] ; for ( int i = 0 ; i < ( this . paths . size ( ) ) ; i ++ ) paths [ i ] = this . paths . get ( i ) ; return paths ; }", "testMethod": "paths_bicyclo ( ) { int [ ] [ ] bicyclo = org . openscience . cdk . graph . InitialCyclesTest . bicyclo ( ) ; org . openscience . cdk . graph . EdgeShortCycles esc = new org . openscience . cdk . graph . EdgeShortCycles ( bicyclo ) ; int [ ] [ ] paths = esc . paths ( ) ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { 5 , 0 , 1 , 2 , 3 , 4 , 5 } , new int [ ] { 5 , 0 , 1 , 2 , 7 , 6 , 5 } , new int [ ] { 5 , 4 , 3 , 2 , 7 , 6 , 5 } } ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( paths , org . hamcrest . CoreMatchers . is ( expected ) )", "total": "paths_bicyclo ( ) { int [ ] [ ] bicyclo = org . openscience . cdk . graph . InitialCyclesTest . bicyclo ( ) ; org . openscience . cdk . graph . EdgeShortCycles esc = new org . openscience . cdk . graph . EdgeShortCycles ( bicyclo ) ; int [ ] [ ] paths = esc . paths ( ) ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { 5 , 0 , 1 , 2 , 3 , 4 , 5 } , new int [ ] { 5 , 0 , 1 , 2 , 7 , 6 , 5 } , new int [ ] { 5 , 4 , 3 , 2 , 7 , 6 , 5 } } ; \"<AssertPlaceHolder>\" ; } paths ( ) { int [ ] [ ] paths = new int [ this . paths . size ( ) ] [ 0 ] ; for ( int i = 0 ; i < ( this . paths . size ( ) ) ; i ++ ) paths [ i ] = this . paths . get ( i ) ; return paths ; }", "answer": "org . junit . Assert . assertThat ( paths , org . hamcrest . CoreMatchers . is ( expected ) )"}
{"focal": "toString ( ) { return ( ( ( \"ReportSet{id='\" + ( getId ( ) ) ) + \"',<sp>reports=\" ) + ( reports ) ) + \"}\" ; }", "testMethod": "copyEmptyStringValidWriter ( ) { java . io . StringWriter writer = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseStringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( org . apache . maven . shared . utils . io . IOUtilTest . emptyString ( ) , writer ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( writer . toString ( ) , org . hamcrest . CoreMatchers . is ( org . apache . maven . shared . utils . io . IOUtilTest . emptyString ( ) ) )", "total": "copyEmptyStringValidWriter ( ) { java . io . StringWriter writer = new org . apache . maven . shared . utils . io . IOUtilTest . DontCloseStringWriter ( ) ; org . apache . maven . shared . utils . io . IOUtil . copy ( org . apache . maven . shared . utils . io . IOUtilTest . emptyString ( ) , writer ) ; \"<AssertPlaceHolder>\" ; } toString ( ) { return ( ( ( \"ReportSet{id='\" + ( getId ( ) ) ) + \"',<sp>reports=\" ) + ( reports ) ) + \"}\" ; }", "answer": "org . junit . Assert . assertThat ( writer . toString ( ) , org . hamcrest . CoreMatchers . is ( org . apache . maven . shared . utils . io . IOUtilTest . emptyString ( ) ) )"}
{"focal": "computeChangeType ( ) { if ( this . oldVersions . isEmpty ( ) ) { if ( ! ( ignoreMissingOldVersion ) ) { throw new japicmp . exception . JApiCmpException ( JApiCmpException . Reason . IllegalArgument , ( \"Could<sp>not<sp>extract<sp>semantic<sp>version<sp>for<sp>at<sp>least<sp>one<sp>old<sp>version.<sp>Please<sp>\" + \"follow<sp>the<sp>rules<sp>for<sp>semantic<sp>versioning.\" ) ) ; } else { return japicmp . util . Optional . absent ( ) ; } } if ( this . newVersions . isEmpty ( ) ) { if ( ! ( ignoreMissingNewVersion ) ) { throw new japicmp . exception . JApiCmpException ( JApiCmpException . Reason . IllegalArgument , ( \"Could<sp>not<sp>extract<sp>semantic<sp>version<sp>for<sp>at<sp>least<sp>one<sp>new<sp>version.<sp>Please<sp>\" + \"follow<sp>the<sp>rules<sp>for<sp>semantic<sp>versioning.\" ) ) ; } else { return japicmp . util . Optional . absent ( ) ; } } if ( ( allVersionsTheSame ( oldVersions ) ) && ( allVersionsTheSame ( newVersions ) ) ) { japicmp . versioning . SemanticVersion oldVersion = oldVersions . get ( 0 ) ; japicmp . versioning . SemanticVersion newVersion = newVersions . get ( 0 ) ; return oldVersion . computeChangeType ( newVersion ) ; } else { if ( ( oldVersions . size ( ) ) != ( newVersions . size ( ) ) ) { throw new japicmp . exception . JApiCmpException ( JApiCmpException . Reason . IllegalArgument , \"Cannot<sp>compare<sp>versions<sp>because<sp>the<sp>number<sp>of<sp>old<sp>versions<sp>is<sp>different<sp>than<sp>the<sp>number<sp>of<sp>new<sp>versions.\" ) ; } else { java . util . List < japicmp . versioning . SemanticVersion . ChangeType > changeTypes = new java . util . ArrayList ( ) ; for ( int i = 0 ; i < ( oldVersions . size ( ) ) ; i ++ ) { japicmp . versioning . SemanticVersion oldVersion = oldVersions . get ( i ) ; japicmp . versioning . SemanticVersion newVersion = newVersions . get ( i ) ; japicmp . util . Optional < japicmp . versioning . SemanticVersion . ChangeType > changeTypeOptional = oldVersion . computeChangeType ( newVersion ) ; if ( changeTypeOptional . isPresent ( ) ) { changeTypes . add ( changeTypeOptional . get ( ) ) ; } } japicmp . versioning . SemanticVersion . ChangeType maxRank = SemanticVersion . ChangeType . UNCHANGED ; for ( japicmp . versioning . SemanticVersion . ChangeType changeType : changeTypes ) { if ( ( changeType . getRank ( ) ) > ( maxRank . getRank ( ) ) ) { maxRank = changeType ; } } return japicmp . util . Optional . fromNullable ( maxRank ) ; } } }", "testMethod": "testOneVersionNoChange ( ) { japicmp . maven . VersionChange vc = new japicmp . maven . VersionChange ( java . util . Collections . singletonList ( new japicmp . cmp . JApiCmpArchive ( new java . io . File ( \"lib-1.2.3.jar\" ) , \"1.2.3\" ) ) , java . util . Collections . singletonList ( new japicmp . cmp . JApiCmpArchive ( new java . io . File ( \"lib-1.2.3.jar\" ) , \"1.2.3\" ) ) , new japicmp . maven . Parameter ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( vc . computeChangeType ( ) . get ( ) , org . hamcrest . core . Is . is ( SemanticVersion . ChangeType . UNCHANGED ) )", "total": "testOneVersionNoChange ( ) { japicmp . maven . VersionChange vc = new japicmp . maven . VersionChange ( java . util . Collections . singletonList ( new japicmp . cmp . JApiCmpArchive ( new java . io . File ( \"lib-1.2.3.jar\" ) , \"1.2.3\" ) ) , java . util . Collections . singletonList ( new japicmp . cmp . JApiCmpArchive ( new java . io . File ( \"lib-1.2.3.jar\" ) , \"1.2.3\" ) ) , new japicmp . maven . Parameter ( ) ) ; \"<AssertPlaceHolder>\" ; } computeChangeType ( ) { if ( this . oldVersions . isEmpty ( ) ) { if ( ! ( ignoreMissingOldVersion ) ) { throw new japicmp . exception . JApiCmpException ( JApiCmpException . Reason . IllegalArgument , ( \"Could<sp>not<sp>extract<sp>semantic<sp>version<sp>for<sp>at<sp>least<sp>one<sp>old<sp>version.<sp>Please<sp>\" + \"follow<sp>the<sp>rules<sp>for<sp>semantic<sp>versioning.\" ) ) ; } else { return japicmp . util . Optional . absent ( ) ; } } if ( this . newVersions . isEmpty ( ) ) { if ( ! ( ignoreMissingNewVersion ) ) { throw new japicmp . exception . JApiCmpException ( JApiCmpException . Reason . IllegalArgument , ( \"Could<sp>not<sp>extract<sp>semantic<sp>version<sp>for<sp>at<sp>least<sp>one<sp>new<sp>version.<sp>Please<sp>\" + \"follow<sp>the<sp>rules<sp>for<sp>semantic<sp>versioning.\" ) ) ; } else { return japicmp . util . Optional . absent ( ) ; } } if ( ( allVersionsTheSame ( oldVersions ) ) && ( allVersionsTheSame ( newVersions ) ) ) { japicmp . versioning . SemanticVersion oldVersion = oldVersions . get ( 0 ) ; japicmp . versioning . SemanticVersion newVersion = newVersions . get ( 0 ) ; return oldVersion . computeChangeType ( newVersion ) ; } else { if ( ( oldVersions . size ( ) ) != ( newVersions . size ( ) ) ) { throw new japicmp . exception . JApiCmpException ( JApiCmpException . Reason . IllegalArgument , \"Cannot<sp>compare<sp>versions<sp>because<sp>the<sp>number<sp>of<sp>old<sp>versions<sp>is<sp>different<sp>than<sp>the<sp>number<sp>of<sp>new<sp>versions.\" ) ; } else { java . util . List < japicmp . versioning . SemanticVersion . ChangeType > changeTypes = new java . util . ArrayList ( ) ; for ( int i = 0 ; i < ( oldVersions . size ( ) ) ; i ++ ) { japicmp . versioning . SemanticVersion oldVersion = oldVersions . get ( i ) ; japicmp . versioning . SemanticVersion newVersion = newVersions . get ( i ) ; japicmp . util . Optional < japicmp . versioning . SemanticVersion . ChangeType > changeTypeOptional = oldVersion . computeChangeType ( newVersion ) ; if ( changeTypeOptional . isPresent ( ) ) { changeTypes . add ( changeTypeOptional . get ( ) ) ; } } japicmp . versioning . SemanticVersion . ChangeType maxRank = SemanticVersion . ChangeType . UNCHANGED ; for ( japicmp . versioning . SemanticVersion . ChangeType changeType : changeTypes ) { if ( ( changeType . getRank ( ) ) > ( maxRank . getRank ( ) ) ) { maxRank = changeType ; } } return japicmp . util . Optional . fromNullable ( maxRank ) ; } } }", "answer": "org . junit . Assert . assertThat ( vc . computeChangeType ( ) . get ( ) , org . hamcrest . core . Is . is ( SemanticVersion . ChangeType . UNCHANGED ) )"}
{"focal": "accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "testMethod": "testAcceptValidParameter3 ( ) { state . setInput ( \"select\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( true ) )", "total": "testAcceptValidParameter3 ( ) { state . setInput ( \"select\" ) ; \"<AssertPlaceHolder>\" ; } accept ( org . openspotlight . graph . query . console . ConsoleState ) { org . openspotlight . common . util . Assertions . checkNotNull ( \"state\" , state ) ; if ( ( ( state . getActiveCommand ( ) ) == null ) && ( state . getInput ( ) . trim ( ) . equals ( \"display<sp>properties\" ) ) ) { return true ; } return false ; }", "answer": "org . junit . Assert . assertThat ( command . accept ( state ) , org . hamcrest . core . Is . is ( true ) )"}
{"focal": "getMyPrimitiveInt ( ) { return myPrimitiveInt ; }", "testMethod": "primitiveInt ( ) { model . setMyPrimitiveInt ( 1 ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( model2 . getMyPrimitiveInt ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "primitiveInt ( ) { model . setMyPrimitiveInt ( 1 ) ; com . google . appengine . api . datastore . Entity entity = meta . modelToEntity ( model ) ; com . google . appengine . api . datastore . Key key = ds . put ( entity ) ; com . google . appengine . api . datastore . Entity entity2 = ds . get ( key ) ; org . slim3 . datastore . model . Hoge model2 = meta . entityToModel ( entity2 ) ; \"<AssertPlaceHolder>\" ; } getMyPrimitiveInt ( ) { return myPrimitiveInt ; }", "answer": "org . junit . Assert . assertThat ( model2 . getMyPrimitiveInt ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "testMethod": "shouldSerializeAllBasicFieldsIdented ( ) { java . lang . String expectedResult = \"{\\\"order\\\":<sp>{\\n<sp>\\\"price\\\":<sp>15.0,\\n<sp>\\\"comments\\\":<sp>\\\"pack<sp>it<sp>nicely,<sp>please\\\"\\n}}\" ; br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"guilherme<sp>silveira\" ) , 15.0 , \"pack<sp>it<sp>nicely,<sp>please\" ) ; serialization . indented ( ) . from ( order ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )", "total": "shouldSerializeAllBasicFieldsIdented ( ) { java . lang . String expectedResult = \"{\\\"order\\\":<sp>{\\n<sp>\\\"price\\\":<sp>15.0,\\n<sp>\\\"comments\\\":<sp>\\\"pack<sp>it<sp>nicely,<sp>please\\\"\\n}}\" ; br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order order = new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Order ( new br . com . caelum . vraptor . serialization . xstream . XStreamJSONSerializationTest . Client ( \"guilherme<sp>silveira\" ) , 15.0 , \"pack<sp>it<sp>nicely,<sp>please\" ) ; serialization . indented ( ) . from ( order ) . serialize ( ) ; \"<AssertPlaceHolder>\" ; } result ( ) { return new java . lang . String ( stream . toByteArray ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( result ( ) , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( expectedResult ) ) )"}
{"focal": "isDiagnosticsEnabled ( ) { return false ; }", "testMethod": "shouldBeDiagnosticMode ( ) { com . oracle . bedrock . runtime . console . PipedApplicationConsole console = new com . oracle . bedrock . runtime . console . PipedApplicationConsole ( PipedApplicationConsole . DEFAULT_PIPE_SIZE , true ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( console . isDiagnosticsEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "shouldBeDiagnosticMode ( ) { com . oracle . bedrock . runtime . console . PipedApplicationConsole console = new com . oracle . bedrock . runtime . console . PipedApplicationConsole ( PipedApplicationConsole . DEFAULT_PIPE_SIZE , true ) ; \"<AssertPlaceHolder>\" ; } isDiagnosticsEnabled ( ) { return false ; }", "answer": "org . junit . Assert . assertThat ( console . isDiagnosticsEnabled ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
{"focal": "getListVersion ( ) { return listVersion ; }", "testMethod": "setListVersion_isNonZero_isCorrect ( ) { for ( int i = 1 ; i <= 100 ; i ++ ) { confirmation . setListVersion ( i ) ; \"<AssertPlaceHolder>\" ; } }", "assertLine": "org . junit . Assert . assertThat ( confirmation . getListVersion ( ) , org . hamcrest . CoreMatchers . equalTo ( i ) )", "total": "setListVersion_isNonZero_isCorrect ( ) { for ( int i = 1 ; i <= 100 ; i ++ ) { confirmation . setListVersion ( i ) ; \"<AssertPlaceHolder>\" ; } } getListVersion ( ) { return listVersion ; }", "answer": "org . junit . Assert . assertThat ( confirmation . getListVersion ( ) , org . hamcrest . CoreMatchers . equalTo ( i ) )"}
{"focal": "isNull ( ) { mark ( 1024 ) ; char ch = readAndSkipBlank ( ) ; if ( ( ( pos ) + 3 ) > ( limit ) ) { reset ( ) ; return false ; } if ( ( ( ( ch == 'n' ) && ( 'u' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) { if ( ( pos ) >= ( limit ) ) return true ; ch = readAndSkipBlank ( ) ; if ( isEndFlag ( ch ) ) { ( pos ) -- ; return true ; } else { reset ( ) ; return false ; } } else { reset ( ) ; return false ; } }", "testMethod": "testIsNull2 ( ) { com . firefly . utils . json . JsonReader reader = new com . firefly . utils . json . io . JsonStringReader ( \"<sp>null<sp>\" . trim ( ) ) ; \"<AssertPlaceHolder>\" ; reader . close ( ) ; }", "assertLine": "org . junit . Assert . assertThat ( reader . isNull ( ) , org . hamcrest . Matchers . is ( true ) )", "total": "testIsNull2 ( ) { com . firefly . utils . json . JsonReader reader = new com . firefly . utils . json . io . JsonStringReader ( \"<sp>null<sp>\" . trim ( ) ) ; \"<AssertPlaceHolder>\" ; reader . close ( ) ; } isNull ( ) { mark ( 1024 ) ; char ch = readAndSkipBlank ( ) ; if ( ( ( pos ) + 3 ) > ( limit ) ) { reset ( ) ; return false ; } if ( ( ( ( ch == 'n' ) && ( 'u' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) && ( 'l' == ( read ( ) ) ) ) { if ( ( pos ) >= ( limit ) ) return true ; ch = readAndSkipBlank ( ) ; if ( isEndFlag ( ch ) ) { ( pos ) -- ; return true ; } else { reset ( ) ; return false ; } } else { reset ( ) ; return false ; } }", "answer": "org . junit . Assert . assertThat ( reader . isNull ( ) , org . hamcrest . Matchers . is ( true ) )"}
{"focal": "getExperiments ( com . intuit . wasabi . experimentobjects . Application$Name , com . intuit . wasabi . experimentobjects . Page$Name ) { java . util . stream . Stream < com . intuit . wasabi . repository . cassandra . pojo . index . PageExperimentByAppNamePage > resultList = java . util . stream . Stream . empty ( ) ; try { com . datastax . driver . mapping . Result < com . intuit . wasabi . repository . cassandra . pojo . index . PageExperimentByAppNamePage > result = pageExperimentIndexAccessor . selectBy ( applicationName . toString ( ) , pageName . toString ( ) ) ; resultList = java . util . stream . StreamSupport . stream ( java . util . Spliterators . spliteratorUnknownSize ( result . iterator ( ) , Spliterator . ORDERED ) , false ) ; } catch ( com . datastax . driver . core . exceptions . ReadTimeoutException | com . datastax . driver . core . exceptions . UnavailableException | com . datastax . driver . core . exceptions . NoHostAvailableException e ) { throw new com . intuit . wasabi . repository . RepositoryException ( new java . lang . StringBuilder ( \"Could<sp>not<sp>retrieve<sp>the<sp>experiments<sp>for<sp>applicationName:\\\"\" ) . append ( applicationName ) . append ( \"\\\",<sp>page:\\\"\" ) . append ( pageName ) . append ( \"\\\"\" ) . toString ( ) , e ) ; } return resultList . map ( ( t ) -> { Optional < com . intuit . wasabi . repository . cassandra . pojo . Experiment > experiment = java . util . Optional . ofNullable ( experimentAccessor . selectBy ( t . getExperimentId ( ) ) . one ( ) ) ; com . intuit . wasabi . experimentobjects . PageExperiment . Builder builder = new com . intuit . wasabi . experimentobjects . PageExperiment . Builder ( Experiment . ID . valueOf ( t . getExperimentId ( ) ) , null , t . isAssign ( ) ) ; if ( experiment . isPresent ( ) ) { builder . setLabel ( Experiment . Label . valueOf ( experiment . get ( ) . getLabel ( ) ) ) ; } return builder . build ( ) ; } ) . filter ( ( t ) -> ( t . getLabel ( ) ) != null ) . collect ( java . util . stream . Collectors . toList ( ) ) ; }", "testMethod": "getExperimentsExceptionTest ( ) { com . intuit . wasabi . experimentobjects . Page . Name pageName = Page . Name . valueOf ( \"testPage1\" ) ; doThrow ( com . datastax . driver . core . exceptions . ReadTimeoutException . class ) . when ( pageExperimentIndexAccessor ) . selectBy ( eq ( com . intuit . wasabi . repository . cassandra . impl . CassandraPagesRepositoryTest . APPLICATION_NAME . toString ( ) ) , eq ( pageName . toString ( ) ) ) ; repository . getExperiments ( com . intuit . wasabi . repository . cassandra . impl . CassandraPagesRepositoryTest . APPLICATION_NAME , pageName ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( 1 , org . hamcrest . CoreMatchers . is ( 2 ) )", "total": "getExperimentsExceptionTest ( ) { com . intuit . wasabi . experimentobjects . Page . Name pageName = Page . Name . valueOf ( \"testPage1\" ) ; doThrow ( com . datastax . driver . core . exceptions . ReadTimeoutException . class ) . when ( pageExperimentIndexAccessor ) . selectBy ( eq ( com . intuit . wasabi . repository . cassandra . impl . CassandraPagesRepositoryTest . APPLICATION_NAME . toString ( ) ) , eq ( pageName . toString ( ) ) ) ; repository . getExperiments ( com . intuit . wasabi . repository . cassandra . impl . CassandraPagesRepositoryTest . APPLICATION_NAME , pageName ) ; \"<AssertPlaceHolder>\" ; } getExperiments ( com . intuit . wasabi . experimentobjects . Application$Name , com . intuit . wasabi . experimentobjects . Page$Name ) { java . util . stream . Stream < com . intuit . wasabi . repository . cassandra . pojo . index . PageExperimentByAppNamePage > resultList = java . util . stream . Stream . empty ( ) ; try { com . datastax . driver . mapping . Result < com . intuit . wasabi . repository . cassandra . pojo . index . PageExperimentByAppNamePage > result = pageExperimentIndexAccessor . selectBy ( applicationName . toString ( ) , pageName . toString ( ) ) ; resultList = java . util . stream . StreamSupport . stream ( java . util . Spliterators . spliteratorUnknownSize ( result . iterator ( ) , Spliterator . ORDERED ) , false ) ; } catch ( com . datastax . driver . core . exceptions . ReadTimeoutException | com . datastax . driver . core . exceptions . UnavailableException | com . datastax . driver . core . exceptions . NoHostAvailableException e ) { throw new com . intuit . wasabi . repository . RepositoryException ( new java . lang . StringBuilder ( \"Could<sp>not<sp>retrieve<sp>the<sp>experiments<sp>for<sp>applicationName:\\\"\" ) . append ( applicationName ) . append ( \"\\\",<sp>page:\\\"\" ) . append ( pageName ) . append ( \"\\\"\" ) . toString ( ) , e ) ; } return resultList . map ( ( t ) -> { Optional < com . intuit . wasabi . repository . cassandra . pojo . Experiment > experiment = java . util . Optional . ofNullable ( experimentAccessor . selectBy ( t . getExperimentId ( ) ) . one ( ) ) ; com . intuit . wasabi . experimentobjects . PageExperiment . Builder builder = new com . intuit . wasabi . experimentobjects . PageExperiment . Builder ( Experiment . ID . valueOf ( t . getExperimentId ( ) ) , null , t . isAssign ( ) ) ; if ( experiment . isPresent ( ) ) { builder . setLabel ( Experiment . Label . valueOf ( experiment . get ( ) . getLabel ( ) ) ) ; } return builder . build ( ) ; } ) . filter ( ( t ) -> ( t . getLabel ( ) ) != null ) . collect ( java . util . stream . Collectors . toList ( ) ) ; }", "answer": "org . junit . Assert . assertThat ( 1 , org . hamcrest . CoreMatchers . is ( 2 ) )"}
{"focal": "getDurationOf ( java . util . List ) { long result = 0 ; if ( stages != null ) { for ( se . diabol . jenkins . workflow . api . Stage stage : stages ) { result = result + ( stage . durationMillis ) ; } } return result ; }", "testMethod": "shouldGetDurationForEmptyParameter ( ) { long duration = se . diabol . jenkins . workflow . api . Stage . getDurationOf ( java . util . Collections . < se . diabol . jenkins . workflow . api . Stage > emptyList ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( duration , org . hamcrest . core . Is . is ( 0L ) )", "total": "shouldGetDurationForEmptyParameter ( ) { long duration = se . diabol . jenkins . workflow . api . Stage . getDurationOf ( java . util . Collections . < se . diabol . jenkins . workflow . api . Stage > emptyList ( ) ) ; \"<AssertPlaceHolder>\" ; } getDurationOf ( java . util . List ) { long result = 0 ; if ( stages != null ) { for ( se . diabol . jenkins . workflow . api . Stage stage : stages ) { result = result + ( stage . durationMillis ) ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( duration , org . hamcrest . core . Is . is ( 0L ) )"}
{"focal": "getExecutionEvents ( org . w3c . dom . Element , java . lang . String [ ] ) { java . util . Set < java . lang . String > expectedTypes = new java . util . HashSet ( java . util . Arrays . asList ( expectedType ) ) ; java . util . List < org . w3c . dom . Element > result = new java . util . ArrayList ( ) ; for ( org . w3c . dom . Element element : org . jenkinsci . plugins . pipeline . maven . util . XmlUtils . getChildrenElements ( mavenSpyLogs , \"ExecutionEvent\" ) ) { if ( expectedTypes . contains ( element . getAttribute ( \"type\" ) ) ) { result . add ( element ) ; } } return result ; }", "testMethod": "test_getExecutionEvents_search_one_type ( ) { java . lang . String xml = \"<mavenExecution>\" + ( \"<ExecutionEvent<sp>type='ProjectSucceeded'<sp>/>\" + \"</mavenExecution>\" ) ; org . w3c . dom . Element documentElement = toXml ( xml ) ; java . util . List < org . w3c . dom . Element > actualElements = org . jenkinsci . plugins . pipeline . maven . util . XmlUtils . getExecutionEvents ( documentElement , \"ProjectSucceeded\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( actualElements . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "total": "test_getExecutionEvents_search_one_type ( ) { java . lang . String xml = \"<mavenExecution>\" + ( \"<ExecutionEvent<sp>type='ProjectSucceeded'<sp>/>\" + \"</mavenExecution>\" ) ; org . w3c . dom . Element documentElement = toXml ( xml ) ; java . util . List < org . w3c . dom . Element > actualElements = org . jenkinsci . plugins . pipeline . maven . util . XmlUtils . getExecutionEvents ( documentElement , \"ProjectSucceeded\" ) ; \"<AssertPlaceHolder>\" ; } getExecutionEvents ( org . w3c . dom . Element , java . lang . String [ ] ) { java . util . Set < java . lang . String > expectedTypes = new java . util . HashSet ( java . util . Arrays . asList ( expectedType ) ) ; java . util . List < org . w3c . dom . Element > result = new java . util . ArrayList ( ) ; for ( org . w3c . dom . Element element : org . jenkinsci . plugins . pipeline . maven . util . XmlUtils . getChildrenElements ( mavenSpyLogs , \"ExecutionEvent\" ) ) { if ( expectedTypes . contains ( element . getAttribute ( \"type\" ) ) ) { result . add ( element ) ; } } return result ; }", "answer": "org . junit . Assert . assertThat ( actualElements . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )"}
{"focal": "getRawCode ( ) { return 0 ; }", "testMethod": "testGetRawCodeReturnsZeroForNullCode ( ) { org . eclipse . californium . core . coap . Request ping = new org . eclipse . californium . core . coap . Request ( null , org . eclipse . californium . core . coap . CoAP . Type . CON ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( ping . getRawCode ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )", "total": "testGetRawCodeReturnsZeroForNullCode ( ) { org . eclipse . californium . core . coap . Request ping = new org . eclipse . californium . core . coap . Request ( null , org . eclipse . californium . core . coap . CoAP . Type . CON ) ; \"<AssertPlaceHolder>\" ; } getRawCode ( ) { return 0 ; }", "answer": "org . junit . Assert . assertThat ( ping . getRawCode ( ) , org . hamcrest . CoreMatchers . is ( 0 ) )"}
{"focal": "getWebhookUrl ( ) { return webhookUrl ; }", "testMethod": "webhookUrl ( ) { com . vincit . go . task . slack . executor . TaskSlackDestination destination = new com . vincit . go . task . slack . executor . TaskSlackDestination ( com . vincit . go . task . slack . executor . TaskSlackDestinationTest . WEBHOOK_URL , com . vincit . go . task . slack . model . ChannelType . CHANNEL , \"channel\" ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( destination . getWebhookUrl ( ) , org . hamcrest . CoreMatchers . is ( com . vincit . go . task . slack . executor . TaskSlackDestinationTest . WEBHOOK_URL ) )", "total": "webhookUrl ( ) { com . vincit . go . task . slack . executor . TaskSlackDestination destination = new com . vincit . go . task . slack . executor . TaskSlackDestination ( com . vincit . go . task . slack . executor . TaskSlackDestinationTest . WEBHOOK_URL , com . vincit . go . task . slack . model . ChannelType . CHANNEL , \"channel\" ) ; \"<AssertPlaceHolder>\" ; } getWebhookUrl ( ) { return webhookUrl ; }", "answer": "org . junit . Assert . assertThat ( destination . getWebhookUrl ( ) , org . hamcrest . CoreMatchers . is ( com . vincit . go . task . slack . executor . TaskSlackDestinationTest . WEBHOOK_URL ) )"}
{"focal": "isEmpty ( ) { if ( ( ( entries ) == null ) || ( entries . isEmpty ( ) ) ) { return true ; } for ( org . silverpeas . web . pdc . vo . FacetEntryVO entry : entries ) { if ( ( entry . getNbElt ( ) ) > 0 ) { return false ; } } return true ; }", "testMethod": "aStartDateTimeBeforeTheEndDateTimeIsValid ( ) { java . time . OffsetDateTime now = java . time . OffsetDateTime . now ( ) ; java . time . OffsetDateTime oneDayAfterNow = now . plusDays ( 1 ) ; org . silverpeas . core . annotation . constraint . DateInterval interval = new org . silverpeas . core . annotation . constraint . DateInterval ( now , oneDayAfterNow ) ; java . util . Set < javax . validation . ConstraintViolation < org . silverpeas . core . annotation . constraint . DateInterval > > violations = validator . validate ( interval ) ; \"<AssertPlaceHolder>\" ; }", "assertLine": "org . junit . Assert . assertThat ( violations . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )", "total": "aStartDateTimeBeforeTheEndDateTimeIsValid ( ) { java . time . OffsetDateTime now = java . time . OffsetDateTime . now ( ) ; java . time . OffsetDateTime oneDayAfterNow = now . plusDays ( 1 ) ; org . silverpeas . core . annotation . constraint . DateInterval interval = new org . silverpeas . core . annotation . constraint . DateInterval ( now , oneDayAfterNow ) ; java . util . Set < javax . validation . ConstraintViolation < org . silverpeas . core . annotation . constraint . DateInterval > > violations = validator . validate ( interval ) ; \"<AssertPlaceHolder>\" ; } isEmpty ( ) { if ( ( ( entries ) == null ) || ( entries . isEmpty ( ) ) ) { return true ; } for ( org . silverpeas . web . pdc . vo . FacetEntryVO entry : entries ) { if ( ( entry . getNbElt ( ) ) > 0 ) { return false ; } } return true ; }", "answer": "org . junit . Assert . assertThat ( violations . isEmpty ( ) , org . hamcrest . CoreMatchers . is ( true ) )"}
